[
    {
        "filename": "AMQ-6548.json",
        "creation_time": "2016-12-21T12:04:12.000+0000",
        "stack_trace": "2016-12-15 16:12:58,831 ERROR [org.jboss.as.ejb3.invocation.processInvocation] (default-threads - 23) WFLYEJB0034: EJB Invocation failed on component test.test.mdb for method public void test.test.onMessage(javax.jms.Message): org.jboss.as.ejb3.component.EJBComponentUnavailableException: WFLYEJB0421: Invocation cannot proceed as component is shutting down\n       at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.java:59)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.deployment.processors.EjbSuspendInterceptor.processInvocation(EjbSuspendInterceptor.java:53)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:66)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java:54)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription$5$1.processInvocation(MessageDrivenComponentDescription.java:213)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)\n        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:634)\n        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)\n        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)\n        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:195)\n        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)\n        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)\n        at test.test$$$view19.onMessage(Unknown Source)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at org.jboss.as.ejb3.inflow.MessageEndpointInvocationHandler.doInvoke(MessageEndpointInvocationHandler.java:139)\n        at org.jboss.as.ejb3.inflow.AbstractInvocationHandler.invoke(AbstractInvocationHandler.java:73)\n        at test.test$$$endpoint12.onMessage(Unknown Source)\n        at org.apache.activemq.ra.MessageEndpointProxy$MessageEndpointAlive.onMessage(MessageEndpointProxy.java:123)\n        at org.apache.activemq.ra.MessageEndpointProxy.onMessage(MessageEndpointProxy.java:64)\n        at org.apache.activemq.ActiveMQSession.run(ActiveMQSession.java:1041)\n        at org.apache.activemq.ra.ServerSessionImpl.run(ServerSessionImpl.java:169)\n        at org.jboss.jca.core.workmanager.WorkWrapper.run(WorkWrapper.java:226)\n        at org.jboss.threads.SimpleDirectExecutor.execute(SimpleDirectExecutor.java:33)\n        at org.jboss.threads.QueueExecutor.runTask(QueueExecutor.java:808)\n        at org.jboss.threads.QueueExecutor.access$100(QueueExecutor.java:45)\n        at org.jboss.threads.QueueExecutor$Worker.run(QueueExecutor.java:828)\n        at java.lang.Thread.run(Thread.java:745)\n        at org.jboss.threads.JBossThread.run(JBossThread.java:320)",
        "source_code": {
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.run": "                                        public void run() {\n                                            /*\n                                            * wait for the first delivery to be complete, i.e. after delivery has been called.\n                                            * */\n                                            synchronized (redeliveryGuard) {\n                                                /*\n                                                * If its non blocking then we can just dispatch in a new session.\n                                                * */\n                                                if (connection.isNonBlockingRedelivery()) {\n                                                    ((ActiveMQDispatcher) md.getConsumer()).dispatch(md);\n                                                } else {\n                                                    /*\n                                                    * If there has been an error thrown during afterDelivery then the\n                                                    * endpoint will be marked as dead so redelivery will fail (and eventually\n                                                    * the session marked as stale), in this case we can only call dispatch\n                                                    * which will create a new session with a new endpoint.\n                                                    * */\n                                                    if (afterDeliveryError.get()) {\n                                                        ((ActiveMQDispatcher) md.getConsumer()).dispatch(md);\n                                                    } else {\n                                                        executor.executeFirst(md);\n                                                        executor.start();\n                                                    }\n                                                }\n                                            }\n                                        }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.asyncSendPacket": "    public void asyncSendPacket(Command command) throws JMSException {\n        connection.asyncSendPacket(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.isIndividualAcknowledge": "    public boolean isIndividualAcknowledge(){\n        return acknowledgementMode == ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.getNextDeliveryId": "    public long getNextDeliveryId() {\n        return deliveryIdGenerator.getNextSequenceId();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.start": "    protected void start() throws JMSException {\n        started.set(true);\n        for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {\n            ActiveMQMessageConsumer c = iter.next();\n            c.start();\n        }\n        executor.start();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.isClientAcknowledge": "    protected boolean isClientAcknowledge() {\n        return this.acknowledgementMode == Session.CLIENT_ACKNOWLEDGE;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.stop": "    protected void stop() throws JMSException {\n\n        for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {\n            ActiveMQMessageConsumer c = iter.next();\n            c.stop();\n        }\n\n        started.set(false);\n        executor.stop();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.clearMessagesInProgress": "    void clearMessagesInProgress(AtomicInteger transportInterruptionProcessingComplete) {\n        clearRequestsCounter.incrementAndGet();\n        executor.clearMessagesInProgress();\n        // we are called from inside the transport reconnection logic which involves us\n        // clearing all the connections' consumers dispatch and delivered lists. So rather\n        // than trying to grab a mutex (which could be already owned by the message listener\n        // calling the send or an ack) we allow it to complete in a separate thread via the\n        // scheduler and notify us via connection.transportInterruptionProcessingComplete()\n        //\n        // We must be careful though not to allow multiple calls to this method from a\n        // connection that is having issue becoming fully established from causing a large\n        // build up of scheduled tasks to clear the same consumers over and over.\n        if (consumers.isEmpty()) {\n            return;\n        }\n\n        if (clearInProgress.compareAndSet(false, true)) {\n            for (final ActiveMQMessageConsumer consumer : consumers) {\n                consumer.inProgressClearRequired();\n                transportInterruptionProcessingComplete.incrementAndGet();\n                try {\n                    connection.getScheduler().executeAfterDelay(new Runnable() {\n                        @Override\n                        public void run() {\n                            consumer.clearMessagesInProgress();\n                        }}, 0l);\n                } catch (JMSException e) {\n                    connection.onClientInternalException(e);\n                }\n            }\n\n            try {\n                connection.getScheduler().executeAfterDelay(new Runnable() {\n                    @Override\n                    public void run() {\n                        clearInProgress.set(false);\n                    }}, 0l);\n            } catch (JMSException e) {\n                connection.onClientInternalException(e);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.sendAck": "    protected void sendAck(MessageAck ack, boolean lazy) throws JMSException {\n        if (lazy || connection.isSendAcksAsync() || getTransacted()) {\n            asyncSendPacket(ack);\n        } else {\n            syncSendPacket(ack);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.beforeDelivery": "        void beforeDelivery(ActiveMQSession session, Message msg);\n\n        void afterDelivery(ActiveMQSession session, Message msg);\n    }\n\n    private static final Logger LOG = LoggerFactory.getLogger(ActiveMQSession.class);\n    private final ThreadPoolExecutor connectionExecutor;\n\n    protected int acknowledgementMode;\n    protected final ActiveMQConnection connection;\n    protected final SessionInfo info;\n    protected final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();\n    protected final LongSequenceGenerator producerIdGenerator = new LongSequenceGenerator();\n    protected final LongSequenceGenerator deliveryIdGenerator = new LongSequenceGenerator();\n    protected final ActiveMQSessionExecutor executor;\n    protected final AtomicBoolean started = new AtomicBoolean(false);\n\n    protected final CopyOnWriteArrayList<ActiveMQMessageConsumer> consumers = new CopyOnWriteArrayList<ActiveMQMessageConsumer>();\n    protected final CopyOnWriteArrayList<ActiveMQMessageProducer> producers = new CopyOnWriteArrayList<ActiveMQMessageProducer>();\n\n    protected boolean closed;\n    private volatile boolean synchronizationRegistered;\n    protected boolean asyncDispatch;\n    protected boolean sessionAsyncDispatch;\n    protected final boolean debug;\n    protected final Object sendMutex = new Object();\n    protected final Object redeliveryGuard = new Object();\n\n    private final AtomicBoolean clearInProgress = new AtomicBoolean();\n\n    private MessageListener messageListener;\n    private final JMSSessionStatsImpl stats;\n    private TransactionContext transactionContext;\n    private DeliveryListener deliveryListener;\n    private MessageTransformer transformer;\n    private BlobTransferPolicy blobTransferPolicy;\n    private long lastDeliveredSequenceId = -2;\n\n    /**\n     * Construct the Session\n     *\n     * @param connection\n     * @param sessionId\n     * @param acknowledgeMode n.b if transacted - the acknowledgeMode ==\n     *                Session.SESSION_TRANSACTED\n     * @param asyncDispatch\n     * @param sessionAsyncDispatch\n     * @throws JMSException on internal error\n     */\n    protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch, boolean sessionAsyncDispatch) throws JMSException {",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.getScheduler": "    protected Scheduler getScheduler() throws JMSException {\n        return this.connection.getScheduler();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.afterDelivery": "        void afterDelivery(ActiveMQSession session, Message msg);\n    }\n\n    private static final Logger LOG = LoggerFactory.getLogger(ActiveMQSession.class);\n    private final ThreadPoolExecutor connectionExecutor;\n\n    protected int acknowledgementMode;\n    protected final ActiveMQConnection connection;\n    protected final SessionInfo info;\n    protected final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();\n    protected final LongSequenceGenerator producerIdGenerator = new LongSequenceGenerator();\n    protected final LongSequenceGenerator deliveryIdGenerator = new LongSequenceGenerator();\n    protected final ActiveMQSessionExecutor executor;\n    protected final AtomicBoolean started = new AtomicBoolean(false);\n\n    protected final CopyOnWriteArrayList<ActiveMQMessageConsumer> consumers = new CopyOnWriteArrayList<ActiveMQMessageConsumer>();\n    protected final CopyOnWriteArrayList<ActiveMQMessageProducer> producers = new CopyOnWriteArrayList<ActiveMQMessageProducer>();\n\n    protected boolean closed;\n    private volatile boolean synchronizationRegistered;\n    protected boolean asyncDispatch;\n    protected boolean sessionAsyncDispatch;\n    protected final boolean debug;\n    protected final Object sendMutex = new Object();\n    protected final Object redeliveryGuard = new Object();\n\n    private final AtomicBoolean clearInProgress = new AtomicBoolean();\n\n    private MessageListener messageListener;\n    private final JMSSessionStatsImpl stats;\n    private TransactionContext transactionContext;\n    private DeliveryListener deliveryListener;\n    private MessageTransformer transformer;\n    private BlobTransferPolicy blobTransferPolicy;\n    private long lastDeliveredSequenceId = -2;\n\n    /**\n     * Construct the Session\n     *\n     * @param connection\n     * @param sessionId\n     * @param acknowledgeMode n.b if transacted - the acknowledgeMode ==\n     *                Session.SESSION_TRANSACTED\n     * @param asyncDispatch\n     * @param sessionAsyncDispatch\n     * @throws JMSException on internal error\n     */\n    protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch, boolean sessionAsyncDispatch) throws JMSException {",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.doStartTransaction": "    protected void doStartTransaction() throws JMSException {\n        if (getTransacted() && !transactionContext.isInXATransaction()) {\n            transactionContext.begin();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.getTransactionContext": "    public TransactionContext getTransactionContext() {\n        return transactionContext;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.RedeliveryPolicy.getInitialRedeliveryDelay": "    public long getInitialRedeliveryDelay() {\n        return initialRedeliveryDelay;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.RedeliveryPolicy.getMaximumRedeliveries": "    public int getMaximumRedeliveries() {\n        return maximumRedeliveries;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.RedeliveryPolicy.getNextRedeliveryDelay": "    public long getNextRedeliveryDelay(long previousDelay) {\n        long nextDelay = redeliveryDelay;\n\n        if (previousDelay > 0 && useExponentialBackOff && backOffMultiplier > 1) {\n            nextDelay = (long) (previousDelay * backOffMultiplier);\n            if(maximumRedeliveryDelay != -1 && nextDelay > maximumRedeliveryDelay) {\n                // in case the user made max redelivery delay less than redelivery delay for some reason.\n                nextDelay = Math.max(maximumRedeliveryDelay, redeliveryDelay);\n            }\n        }\n\n        if (useCollisionAvoidance) {\n            /*\n             * First random determines +/-, second random determines how far to\n             * go in that direction. -cgs\n             */\n            Random random = getRandomNumberGenerator();\n            double variance = (random.nextBoolean() ? collisionAvoidanceFactor : -collisionAvoidanceFactor) * random.nextDouble();\n            nextDelay += nextDelay * variance;\n        }\n\n        return nextDelay;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.RedeliveryPolicy.getRandomNumberGenerator": "    protected static synchronized Random getRandomNumberGenerator() {\n        if (randomNumberGenerator == null) {\n            randomNumberGenerator = new Random();\n        }\n        return randomNumberGenerator;\n    }"
        },
        "bug_report": {
            "Title": "Commit messages on exception",
            "Description": "At ear stop jsm connection consumes messages, although there occured exception\n{noformat}\n2016-12-15 16:12:58,831 ERROR [org.jboss.as.ejb3.invocation.processInvocation] (default-threads - 23) WFLYEJB0034: EJB Invocation failed on component test.test.mdb for method public void test.test.onMessage(javax.jms.Message): org.jboss.as.ejb3.component.EJBComponentUnavailableException: WFLYEJB0421: Invocation cannot proceed as component is shutting down\n        at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.java:59)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.deployment.processors.EjbSuspendInterceptor.processInvocation(EjbSuspendInterceptor.java:53)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:66)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java:54)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription$5$1.processInvocation(MessageDrivenComponentDescription.java:213)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)\n        at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:634)\n        at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)\n        at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)\n        at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:195)\n        at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)\n        at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)\n        at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)\n        at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)\n        at test.test$$$view19.onMessage(Unknown Source)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at org.jboss.as.ejb3.inflow.MessageEndpointInvocationHandler.doInvoke(MessageEndpointInvocationHandler.java:139)\n        at org.jboss.as.ejb3.inflow.AbstractInvocationHandler.invoke(AbstractInvocationHandler.java:73)\n        at test.test$$$endpoint12.onMessage(Unknown Source)\n        at org.apache.activemq.ra.MessageEndpointProxy$MessageEndpointAlive.onMessage(MessageEndpointProxy.java:123)\n        at org.apache.activemq.ra.MessageEndpointProxy.onMessage(MessageEndpointProxy.java:64)\n        at org.apache.activemq.ActiveMQSession.run(ActiveMQSession.java:1041)\n        at org.apache.activemq.ra.ServerSessionImpl.run(ServerSessionImpl.java:169)\n        at org.jboss.jca.core.workmanager.WorkWrapper.run(WorkWrapper.java:226)\n        at org.jboss.threads.SimpleDirectExecutor.execute(SimpleDirectExecutor.java:33)\n        at org.jboss.threads.QueueExecutor.runTask(QueueExecutor.java:808)\n        at org.jboss.threads.QueueExecutor.access$100(QueueExecutor.java:45)\n        at org.jboss.threads.QueueExecutor$Worker.run(QueueExecutor.java:828)\n        at java.lang.Thread.run(Thread.java:745)\n        at org.jboss.threads.JBossThread.run(JBossThread.java:320)\n{noformat}"
        }
    },
    {
        "filename": "AMQ-3434.json",
        "creation_time": "2011-08-03T09:15:05.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.kahadb.index.ListIndex.loadNode(ListIndex.java:203)\n\tat org.apache.kahadb.index.ListIndex.load(ListIndex.java:75)\n\tat org.apache.activemq.store.kahadb.plist.PListStore$1.execute(PListStore.java:219)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:729)\n\tat org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:216)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:454)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:432)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast(FilePendingMessageCursor.java:217)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast(FilePendingMessageCursor.java:193)\n\tat org.apache.activemq.broker.region.Queue.sendMessage(Queue.java:1629)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:720)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:652)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:379)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:523)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:304)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.UserIDBroker.send(UserIDBroker.java:56)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:468)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:316)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:180)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:81)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:140)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:257)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:178)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:70)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:221)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:203)\n\tat java.lang.Thread.run(Thread.java:662)",
        "source_code": {
            "kahadb.src.main.java.org.apache.kahadb.index.ListIndex.loadNode": "    ListNode<Key,Value> loadNode(Transaction tx, long pageId) throws IOException {\n        Page<ListNode<Key,Value>> page = tx.load(pageId, marshaller);\n        ListNode<Key, Value> node = page.get();\n        node.setPage(page);\n        return node;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.ListIndex.get": "    synchronized public Value get(Transaction tx, Key key) throws IOException {\n        assertLoaded();\n        for (Iterator<Map.Entry<Key,Value>> iterator = iterator(tx); iterator.hasNext(); ) {\n            Map.Entry<Key,Value> candidate = iterator.next();\n            if (key.equals(candidate.getKey())) {\n                return candidate.getValue();\n            }\n        }\n        return null;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.ListIndex.load": "    synchronized public void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            LOG.debug(\"loading\");\n            if( keyMarshaller == null ) {\n                throw new IllegalArgumentException(\"The key marshaller must be set before loading the ListIndex\");\n            }\n            if( valueMarshaller == null ) {\n                throw new IllegalArgumentException(\"The value marshaller must be set before loading the ListIndex\");\n            }\n            \n            final Page<ListNode<Key,Value>> p = tx.load(headPageId, null);\n            if( p.getType() == Page.PAGE_FREE_TYPE ) {\n                 // Need to initialize it..\n                ListNode<Key, Value> root = createNode(p);\n                storeNode(tx, root, true);\n                tailPageId = headPageId = p.getPageId();\n            } else {\n                ListNode<Key, Value> node = loadNode(tx, headPageId);\n                size.addAndGet(node.size(tx));\n                while (node.getNext() != -1) {\n                    node = loadNode(tx, node.getNext());\n                    size.addAndGet(node.size(tx));\n                    tailPageId = node.getPageId();\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.execute": "                    public void execute(Transaction tx) throws IOException {\n                        if (pageFile.getPageCount() == 0) {\n                            Page<MetaData> page = tx.allocate();\n                            assert page.getPageId() == 0;\n                            page.set(metaData);\n                            metaData.page = page;\n                            metaData.createIndexes(tx);\n                            tx.store(metaData.page, metaDataMarshaller, true);\n\n                        } else {\n                            Page<MetaData> page = tx.load(0, metaDataMarshaller);\n                            metaData = page.get();\n                            metaData.page = page;\n                        }\n                        metaData.load(tx);\n                        metaData.loadLists(tx, persistentLists);\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.load": "        void load(Transaction tx) throws IOException {\n            this.lists.setKeyMarshaller(StringMarshaller.INSTANCE);\n            this.lists.setValueMarshaller(new PListMarshaller(this.store));\n            this.lists.load(tx);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.loadLists": "        void loadLists(Transaction tx, Map<String, PList> lists) throws IOException {\n            for (Iterator<Entry<String, PList>> i = this.lists.iterator(tx); i.hasNext();) {\n                Entry<String, PList> entry = i.next();\n                entry.getValue().load(tx);\n                lists.put(entry.getKey(), entry.getValue());\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.createIndexes": "        void createIndexes(Transaction tx) throws IOException {\n            this.lists = new BTreeIndex<String, PList>(pageFile, tx.allocate().getPageId());\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getPList": "    public PList getPList(final String name) throws Exception {\n        if (!isStarted()) {\n            throw new IllegalStateException(\"Not started\");\n        }\n        intialize();\n        synchronized (indexLock) {\n            synchronized (this) {\n                PList result = this.persistentLists.get(name);\n                if (result == null) {\n                    final PList pl = new PList(this);\n                    pl.setName(name);\n                    getPageFile().tx().execute(new Transaction.Closure<IOException>() {\n                        public void execute(Transaction tx) throws IOException {\n                            pl.setHeadPageId(tx.allocate().getPageId());\n                            pl.load(tx);\n                            metaData.lists.put(tx, name, pl);\n                        }\n                    });\n                    result = pl;\n                    this.persistentLists.put(name, pl);\n                }\n                final PList load = result;\n                getPageFile().tx().execute(new Transaction.Closure<IOException>() {\n                    public void execute(Transaction tx) throws IOException {\n                        load.load(tx);\n                    }\n                });\n\n                return result;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getPageFile": "    PageFile getPageFile() {\n        this.pageFile.isLoaded();\n        return this.pageFile;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.intialize": "    protected synchronized void intialize() throws Exception {\n        if (isStarted()) {\n            if (this.initialized == false) {\n                this.initialized = true;\n                if (this.directory == null) {\n                    this.directory = new File(IOHelper.getDefaultDataDirectory() + File.pathSeparator + \"delayedDB\");\n                }\n                IOHelper.mkdirs(this.directory);\n                lock();\n                this.journal = new Journal();\n                this.journal.setDirectory(directory);\n                this.journal.setMaxFileLength(getJournalMaxFileLength());\n                this.journal.setWriteBatchSize(getJournalMaxWriteBatchSize());\n                this.journal.start();\n                this.pageFile = new PageFile(directory, \"tmpDB\");\n                this.pageFile.setPageSize(getIndexPageSize());\n                this.pageFile.setWriteBatchSize(getIndexWriteBatchSize());\n                this.pageFile.setPageCacheSize(getIndexCacheSize());\n                this.pageFile.load();\n\n                this.pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                    public void execute(Transaction tx) throws IOException {\n                        if (pageFile.getPageCount() == 0) {\n                            Page<MetaData> page = tx.allocate();\n                            assert page.getPageId() == 0;\n                            page.set(metaData);\n                            metaData.page = page;\n                            metaData.createIndexes(tx);\n                            tx.store(metaData.page, metaDataMarshaller, true);\n\n                        } else {\n                            Page<MetaData> page = tx.load(0, metaDataMarshaller);\n                            metaData = page.get();\n                            metaData.page = page;\n                        }\n                        metaData.load(tx);\n                        metaData.loadLists(tx, persistentLists);\n                    }\n                });\n                this.pageFile.flush();\n\n                if (cleanupInterval > 0) {\n                    if (scheduler == null) {\n                        scheduler = new Scheduler(PListStore.class.getSimpleName());\n                        scheduler.start();\n                    }\n                    scheduler.executePeriodically(this, cleanupInterval);\n                }\n                LOG.info(this + \" initialized\");\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList": "    protected PList getDiskList() {\n        if (diskList == null) {\n            try {\n                diskList = store.getPList(name);\n            } catch (Exception e) {\n                LOG.error(\"Caught an IO Exception getting the DiskList \" + name, e);\n                throw new RuntimeException(e);\n            }\n        }\n        return diskList;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk": "    protected synchronized void flushToDisk() {\n        if (!memoryList.isEmpty()) {\n            long start = 0;\n             if (LOG.isTraceEnabled()) {\n                start = System.currentTimeMillis();\n                LOG.trace(\"\" + name + \", flushToDisk() mem list size: \" +memoryList.size()  + \" \" +  (systemUsage != null ? systemUsage.getMemoryUsage() : \"\") );\n             }\n            while (!memoryList.isEmpty()) {\n                MessageReference node = memoryList.removeFirst();\n                node.decrementReferenceCount();\n                ByteSequence bs;\n                try {\n                    bs = getByteSequence(node.getMessage());\n                    getDiskList().addLast(node.getMessageId().toString(), bs);\n                } catch (IOException e) {\n                    LOG.error(\"Failed to write to disk list\", e);\n                    throw new RuntimeException(e);\n                }\n\n            }\n            memoryList.clear();\n            setCacheEnabled(false);\n             if (LOG.isTraceEnabled()) {\n                LOG.trace(\"\" + name + \", flushToDisk() done - \" + (System.currentTimeMillis() - start) + \"ms \" + (systemUsage != null ? systemUsage.getMemoryUsage() : \"\"));\n             }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.clear": "    public synchronized void clear() {\n        memoryList.clear();\n        if (!isDiskListEmpty()) {\n            try {\n                getDiskList().destroy();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        last = null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.isEmpty": "    public synchronized boolean isEmpty() {\n        if (memoryList.isEmpty() && isDiskListEmpty()) {\n            return true;\n        }\n        for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {\n            MessageReference node = iterator.next();\n            if (node == QueueMessageReference.NULL_MESSAGE) {\n                continue;\n            }\n            if (!node.isDropped()) {\n                return false;\n            }\n            // We can remove dropped references.\n            iterator.remove();\n        }\n        return isDiskListEmpty();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.size": "    public synchronized int size() {\n        return memoryList.size() + (isDiskListEmpty() ? 0 : (int)getDiskList().size());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getByteSequence": "    protected ByteSequence getByteSequence(Message message) throws IOException {\n        org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);\n        return new ByteSequence(packet.data, packet.offset, packet.length);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getMessage": "    protected Message getMessage(ByteSequence bs) throws IOException {\n        org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(bs.getData(), bs\n                .getOffset(), bs.getLength());\n        return (Message) this.wireFormat.unmarshal(packet);\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast": "    public synchronized boolean tryAddMessageLast(MessageReference node, long maxWaitTime) throws Exception {\n        if (!node.isExpired()) {\n            try {\n                regionDestination = node.getMessage().getRegionDestination();\n                if (isDiskListEmpty()) {\n                    if (hasSpace() || this.store == null) {\n                        memoryList.add(node);\n                        node.incrementReferenceCount();\n                        setCacheEnabled(true);\n                        return true;\n                    }\n                }\n                if (!hasSpace()) {\n                    if (isDiskListEmpty()) {\n                        expireOldMessages();\n                        if (hasSpace()) {\n                            memoryList.add(node);\n                            node.incrementReferenceCount();\n                            return true;\n                        } else {\n                            flushToDisk();\n                        }\n                    }\n                }\n                if (systemUsage.getTempUsage().waitForSpace(maxWaitTime)) {\n                    ByteSequence bs = getByteSequence(node.getMessage());\n                    getDiskList().addLast(node.getMessageId().toString(), bs);\n                    return true;\n                }\n                return false;\n\n            } catch (Exception e) {\n                LOG.error(\"Caught an Exception adding a message: \" + node + \" first to FilePendingMessageCursor \", e);\n                throw new RuntimeException(e);\n            }\n        } else {\n            discard(node);\n        }\n        //message expired\n        return true;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.discard": "    protected void discard(MessageReference message) {\n        message.decrementReferenceCount();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Discarding message \" + message);\n        }\n        ConnectionContext ctx = new ConnectionContext(new NonCachedMessageEvaluationContext());\n        ctx.setBroker(broker);\n        broker.getRoot().sendToDeadLetterQueue(ctx, message, null);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.isDiskListEmpty": "    protected boolean isDiskListEmpty() {\n        return diskList == null || diskList.isEmpty();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.expireOldMessages": "    protected synchronized void expireOldMessages() {\n        if (!memoryList.isEmpty()) {\n            LinkedList<MessageReference> tmpList = new LinkedList<MessageReference>(this.memoryList);\n            this.memoryList = new LinkedList<MessageReference>();\n            while (!tmpList.isEmpty()) {\n                MessageReference node = tmpList.removeFirst();\n                if (node.isExpired()) {\n                    discard(node);\n                } else {\n                    memoryList.add(node);\n                }\n            }\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast": "    public synchronized void addMessageLast(MessageReference node) throws Exception {\n        tryAddMessageLast(node, 0);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.sendMessage": "    final void sendMessage(final Message msg) throws Exception {\n        messagesLock.writeLock().lock();\n        try{\n            messages.addMessageLast(msg);\n        }finally {\n            messagesLock.writeLock().unlock();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doMessageSend": "    void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,\n            Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Future<Object> result = null;\n\n        checkUsage(context, message);\n        sendLock.lockInterruptibly();\n        try {\n            if (store != null && message.isPersistent()) {\n                message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n                if (messages.isCacheEnabled()) {\n                    result = store.asyncAddQueueMessage(context, message);\n                } else {\n                    store.addMessage(context, message);\n                }\n                if (isReduceMemoryFootprint()) {\n                    message.clearMarshalledState();\n                }\n            }\n            if (context.isInTransaction()) {\n                // If this is a transacted message.. increase the usage now so that\n                // a big TX does not blow up\n                // our memory. This increment is decremented once the tx finishes..\n                message.incrementReferenceCount();\n\n                context.getTransaction().addSynchronization(new Synchronization() {\n                    @Override\n                    public void afterCommit() throws Exception {\n                        sendLock.lockInterruptibly();\n                        try {\n                            // It could take while before we receive the commit\n                            // op, by that time the message could have expired..\n                            if (broker.isExpired(message)) {\n                                broker.messageExpired(context, message, null);\n                                destinationStatistics.getExpired().increment();\n                                return;\n                            }\n                            sendMessage(message);\n                        } finally {\n                            sendLock.unlock();\n                            message.decrementReferenceCount();\n                        }\n                        messageSent(context, message);\n                    }\n                    @Override\n                    public void afterRollback() throws Exception {\n                        message.decrementReferenceCount();\n                    }\n                });\n            } else {\n                // Add to the pending list, this takes care of incrementing the\n                // usage manager.\n                sendMessage(message);\n            }\n        } finally {\n            sendLock.unlock();\n        }\n        if (!context.isInTransaction()) {\n            messageSent(context, message);\n        }\n        if (result != null && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.get": "            public Message get(int index) {\n                return null;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message expired: \" + reference);\n        }\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.messageSent": "    final void messageSent(final ConnectionContext context, final Message msg) throws Exception {\n        destinationStatistics.getEnqueues().increment();\n        destinationStatistics.getMessages().increment();\n        messageDelivered(context, msg);\n        consumersLock.readLock().lock();\n        try {\n            if (consumers.isEmpty()) {\n                onMessageWithNoConsumers(context, msg);\n            }\n        }finally {\n            consumersLock.readLock().unlock();\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Message \" + msg.getMessageId() + \" sent to \" + this.destination);\n        }\n        wakeup();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.checkUsage": "    private void checkUsage(ConnectionContext context, Message message) throws ResourceAllocationException, IOException, InterruptedException {\n        if (message.isPersistent()) {\n            if (store != null && systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {\n                final String logMessage = \"Persistent store is Full, \" + getStoreUsageHighWaterMark() + \"% of \"\n                    + systemUsage.getStoreUsage().getLimit() + \". Stopping producer (\"\n                    + message.getProducerId() + \") to prevent flooding \"\n                    + getActiveMQDestination().getQualifiedName() + \".\"\n                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n\n                waitForSpace(context, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);\n            }\n        } else if (messages.getSystemUsage() != null && systemUsage.getTempUsage().isFull()) {\n            final String logMessage = \"Temp Store is Full (\"\n                    + systemUsage.getTempUsage().getPercentUsage() + \"% of \" + systemUsage.getTempUsage().getLimit()\n                    +\"). Stopping producer (\" + message.getProducerId()\n                + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n\n            waitForSpace(context, messages.getSystemUsage().getTempUsage(), logMessage);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.send": "    public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        // There is delay between the client sending it and it arriving at the\n        // destination.. it may have expired.\n        message.setRegionDestination(this);\n        final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();\n        final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0\n                && !context.isInRecoveryMode();\n        if (message.isExpired()) {\n            // message not stored - or added to stats yet - so chuck here\n            broker.getRoot().messageExpired(context, message, null);\n            if (sendProducerAck) {\n                ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n                context.getConnection().dispatchAsync(ack);\n            }\n            return;\n        }\n        if (memoryUsage.isFull()) {\n            isFull(context, memoryUsage);\n            fastProducer(context, producerInfo);\n            if (isProducerFlowControl() && context.isProducerFlowControl()) {\n                if (warnOnProducerFlowControl) {\n                    warnOnProducerFlowControl = false;\n                    LOG\n                            .info(\"Usage Manager Memory Limit (\"\n                                    + memoryUsage.getLimit()\n                                    + \") reached on \"\n                                    + getActiveMQDestination().getQualifiedName()\n                                    + \". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it.\"\n                                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                if (systemUsage.isSendFailIfNoSpace()) {\n                    throw new ResourceAllocationException(\"Usage Manager Memory Limit reached. Stopping producer (\"\n                            + message.getProducerId() + \") to prevent flooding \"\n                            + getActiveMQDestination().getQualifiedName() + \".\"\n                            + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                // We can avoid blocking due to low usage if the producer is\n                // sending\n                // a sync message or if it is using a producer window\n                if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {\n                    // copy the exchange state since the context will be\n                    // modified while we are waiting\n                    // for space.\n                    final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy();\n                    synchronized (messagesWaitingForSpace) {\n                     // Start flow control timeout task\n                        // Prevent trying to start it multiple times\n                        if (!flowControlTimeoutTask.isAlive()) {\n                            flowControlTimeoutTask.setName(getName()+\" Producer Flow Control Timeout Task\");\n                            flowControlTimeoutTask.start();\n                        }\n                        messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {\n                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message, null);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of :\" + message, e);\n                                    }\n                                }\n                            }\n                        });\n\n                        if (systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {\n                            flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage\n                                    .getSendFailIfNoSpaceAfterTimeout()));\n                        }\n\n                        registerCallbackForNotFullNotification();\n                        context.setDontSendReponse(true);\n                        return;\n                    }\n\n                } else {\n\n                    if (memoryUsage.isFull()) {\n                        waitForSpace(context, memoryUsage, \"Usage Manager Memory Limit reached. Producer (\"\n                                + message.getProducerId() + \") stopped to prevent flooding \"\n                                + getActiveMQDestination().getQualifiedName() + \".\"\n                                + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                    }\n\n                    // The usage manager could have delayed us by the time\n                    // we unblock the message could have expired..\n                    if (message.isExpired()) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Expired message: \" + message);\n                        }\n                        broker.getRoot().messageExpired(context, message, null);\n                        return;\n                    }\n                }\n            }\n        }\n        doMessageSend(producerExchange, message);\n        if (sendProducerAck) {\n            ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n            context.getConnection().dispatchAsync(ack);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.start": "    public void start() throws Exception {\n        if (memoryUsage != null) {\n            memoryUsage.start();\n        }\n        if (systemUsage.getStoreUsage() != null) {\n            systemUsage.getStoreUsage().start();\n        }\n        systemUsage.getMemoryUsage().addUsageListener(this);\n        messages.start();\n        if (getExpireMessagesPeriod() > 0) {\n            scheduler.schedualPeriodically(expireMessagesTask, getExpireMessagesPeriod());\n        }\n        doPageIn(false);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.add": "            public void add(int index, Message element) {\n                size++;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getActiveMQDestination": "    public ActiveMQDestination getActiveMQDestination() {\n        return destination;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.send": "    public void send(final ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n\n        if (producerExchange.isMutable() || producerExchange.getRegionDestination() == null) {\n            final Destination regionDestination = lookup(context, messageSend.getDestination(),false);\n            producerExchange.setRegionDestination(regionDestination);\n        }\n\n        producerExchange.getRegionDestination().send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.lookup": "    protected Destination lookup(ConnectionContext context, ActiveMQDestination destination,boolean createTemporary) throws Exception {\n        Destination dest = null;\n        synchronized (destinationsMutex) {\n            dest = destinations.get(destination);\n        }\n        if (dest == null) {\n            if (isAutoCreateDestinations()) {\n                // Try to auto create the destination... re-invoke broker\n                // from the\n                // top so that the proper security checks are performed.\n                try {\n                    context.getBroker().addDestination(context, destination, createTemporary);\n                    dest = addDestination(context, destination, false);\n                } catch (DestinationAlreadyExistsException e) {\n                    // if the destination already exists then lets ignore\n                    // this error\n                }\n                // We should now have the dest created.\n                synchronized (destinationsMutex) {\n                    dest = destinations.get(destination);\n                }\n            }\n            if (dest == null) {\n                throw new JMSException(\"The destination \" + destination + \" does not exist.\");\n            }\n        }\n        return dest;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        message.setBrokerInTime(System.currentTimeMillis());\n        if (producerExchange.isMutable() || producerExchange.getRegion() == null\n                || (producerExchange.getRegion() != null && producerExchange.getRegion().getDestinationMap().get(message.getDestination()) == null)\n                || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {\n            ActiveMQDestination destination = message.getDestination();\n            // ensure the destination is registered with the RegionBroker\n            producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());\n            Region region;\n            switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                region = queueRegion;\n                break;\n            case ActiveMQDestination.TOPIC_TYPE:\n                region = topicRegion;\n                break;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                region = tempQueueRegion;\n                break;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                region = tempTopicRegion;\n                break;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n            }\n            producerExchange.setRegion(region);\n            producerExchange.setRegionDestination(null);\n        }\n\n        producerExchange.getRegion().send(producerExchange, message);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.createUnknownDestinationTypeException": "    protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {\n        return new JMSException(\"Unknown destination type: \" + destination.getDestinationType());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean create) throws Exception {\n\n        Destination answer;\n\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            answer = queueRegion.addDestination(context, destination,true);\n            break;\n        case ActiveMQDestination.TOPIC_TYPE:\n            answer = topicRegion.addDestination(context, destination,true);\n            break;\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            answer = tempQueueRegion.addDestination(context, destination,create);\n            break;\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            answer = tempTopicRegion.addDestination(context, destination,create);\n            break;\n        default:\n            throw createUnknownDestinationTypeException(destination);\n        }\n\n        destinations.put(destination, answer);\n        return answer;\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.isAllowTempAutoCreationOnSend": "    public boolean isAllowTempAutoCreationOnSend() {\n        return allowTempAutoCreationOnSend;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.getDestinationMap": "    public Map<ActiveMQDestination, Destination> getDestinationMap() {\n        Map<ActiveMQDestination, Destination> answer = getQueueRegion().getDestinationMap();\n        answer.putAll(getTopicRegion().getDestinationMap());\n        return answer;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        next.send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.CompositeDestinationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        if (destination.isComposite()) {\n            ActiveMQDestination[] destinations = destination.getCompositeDestinations();\n            for (int i = 0; i < destinations.length; i++) {\n                if (i != 0) {\n                    message = message.copy();\n                    message.setMemoryUsage(null);\n                }\n                message.setOriginalDestination(destination);\n                message.setDestination(destinations[i]);\n                next.send(producerExchange, message);\n            }\n        } else {\n            next.send(producerExchange, message);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        Synchronization sync = null;\n        if (message.getTransactionId() != null) {\n            transaction = getTransaction(context, message.getTransactionId(), false);\n            if (transaction != null) {\n                sync = new Synchronization() {\n\n                    public void afterRollback() {\n                        if (audit != null) {\n                            audit.rollback(message);\n                        }\n                    }\n                };\n                transaction.addSynchronization(sync);\n            }\n        }\n        if (audit == null || !audit.isDuplicate(message)) {\n            context.setTransaction(transaction);\n            try {\n                next.send(producerExchange, message);\n            } finally {\n                context.setTransaction(originalTx);\n            }\n        } else {\n            if (sync != null && transaction != null) {\n                transaction.removeSynchronization(sync);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"IGNORING duplicate message \" + message);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.UserIDBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        String userID = context.getUserName();\n        if (isUseAuthenticatePrincipal()) {\n            SecurityContext securityContext = context.getSecurityContext();\n            if (securityContext != null) {\n                Set<?> principals = securityContext.getPrincipals();\n                if (principals != null) {\n                    for (Object candidate : principals) {\n                        if (candidate instanceof UserPrincipal) {\n                            userID = ((UserPrincipal)candidate).getName();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        messageSend.setUserID(userID);\n        super.send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.UserIDBroker.isUseAuthenticatePrincipal": "    public boolean isUseAuthenticatePrincipal() {\n        return useAuthenticatePrincipal;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processMessage": "    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.getProducerBrokerExchange": "    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                if (context.isReconnect()) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                result.setConnectionContext(context);\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.ActiveMQMessage.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessage(this);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            response = command.visit(this);\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Wait a little bit to try to get the output buffer to flush\n                // the exption notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchAsync(ce);\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        // getStatistics().getEnqueues().increment();\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportFilter.onCommand": "    public void onCommand(Object command) {\n        transportListener.onCommand(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ": "    public void sendToActiveMQ(Command command) {\n        TransportListener l = transportListener;\n        if (l!=null) {\n            l.onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.StompTransportFilter.onCommand": "    public void onCommand(Object command) {\n        try {\n            if (trace) {\n                LOG.trace(\"Received: \\n\" + command);\n            }\n           \n            protocolConverter.onStompCommand((StompFrame)command);\n        } catch (IOException e) {\n            onException(e);\n        } catch (JMSException e) {\n            onException(IOExceptionSupport.create(e));\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ": "    protected void sendToActiveMQ(Command command, ResponseHandler handler) {\n        command.setCommandId(generateCommandId());\n        if (handler != null) {\n            command.setResponseRequired(true);\n            resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);\n        }\n        stompTransport.sendToActiveMQ(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.generateCommandId": "    protected int generateCommandId() {\n        synchronized (commnadIdMutex) {\n            return lastCommandId++;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend": "    protected void onStompSend(StompFrame command) throws IOException, JMSException {\n        checkConnected();\n\n        Map<String, String> headers = command.getHeaders();\n        String stompTx = headers.get(Stomp.Headers.TRANSACTION);\n        headers.remove(\"transaction\");\n\n        ActiveMQMessage message = convertMessage(command);\n\n        message.setProducerId(producerId);\n        MessageId id = new MessageId(producerId, messageIdGenerator.getNextSequenceId());\n        message.setMessageId(id);\n        message.setJMSTimestamp(System.currentTimeMillis());\n\n        if (stompTx != null) {\n            TransactionId activemqTx = transactions.get(stompTx);\n            if (activemqTx == null) {\n                throw new ProtocolException(\"Invalid transaction id: \" + stompTx);\n            }\n            message.setTransactionId(activemqTx);\n        }\n\n        message.onSend();\n        sendToActiveMQ(message, createResponseHandler(command));\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.createResponseHandler": "    protected ResponseHandler createResponseHandler(final StompFrame command) {\n        final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);\n        if (receiptId != null) {\n            return new ResponseHandler() {\n                public void onResponse(ProtocolConverter converter, Response response) throws IOException {\n                    if (response.isException()) {\n                        // Generally a command can fail.. but that does not invalidate the connection.\n                        // We report back the failure but we don't close the connection.\n                        Throwable exception = ((ExceptionResponse)response).getException();\n                        handleException(exception, command);\n                    } else {\n                        StompFrame sc = new StompFrame();\n                        sc.setAction(Stomp.Responses.RECEIPT);\n                        sc.setHeaders(new HashMap<String, String>(1));\n                        sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);\n                        stompTransport.sendToStomp(sc);\n                    }\n                }\n            };\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.checkConnected": "    protected void checkConnected() throws ProtocolException {\n        if (!connected.get()) {\n            throw new ProtocolException(\"Not connected.\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.convertMessage": "    public StompFrame convertMessage(ActiveMQMessage message, boolean ignoreTransformation) throws IOException, JMSException {\n        if (ignoreTransformation == true) {\n            return frameTranslator.convertMessage(this, message);\n        } else {\n            return findTranslator(message.getStringProperty(Stomp.Headers.TRANSFORMATION)).convertMessage(this, message);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand": "    public void onStompCommand(StompFrame command) throws IOException, JMSException {\n        try {\n\n            if (command.getClass() == StompFrameError.class) {\n                throw ((StompFrameError)command).getException();\n            }\n\n            String action = command.getAction();\n            if (action.startsWith(Stomp.Commands.SEND)) {\n                onStompSend(command);\n            } else if (action.startsWith(Stomp.Commands.ACK)) {\n                onStompAck(command);\n            } else if (action.startsWith(Stomp.Commands.BEGIN)) {\n                onStompBegin(command);\n            } else if (action.startsWith(Stomp.Commands.COMMIT)) {\n                onStompCommit(command);\n            } else if (action.startsWith(Stomp.Commands.ABORT)) {\n                onStompAbort(command);\n            } else if (action.startsWith(Stomp.Commands.SUBSCRIBE)) {\n                onStompSubscribe(command);\n            } else if (action.startsWith(Stomp.Commands.UNSUBSCRIBE)) {\n                onStompUnsubscribe(command);\n            } else if (action.startsWith(Stomp.Commands.CONNECT)) {\n                onStompConnect(command);\n            } else if (action.startsWith(Stomp.Commands.DISCONNECT)) {\n                onStompDisconnect(command);\n            } else {\n                throw new ProtocolException(\"Unknown STOMP action: \" + action);\n            }\n\n        } catch (ProtocolException e) {\n            handleException(e, command);\n            // Some protocol errors can cause the connection to get closed.\n            if( e.isFatal() ) {\n               getStompTransport().onException(e);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommit": "    protected void onStompCommit(StompFrame command) throws ProtocolException {\n        checkConnected();\n\n        Map<String, String> headers = command.getHeaders();\n\n        String stompTx = headers.get(Stomp.Headers.TRANSACTION);\n        if (stompTx == null) {\n            throw new ProtocolException(\"Must specify the transaction you are committing\");\n        }\n\n        TransactionId activemqTx = transactions.remove(stompTx);\n        if (activemqTx == null) {\n            throw new ProtocolException(\"Invalid transaction id: \" + stompTx);\n        }\n\n        for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {\n            StompSubscription sub = iter.next();\n            sub.onStompCommit(activemqTx);\n        }\n\n        TransactionInfo tx = new TransactionInfo();\n        tx.setConnectionId(connectionId);\n        tx.setTransactionId(activemqTx);\n        tx.setType(TransactionInfo.COMMIT_ONE_PHASE);\n\n        sendToActiveMQ(tx, createResponseHandler(command));\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompAbort": "    protected void onStompAbort(StompFrame command) throws ProtocolException {\n        checkConnected();\n        Map<String, String> headers = command.getHeaders();\n\n        String stompTx = headers.get(Stomp.Headers.TRANSACTION);\n        if (stompTx == null) {\n            throw new ProtocolException(\"Must specify the transaction you are committing\");\n        }\n\n        TransactionId activemqTx = transactions.remove(stompTx);\n        if (activemqTx == null) {\n            throw new ProtocolException(\"Invalid transaction id: \" + stompTx);\n        }\n        for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {\n            StompSubscription sub = iter.next();\n            try {\n                sub.onStompAbort(activemqTx);\n            } catch (Exception e) {\n                throw new ProtocolException(\"Transaction abort failed\", false, e);\n            }\n        }\n\n        TransactionInfo tx = new TransactionInfo();\n        tx.setConnectionId(connectionId);\n        tx.setTransactionId(activemqTx);\n        tx.setType(TransactionInfo.ROLLBACK);\n\n        sendToActiveMQ(tx, createResponseHandler(command));\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompDisconnect": "    protected void onStompDisconnect(StompFrame command) throws ProtocolException {\n        checkConnected();\n        sendToActiveMQ(connectionInfo.createRemoveCommand(), createResponseHandler(command));\n        sendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));\n        connected.set(false);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompAck": "    protected void onStompAck(StompFrame command) throws ProtocolException {\n        checkConnected();\n\n        // TODO: acking with just a message id is very bogus\n        // since the same message id could have been sent to 2 different\n        // subscriptions\n        // on the same stomp connection. For example, when 2 subs are created on\n        // the same topic.\n\n        Map<String, String> headers = command.getHeaders();\n        String messageId = headers.get(Stomp.Headers.Ack.MESSAGE_ID);\n        if (messageId == null) {\n            throw new ProtocolException(\"ACK received without a message-id to acknowledge!\");\n        }\n\n        TransactionId activemqTx = null;\n        String stompTx = headers.get(Stomp.Headers.TRANSACTION);\n        if (stompTx != null) {\n            activemqTx = transactions.get(stompTx);\n            if (activemqTx == null) {\n                throw new ProtocolException(\"Invalid transaction id: \" + stompTx);\n            }\n        }\n\n        boolean acked = false;\n        for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {\n            StompSubscription sub = iter.next();\n            MessageAck ack = sub.onStompMessageAck(messageId, activemqTx);\n            if (ack != null) {\n                ack.setTransactionId(activemqTx);\n                sendToActiveMQ(ack, createResponseHandler(command));\n                acked = true;\n                break;\n            }\n        }\n\n        if (!acked) {\n            throw new ProtocolException(\"Unexpected ACK received for message-id [\" + messageId + \"]\");\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompBegin": "    protected void onStompBegin(StompFrame command) throws ProtocolException {\n        checkConnected();\n\n        Map<String, String> headers = command.getHeaders();\n\n        String stompTx = headers.get(Stomp.Headers.TRANSACTION);\n\n        if (!headers.containsKey(Stomp.Headers.TRANSACTION)) {\n            throw new ProtocolException(\"Must specify the transaction you are beginning\");\n        }\n\n        if (transactions.get(stompTx) != null) {\n            throw new ProtocolException(\"The transaction was allready started: \" + stompTx);\n        }\n\n        LocalTransactionId activemqTx = new LocalTransactionId(connectionId, transactionIdGenerator.getNextSequenceId());\n        transactions.put(stompTx, activemqTx);\n\n        TransactionInfo tx = new TransactionInfo();\n        tx.setConnectionId(connectionId);\n        tx.setTransactionId(activemqTx);\n        tx.setType(TransactionInfo.BEGIN);\n\n        sendToActiveMQ(tx, createResponseHandler(command));\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompUnsubscribe": "    protected void onStompUnsubscribe(StompFrame command) throws ProtocolException {\n        checkConnected();\n        Map<String, String> headers = command.getHeaders();\n\n        ActiveMQDestination destination = null;\n        Object o = headers.get(Stomp.Headers.Unsubscribe.DESTINATION);\n        if (o != null) {\n            destination = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION)).convertDestination(this, (String)o);\n        }\n\n        String subscriptionId = headers.get(Stomp.Headers.Unsubscribe.ID);\n\n        if (subscriptionId == null && destination == null) {\n            throw new ProtocolException(\"Must specify the subscriptionId or the destination you are unsubscribing from\");\n        }\n\n        // check if it is a durable subscription\n        String durable = command.getHeaders().get(\"activemq.subscriptionName\");\n        if (durable != null) {\n            RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();\n            info.setClientId(durable);\n            info.setSubscriptionName(durable);\n            info.setConnectionId(connectionId);\n            sendToActiveMQ(info, createResponseHandler(command));\n            return;\n        }\n\n        // TODO: Unsubscribing using a destination is a bit wierd if multiple\n        // subscriptions\n        // are created with the same destination. Perhaps this should be\n        // removed.\n        //\n        for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {\n            StompSubscription sub = iter.next();\n            if ((subscriptionId != null && subscriptionId.equals(sub.getSubscriptionId())) || (destination != null && destination.equals(sub.getDestination()))) {\n                sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));\n                iter.remove();\n                return;\n            }\n        }\n\n        throw new ProtocolException(\"No subscription matched.\");\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompConnect": "    protected void onStompConnect(final StompFrame command) throws ProtocolException {\n\n        if (connected.get()) {\n            throw new ProtocolException(\"Allready connected.\");\n        }\n\n        final Map<String, String> headers = command.getHeaders();\n\n        // allow anyone to login for now\n        String login = headers.get(Stomp.Headers.Connect.LOGIN);\n        String passcode = headers.get(Stomp.Headers.Connect.PASSCODE);\n        String clientId = headers.get(Stomp.Headers.Connect.CLIENT_ID);\n\n\n        IntrospectionSupport.setProperties(connectionInfo, headers, \"activemq.\");\n\n        connectionInfo.setConnectionId(connectionId);\n        if (clientId != null) {\n            connectionInfo.setClientId(clientId);\n        } else {\n            connectionInfo.setClientId(\"\" + connectionInfo.getConnectionId().toString());\n        }\n\n        connectionInfo.setResponseRequired(true);\n        connectionInfo.setUserName(login);\n        connectionInfo.setPassword(passcode);\n        connectionInfo.setTransportContext(stompTransport.getPeerCertificates());\n\n        sendToActiveMQ(connectionInfo, new ResponseHandler() {\n            public void onResponse(ProtocolConverter converter, Response response) throws IOException {\n\n                if (response.isException()) {\n                    // If the connection attempt fails we close the socket.\n                    Throwable exception = ((ExceptionResponse)response).getException();\n                    handleException(exception, command);\n                    getStompTransport().onException(IOExceptionSupport.create(exception));\n                    return;\n                }\n\n                final SessionInfo sessionInfo = new SessionInfo(sessionId);\n                sendToActiveMQ(sessionInfo, null);\n\n                final ProducerInfo producerInfo = new ProducerInfo(producerId);\n                sendToActiveMQ(producerInfo, new ResponseHandler() {\n                    public void onResponse(ProtocolConverter converter, Response response) throws IOException {\n\n                        if (response.isException()) {\n                            // If the connection attempt fails we close the socket.\n                            Throwable exception = ((ExceptionResponse)response).getException();\n                            handleException(exception, command);\n                            getStompTransport().onException(IOExceptionSupport.create(exception));\n                        }\n\n                        connected.set(true);\n                        HashMap<String, String> responseHeaders = new HashMap<String, String>();\n\n                        responseHeaders.put(Stomp.Headers.Connected.SESSION, connectionInfo.getClientId());\n                        String requestId = headers.get(Stomp.Headers.Connect.REQUEST_ID);\n                        if (requestId == null) {\n                            // TODO legacy\n                            requestId = headers.get(Stomp.Headers.RECEIPT_REQUESTED);\n                        }\n                        if (requestId != null) {\n                            // TODO legacy\n                            responseHeaders.put(Stomp.Headers.Connected.RESPONSE_ID, requestId);\n                            responseHeaders.put(Stomp.Headers.Response.RECEIPT_ID, requestId);\n                        }\n\n                        StompFrame sc = new StompFrame();\n                        sc.setAction(Stomp.Responses.CONNECTED);\n                        sc.setHeaders(responseHeaders);\n                        sendToStomp(sc);\n                    }\n                });\n\n            }\n        });\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.getStompTransport": "    public StompTransport getStompTransport() {\n        return stompTransport;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.handleException": "    protected void handleException(Throwable exception, StompFrame command) throws IOException {\n        LOG.warn(\"Exception occurred processing: \\n\" + command + \": \" + exception.toString());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Exception detail\", exception);\n        }\n\n        // Let the stomp client know about any protocol errors.\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        PrintWriter stream = new PrintWriter(new OutputStreamWriter(baos, \"UTF-8\"));\n        exception.printStackTrace(stream);\n        stream.close();\n\n        HashMap<String, String> headers = new HashMap<String, String>();\n        headers.put(Stomp.Headers.Error.MESSAGE, exception.getMessage());\n\n        if (command != null) {\n            final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);\n            if (receiptId != null) {\n                headers.put(Stomp.Headers.Response.RECEIPT_ID, receiptId);\n            }\n        }\n\n        StompFrame errorMessage = new StompFrame(Stomp.Responses.ERROR, headers, baos.toByteArray());\n        sendToStomp(errorMessage);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.stomp.ProtocolConverter.onStompSubscribe": "    protected void onStompSubscribe(StompFrame command) throws ProtocolException {\n        checkConnected();\n        FrameTranslator translator = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION));\n        Map<String, String> headers = command.getHeaders();\n\n        String subscriptionId = headers.get(Stomp.Headers.Subscribe.ID);\n        String destination = headers.get(Stomp.Headers.Subscribe.DESTINATION);\n\n        ActiveMQDestination actualDest = translator.convertDestination(this, destination);\n\n        if (actualDest == null) {\n            throw new ProtocolException(\"Invalid Destination.\");\n        }\n\n        ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());\n        ConsumerInfo consumerInfo = new ConsumerInfo(id);\n        consumerInfo.setPrefetchSize(1000);\n        consumerInfo.setDispatchAsync(true);\n\n        String selector = headers.remove(Stomp.Headers.Subscribe.SELECTOR);\n        consumerInfo.setSelector(selector);\n\n        IntrospectionSupport.setProperties(consumerInfo, headers, \"activemq.\");\n\n        consumerInfo.setDestination(translator.convertDestination(this, destination));\n\n        StompSubscription stompSubscription = new StompSubscription(this, subscriptionId, consumerInfo, headers.get(Stomp.Headers.TRANSFORMATION));\n        stompSubscription.setDestination(actualDest);\n\n        String ackMode = headers.get(Stomp.Headers.Subscribe.ACK_MODE);\n        if (Stomp.Headers.Subscribe.AckModeValues.CLIENT.equals(ackMode)) {\n            stompSubscription.setAckMode(StompSubscription.CLIENT_ACK);\n        } else if (Stomp.Headers.Subscribe.AckModeValues.INDIVIDUAL.equals(ackMode)) {\n            stompSubscription.setAckMode(StompSubscription.INDIVIDUAL_ACK);\n        } else {\n            stompSubscription.setAckMode(StompSubscription.AUTO_ACK);\n        }\n\n        subscriptionsByConsumerId.put(id, stompSubscription);\n        sendToActiveMQ(consumerInfo, createResponseHandler(command));\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        try {\n                            socket.close();\n                        } catch (IOException e) {\n                            LOG.debug(\"Caught exception closing socket\",e);\n                        }finally {\n                            latch.countDown();\n                        }\n                    }",
            "kahadb.src.main.java.org.apache.kahadb.index.ListNode.setPage": "    public void setPage(Page<ListNode<Key, Value>> page) {\n        this.page = page;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.destroy": "    public synchronized void destroy() throws IOException {\n        synchronized (indexLock) {\n            this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {\n                public void execute(Transaction tx) throws IOException {\n                    clear(tx);\n                    unload(tx);\n                }\n            });\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.execute": "                    public void execute(Transaction tx) throws IOException {\n                        Iterator<Map.Entry<String,Location>> iterator = iterator(tx);\n                        while (iterator.hasNext()) {\n                            Location location = iterator.next().getValue();\n                            candidates.remove(location.getDataFileId());\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.setName": "    public void setName(String name) {\n        this.name = name;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getExpired": "    public CountStatisticImpl getExpired() {\n        return expired;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConnectionContext.getUserName": "    public String getUserName() {\n        return userName;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConnectionContext.getSecurityContext": "    public SecurityContext getSecurityContext() {\n        return securityContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.canDispatch": "    public boolean canDispatch(Message messageSend) {\n        boolean canDispatch = true;\n        if (lastSendSequenceNumber > 0) {\n            if (messageSend.getMessageId().getProducerSequenceId() <= lastSendSequenceNumber) {\n                canDispatch = false;\n                LOG.debug(\"suppressing duplicate message send [\" + messageSend.getMessageId() + \"] with producerSequenceId [\" \n                        + messageSend.getMessageId().getProducerSequenceId() + \"] less than last stored: \"  + lastSendSequenceNumber);\n            }\n        }\n        return canDispatch;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "Contention in PLIist  creation results in NPE on load - FilePendingMessageCursor",
            "Description": "Ocassional ocurrance of stack trace{code}2011-06-30 16:02:09,903 [127.0.0.1:50524] ERROR FilePendingMessageCursor       - Caught an IO Exception getting the DiskList 98_PendingCursor:loadq-3\njava.lang.NullPointerException\n\tat org.apache.kahadb.index.ListIndex.loadNode(ListIndex.java:203)\n\tat org.apache.kahadb.index.ListIndex.load(ListIndex.java:75)\n\tat org.apache.activemq.store.kahadb.plist.PListStore$1.execute(PListStore.java:219)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:729)\n\tat org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:216)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:454)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:432)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast(FilePendingMessageCursor.java:217)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast(FilePendingMessageCursor.java:193)\n\tat org.apache.activemq.broker.region.Queue.sendMessage(Queue.java:1629)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:720)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:652)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:379)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:523)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:304)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.UserIDBroker.send(UserIDBroker.java:56)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:468)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:316)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:180)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:81)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:140)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:257)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:178)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:70)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:221)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:203)\n\tat java.lang.Thread.run(Thread.java:662)\n2011-06-30 16:02:09,912 [127.0.0.1:50524] ERROR FilePendingMessageCursor       - Caught an Exception adding a message: ActiveMQBytesMessage {commandId = 19796,\n responseRequired = false, messageId = ID:bigmacli-40948-1309463846336-2:105:-1:1:19794, originalDestination = null, originalTransactionId = null, producerId = ID:bigmacli-\n40948-1309463846336-2:105:-1:1, destination = queue://loadq-3, transactionId = null, expiration = 0, timestamp = 1309464129898, arrival = 0, brokerInTime = 1309464129898, \nbrokerOutTime = 0, correlationId = null, replyTo = null, persistent = false, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, \nuserID = null, content = org.apache.activemq.util.ByteSequence@665e2517, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 0, properties = null, \nreadOnlyProperties = true, readOnlyBody = true, droppable = false} ActiveMQBytesMessage{ bytesOut = null, dataOut = null, dataIn = null } first to FilePendingMessageCursor \n\njava.lang.RuntimeException: java.lang.NullPointerException\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:457)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:432)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast(FilePendingMessageCursor.java:217)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast(FilePendingMessageCursor.java:193)\n\tat org.apache.activemq.broker.region.Queue.sendMessage(Queue.java:1629)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:720)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:652)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:379)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:523)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:304)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.UserIDBroker.send(UserIDBroker.java:56)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:468)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:316)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:180)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:81)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:140)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:257)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:178)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:70)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:221)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:203)\n\tat java.lang.Thread.run(Thread.java:662)\nCaused by: java.lang.NullPointerException\n\tat org.apache.kahadb.index.ListIndex.loadNode(ListIndex.java:203)\n\tat org.apache.kahadb.index.ListIndex.load(ListIndex.java:75)\n\tat org.apache.activemq.store.kahadb.plist.PListStore$1.execute(PListStore.java:219)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:729)\n\tat org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:216)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:454)\n\t... 28 more\n\n \n\n2011-06-30 16:02:44,121 [Queue:loadq-9  ] ERROR Queue                          - Failed to page in more queue messages \njava.util.NoSuchElementException: Chunk stream does not exist, page: 63122 is marked free\n\tat org.apache.kahadb.index.ListNode$ListIterator.nextFromNextListNode(ListNode.java:149)\n\tat org.apache.kahadb.index.ListNode$ListIterator.hasNext(ListNode.java:160)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator.hasNext(PList.java:203)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.hasNext(FilePendingMessageCursor.java:496)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.hasNext(FilePendingMessageCursor.java:288)\n\tat org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1725)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1944)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1452)\n\tat org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)\n\tat org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)\nCaused by: java.io.EOFException: Chunk stream does not exist, page: 63122 is marked free\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:456)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:433)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:430)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:406)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:363)\n\tat org.apache.kahadb.index.ListIndex.loadNode(ListIndex.java:201)\n\tat org.apache.kahadb.index.ListNode$ListIterator.nextFromNextListNode(ListNode.java:147)\n\t... 9 more\n\n \n\n2011-06-30 16:02:49,401 [Queue:loadq-4  ] ERROR Queue                          - Failed to page in more queue messages \njava.util.NoSuchElementException: Could not locate data file /lab/activemq-5.5.0-fuse-00-27/data/broker/tmp_storage/db-3.log\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator.next(PList.java:213)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator.next(PList.java:192)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:501)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:485)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.next(FilePendingMessageCursor.java:296)\n\tat org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1726)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1944)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1452)\n\tat org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)\n\tat org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)\nCaused by: java.io.IOException: Could not locate data file /lab/activemq-5.5.0-fuse-00-27/data/broker/tmp_storage/db-3.log\n\tat org.apache.kahadb.journal.Journal.getDataFile(Journal.java:350)\n\tat org.apache.kahadb.journal.Journal.read(Journal.java:597)\n\tat org.apache.activemq.store.kahadb.plist.PListStore.getPayload(PListStore.java:367)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator.next(PList.java:211)\n\t... 9 more{code}"
        }
    },
    {
        "filename": "AMQ-3443.json",
        "creation_time": "2011-08-09T17:46:14.000+0000",
        "stack_trace": "java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)\n\tat org.apache.kahadb.util.IOExceptionSupport.create(IOExceptionSupport.java:27)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1002)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:482)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1167)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:728)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:762)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:726)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:714)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:279)\nCaused by: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:212)\n\tat org.apache.kahadb.page.PageFile$PageWrite.getDiskBound(PageFile.java:185)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1000)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.util.IOExceptionSupport.create": "    public static IOException create(Exception cause) {\n        IOException exception = new IOException(cause.getMessage());\n        exception.initCause(cause);\n        return exception;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.writeBatch": "     private void writeBatch() throws IOException {\n\n         CountDownLatch checkpointLatch;\n         ArrayList<PageWrite> batch;\n         synchronized( writes ) {\n            // If there is not enough to write, wait for a notification...\n\n            batch = new ArrayList<PageWrite>(writes.size());\n            // build a write batch from the current write cache.\n            for (PageWrite write : writes.values()) {\n                batch.add(write);\n                // Move the current write to the diskBound write, this lets folks update the\n                // page again without blocking for this write.\n                write.begin();\n                if (write.diskBound == null && write.diskBoundLocation == -1) {\n                    batch.remove(write);\n                }\n            }\n\n            // Grab on to the existing checkpoint latch cause once we do this write we can\n            // release the folks that were waiting for those writes to hit disk.\n            checkpointLatch = this.checkpointLatch;\n            this.checkpointLatch=null;\n         }\n\n         Checksum checksum = new Adler32();\n         recoveryFile.seek(RECOVERY_FILE_HEADER_SIZE);\n         for (PageWrite w : batch) {\n             if (enableRecoveryFile) {\n                 try {\n                     checksum.update(w.getDiskBound(), 0, pageSize);\n                 } catch (Throwable t) {\n                     throw IOExceptionSupport.create(\"Cannot create recovery file. Reason: \" + t, t);\n                 }\n                 recoveryFile.writeLong(w.page.getPageId());\n                 recoveryFile.write(w.getDiskBound(), 0, pageSize);\n             }\n\n             writeFile.seek(toOffset(w.page.getPageId()));\n             writeFile.write(w.getDiskBound(), 0, pageSize);\n             w.done();\n         }\n\n         try {\n             if (enableRecoveryFile) {\n                 // Can we shrink the recovery buffer??\n                 if (recoveryPageCount > recoveryFileMaxPageCount) {\n                     int t = Math.max(recoveryFileMinPageCount, batch.size());\n                     recoveryFile.setLength(recoveryFileSizeForPages(t));\n                 }\n\n                 // Record the page writes in the recovery buffer.\n                 recoveryFile.seek(0);\n                 // Store the next tx id...\n                 recoveryFile.writeLong(nextTxid.get());\n                 // Store the checksum for thw write batch so that on recovery we\n                 // know if we have a consistent\n                 // write batch on disk.\n                 recoveryFile.writeLong(checksum.getValue());\n                 // Write the # of pages that will follow\n                 recoveryFile.writeInt(batch.size());\n             }\n\n             if (enableDiskSyncs) {\n                 // Sync to make sure recovery buffer writes land on disk..\n                 recoveryFile.getFD().sync();\n                 writeFile.getFD().sync();\n             }\n         } finally {\n             synchronized (writes) {\n                 for (PageWrite w : batch) {\n                     // If there are no more pending writes, then remove it from\n                     // the write cache.\n                     if (w.isDone()) {\n                         writes.remove(w.page.getPageId());\n                     }\n                 }\n             }\n\n             if (checkpointLatch != null) {\n                 checkpointLatch.countDown();\n             }\n         }\n     }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.write": "    void write(Collection<Map.Entry<Long, PageWrite>> updates) throws IOException {\n        synchronized( writes ) {\n            if( enabledWriteThread  ) {\n                while( writes.size() >= writeBatchSize && !stopWriter.get() ) {\n                    try {\n                        writes.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        throw new InterruptedIOException();\n                    }\n                }\n            }\n\n            boolean longTx = false;\n\n            for (Map.Entry<Long, PageWrite> entry : updates) {\n                Long key = entry.getKey();\n                PageWrite value = entry.getValue();\n                PageWrite write = writes.get(key);\n                if( write==null ) {\n                    writes.put(key, value);\n                } else {\n                    if (value.currentLocation != -1) {\n                        write.setCurrentLocation(value.page, value.currentLocation, value.length);\n                        write.tmpFile = value.tmpFile;\n                        longTx = true;\n                    } else {\n                        write.setCurrent(value.page, value.current);\n                    }\n                }\n            }\n            \n            // Once we start approaching capacity, notify the writer to start writing\n            // sync immediately for long txs\n            if( longTx || canStartWriteBatch() ) {\n\n                if( enabledWriteThread  ) {\n                    writes.notify();\n                } else {\n                    writeBatch();\n                }\n            }\n        }            \n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getDiskBound": "        public byte[] getDiskBound() throws IOException {\n            if (diskBound == null && diskBoundLocation != -1) {\n                diskBound = new byte[length];\n                RandomAccessFile file = new RandomAccessFile(tmpFile, \"r\");\n                file.seek(diskBoundLocation);\n                int readNum = file.read(diskBound);\n                file.close();\n                diskBoundLocation = -1;\n            }\n            return diskBound;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.toOffset": "    public long toOffset(long pageId) {\n        return PAGE_FILE_HEADER_SIZE+(pageId*pageSize);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.isDone": "        boolean isDone() {\n            return diskBound == null && diskBoundLocation == -1 && current == null && currentLocation == -1;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.recoveryFileSizeForPages": "    private long recoveryFileSizeForPages(int pageCount) {\n        return RECOVERY_FILE_HEADER_SIZE+((pageSize+8)*pageCount);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getValue": "            public PageWrite getValue() {\n                return write;\n            }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.begin": "        void begin() {\n           if (currentLocation != -1) {\n              diskBoundLocation = currentLocation;\n              currentLocation = -1;\n              current = null;\n           }  else {\n              diskBound = current;\n              current = null;\n              currentLocation = -1;\n           }\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.done": "        boolean done() {\n            diskBoundLocation = -1;\n            diskBound=null;\n            return current == null || currentLocation == -1;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.flush": "    public void flush() throws IOException {\n\n        if( enabledWriteThread && stopWriter.get() ) {\n            throw new IOException(\"Page file already stopped: checkpointing is not allowed\");\n        }\n        \n        // Setup a latch that gets notified when all buffered writes hits the disk.\n        CountDownLatch checkpointLatch;\n        synchronized( writes ) {\n            if( writes.isEmpty()) {                \n                return;\n            }\n            if( enabledWriteThread ) {\n                if( this.checkpointLatch == null ) {\n                    this.checkpointLatch = new CountDownLatch(1);\n                }\n                checkpointLatch = this.checkpointLatch;\n                writes.notify();\n            } else {\n                writeBatch();\n                return;\n            }\n        }\n        try {\n            checkpointLatch.await();\n        } catch (InterruptedException e) {\n            throw new InterruptedIOException();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    void checkpointUpdate(Transaction tx, Journal journal, boolean cleanup) throws IOException {\n        LOG.debug(\"Checkpoint started.\");\n\n        // reflect last update exclusive of current checkpoint\n        Location firstTxLocation = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit(journal);\n        metadata.firstInProgressTransactionLocation = getFirstInProgressTxLocation();\n        tx.store(metadata.page, metadataMarshaller, true);\n        pageFile.flush();\n\n        if (cleanup) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n            final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);\n\n            LOG.trace(\"Last update: \" + firstTxLocation + \", full gc candidates set: \" + gcCandidateSet);\n\n            // Don't GC files under replication\n            if (journalFilesBeingReplicated != null) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                gcCandidateSet.remove(metadata.producerSequenceIdTrackerLocation.getDataFileId());\n            }\n\n            // Don't GC files after the first in progress tx\n            if (metadata.firstInProgressTransactionLocation != null) {\n                if (metadata.firstInProgressTransactionLocation.getDataFileId() < firstTxLocation.getDataFileId()) {\n                    firstTxLocation = metadata.firstInProgressTransactionLocation;\n                }\n            }\n\n            if (firstTxLocation != null) {\n                while (!gcCandidateSet.isEmpty()) {\n                    Integer last = gcCandidateSet.last();\n                    if (last >= firstTxLocation.getDataFileId()) {\n                        gcCandidateSet.remove(last);\n                    } else {\n                        break;\n                    }\n                }\n                LOG.trace(\"gc candidates after first tx:\" + firstTxLocation + \", \" + gcCandidateSet);\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if (gcCandidateSet.isEmpty()) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last = -1;\n\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if (first == null) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId() + 1);\n                            if (!subset.isEmpty() && subset.last() == second.getDataFileId()) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if (second == null) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if (!subset.isEmpty() && subset.first() == first.getDataFileId()) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId() + 1);\n                            if (!subset.isEmpty() && subset.first() == first.getDataFileId()) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if (!subset.isEmpty() && subset.last() == second.getDataFileId()) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if (last != fileId) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n                LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            LOG.trace(\"gc candidates: \" + gcCandidateSet);\n            final TreeSet<Integer> gcCandidates = new TreeSet<Integer>(gcCandidateSet);\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidates.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don't delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        ackMessageFileMap.remove(candidate);\n                    } else {\n                        LOG.trace(\"not removing data file: \" + candidate\n                                + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                LOG.debug(\"Cleanup removing the data files: \" + gcCandidateSet);\n                journal.removeDataFiles(gcCandidateSet);\n            }\n        }\n\n        LOG.debug(\"Checkpoint done.\");\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointProducerAudit": "    private Location checkpointProducerAudit(Journal journal) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oout = new ObjectOutputStream(baos);\n        oout.writeObject(metadata.producerSequenceIdTracker);\n        oout.flush();\n        oout.close();\n        return store(journal, new KahaProducerAuditCommand().setAudit(new Buffer(baos.toByteArray())), true, null, null);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.remove": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException {\n            return new MessageOrderIterator(tx, m);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getFirstInProgressTxLocation": "    public Location getFirstInProgressTxLocation() {\n        Location l = null;\n        synchronized (inflightTransactions) {\n            if (!inflightTransactions.isEmpty()) {\n                l = inflightTransactions.values().iterator().next().get(0).getLocation();\n            }\n            if (!preparedTransactions.isEmpty()) {\n                Location t = preparedTransactions.values().iterator().next().get(0).getLocation();\n                if (l == null || t.compareTo(l) <= 0) {\n                    l = t;\n                }\n            }\n        }\n        return l;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(final Journal journal, JournalCommand<?> data, boolean sync, Runnable before, Runnable after) throws IOException {\n        if (before != null) {\n            before.run();\n        }\n        try {\n            int size = data.serializedSizeFramed();\n            DataByteArrayOutputStream os = new DataByteArrayOutputStream(size + 1);\n            os.writeByte(data.type().getNumber());\n            data.writeFramed(os);\n\n            long start = System.currentTimeMillis();\n            Location location = journal.write(os.toByteSequence(), sync);\n            long start2 = System.currentTimeMillis();\n            process(data, location);\n            long end = System.currentTimeMillis();\n            if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n                LOG.info(\"Slow KahaDB access: Journal append took: \" + (start2 - start) + \" ms, Index update took \" + (end - start2) + \" ms\");\n            }\n\n            this.indexLock.writeLock().lock();\n            try {\n                metadata.lastUpdate = location;\n            } finally {\n                this.indexLock.writeLock().unlock();\n            }\n            if (!checkpointThread.isAlive()) {\n                startCheckpoint();\n            }\n            if (after != null) {\n                after.run();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal\", ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.hasNext": "            public boolean hasNext() {\n                if (currentIterator == null) {\n                    if (highIterator != null) {\n                        if (highIterator.hasNext()) {\n                            currentIterator = highIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    } else {\n                        currentIterator = defaultIterator;\n                        return currentIterator.hasNext();\n                    }\n                }\n                if (highIterator != null) {\n                    if (currentIterator.hasNext()) {\n                        return true;\n                    }\n                    if (currentIterator == highIterator) {\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                    if (currentIterator == defaultIterator) {\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                }\n                return currentIterator.hasNext();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.visit": "                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if (last != fileId) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.next": "            public Entry<Long, MessageKeys> next() {\n                Entry<Long, MessageKeys> result = currentIterator.next();\n                if (result != null) {\n                    Long key = result.getKey();\n                    if (highIterator != null) {\n                        if (currentIterator == defaultIterator) {\n                            lastDefaultKey = key;\n                        } else if (currentIterator == highIterator) {\n                            lastHighKey = key;\n                        } else {\n                            lastLowKey = key;\n                        }\n                    } else {\n                        lastDefaultKey = key;\n                    }\n                }\n                return result;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.execute": "        public void execute(Transaction tx) throws IOException {\n            updateIndex(tx, command, location);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.put": "        MessageKeys put(Transaction tx, int priority, Long key, MessageKeys value) throws IOException {\n            if (priority == javax.jms.Message.DEFAULT_PRIORITY) {\n                return defaultPriorityIndex.put(tx, key, value);\n            } else if (priority > javax.jms.Message.DEFAULT_PRIORITY) {\n                return highPriorityIndex.put(tx, key, value);\n            } else {\n                return lowPriorityIndex.put(tx, key, value);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex": "    void upadateIndex(Transaction tx, KahaAddMessageCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n\n        // Skip adding the message to the index if this is a topic and there are\n        // no subscriptions.\n        if (sd.subscriptions != null && sd.subscriptions.isEmpty(tx)) {\n            return;\n        }\n\n        // Add the message.\n        int priority = command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY;\n        long id = sd.orderIndex.getNextMessageId(priority);\n        Long previous = sd.locationIndex.put(tx, location, id);\n        if (previous == null) {\n            previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);\n            if (previous == null) {\n                sd.orderIndex.put(tx, priority, id, new MessageKeys(command.getMessageId(), location));\n                if (sd.subscriptions != null && !sd.subscriptions.isEmpty(tx)) {\n                    addAckLocationForNewMessage(tx, sd, id);\n                }\n            } else {\n                // If the message ID as indexed, then the broker asked us to\n                // store a DUP\n                // message. Bad BOY! Don't do it, and log a warning.\n                LOG.warn(\"Duplicate message add attempt rejected. Destination: \" + command.getDestination().getName() + \", Message id: \" + command.getMessageId());\n                // TODO: consider just rolling back the tx.\n                sd.messageIdIndex.put(tx, command.getMessageId(), previous);\n                sd.locationIndex.remove(tx, location);\n            }\n        } else {\n            // restore the previous value.. Looks like this was a redo of a\n            // previously\n            // added message. We don't want to assign it a new id as the other\n            // indexes would\n            // be wrong..\n            //\n            // TODO: consider just rolling back the tx.\n            sd.locationIndex.put(tx, location, previous);\n        }\n        // record this id in any event, initial send or recovery\n        metadata.producerSequenceIdTracker.isDuplicate(command.getMessageId());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.load": "        void load(Transaction tx) throws IOException {\n            defaultPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            defaultPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            defaultPriorityIndex.load(tx);\n            lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            lowPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            lowPriorityIndex.load(tx);\n            highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            highPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            highPriorityIndex.load(tx);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex": "    protected void recoverIndex(Transaction tx, Journal journal) throws IOException {\n        long start = System.currentTimeMillis();\n        // It is possible index updates got applied before the journal updates..\n        // in that case we need to removed references to messages that are not in the journal\n        final Location lastAppendLocation = journal.getLastAppendLocation();\n        long undoCounter = 0;\n\n        // Go through all the destinations to see if they have messages past the lastAppendLocation\n        for (StoredDestination sd : storedDestinations.values()) {\n\n            final ArrayList<Long> matches = new ArrayList<Long>();\n            // Find all the Locations that are >= than the last Append Location.\n            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor<Location, Long>(lastAppendLocation) {\n                @Override\n                protected void matched(Location key, Long value) {\n                    matches.add(value);\n                }\n            });\n\n\n            for (Long sequenceId : matches) {\n                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                sd.locationIndex.remove(tx, keys.location);\n                sd.messageIdIndex.remove(tx, keys.messageId);\n                metadata.producerSequenceIdTracker.rollback(keys.messageId);\n                undoCounter++;\n                // TODO: do we need to modify the ack positions for the pub sub case?\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        if (undoCounter > 0) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user\n            // should do sync writes to the journal.\n            LOG.info(\"Rolled back \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n        }\n\n        undoCounter = 0;\n        start = System.currentTimeMillis();\n\n        // Lets be extra paranoid here and verify that all the datafiles being referenced\n        // by the indexes still exists.\n\n        final SequenceSet ss = new SequenceSet();\n        for (StoredDestination sd : storedDestinations.values()) {\n            // Use a visitor to cut down the number of pages that we load\n            sd.locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                int last = -1;\n\n                public boolean isInterestedInKeysBetween(Location first, Location second) {\n                    if (first == null) {\n                        return !ss.contains(0, second.getDataFileId());\n                    } else if (second == null) {\n                        return true;\n                    } else {\n                        return !ss.contains(first.getDataFileId(), second.getDataFileId());\n                    }\n                }\n\n                public void visit(List<Location> keys, List<Long> values) {\n                    for (Location l : keys) {\n                        int fileId = l.getDataFileId();\n                        if (last != fileId) {\n                            ss.add(fileId);\n                            last = fileId;\n                        }\n                    }\n                }\n\n            });\n        }\n        HashSet<Integer> missingJournalFiles = new HashSet<Integer>();\n        while (!ss.isEmpty()) {\n            missingJournalFiles.add((int) ss.removeFirst());\n        }\n        missingJournalFiles.removeAll(journal.getFileMap().keySet());\n\n        if (!missingJournalFiles.isEmpty()) {\n            LOG.info(\"Some journal files are missing: \" + missingJournalFiles);\n        }\n\n        ArrayList<BTreeVisitor.Predicate<Location>> missingPredicates = new ArrayList<BTreeVisitor.Predicate<Location>>();\n        for (Integer missing : missingJournalFiles) {\n            missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(missing, 0), new Location(missing + 1, 0)));\n        }\n\n        if (checkForCorruptJournalFiles) {\n            Collection<DataFile> dataFiles = journal.getFileMap().values();\n            for (DataFile dataFile : dataFiles) {\n                int id = dataFile.getDataFileId();\n                missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));\n                Sequence seq = dataFile.getCorruptedBlocks().getHead();\n                while (seq != null) {\n                    missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1)));\n                    seq = seq.getNext();\n                }\n            }\n        }\n\n        if (!missingPredicates.isEmpty()) {\n            for (StoredDestination sd : storedDestinations.values()) {\n\n                final ArrayList<Long> matches = new ArrayList<Long>();\n                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor<Location, Long>(missingPredicates) {\n                    @Override\n                    protected void matched(Location key, Long value) {\n                        matches.add(value);\n                    }\n                });\n\n                // If somes message references are affected by the missing data files...\n                if (!matches.isEmpty()) {\n\n                    // We either 'gracefully' recover dropping the missing messages or\n                    // we error out.\n                    if (ignoreMissingJournalfiles) {\n                        // Update the index to remove the references to the missing data\n                        for (Long sequenceId : matches) {\n                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                            sd.locationIndex.remove(tx, keys.location);\n                            sd.messageIdIndex.remove(tx, keys.messageId);\n                            undoCounter++;\n                            // TODO: do we need to modify the ack positions for the pub sub case?\n                        }\n\n                    } else {\n                        throw new IOException(\"Detected missing/corrupt journal files. \" + matches.size() + \" messages affected.\");\n                    }\n                }\n            }\n        }\n\n        end = System.currentTimeMillis();\n        if (undoCounter > 0) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user\n            // should do sync writes to the journal.\n            LOG.info(\"Detected missing/corrupt journal files.  Dropped \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.updateIndex": "    void updateIndex(Transaction tx, KahaSubscriptionCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n        final String subscriptionKey = command.getSubscriptionKey();\n\n        // If set then we are creating it.. otherwise we are destroying the sub\n        if (command.hasSubscriptionInfo()) {\n            sd.subscriptions.put(tx, subscriptionKey, command);\n            long ackLocation = NOT_ACKED;\n            if (!command.getRetroactive()) {\n                ackLocation = sd.orderIndex.nextMessageId - 1;\n            } else {\n                addAckLocationForRetroactiveSub(tx, sd, ackLocation, subscriptionKey);\n            }\n            sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(ackLocation));\n        } else {\n            // delete the sub...\n            sd.subscriptions.remove(tx, subscriptionKey);\n            sd.subscriptionAcks.remove(tx, subscriptionKey);\n            removeAckLocationsForSub(tx, sd, subscriptionKey);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.allocate": "        void allocate(Transaction tx) throws IOException {\n            defaultPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            if (metadata.version >= 2) {\n                lowPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n                highPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getJournalManager": "    public JournalManager getJournalManager() throws IOException {\n        if (journalManager == null) {\n            journalManager = createJournalManager();\n        }\n        return journalManager;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.loadStoredDestination": "    private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {\n        // Try to load the existing indexes..\n        StoredDestination rc = metadata.destinations.get(tx, key);\n        if (rc == null) {\n            // Brand new destination.. allocate indexes for it.\n            rc = new StoredDestination();\n            rc.orderIndex.allocate(tx);\n            rc.locationIndex = new BTreeIndex<Location, Long>(pageFile, tx.allocate());\n            rc.messageIdIndex = new BTreeIndex<String, Long>(pageFile, tx.allocate());\n\n            if (topic) {\n                rc.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, tx.allocate());\n                rc.subscriptionAcks = new BTreeIndex<String, LastAck>(pageFile, tx.allocate());\n                rc.ackPositions = new BTreeIndex<Long, HashSet<String>>(pageFile, tx.allocate());\n            }\n            metadata.destinations.put(tx, key, rc);\n        }\n\n        // Configure the marshalers and load.\n        rc.orderIndex.load(tx);\n\n        // Figure out the next key using the last entry in the destination.\n        rc.orderIndex.configureLast(tx);\n\n        rc.locationIndex.setKeyMarshaller(org.apache.kahadb.util.LocationMarshaller.INSTANCE);\n        rc.locationIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.locationIndex.load(tx);\n\n        rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);\n        rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.messageIdIndex.load(tx);\n\n        // If it was a topic...\n        if (topic) {\n\n            rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);\n            rc.subscriptions.load(tx);\n\n            rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptionAcks.setValueMarshaller(new LastAckMarshaller());\n            rc.subscriptionAcks.load(tx);\n\n            rc.ackPositions.setKeyMarshaller(LongMarshaller.INSTANCE);\n            rc.ackPositions.setValueMarshaller(HashSetStringMarshaller.INSTANCE);\n            rc.ackPositions.load(tx);\n\n            rc.subscriptionCursors = new HashMap<String, MessageOrderCursor>();\n\n            if (metadata.version < 3) {\n\n                // on upgrade need to fill ackLocation with available messages past last ack\n                for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                    Entry<String, LastAck> entry = iterator.next();\n                    for (Iterator<Entry<Long, MessageKeys>> orderIterator =\n                                 rc.orderIndex.iterator(tx, new MessageOrderCursor(entry.getValue().lastAckedSequence)); orderIterator.hasNext(); ) {\n                        Long sequence = orderIterator.next().getKey();\n                        addAckLocation(tx, rc, sequence, entry.getKey());\n                    }\n                    // modify so it is upgraded\n                    rc.subscriptionAcks.put(tx, entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (rc.orderIndex.nextMessageId == 0) {\n                // check for existing durable sub all acked out - pull next seq from acks as messages are gone\n                if (!rc.subscriptionAcks.isEmpty(tx)) {\n                    for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                        Entry<String, LastAck> entry = iterator.next();\n                        rc.orderIndex.nextMessageId =\n                                Math.max(rc.orderIndex.nextMessageId, entry.getValue().lastAckedSequence + 1);\n                    }\n                }\n            } else {\n                // update based on ackPositions for unmatched, last entry is always the next\n                if (!rc.ackPositions.isEmpty(tx)) {\n                    Entry<Long, HashSet<String>> last = rc.ackPositions.getLast(tx);\n                    rc.orderIndex.nextMessageId =\n                            Math.max(rc.orderIndex.nextMessageId, last.getKey());\n                }\n            }\n\n        }\n\n        if (metadata.version < 3) {\n            // store again after upgrade\n            metadata.destinations.put(tx, key, rc);\n        }\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup": "    protected void checkpointCleanup(final Journal journal, final boolean cleanup) throws IOException {\n        long start;\n        this.indexLock.writeLock().lock();\n        try {\n            start = System.currentTimeMillis();\n            if (!opened.get()) {\n                return;\n            }\n            pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                public void execute(Transaction tx) throws IOException {\n                    checkpointUpdate(tx, journal, cleanup);\n                }\n            });\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n        long end = System.currentTimeMillis();\n        if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n            LOG.info(\"Slow KahaDB access: cleanup took \" + (end - start));\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.lock": "    private void lock() throws IOException {\n\n        if (lockFile == null) {\n            File lockFileName = new File(directory, \"lock\");\n            lockFile = new LockFile(lockFileName, true);\n            if (failIfDatabaseIsLocked) {\n                lockFile.lock();\n            } else {\n                boolean locked = false;\n                while ((!isStopped()) && (!isStopping())) {\n                    try {\n                        lockFile.lock();\n                        locked = true;\n                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \"\n                                + lockFileName\n                                + \" is locked... waiting \"\n                                + (getDatabaseLockedWaitDelay() / 1000)\n                                + \" seconds for the database to be unlocked. Reason: \"\n                                + e);\n                        try {\n                            Thread.sleep(getDatabaseLockedWaitDelay());\n                        } catch (InterruptedException e1) {\n                        }\n                    }\n                }\n                if (!locked) {\n                    throw new IOException(\"attempt to obtain lock aborted due to shutdown\");\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.run": "                    public void run() {\n                        try {\n                            long lastCleanup = System.currentTimeMillis();\n                            long lastCheckpoint = System.currentTimeMillis();\n                            // Sleep for a short time so we can periodically check\n                            // to see if we need to exit this thread.\n                            long sleepTime = Math.min(checkpointInterval, 500);\n                            while (opened.get()) {\n                                Thread.sleep(sleepTime);\n                                long now = System.currentTimeMillis();\n                                if (now - lastCleanup >= cleanupInterval) {\n                                    checkpointCleanup(true);\n                                    lastCleanup = now;\n                                    lastCheckpoint = now;\n                                } else if (now - lastCheckpoint >= checkpointInterval) {\n                                    checkpointCleanup(false);\n                                    lastCheckpoint = now;\n                                }\n                            }\n                        } catch (InterruptedException e) {\n                            // Looks like someone really wants us to exit this thread...\n                        } catch (IOException ioe) {\n                            LOG.error(\"Checkpoint failed\", ioe);\n                            brokerService.handleIOException(ioe);\n                        }\n                    }"
        },
        "bug_report": {
            "Title": "checkpoint contention with large transaction write using temp file",
            "Description": "Unit test failure intermittently: \n org.apache.activemq.bugs \u00bb AMQ2149KahaDBTest \u00bb testQueueTransactionalOrderWithRestart\n\n{code}2011-08-09 05:25:21,468 [eckpoint Worker] - ERROR MessageDatabase                - Checkpoint failed\njava.io.IOException: Cannot create recovery file. Reason: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)\n\tat org.apache.kahadb.util.IOExceptionSupport.create(IOExceptionSupport.java:27)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1002)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:482)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1167)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:728)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:762)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:726)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:714)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:279)\nCaused by: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:212)\n\tat org.apache.kahadb.page.PageFile$PageWrite.getDiskBound(PageFile.java:185)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1000)\n\t... 7 more\n2011-08-09 05:25:21,469 [eckpoint Worker] - INFO  DefaultIOExceptionHandler      - Stopping the broker due to IO exception, java.io.IOException: Cannot create recovery file. Reason: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)\njava.io.IOException: Cannot create recovery file. Reason: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)\n\tat org.apache.kahadb.util.IOExceptionSupport.create(IOExceptionSupport.java:27)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1002)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:482)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1167)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:728)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:762)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:726)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:714)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:279)\nCaused by: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory){code}"
        }
    },
    {
        "filename": "AMQ-4369.json",
        "creation_time": "2013-03-13T13:51:31.000+0000",
        "stack_trace": "java.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.readBytes(Native Method)\n\tat java.io.RandomAccessFile.read(RandomAccessFile.java:355)\n\tat java.io.RandomAccessFile.readFully(RandomAccessFile.java:414)\n\tat java.io.RandomAccessFile.readFully(RandomAccessFile.java:394)\n\tat org.apache.kahadb.page.PageFile.readPage(PageFile.java:833)\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:447)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:438)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:435)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:411)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:368)\n\tat org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)\n\tat org.apache.kahadb.index.BTreeIndex.getRoot(BTreeIndex.java:174)\n\tat org.apache.kahadb.index.BTreeIndex.remove(BTreeIndex.java:194)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.updateIndex(MessageDatabase.java:1212)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$15.execute(MessageDatabase.java:1028)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:771)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1026)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)\n\tat org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand.visit(KahaRemoveMessageCommand.java:220)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:953)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:865)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeMessage(KahaDBStore.java:439)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeAsyncMessage(KahaDBStore.java:411)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore.removeAsyncMessage(KahaDBTransactionStore.java:468)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore$1.removeAsyncMessage(KahaDBTransactionStore.java:171)\n\tat org.apache.activemq.broker.region.Queue.acknowledge(Queue.java:830)\n\tat org.apache.activemq.broker.region.Queue.removeMessage(Queue.java:1584)\n\tat org.apache.activemq.broker.region.QueueSubscription.acknowledge(QueueSubscription.java:59)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.acknowledge(PrefetchSubscription.java:294)\n\tat org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:426)\n\tat org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:537)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:287)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:87)\n\tat org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:461)\n\tat org.apache.activemq.command.MessageAck.visit(MessageAck.java:236)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:268)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.SslTransport.doConsume(SslTransport.java:91)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:215)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:197)\n\tat java.lang.Thread.run(Thread.java:679)",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.readPage": "    synchronized void readPage(long pageId, byte[] data) throws IOException {\n        readFile.seek(toOffset(pageId));\n        readFile.readFully(data);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.toOffset": "    public long toOffset(long pageId) {\n        return PAGE_FILE_HEADER_SIZE + (pageId * pageSize);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.loadNode": "    BTreeNode<Key,Value> loadNode(Transaction tx, long pageId, BTreeNode<Key,Value> parent) throws IOException {\n        Page<BTreeNode<Key,Value>> page = tx.load(pageId, marshaller);\n        BTreeNode<Key, Value> node = page.get();\n        node.setPage(page);\n        node.setParent(parent);\n        return node;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.get": "    synchronized public Value get(Transaction tx, Key key) throws IOException {\n        assertLoaded();\n        return getRoot(tx).get(tx, key);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.load": "    synchronized public void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            LOG.debug(\"loading\");\n            if( keyMarshaller == null ) {\n                throw new IllegalArgumentException(\"The key marshaller must be set before loading the BTreeIndex\");\n            }\n            if( valueMarshaller == null ) {\n                throw new IllegalArgumentException(\"The value marshaller must be set before loading the BTreeIndex\");\n            }\n            \n            final Page<BTreeNode<Key,Value>> p = tx.load(pageId, null);\n            if( p.getType() == Page.PAGE_FREE_TYPE ) {\n                 // Need to initialize it..\n                BTreeNode<Key, Value> root = createNode(p, null);\n                storeNode(tx, root, true);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.getRoot": "    private BTreeNode<Key,Value> getRoot(Transaction tx) throws IOException {\n        return loadNode(tx, pageId, null);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.remove": "    synchronized public Value remove(Transaction tx, Key key) throws IOException {\n        assertLoaded();\n        return getRoot(tx).remove(tx, key);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.assertLoaded": "    private void assertLoaded() throws IllegalStateException {\n        if( !loaded.get() ) {\n            throw new IllegalStateException(\"The BTreeIndex is not loaded\");\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.updateIndex": "    void updateIndex(Transaction tx, KahaSubscriptionCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n        final String subscriptionKey = command.getSubscriptionKey();\n\n        // If set then we are creating it.. otherwise we are destroying the sub\n        if (command.hasSubscriptionInfo()) {\n            sd.subscriptions.put(tx, subscriptionKey, command);\n            long ackLocation=NOT_ACKED;\n            if (!command.getRetroactive()) {\n                ackLocation = sd.orderIndex.nextMessageId-1;\n            } else {\n                addAckLocationForRetroactiveSub(tx, sd, subscriptionKey);\n            }\n            sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(ackLocation));\n            sd.subscriptionCache.add(subscriptionKey);\n        } else {\n            // delete the sub...\n            sd.subscriptions.remove(tx, subscriptionKey);\n            sd.subscriptionAcks.remove(tx, subscriptionKey);\n            sd.subscriptionCache.remove(subscriptionKey);\n            removeAckLocationsForSub(tx, sd, subscriptionKey);\n\n            if (sd.subscriptions.isEmpty(tx)) {\n                sd.messageIdIndex.clear(tx);\n                sd.locationIndex.clear(tx);\n                sd.orderIndex.clear(tx);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.addAckLocationForRetroactiveSub": "    private void addAckLocationForRetroactiveSub(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {\n        SequenceSet allOutstanding = new SequenceSet();\n        Iterator<Map.Entry<String, SequenceSet>> iterator = sd.ackPositions.iterator(tx);\n        while (iterator.hasNext()) {\n            SequenceSet set = iterator.next().getValue();\n            for (Long entry : set) {\n                allOutstanding.add(entry);\n            }\n        }\n        sd.ackPositions.put(tx, subscriptionKey, allOutstanding);\n\n        for (Long ackPosition : allOutstanding) {\n            Long count = sd.messageReferences.get(ackPosition);\n            count = count.longValue() + 1;\n            sd.messageReferences.put(ackPosition, count);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getStoredDestination": "    protected StoredDestination getStoredDestination(KahaDestination destination, Transaction tx) throws IOException {\n        String key = key(destination);\n        StoredDestination rc = storedDestinations.get(key);\n        if (rc == null) {\n            boolean topic = destination.getType() == KahaDestination.DestinationType.TOPIC || destination.getType() == KahaDestination.DestinationType.TEMP_TOPIC;\n            rc = loadStoredDestination(tx, key, topic);\n            // Cache it. We may want to remove/unload destinations from the\n            // cache that are not used for a while\n            // to reduce memory usage.\n            storedDestinations.put(key, rc);\n        }\n        return rc;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recordAckMessageReferenceLocation": "    private void recordAckMessageReferenceLocation(Location ackLocation, Location messageLocation) {\n        Set<Integer> referenceFileIds = ackMessageFileMap.get(Integer.valueOf(ackLocation.getDataFileId()));\n        if (referenceFileIds == null) {\n            referenceFileIds = new HashSet<Integer>();\n            referenceFileIds.add(messageLocation.getDataFileId());\n            ackMessageFileMap.put(ackLocation.getDataFileId(), referenceFileIds);\n        } else {\n            Integer id = Integer.valueOf(messageLocation.getDataFileId());\n            if (!referenceFileIds.contains(id)) {\n                referenceFileIds.add(id);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.key": "    private TransactionId key(KahaTransactionInfo transactionInfo) {\n        return TransactionIdConversion.convert(transactionInfo);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.removeAckLocation": "    private void removeAckLocation(Transaction tx, StoredDestination sd, String subscriptionKey, Long messageSequence) throws IOException {\n        // Remove the sub from the previous location set..\n        if (messageSequence != null) {\n            SequenceSet range = sd.ackPositions.get(tx, subscriptionKey);\n            if (range != null && !range.isEmpty()) {\n                range.remove(messageSequence);\n                if (!range.isEmpty()) {\n                    sd.ackPositions.put(tx, subscriptionKey, range);\n                } else {\n                    sd.ackPositions.remove(tx, subscriptionKey);\n                }\n\n                // Check if the message is reference by any other subscription.\n                Long count = sd.messageReferences.get(messageSequence);\n                if (count != null){\n                long references = count.longValue() - 1;\n                    if (references > 0) {\n                        sd.messageReferences.put(messageSequence, Long.valueOf(references));\n                        return;\n                    } else {\n                        sd.messageReferences.remove(messageSequence);\n                    }\n                }\n\n                // Find all the entries that need to get deleted.\n                ArrayList<Entry<Long, MessageKeys>> deletes = new ArrayList<Entry<Long, MessageKeys>>();\n                sd.orderIndex.getDeleteList(tx, deletes, messageSequence);\n\n                // Do the actual deletes.\n                for (Entry<Long, MessageKeys> entry : deletes) {\n                    sd.locationIndex.remove(tx, entry.getValue().location);\n                    sd.messageIdIndex.remove(tx, entry.getValue().messageId);\n                    sd.orderIndex.remove(tx, entry.getKey());\n                }\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.removeAckLocationsForSub": "    private void removeAckLocationsForSub(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {\n        if (!sd.ackPositions.isEmpty(tx)) {\n            SequenceSet sequences = sd.ackPositions.remove(tx, subscriptionKey);\n            if (sequences == null || sequences.isEmpty()) {\n                return;\n            }\n\n            ArrayList<Long> unreferenced = new ArrayList<Long>();\n\n            for(Long sequenceId : sequences) {\n                Long references = sd.messageReferences.get(sequenceId);\n                if (references != null) {\n                    references = references.longValue() - 1;\n\n                    if (references.longValue() > 0) {\n                        sd.messageReferences.put(sequenceId, references);\n                    } else {\n                        sd.messageReferences.remove(sequenceId);\n                        unreferenced.add(sequenceId);\n                    }\n                }\n            }\n\n            for(Long sequenceId : unreferenced) {\n                // Find all the entries that need to get deleted.\n                ArrayList<Entry<Long, MessageKeys>> deletes = new ArrayList<Entry<Long, MessageKeys>>();\n                sd.orderIndex.getDeleteList(tx, deletes, sequenceId);\n\n                // Do the actual deletes.\n                for (Entry<Long, MessageKeys> entry : deletes) {\n                    sd.locationIndex.remove(tx, entry.getValue().location);\n                    sd.messageIdIndex.remove(tx, entry.getValue().messageId);\n                    sd.orderIndex.remove(tx, entry.getKey());\n                }\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.remove": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.execute": "        public void execute(Transaction tx) throws IOException {\n            updateIndex(tx, command, location);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.put": "        MessageKeys put(Transaction tx, int priority, Long key, MessageKeys value) throws IOException {\n            if (priority == javax.jms.Message.DEFAULT_PRIORITY) {\n                return defaultPriorityIndex.put(tx, key, value);\n            } else if (priority > javax.jms.Message.DEFAULT_PRIORITY) {\n                return highPriorityIndex.put(tx, key, value);\n            } else {\n                return lowPriorityIndex.put(tx, key, value);\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex": "    void upadateIndex(Transaction tx, KahaAddMessageCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n\n        // Skip adding the message to the index if this is a topic and there are\n        // no subscriptions.\n        if (sd.subscriptions != null && sd.subscriptions.isEmpty(tx)) {\n            return;\n        }\n\n        // Add the message.\n        int priority = command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY;\n        long id = sd.orderIndex.getNextMessageId(priority);\n        Long previous = sd.locationIndex.put(tx, location, id);\n        if (previous == null) {\n            previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);\n            if (previous == null) {\n                sd.orderIndex.put(tx, priority, id, new MessageKeys(command.getMessageId(), location));\n                if (sd.subscriptions != null && !sd.subscriptions.isEmpty(tx)) {\n                    addAckLocationForNewMessage(tx, sd, id);\n                }\n            } else {\n                // If the message ID as indexed, then the broker asked us to\n                // store a DUP\n                // message. Bad BOY! Don't do it, and log a warning.\n                LOG.warn(\"Duplicate message add attempt rejected. Destination: \" + command.getDestination().getName() + \", Message id: \" + command.getMessageId());\n                sd.messageIdIndex.put(tx, command.getMessageId(), previous);\n                sd.locationIndex.remove(tx, location);\n                rollbackStatsOnDuplicate(command.getDestination());\n            }\n        } else {\n            // restore the previous value.. Looks like this was a redo of a\n            // previously\n            // added message. We don't want to assign it a new id as the other\n            // indexes would\n            // be wrong..\n            //\n            sd.locationIndex.put(tx, location, previous);\n        }\n        // record this id in any event, initial send or recovery\n        metadata.producerSequenceIdTracker.isDuplicate(command.getMessageId());\n        metadata.lastUpdate = location;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.load": "        void load(Transaction tx) throws IOException {\n            defaultPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            defaultPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            defaultPriorityIndex.load(tx);\n            lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            lowPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            lowPriorityIndex.load(tx);\n            highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            highPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            highPriorityIndex.load(tx);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(JournalCommand<?> data, boolean sync, Runnable before,Runnable after, Runnable onJournalStoreComplete) throws IOException {\n        if (before != null) {\n            before.run();\n        }\n        try {\n            ByteSequence sequence = toByteSequence(data);\n\n            Location location;\n            checkpointLock.readLock().lock();\n            try {\n\n                long start = System.currentTimeMillis();\n                location = onJournalStoreComplete == null ? journal.write(sequence, sync) :  journal.write(sequence, onJournalStoreComplete) ;\n                long start2 = System.currentTimeMillis();\n                process(data, location, after);\n\n                long end = System.currentTimeMillis();\n                if( LOG_SLOW_ACCESS_TIME>0 && end-start > LOG_SLOW_ACCESS_TIME) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Slow KahaDB access: Journal append took: \"+(start2-start)+\" ms, Index update took \"+(end-start2)+\" ms\");\n                    }\n                }\n\n            } finally{\n                checkpointLock.readLock().unlock();\n            }\n            if (after != null) {\n                Runnable afterCompletion = null;\n                synchronized (orderedTransactionAfters) {\n                    if (!orderedTransactionAfters.empty()) {\n                        afterCompletion = orderedTransactionAfters.pop();\n                    }\n                }\n                if (afterCompletion != null) {\n                    afterCompletion.run();\n                } else {\n                    // non persistent message case\n                    after.run();\n                }\n            }\n\n            if (checkpointThread != null && !checkpointThread.isAlive()) {\n                startCheckpoint();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal\", ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex": "    protected void recoverIndex(Transaction tx) throws IOException {\n        long start = System.currentTimeMillis();\n        // It is possible index updates got applied before the journal updates..\n        // in that case we need to removed references to messages that are not in the journal\n        final Location lastAppendLocation = journal.getLastAppendLocation();\n        long undoCounter=0;\n\n        // Go through all the destinations to see if they have messages past the lastAppendLocation\n        for (StoredDestination sd : storedDestinations.values()) {\n\n            final ArrayList<Long> matches = new ArrayList<Long>();\n            // Find all the Locations that are >= than the last Append Location.\n            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor<Location, Long>(lastAppendLocation) {\n                @Override\n                protected void matched(Location key, Long value) {\n                    matches.add(value);\n                }\n            });\n\n            for (Long sequenceId : matches) {\n                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                sd.locationIndex.remove(tx, keys.location);\n                sd.messageIdIndex.remove(tx, keys.messageId);\n                metadata.producerSequenceIdTracker.rollback(keys.messageId);\n                undoCounter++;\n                // TODO: do we need to modify the ack positions for the pub sub case?\n            }\n        }\n\n        if( undoCounter > 0 ) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting\n            // these the end user should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Rolled back \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n\n        undoCounter = 0;\n        start = System.currentTimeMillis();\n\n        // Lets be extra paranoid here and verify that all the datafiles being referenced\n        // by the indexes still exists.\n\n        final SequenceSet ss = new SequenceSet();\n        for (StoredDestination sd : storedDestinations.values()) {\n            // Use a visitor to cut down the number of pages that we load\n            sd.locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                int last=-1;\n\n                @Override\n                public boolean isInterestedInKeysBetween(Location first, Location second) {\n                    if( first==null ) {\n                        return !ss.contains(0, second.getDataFileId());\n                    } else if( second==null ) {\n                        return true;\n                    } else {\n                        return !ss.contains(first.getDataFileId(), second.getDataFileId());\n                    }\n                }\n\n                @Override\n                public void visit(List<Location> keys, List<Long> values) {\n                    for (Location l : keys) {\n                        int fileId = l.getDataFileId();\n                        if( last != fileId ) {\n                            ss.add(fileId);\n                            last = fileId;\n                        }\n                    }\n                }\n\n            });\n        }\n        HashSet<Integer> missingJournalFiles = new HashSet<Integer>();\n        while (!ss.isEmpty()) {\n            missingJournalFiles.add((int) ss.removeFirst());\n        }\n        missingJournalFiles.removeAll(journal.getFileMap().keySet());\n\n        if (!missingJournalFiles.isEmpty()) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Some journal files are missing: \" + missingJournalFiles);\n            }\n        }\n\n        ArrayList<BTreeVisitor.Predicate<Location>> missingPredicates = new ArrayList<BTreeVisitor.Predicate<Location>>();\n        for (Integer missing : missingJournalFiles) {\n            missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(missing, 0), new Location(missing + 1, 0)));\n        }\n\n        if (checkForCorruptJournalFiles) {\n            Collection<DataFile> dataFiles = journal.getFileMap().values();\n            for (DataFile dataFile : dataFiles) {\n                int id = dataFile.getDataFileId();\n                missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));\n                Sequence seq = dataFile.getCorruptedBlocks().getHead();\n                while (seq != null) {\n                    missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1)));\n                    seq = seq.getNext();\n                }\n            }\n        }\n\n        if (!missingPredicates.isEmpty()) {\n            for (StoredDestination sd : storedDestinations.values()) {\n\n                final ArrayList<Long> matches = new ArrayList<Long>();\n                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor<Location, Long>(missingPredicates) {\n                    @Override\n                    protected void matched(Location key, Long value) {\n                        matches.add(value);\n                    }\n                });\n\n                // If somes message references are affected by the missing data files...\n                if (!matches.isEmpty()) {\n\n                    // We either 'gracefully' recover dropping the missing messages or\n                    // we error out.\n                    if( ignoreMissingJournalfiles ) {\n                        // Update the index to remove the references to the missing data\n                        for (Long sequenceId : matches) {\n                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                            sd.locationIndex.remove(tx, keys.location);\n                            sd.messageIdIndex.remove(tx, keys.messageId);\n                            undoCounter++;\n                            // TODO: do we need to modify the ack positions for the pub sub case?\n                        }\n\n                    } else {\n                        throw new IOException(\"Detected missing/corrupt journal files. \"+matches.size()+\" messages affected.\");\n                    }\n                }\n            }\n        }\n\n        if( undoCounter > 0 ) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user\n            // should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Detected missing/corrupt journal files.  Dropped \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.hasNext": "            public boolean hasNext() {\n                if (currentIterator == null) {\n                    if (highIterator != null) {\n                        if (highIterator.hasNext()) {\n                            currentIterator = highIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    } else {\n                        currentIterator = defaultIterator;\n                        return currentIterator.hasNext();\n                    }\n                }\n                if (highIterator != null) {\n                    if (currentIterator.hasNext()) {\n                        return true;\n                    }\n                    if (currentIterator == highIterator) {\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n\n                    if (currentIterator == defaultIterator) {\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                }\n                return currentIterator.hasNext();\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException{\n            return new MessageOrderIterator(tx,m);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.allocate": "        void allocate(Transaction tx) throws IOException {\n            defaultPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            if (metadata.version >= 2) {\n                lowPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n                highPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.next": "            public Entry<Long, MessageKeys> next() {\n                Entry<Long, MessageKeys> result = currentIterator.next();\n                if (result != null) {\n                    Long key = result.getKey();\n                    if (highIterator != null) {\n                        if (currentIterator == defaultIterator) {\n                            lastDefaultKey = key;\n                        } else if (currentIterator == highIterator) {\n                            lastHighKey = key;\n                        } else {\n                            lastLowKey = key;\n                        }\n                    } else {\n                        lastDefaultKey = key;\n                    }\n                }\n                return result;\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    void checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {\n        LOG.debug(\"Checkpoint started.\");\n\n        // reflect last update exclusive of current checkpoint\n        Location lastUpdate = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit();\n        Location[] inProgressTxRange = getInProgressTxLocationRange();\n        metadata.firstInProgressTransactionLocation = inProgressTxRange[0];\n        tx.store(metadata.page, metadataMarshaller, true);\n        pageFile.flush();\n\n        if( cleanup ) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n            final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Last update: \" + lastUpdate + \", full gc candidates set: \" + gcCandidateSet);\n            }\n\n            if (lastUpdate != null) {\n                gcCandidateSet.remove(lastUpdate.getDataFileId());\n            }\n\n            // Don't GC files under replication\n            if( journalFilesBeingReplicated!=null ) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                int dataFileId = metadata.producerSequenceIdTrackerLocation.getDataFileId();\n                if (gcCandidateSet.contains(dataFileId) && gcCandidateSet.first() == dataFileId) {\n                    // rewrite so we don't prevent gc\n                    metadata.producerSequenceIdTracker.setModified(true);\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"rewriting producerSequenceIdTracker:\" + metadata.producerSequenceIdTrackerLocation);\n                    }\n                }\n                gcCandidateSet.remove(dataFileId);\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after producerSequenceIdTrackerLocation:\" + dataFileId + \", \" + gcCandidateSet);\n                }\n            }\n\n            // Don't GC files referenced by in-progress tx\n            if (inProgressTxRange[0] != null) {\n                for (int pendingTx=inProgressTxRange[0].getDataFileId(); pendingTx <= inProgressTxRange[1].getDataFileId(); pendingTx++) {\n                    gcCandidateSet.remove(pendingTx);\n                }\n            }\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates after tx range:\" + Arrays.asList(inProgressTxRange) + \", \" + gcCandidateSet);\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if( gcCandidateSet.isEmpty() ) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last=-1;\n                    @Override\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if( first==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if( second==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    @Override\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n                }\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates: \" + gcCandidateSet);\n            }\n            final TreeSet<Integer> gcCandidates = new TreeSet<Integer>(gcCandidateSet);\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidates.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don't delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        ackMessageFileMap.remove(candidate);\n                    } else {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"not removing data file: \" + candidate\n                                    + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                        }\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cleanup removing the data files: \" + gcCandidateSet);\n                }\n                journal.removeDataFiles(gcCandidateSet);\n            }\n        }\n\n        LOG.debug(\"Checkpoint done.\");\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.loadStoredDestination": "    private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {\n        // Try to load the existing indexes..\n        StoredDestination rc = metadata.destinations.get(tx, key);\n        if (rc == null) {\n            // Brand new destination.. allocate indexes for it.\n            rc = new StoredDestination();\n            rc.orderIndex.allocate(tx);\n            rc.locationIndex = new BTreeIndex<Location, Long>(pageFile, tx.allocate());\n            rc.messageIdIndex = new BTreeIndex<String, Long>(pageFile, tx.allocate());\n\n            if (topic) {\n                rc.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, tx.allocate());\n                rc.subscriptionAcks = new BTreeIndex<String, LastAck>(pageFile, tx.allocate());\n                rc.ackPositions = new ListIndex<String, SequenceSet>(pageFile, tx.allocate());\n            }\n            metadata.destinations.put(tx, key, rc);\n        }\n\n        // Configure the marshalers and load.\n        rc.orderIndex.load(tx);\n\n        // Figure out the next key using the last entry in the destination.\n        rc.orderIndex.configureLast(tx);\n\n        rc.locationIndex.setKeyMarshaller(org.apache.activemq.store.kahadb.disk.util.LocationMarshaller.INSTANCE);\n        rc.locationIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.locationIndex.load(tx);\n\n        rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);\n        rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.messageIdIndex.load(tx);\n\n        // If it was a topic...\n        if (topic) {\n\n            rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);\n            rc.subscriptions.load(tx);\n\n            rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptionAcks.setValueMarshaller(new LastAckMarshaller());\n            rc.subscriptionAcks.load(tx);\n\n            rc.ackPositions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.ackPositions.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);\n            rc.ackPositions.load(tx);\n\n            rc.subscriptionCursors = new HashMap<String, MessageOrderCursor>();\n\n            if (metadata.version < 3) {\n\n                // on upgrade need to fill ackLocation with available messages past last ack\n                for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                    Entry<String, LastAck> entry = iterator.next();\n                    for (Iterator<Entry<Long, MessageKeys>> orderIterator =\n                            rc.orderIndex.iterator(tx, new MessageOrderCursor(entry.getValue().lastAckedSequence)); orderIterator.hasNext(); ) {\n                        Long sequence = orderIterator.next().getKey();\n                        addAckLocation(tx, rc, sequence, entry.getKey());\n                    }\n                    // modify so it is upgraded\n                    rc.subscriptionAcks.put(tx, entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Configure the message references index\n            Iterator<Entry<String, SequenceSet>> subscriptions = rc.ackPositions.iterator(tx);\n            while (subscriptions.hasNext()) {\n                Entry<String, SequenceSet> subscription = subscriptions.next();\n                SequenceSet pendingAcks = subscription.getValue();\n                if (pendingAcks != null && !pendingAcks.isEmpty()) {\n                    Long lastPendingAck = pendingAcks.getTail().getLast();\n                    for(Long sequenceId : pendingAcks) {\n                        Long current = rc.messageReferences.get(sequenceId);\n                        if (current == null) {\n                            current = new Long(0);\n                        }\n\n                        // We always add a trailing empty entry for the next position to start from\n                        // so we need to ensure we don't count that as a message reference on reload.\n                        if (!sequenceId.equals(lastPendingAck)) {\n                            current = current.longValue() + 1;\n                        }\n\n                        rc.messageReferences.put(sequenceId, current);\n                    }\n                }\n            }\n\n            // Configure the subscription cache\n            for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                Entry<String, LastAck> entry = iterator.next();\n                rc.subscriptionCache.add(entry.getKey());\n            }\n\n            if (rc.orderIndex.nextMessageId == 0) {\n                // check for existing durable sub all acked out - pull next seq from acks as messages are gone\n                if (!rc.subscriptionAcks.isEmpty(tx)) {\n                    for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {\n                        Entry<String, LastAck> entry = iterator.next();\n                        rc.orderIndex.nextMessageId =\n                                Math.max(rc.orderIndex.nextMessageId, entry.getValue().lastAckedSequence +1);\n                    }\n                }\n            } else {\n                // update based on ackPositions for unmatched, last entry is always the next\n                if (!rc.messageReferences.isEmpty()) {\n                    Long nextMessageId = (Long) rc.messageReferences.keySet().toArray()[rc.messageReferences.size() - 1];\n                    rc.orderIndex.nextMessageId =\n                            Math.max(rc.orderIndex.nextMessageId, nextMessageId);\n                }\n            }\n        }\n\n        if (metadata.version < VERSION) {\n            // store again after upgrade\n            metadata.destinations.put(tx, key, rc);\n        }\n        return rc;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.process": "    protected void process(KahaRollbackCommand command, Location location)  throws IOException {\n        TransactionId key = TransactionIdConversion.convert(command.getTransactionInfo());\n        List<Operation> updates = null;\n        synchronized (inflightTransactions) {\n            updates = inflightTransactions.remove(key);\n            if (updates == null) {\n                updates = preparedTransactions.remove(key);\n            }\n        }\n        if (isRewriteOnRedelivery()) {\n            persistRedeliveryCount(updates);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.visit": "                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.push": "    private void push(Runnable after) {\n        if (after != null) {\n            synchronized (orderedTransactionAfters) {\n                orderedTransactionAfters.push(after);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.isRewriteOnRedelivery": "    public boolean isRewriteOnRedelivery() {\n        return rewriteOnRedelivery;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.persistRedeliveryCount": "    private void persistRedeliveryCount(List<Operation> updates)  throws IOException {\n        if (updates != null) {\n            for (Operation operation : updates) {\n                operation.getCommand().visit(new Visitor() {\n                    @Override\n                    public void visit(KahaRemoveMessageCommand command) throws IOException {\n                        incrementRedeliveryAndReWrite(command.getMessageId(), command.getDestination());\n                    }\n                });\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.run": "        public void run() {\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.processLocation": "    protected void processLocation(final Location location) {\n        this.indexLock.writeLock().lock();\n        try {\n            metadata.lastUpdate = location;\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getInflightTx": "    private List<Operation> getInflightTx(KahaTransactionInfo info, Location location) {\n        TransactionId key = TransactionIdConversion.convert(info);\n        List<Operation> tx;\n        synchronized (inflightTransactions) {\n            tx = inflightTransactions.get(key);\n            if (tx == null) {\n                tx = Collections.synchronizedList(new ArrayList<Operation>());\n                inflightTransactions.put(key, tx);\n            }\n        }\n        return tx;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.removeMessage": "        public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n            KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();\n            command.setDestination(dest);\n            command.setMessageId(ack.getLastMessageId().toString());\n            command.setTransactionInfo(transactionIdTransformer.transform(ack.getTransactionId()));\n\n            org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);\n            command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));\n            store(command, isEnableJournalDiskSyncs() && ack.isResponseRequired(), null, null);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.toString": "        public String toString() {\n            return destination.getPhysicalName() + \"-\" + id;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.transform": "            public KahaTransactionInfo transform(TransactionId txid) {\n                return TransactionIdConversion.convert(txid);\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.removeAsyncMessage": "        public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {\n            if (isConcurrentStoreAndDispatchQueues()) {\n                AsyncJobKey key = new AsyncJobKey(ack.getLastMessageId(), getDestination());\n                StoreQueueTask task = null;\n                synchronized (asyncTaskMap) {\n                    task = (StoreQueueTask) asyncTaskMap.get(key);\n                }\n                if (task != null) {\n                    if (ack.isInTransaction() || !task.cancel()) {\n                        try {\n                            task.future.get();\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(e.toString());\n                        } catch (Exception ignored) {\n                            LOG.debug(\"removeAsync: cannot cancel, waiting for add resulted in ex\", ignored);\n                        }\n                        removeMessage(context, ack);\n                    } else {\n                        synchronized (asyncTaskMap) {\n                            asyncTaskMap.remove(key);\n                        }\n                    }\n                } else {\n                    removeMessage(context, ack);\n                }\n            } else {\n                removeMessage(context, ack);\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.cancel": "        public boolean cancel() {\n            if (this.done.compareAndSet(false, true)) {\n                return this.future.cancel(false);\n            }\n            return false;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.isConcurrentStoreAndDispatchQueues": "    public boolean isConcurrentStoreAndDispatchQueues() {\n        return this.concurrentStoreAndDispatchQueues;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.getDestination": "        public ActiveMQDestination getDestination() {\n            return destination;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.removeAsyncMessage": "    final void removeAsyncMessage(ConnectionContext context, final MessageStore destination, final MessageAck ack)\n            throws IOException {\n\n        if (ack.isInTransaction()) {\n            if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {\n                destination.removeAsyncMessage(context, ack);\n            } else {\n                Tx tx = getTx(ack.getTransactionId());\n                tx.add(new RemoveMessageCommand(context) {\n                    @Override\n                    public MessageAck getMessageAck() {\n                        return ack;\n                    }\n\n                    @Override\n                    public Future<Object> run(ConnectionContext ctx) throws IOException {\n                        destination.removeMessage(ctx, ack);\n                        return AbstractMessageStore.FUTURE;\n                    }\n                });\n            }\n        } else {\n            destination.removeAsyncMessage(context, ack);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.getTx": "    public Tx getTx(Object txid) {\n        Tx tx = inflightTransactions.get(txid);\n        if (tx == null) {\n            tx = new Tx();\n            inflightTransactions.put(txid, tx);\n        }\n        return tx;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.removeMessage": "    final void removeMessage(ConnectionContext context, final MessageStore destination, final MessageAck ack)\n            throws IOException {\n\n        if (ack.isInTransaction()) {\n            if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {\n                destination.removeMessage(context, ack);\n            } else {\n                Tx tx = getTx(ack.getTransactionId());\n                tx.add(new RemoveMessageCommand(context) {\n                    @Override\n                    public MessageAck getMessageAck() {\n                        return ack;\n                    }\n\n                    @Override\n                    public Future<Object> run(ConnectionContext ctx) throws IOException {\n                        destination.removeMessage(ctx, ack);\n                        return AbstractMessageStore.FUTURE;\n                    }\n                });\n            }\n        } else {\n            destination.removeMessage(context, ack);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.add": "        public void add(RemoveMessageCommand ack) {\n            acks.add(ack);\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.acknowledge": "    public void acknowledge(ConnectionContext context, Subscription sub, MessageAck ack, MessageReference node)\n            throws IOException {\n        messageConsumed(context, node);\n        if (store != null && node.isPersistent()) {\n            store.removeAsyncMessage(context, convertToNonRangedAck(ack, node));\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeMessage": "    protected void removeMessage(ConnectionContext context, Subscription sub, final QueueMessageReference reference,\n            MessageAck ack) throws IOException {\n        reference.setAcked(true);\n        // This sends the ack the the journal..\n        if (!ack.isInTransaction()) {\n            acknowledge(context, sub, ack, reference);\n            getDestinationStatistics().getDequeues().increment();\n            dropMessage(reference);\n        } else {\n            try {\n                acknowledge(context, sub, ack, reference);\n            } finally {\n                context.getTransaction().addSynchronization(new Synchronization() {\n\n                    @Override\n                    public void afterCommit() throws Exception {\n                        getDestinationStatistics().getDequeues().increment();\n                        dropMessage(reference);\n                        wakeup();\n                    }\n\n                    @Override\n                    public void afterRollback() throws Exception {\n                        reference.setAcked(false);\n                        wakeup();\n                    }\n                });\n            }\n        }\n        if (ack.isPoisonAck()) {\n            // message gone to DLQ, is ok to allow redelivery\n            messagesLock.writeLock().lock();\n            try{\n                messages.rollback(reference.getMessageId());\n            }finally {\n                messagesLock.writeLock().unlock();\n            }\n        }\n\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeMatchingMessages": "    public int removeMatchingMessages(MessageReferenceFilter filter, int maximumMessages) throws Exception {\n        int movedCounter = 0;\n        Set<MessageReference> set = new LinkedHashSet<MessageReference>();\n        ConnectionContext context = createConnectionContext();\n        do {\n            doPageIn(true);\n            pagedInMessagesLock.readLock().lock();\n            try{\n                set.addAll(pagedInMessages.values());\n            }finally {\n                pagedInMessagesLock.readLock().unlock();\n            }\n            List<MessageReference> list = new ArrayList<MessageReference>(set);\n            for (MessageReference ref : list) {\n                IndirectMessageReference r = (IndirectMessageReference) ref;\n                if (filter.evaluate(context, r)) {\n\n                    removeMessage(context, r);\n                    set.remove(r);\n                    if (++movedCounter >= maximumMessages && maximumMessages > 0) {\n                        return movedCounter;\n                    }\n                }\n            }\n        } while (set.size() < this.destinationStatistics.getMessages().getCount());\n        return movedCounter;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.dropMessage": "    private void dropMessage(QueueMessageReference reference) {\n        reference.drop();\n        destinationStatistics.getMessages().decrement();\n        pagedInMessagesLock.writeLock().lock();\n        try{\n            pagedInMessages.remove(reference.getMessageId());\n        }finally {\n            pagedInMessagesLock.writeLock().unlock();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.createMessageIdFilter": "    protected MessageReferenceFilter createMessageIdFilter(final String messageId) {\n        return new MessageReferenceFilter() {\n            public boolean evaluate(ConnectionContext context, MessageReference r) {\n                return messageId.equals(r.getMessageId().toString());\n            }\n\n            @Override\n            public String toString() {\n                return \"MessageIdFilter: \" + messageId;\n            }\n        };\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.wakeup": "    public void wakeup() {\n        if (optimizedDispatch && !iterationRunning) {\n            iterate();\n            pendingWakeups.incrementAndGet();\n        } else {\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueSubscription.acknowledge": "    protected void acknowledge(final ConnectionContext context, final MessageAck ack, final MessageReference n) throws IOException {\n        final Destination q = (Destination) n.getRegionDestination();\n        final QueueMessageReference node = (QueueMessageReference)n;\n        final Queue queue = (Queue)q;\n        \n        if (n.isExpired()) {\n            // sync with message expiry processing\n            if (!broker.isExpired(n)) {\n                LOG.warn(\"ignoring ack \" + ack + \", for already expired message: \" + n);\n                return;\n            }\n        }\n        queue.removeMessage(context, this, node, ack);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.acknowledge": "    protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;\n\n\n    public int getMaxProducersToAudit() {\n        return maxProducersToAudit;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.remove": "    public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {\n        List<MessageReference> rc = new ArrayList<MessageReference>();\n        synchronized(pendingLock) {\n            super.remove(context, destination);\n            // Here is a potential problem concerning Inflight stat:\n            // Messages not already committed or rolled back may not be removed from dispatched list at the moment\n            // Except if each commit or rollback callback action comes before remove of subscriber.\n            rc.addAll(pending.remove(context, destination));\n\n            // Synchronized to DispatchLock\n            synchronized(dispatchLock) {\n                ArrayList<MessageReference> references = new ArrayList<MessageReference>();\n                for (MessageReference r : dispatched) {\n                    if( r.getRegionDestination() == destination) {\n                        references.add(r);\n                    }\n                }\n                rc.addAll(references);\n                destination.getDestinationStatistics().getDispatched().subtract(references.size());\n                destination.getDestinationStatistics().getInflight().subtract(references.size());\n                dispatched.removeAll(references);\n            }\n        }\n        return rc;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.assertAckMatchesDispatched": "    protected void assertAckMatchesDispatched(MessageAck ack) throws JMSException {\n        MessageId firstAckedMsg = ack.getFirstMessageId();\n        MessageId lastAckedMsg = ack.getLastMessageId();\n        int checkCount = 0;\n        boolean checkFoundStart = false;\n        boolean checkFoundEnd = false;\n        for (MessageReference node : dispatched) {\n\n            if (firstAckedMsg == null) {\n                checkFoundStart = true;\n            } else if (!checkFoundStart && firstAckedMsg.equals(node.getMessageId())) {\n                checkFoundStart = true;\n            }\n\n            if (checkFoundStart) {\n                checkCount++;\n            }\n\n            if (lastAckedMsg != null && lastAckedMsg.equals(node.getMessageId())) {\n                checkFoundEnd = true;\n                break;\n            }\n        }\n        if (!checkFoundStart && firstAckedMsg != null)\n            throw new JMSException(\"Unmatched acknowledge: \" + ack\n                    + \"; Could not find Message-ID \" + firstAckedMsg\n                    + \" in dispatched-list (start of ack)\");\n        if (!checkFoundEnd && lastAckedMsg != null)\n            throw new JMSException(\"Unmatched acknowledge: \" + ack\n                    + \"; Could not find Message-ID \" + lastAckedMsg\n                    + \" in dispatched-list (end of ack)\");\n        if (ack.getMessageCount() != checkCount && !ack.isInTransaction()) {\n            throw new JMSException(\"Unmatched acknowledge: \" + ack\n                    + \"; Expected message count (\" + ack.getMessageCount()\n                    + \") differs from count in dispatched-list (\" + checkCount\n                    + \")\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.sendToDLQ": "    protected void sendToDLQ(final ConnectionContext context, final MessageReference node) throws IOException, Exception {\n        broker.getRoot().sendToDeadLetterQueue(context, node, this);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending": "    protected void dispatchPending() throws IOException {\n       synchronized(pendingLock) {\n            try {\n                int numberToDispatch = countBeforeFull();\n                if (numberToDispatch > 0) {\n                    setSlowConsumer(false);\n                    setPendingBatchSize(pending, numberToDispatch);\n                    int count = 0;\n                    pending.reset();\n                    while (pending.hasNext() && !isFull() && count < numberToDispatch) {\n                        MessageReference node = pending.next();\n                        if (node == null) {\n                            break;\n                        }\n\n                        // Synchronize between dispatched list and remove of message from pending list\n                        // related to remove subscription action\n                        synchronized(dispatchLock) {\n                            pending.remove();\n                            node.decrementReferenceCount();\n                            if( !isDropped(node) && canDispatch(node)) {\n\n                                // Message may have been sitting in the pending\n                                // list a while waiting for the consumer to ak the message.\n                                if (node!=QueueMessageReference.NULL_MESSAGE && node.isExpired()) {\n                                    //increment number to dispatch\n                                    numberToDispatch++;\n                                    if (broker.isExpired(node)) {\n                                        ((Destination)node.getRegionDestination()).messageExpired(context, this, node);\n                                    }\n                                    continue;\n                                }\n                                dispatch(node);\n                                count++;\n                            }\n                        }\n                    }\n                } else if (!isSlowConsumer()) {\n                    setSlowConsumer(true);\n                    for (Destination dest :destinations) {\n                        dest.slowConsumer(context, this);\n                    }\n                }\n            } finally {\n                pending.release();\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.registerRemoveSync": "    private void registerRemoveSync(ConnectionContext context, final MessageReference node) {\n        // setup a Synchronization to remove nodes from the\n        // dispatched list.\n        context.getTransaction().addSynchronization(\n                new Synchronization() {\n\n                    @Override\n                    public void afterCommit()\n                            throws Exception {\n                        Destination nodeDest = (Destination) node.getRegionDestination();\n                        synchronized(dispatchLock) {\n                            dequeueCounter++;\n                            dispatched.remove(node);\n                            nodeDest.getDestinationStatistics().getInflight().decrement();\n                        }\n                        nodeDest.wakeup();\n                        dispatchPending();\n                    }\n\n                    @Override\n                    public void afterRollback() throws Exception {\n                        synchronized(dispatchLock) {\n                            // poisionAck will decrement - otherwise still inflight on client\n                        }\n                    }\n                });\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.add": "    public void add(ConnectionContext context, Destination destination) throws Exception {\n        synchronized(pendingLock) {\n            super.add(context, destination);\n            pending.add(context, destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        Subscription sub = consumerExchange.getSubscription();\n        if (sub == null) {\n            sub = subscriptions.get(ack.getConsumerId());\n            if (sub == null) {\n                if (!consumerExchange.getConnectionContext().isInRecoveryMode()) {\n                    LOG.warn(\"Ack for non existent subscription, ack:\" + ack);\n                    throw new IllegalArgumentException(\"The subscription does not exist: \" + ack.getConsumerId());\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Ack for non existent subscription in recovery, ack:\" + ack);\n                    }\n                    return;\n                }\n            }\n            consumerExchange.setSubscription(sub);\n        }\n        sub.acknowledge(consumerExchange.getConnectionContext(), ack);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        if (consumerExchange.isWildcard() || consumerExchange.getRegion() == null) {\n            ActiveMQDestination destination = ack.getDestination();\n            consumerExchange.setRegion(getRegion(destination));\n        }\n        consumerExchange.getRegion().acknowledge(consumerExchange, ack);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getRegion": "    protected Region getRegion(ActiveMQDestination destination) throws JMSException {\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            return queueRegion;\n        case ActiveMQDestination.TOPIC_TYPE:\n            return topicRegion;\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            return tempQueueRegion;\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            return tempTopicRegion;\n        default:\n            throw createUnknownDestinationTypeException(destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        next.acknowledge(consumerExchange, ack);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = consumerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        if (ack.isInTransaction()) {\n            transaction = getTransaction(context, ack.getTransactionId(), false);\n        }\n        context.setTransaction(transaction);\n        try {\n            next.acknowledge(consumerExchange, ack);\n        } finally {\n            context.setTransaction(originalTx);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        getNext().acknowledge(consumerExchange, ack);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processMessageAck": "    public Response processMessageAck(MessageAck ack) throws Exception {\n        ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(ack.getConsumerId());\n        if (consumerExchange != null) {\n            broker.acknowledge(consumerExchange, ack);\n        }\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getConsumerBrokerExchange": "    private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id) {\n        ConsumerBrokerExchange result = consumerExchanges.get(id);\n        return result;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.MessageAck.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessageAck(this);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        this.sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            this.sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.SslTransport.doConsume": "    public void doConsume(Object command) {\n        // The instanceof can be avoided, but that would require modifying the\n        // Command clas tree and that would require too much effort right\n        // now.\n        if (command instanceof ConnectionInfo) {\n            ConnectionInfo connectionInfo = (ConnectionInfo)command;\n            connectionInfo.setTransportContext(getPeerCertificates());\n        } \n        super.doConsume(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.SslTransport.getPeerCertificates": "    public X509Certificate[] getPeerCertificates() {\n    \t\n        SSLSocket sslSocket = (SSLSocket)this.socket;\n\n        SSLSession sslSession = sslSocket.getSession();\n\n        X509Certificate[] clientCertChain;\n        try {\n            clientCertChain = (X509Certificate[])sslSession.getPeerCertificates();\n        } catch (SSLPeerUnverifiedException e) {\n        \tclientCertChain = null;\n        }\n    \t\n        return clientCertChain;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.TransactionIdConversion.convert": "    static TransactionId convert(KahaTransactionInfo transactionInfo) {\n        if (transactionInfo.hasLocalTransactionId()) {\n            KahaLocalTransactionId tx = transactionInfo.getLocalTransactionId();\n            LocalTransactionId rc = new LocalTransactionId();\n            rc.setConnectionId(new ConnectionId(tx.getConnectionId()));\n            rc.setValue(tx.getTransactionId());\n            return rc;\n        } else {\n            KahaXATransactionId tx = transactionInfo.getXaTransactionId();\n            XATransactionId rc = new XATransactionId();\n            rc.setBranchQualifier(tx.getBranchQualifier().toByteArray());\n            rc.setGlobalTransactionId(tx.getGlobalTransactionId().toByteArray());\n            rc.setFormatId(tx.getFormatId());\n            return rc;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.TransactionIdConversion.convertToLocal": "    static KahaTransactionInfo convertToLocal(TransactionId tx) {\n        KahaTransactionInfo rc = new KahaTransactionInfo();\n        LocalTransactionId t = (LocalTransactionId) tx;\n        KahaLocalTransactionId kahaTxId = new KahaLocalTransactionId();\n        kahaTxId.setConnectionId(t.getConnectionId().getValue());\n        kahaTxId.setTransactionId(t.getValue());\n        rc.setLocalTransactionId(kahaTxId);\n        return rc;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.isPersistent": "    boolean isPersistent();\n    \n    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessage": "    Message getMessage();\n    boolean isPersistent();\n    \n    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getRegionDestination": "    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Destination.messageExpired": "    void messageExpired(ConnectionContext context, Subscription subs, MessageReference node);\n\n    /**\n     * called when message is consumed\n     *\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     *\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory This will\n     * happen only if the policy is enabled - e.g. non durable topics\n     *\n     * @param context\n     * @param messageReference\n     * @param sub\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     *\n     * @param context\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     *\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context, ProducerInfo producerInfo);\n\n    /**\n     * Called when a Usage reaches a limit\n     *\n     * @param context\n     * @param usage\n     */\n    void isFull(ConnectionContext context, Usage<?> usage);\n\n    List<Subscription> getConsumers();\n\n    /**\n     * called on Queues in slave mode to allow dispatch to follow subscription\n     * choice of master\n     *\n     * @param messageDispatchNotification\n     * @throws Exception\n     */\n    void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception;\n\n    boolean isPrioritizedMessages();\n\n    SlowConsumerStrategy getSlowConsumerStrategy();\n\n    boolean isDoOptimzeMessageStorage();\n    void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage);\n\n    public void clearPendingMessages();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Destination.getDestinationStatistics": "    DestinationStatistics getDestinationStatistics();\n\n    DeadLetterStrategy getDeadLetterStrategy();\n\n    Message[] browse();\n\n    String getName();\n\n    MessageStore getMessageStore();\n\n    boolean isProducerFlowControl();\n\n    void setProducerFlowControl(boolean value);\n\n    boolean isAlwaysRetroactive();\n\n    void setAlwaysRetroactive(boolean value);\n\n    /**\n     * Set's the interval at which warnings about producers being blocked by\n     * resource usage will be triggered. Values of 0 or less will disable\n     * warnings\n     *\n     * @param blockedProducerWarningInterval the interval at which warning about\n     *            blocked producers will be triggered.\n     */\n    public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval);\n\n    /**\n     *\n     * @return the interval at which warning about blocked producers will be\n     *         triggered.\n     */\n    public long getBlockedProducerWarningInterval();\n\n    int getMaxProducersToAudit();\n\n    void setMaxProducersToAudit(int maxProducersToAudit);\n\n    int getMaxAuditDepth();\n\n    void setMaxAuditDepth(int maxAuditDepth);\n\n    boolean isEnableAudit();\n\n    void setEnableAudit(boolean enableAudit);\n\n    boolean isActive();\n\n    int getMaxPageSize();\n\n    public void setMaxPageSize(int maxPageSize);\n\n    public int getMaxBrowsePageSize();\n\n    public void setMaxBrowsePageSize(int maxPageSize);\n\n    public boolean isUseCache();\n\n    public void setUseCache(boolean useCache);\n\n    public int getMinimumMessageSize();\n\n    public void setMinimumMessageSize(int minimumMessageSize);\n\n    public int getCursorMemoryHighWaterMark();\n\n    public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n\n    /**\n     * optionally called by a Subscriber - to inform the Destination its ready\n     * for more messages\n     */\n    public void wakeup();\n\n    /**\n     * @return true if lazyDispatch is enabled\n     */\n    public boolean isLazyDispatch();\n\n    /**\n     * set the lazy dispatch - default is false\n     *\n     * @param value\n     */\n    public void setLazyDispatch(boolean value);\n\n    /**\n     * Inform the Destination a message has expired\n     *\n     * @param context\n     * @param subs\n     * @param node\n     */\n    void messageExpired(ConnectionContext context, Subscription subs, MessageReference node);\n\n    /**\n     * called when message is consumed\n     *\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     *\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory This will\n     * happen only if the policy is enabled - e.g. non durable topics\n     *\n     * @param context\n     * @param messageReference\n     * @param sub\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     *\n     * @param context\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     *\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context, ProducerInfo producerInfo);\n\n    /**\n     * Called when a Usage reaches a limit\n     *\n     * @param context\n     * @param usage\n     */\n    void isFull(ConnectionContext context, Usage<?> usage);\n\n    List<Subscription> getConsumers();\n\n    /**\n     * called on Queues in slave mode to allow dispatch to follow subscription\n     * choice of master\n     *\n     * @param messageDispatchNotification\n     * @throws Exception\n     */\n    void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception;\n\n    boolean isPrioritizedMessages();\n\n    SlowConsumerStrategy getSlowConsumerStrategy();\n\n    boolean isDoOptimzeMessageStorage();\n    void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage);\n\n    public void clearPendingMessages();\n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.isExpired": "    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessageId": "    MessageId getMessageId();\n    Message getMessageHardRef();\n    Message getMessage();\n    boolean isPersistent();\n    \n    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Destination.wakeup": "    public void wakeup();\n\n    /**\n     * @return true if lazyDispatch is enabled\n     */\n    public boolean isLazyDispatch();\n\n    /**\n     * set the lazy dispatch - default is false\n     *\n     * @param value\n     */\n    public void setLazyDispatch(boolean value);\n\n    /**\n     * Inform the Destination a message has expired\n     *\n     * @param context\n     * @param subs\n     * @param node\n     */\n    void messageExpired(ConnectionContext context, Subscription subs, MessageReference node);\n\n    /**\n     * called when message is consumed\n     *\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     *\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory This will\n     * happen only if the policy is enabled - e.g. non durable topics\n     *\n     * @param context\n     * @param messageReference\n     * @param sub\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     *\n     * @param context\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     *\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context, ProducerInfo producerInfo);\n\n    /**\n     * Called when a Usage reaches a limit\n     *\n     * @param context\n     * @param usage\n     */\n    void isFull(ConnectionContext context, Usage<?> usage);\n\n    List<Subscription> getConsumers();\n\n    /**\n     * called on Queues in slave mode to allow dispatch to follow subscription\n     * choice of master\n     *\n     * @param messageDispatchNotification\n     * @throws Exception\n     */\n    void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception;\n\n    boolean isPrioritizedMessages();\n\n    SlowConsumerStrategy getSlowConsumerStrategy();\n\n    boolean isDoOptimzeMessageStorage();\n    void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage);\n\n    public void clearPendingMessages();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ConsumerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "Default IOException handler needs to be set before Persistence adapter and network connectors are started",
            "Description": "It is possible to get an IOException before the current default handler is installed, so it is bypassed. It needs to be set earlier.\n{code}2013-03-11 09:51:24,409 | INFO  | No IOExceptionHandler registered, ignoring IO exception, java.io.IOException: Input/output error | org.apache.activemq.broker.BrokerService | ActiveMQ Transport: ssl:///xxx:yyy\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.readBytes(Native Method)\n\tat java.io.RandomAccessFile.read(RandomAccessFile.java:355)\n\tat java.io.RandomAccessFile.readFully(RandomAccessFile.java:414)\n\tat java.io.RandomAccessFile.readFully(RandomAccessFile.java:394)\n\tat org.apache.kahadb.page.PageFile.readPage(PageFile.java:833)\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:447)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:438)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:435)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:411)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:368)\n\tat org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)\n\tat org.apache.kahadb.index.BTreeIndex.getRoot(BTreeIndex.java:174)\n\tat org.apache.kahadb.index.BTreeIndex.remove(BTreeIndex.java:194)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.updateIndex(MessageDatabase.java:1212)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$15.execute(MessageDatabase.java:1028)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:771)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1026)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)\n\tat org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand.visit(KahaRemoveMessageCommand.java:220)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:953)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:865)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeMessage(KahaDBStore.java:439)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeAsyncMessage(KahaDBStore.java:411)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore.removeAsyncMessage(KahaDBTransactionStore.java:468)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore$1.removeAsyncMessage(KahaDBTransactionStore.java:171)\n\tat org.apache.activemq.broker.region.Queue.acknowledge(Queue.java:830)\n\tat org.apache.activemq.broker.region.Queue.removeMessage(Queue.java:1584)\n\tat org.apache.activemq.broker.region.QueueSubscription.acknowledge(QueueSubscription.java:59)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.acknowledge(PrefetchSubscription.java:294)\n\tat org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:426)\n\tat org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:537)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:287)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n\tat org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:87)\n\tat org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:461)\n\tat org.apache.activemq.command.MessageAck.visit(MessageAck.java:236)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:268)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.SslTransport.doConsume(SslTransport.java:91)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:215)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:197)\n\tat java.lang.Thread.run(Thread.java:679){code}"
        }
    },
    {
        "filename": "AMQ-5016.json",
        "creation_time": "2014-02-03T16:40:26.000+0000",
        "stack_trace": "\"ActiveMQ Session Task-869879\" prio=10 tid=0x00007f412d6ee000 nid=0x3cbe runnable [0x00007f405b7b6000]\n   java.lang.Thread.State: RUNNABLE\n        at java.util.LinkedList.linkLast(LinkedList.java:140)\n        at java.util.LinkedList.add(LinkedList.java:336)\n        at org.apache.activemq.util.BitArrayBin.getBitArray(BitArrayBin.java:123)\n        at org.apache.activemq.util.BitArrayBin.setBit(BitArrayBin.java:59)\n        at org.apache.activemq.ActiveMQMessage AuditNoSync.isDuplicate(ActiveMQMessageAuditNoSyn c.java:160)\n        at org.apache.activemq.ActiveMQMessageAudit.isDuplicate(ActiveMQMessageAudit.java:59)\n        - locked <0x00007f46a0138ab0> (a org.apache.activemq.ActiveMQMessageAudit)\n        at org.apache.activemq.ActiveMQMessage AuditNoSync.isDuplicate(ActiveMQMessageAuditNoSyn c.java:140)\n        at org.apache.activemq.ConnectionAudit.isDuplicate(ConnectionAudit.java:52)\n        - locked <0x00007f4881e6b968> (a org.apache.activemq.ConnectionAudit)\n        at org.apache.activemq.ActiveMQConnection.isDuplicate(ActiveMQConnection.java:2291)\n        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1223)\n        - locked <0x00007f45db222fb8> (a java.lang.Object)\n        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:134)\n        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:205)\n        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:127)\n        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:48)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n        at java.lang.Thread.run(Thread.java:722)",
        "source_code": {
            "activemq-client.src.main.java.org.apache.activemq.util.BitArrayBin.getBitArray": "    private BitArray getBitArray(long index) {\n        int bin = getBin(index);\n        BitArray answer = null;\n        if (bin >= 0) {\n            if (bin >= maxNumberOfArrays) {\n                int overShoot = bin - maxNumberOfArrays + 1;\n                while (overShoot > 0) {\n                    list.removeFirst();\n                    firstIndex += BitArray.LONG_SIZE;\n                    list.add(new BitArray());\n                    overShoot--;\n                }\n                \n                bin = maxNumberOfArrays - 1;\n            }\n            answer = list.get(bin);\n            if (answer == null) {\n                answer = new BitArray();\n                list.set(bin, answer);\n            }\n        }\n        return answer;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.util.BitArrayBin.getBin": "    private int getBin(long index) {\n        int answer = 0;\n        if (firstIndex < 0) {\n            firstIndex = (int) (index - (index % BitArray.LONG_SIZE));\n        } else if (firstIndex >= 0) {\n            answer = (int)((index - firstIndex) / BitArray.LONG_SIZE);\n        }\n        return answer;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.util.BitArrayBin.setBit": "    public boolean setBit(long index, boolean value) {\n        boolean answer = false;\n        BitArray ba = getBitArray(index);\n        if (ba != null) {\n            int offset = getOffset(index);\n            if (offset >= 0) {\n                answer = ba.set(offset, value);\n            }\n        }\n        return answer;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.util.BitArrayBin.getOffset": "    private int getOffset(long index) {\n        int answer = 0;\n        if (firstIndex >= 0) {\n            answer = (int)((index - firstIndex) - (BitArray.LONG_SIZE * getBin(index)));\n        }\n        return answer;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageAudit.isDuplicate": "    public boolean isDuplicate(final MessageId id) {\n        synchronized (this) {\n            return super.isDuplicate(id);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ConnectionAudit.isDuplicate": "    synchronized boolean isDuplicate(ActiveMQDispatcher dispatcher, Message message) {\n        if (checkForDuplicates && message != null) {\n            ActiveMQDestination destination = message.getDestination();\n            if (destination != null) {\n                if (destination.isQueue()) {\n                    ActiveMQMessageAudit audit = destinations.get(destination);\n                    if (audit == null) {\n                        audit = new ActiveMQMessageAudit(auditDepth, auditMaximumProducerNumber);\n                        destinations.put(destination, audit);\n                    }\n                    boolean result = audit.isDuplicate(message);\n                    return result;\n                }\n                ActiveMQMessageAudit audit = dispatchers.get(dispatcher);\n                if (audit == null) {\n                    audit = new ActiveMQMessageAudit(auditDepth, auditMaximumProducerNumber);\n                    dispatchers.put(dispatcher, audit);\n                }\n                boolean result = audit.isDuplicate(message);\n                return result;\n            }\n        }\n        return false;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.isDuplicate": "    protected boolean isDuplicate(ActiveMQDispatcher dispatcher, Message message) {\n        return checkForDuplicates && connectionAudit.isDuplicate(dispatcher, message);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.dispatch": "    public void dispatch(MessageDispatch md) {\n        MessageListener listener = this.messageListener.get();\n        try {\n            clearMessagesInProgress();\n            clearDeliveredList();\n            synchronized (unconsumedMessages.getMutex()) {\n                if (!unconsumedMessages.isClosed()) {\n                    if (this.info.isBrowser() || !session.connection.isDuplicate(this, md.getMessage())) {\n                        if (listener != null && unconsumedMessages.isRunning()) {\n                            ActiveMQMessage message = createActiveMQMessage(md);\n                            beforeMessageIsConsumed(md);\n                            try {\n                                boolean expired = message.isExpired();\n                                if (!expired) {\n                                    listener.onMessage(message);\n                                }\n                                afterMessageIsConsumed(md, expired);\n                            } catch (RuntimeException e) {\n                                LOG.error(getConsumerId() + \" Exception while processing message: \" + md.getMessage().getMessageId(), e);\n                                if (isAutoAcknowledgeBatch() || isAutoAcknowledgeEach() || session.isIndividualAcknowledge()) {\n                                    // schedual redelivery and possible dlq processing\n                                    md.setRollbackCause(e);\n                                    rollback();\n                                } else {\n                                    // Transacted or Client ack: Deliver the\n                                    // next message.\n                                    afterMessageIsConsumed(md, false);\n                                }\n                            }\n                        } else {\n                            if (!unconsumedMessages.isRunning()) {\n                                // delayed redelivery, ensure it can be re delivered\n                                session.connection.rollbackDuplicate(this, md.getMessage());\n                            }\n                            unconsumedMessages.enqueue(md);\n                            if (availableListener != null) {\n                                availableListener.onMessageAvailable(this);\n                            }\n                        }\n                    } else {\n                        if (!session.isTransacted()) {\n                            LOG.warn(\"Duplicate non transacted dispatch to consumer: \"  + getConsumerId() + \", poison acking: \" + md);\n                            MessageAck poisonAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);\n                            poisonAck.setFirstMessageId(md.getMessage().getMessageId());\n                            poisonAck.setPoisonCause(new Throwable(\"Duplicate non transacted delivery to \" + getConsumerId()));\n                            session.sendAck(poisonAck);\n                        } else {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(getConsumerId() + \" tracking transacted redelivery of duplicate: \" + md.getMessage());\n                            }\n                            boolean needsPoisonAck = false;\n                            synchronized (deliveredMessages) {\n                                if (previouslyDeliveredMessages != null) {\n                                    previouslyDeliveredMessages.put(md.getMessage().getMessageId(), true);\n                                } else {\n                                    // delivery while pending redelivery to another consumer on the same connection\n                                    // not waiting for redelivery will help here\n                                    needsPoisonAck = true;\n                                }\n                            }\n                            if (needsPoisonAck) {\n                                MessageAck poisonAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);\n                                poisonAck.setFirstMessageId(md.getMessage().getMessageId());\n                                poisonAck.setPoisonCause(new JMSException(\"Duplicate dispatch with transacted redeliver pending on another consumer, connection: \"\n                                        + session.getConnection().getConnectionInfo().getConnectionId()));\n                                LOG.warn(\"acking duplicate delivery as poison, redelivery must be pending to another\"\n                                        + \" consumer on this connection, failoverRedeliveryWaitPeriod=\"\n                                        + failoverRedeliveryWaitPeriod + \". Message: \" + md + \", poisonAck: \" + poisonAck);\n                                session.sendAck(poisonAck);\n                            } else {\n                                if (transactedIndividualAck) {\n                                    immediateIndividualTransactedAck(md);\n                                } else {\n                                    session.sendAck(new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (++dispatchedCount % 1000 == 0) {\n                dispatchedCount = 0;\n                Thread.yield();\n            }\n        } catch (Exception e) {\n            session.connection.onClientInternalException(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.clearMessagesInProgress": "    void clearMessagesInProgress() {\n        if (inProgressClearRequiredFlag.get() > 0) {\n            synchronized (unconsumedMessages.getMutex()) {\n                if (inProgressClearRequiredFlag.get() > 0) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(getConsumerId() + \" clearing unconsumed list (\" + unconsumedMessages.size() + \") on transport interrupt\");\n                    }\n                    // ensure unconsumed are rolledback up front as they may get redelivered to another consumer\n                    List<MessageDispatch> list = unconsumedMessages.removeAll();\n                    if (!this.info.isBrowser()) {\n                        for (MessageDispatch old : list) {\n                            session.connection.rollbackDuplicate(this, old.getMessage());\n                        }\n                    }\n                    // allow dispatch on this connection to resume\n                    session.connection.transportInterruptionProcessingComplete();\n                    inProgressClearRequiredFlag.decrementAndGet();\n\n                    // Wake up any blockers and allow them to recheck state.\n                    unconsumedMessages.getMutex().notifyAll();\n                }\n            }\n        }\n        clearDeliveredList();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.clearDeliveredList": "    private void clearDeliveredList() {\n        if (clearDeliveredList) {\n            synchronized (deliveredMessages) {\n                if (clearDeliveredList) {\n                    if (!deliveredMessages.isEmpty()) {\n                        if (session.isTransacted()) {\n\n                            if (previouslyDeliveredMessages == null) {\n                                previouslyDeliveredMessages = new PreviouslyDeliveredMap<MessageId, Boolean>(session.getTransactionContext().getTransactionId());\n                            }\n                            for (MessageDispatch delivered : deliveredMessages) {\n                                previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);\n                            }\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(getConsumerId() + \" tracking existing transacted \" + previouslyDeliveredMessages.transactionId +\n                                        \" delivered list (\" + deliveredMessages.size() + \") on transport interrupt\");\n                            }\n                        } else {\n                            if (session.isClientAcknowledge()) {\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(getConsumerId() + \" rolling back delivered list (\" + deliveredMessages.size() + \") on transport interrupt\");\n                                }\n                                // allow redelivery\n                                if (!this.info.isBrowser()) {\n                                    for (MessageDispatch md: deliveredMessages) {\n                                        this.session.connection.rollbackDuplicate(this, md.getMessage());\n                                    }\n                                }\n                            }\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(getConsumerId() + \" clearing delivered list (\" + deliveredMessages.size() + \") on transport interrupt\");\n                            }\n                            deliveredMessages.clear();\n                            pendingAck = null;\n                        }\n                    }\n                    clearDeliveredList = false;\n                }\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.rollback": "    public void rollback() throws JMSException {\n        clearDeliveredList();\n        synchronized (unconsumedMessages.getMutex()) {\n            if (optimizeAcknowledge) {\n                // remove messages read but not acked at the broker yet through\n                // optimizeAcknowledge\n                if (!this.info.isBrowser()) {\n                    synchronized(deliveredMessages) {\n                        for (int i = 0; (i < deliveredMessages.size()) && (i < ackCounter); i++) {\n                            // ensure we don't filter this as a duplicate\n                            MessageDispatch md = deliveredMessages.removeLast();\n                            session.connection.rollbackDuplicate(this, md.getMessage());\n                        }\n                    }\n                }\n            }\n            synchronized(deliveredMessages) {\n                rollbackPreviouslyDeliveredAndNotRedelivered();\n                if (deliveredMessages.isEmpty()) {\n                    return;\n                }\n\n                // use initial delay for first redelivery\n                MessageDispatch lastMd = deliveredMessages.getFirst();\n                final int currentRedeliveryCount = lastMd.getMessage().getRedeliveryCounter();\n                if (currentRedeliveryCount > 0) {\n                    redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);\n                } else {\n                    redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();\n                }\n                MessageId firstMsgId = deliveredMessages.getLast().getMessage().getMessageId();\n\n                for (Iterator<MessageDispatch> iter = deliveredMessages.iterator(); iter.hasNext();) {\n                    MessageDispatch md = iter.next();\n                    md.getMessage().onMessageRolledBack();\n                    // ensure we don't filter this as a duplicate\n                    session.connection.rollbackDuplicate(this, md.getMessage());\n                }\n\n                if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES\n                    && lastMd.getMessage().getRedeliveryCounter() > redeliveryPolicy.getMaximumRedeliveries()) {\n                    // We need to NACK the messages so that they get sent to the\n                    // DLQ.\n                    // Acknowledge the last message.\n\n                    MessageAck ack = new MessageAck(lastMd, MessageAck.POSION_ACK_TYPE, deliveredMessages.size());\n                    ack.setFirstMessageId(firstMsgId);\n                    ack.setPoisonCause(new Throwable(\"Exceeded redelivery policy limit:\" + redeliveryPolicy\n                            + \", cause:\" + lastMd.getRollbackCause(), lastMd.getRollbackCause()));\n                    session.sendAck(ack,true);\n                    // Adjust the window size.\n                    additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());\n                    redeliveryDelay = 0;\n\n                    deliveredCounter -= deliveredMessages.size();\n                    deliveredMessages.clear();\n\n                } else {\n\n                    // only redelivery_ack after first delivery\n                    if (currentRedeliveryCount > 0) {\n                        MessageAck ack = new MessageAck(lastMd, MessageAck.REDELIVERED_ACK_TYPE, deliveredMessages.size());\n                        ack.setFirstMessageId(firstMsgId);\n                        session.sendAck(ack,true);\n                    }\n\n                    // stop the delivery of messages.\n                    if (nonBlockingRedelivery) {\n                        if (!unconsumedMessages.isClosed()) {\n\n                            final LinkedList<MessageDispatch> pendingRedeliveries =\n                                new LinkedList<MessageDispatch>(deliveredMessages);\n\n                            Collections.reverse(pendingRedeliveries);\n\n                            deliveredCounter -= deliveredMessages.size();\n                            deliveredMessages.clear();\n\n                            // Start up the delivery again a little later.\n                            session.getScheduler().executeAfterDelay(new Runnable() {\n                                @Override\n                                public void run() {\n                                    try {\n                                        if (!unconsumedMessages.isClosed()) {\n                                            for(MessageDispatch dispatch : pendingRedeliveries) {\n                                                session.dispatch(dispatch);\n                                            }\n                                        }\n                                    } catch (Exception e) {\n                                        session.connection.onAsyncException(e);\n                                    }\n                                }\n                            }, redeliveryDelay);\n                        }\n\n                    } else {\n                        unconsumedMessages.stop();\n\n                        for (MessageDispatch md : deliveredMessages) {\n                            unconsumedMessages.enqueueFirst(md);\n                        }\n\n                        deliveredCounter -= deliveredMessages.size();\n                        deliveredMessages.clear();\n\n                        if (redeliveryDelay > 0 && !unconsumedMessages.isClosed()) {\n                            // Start up the delivery again a little later.\n                            session.getScheduler().executeAfterDelay(new Runnable() {\n                                @Override\n                                public void run() {\n                                    try {\n                                        if (started.get()) {\n                                            start();\n                                        }\n                                    } catch (JMSException e) {\n                                        session.connection.onAsyncException(e);\n                                    }\n                                }\n                            }, redeliveryDelay);\n                        } else {\n                            start();\n                        }\n                    }\n                }\n            }\n        }\n        if (messageListener.get() != null) {\n            session.redispatch(this, unconsumedMessages);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.afterMessageIsConsumed": "    private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n        if (unconsumedMessages.isClosed()) {\n            return;\n        }\n        if (messageExpired) {\n            acknowledge(md, MessageAck.DELIVERED_ACK_TYPE);\n            stats.getExpiredMessageCount().increment();\n        } else {\n            stats.onMessage();\n            if (session.getTransacted()) {\n                // Do nothing.\n            } else if (isAutoAcknowledgeEach()) {\n                if (deliveryingAcknowledgements.compareAndSet(false, true)) {\n                    synchronized (deliveredMessages) {\n                        if (!deliveredMessages.isEmpty()) {\n                            if (optimizeAcknowledge) {\n                                ackCounter++;\n\n                                // AMQ-3956 evaluate both expired and normal msgs as\n                                // otherwise consumer may get stalled\n                                if (ackCounter + deliveredCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {\n                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                    if (ack != null) {\n                                        deliveredMessages.clear();\n                                        ackCounter = 0;\n                                        session.sendAck(ack);\n                                        optimizeAckTimestamp = System.currentTimeMillis();\n                                    }\n                                    // AMQ-3956 - as further optimization send\n                                    // ack for expired msgs when there are any.\n                                    // This resets the deliveredCounter to 0 so that\n                                    // we won't sent standard acks with every msg just\n                                    // because the deliveredCounter just below\n                                    // 0.5 * prefetch as used in ackLater()\n                                    if (pendingAck != null && deliveredCounter > 0) {\n                                        session.sendAck(pendingAck);\n                                        pendingAck = null;\n                                        deliveredCounter = 0;\n                                    }\n                                }\n                            } else {\n                                MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                if (ack!=null) {\n                                    deliveredMessages.clear();\n                                    session.sendAck(ack);\n                                }\n                            }\n                        }\n                    }\n                    deliveryingAcknowledgements.set(false);\n                }\n            } else if (isAutoAcknowledgeBatch()) {\n                ackLater(md, MessageAck.STANDARD_ACK_TYPE);\n            } else if (session.isClientAcknowledge()||session.isIndividualAcknowledge()) {\n                boolean messageUnackedByConsumer = false;\n                synchronized (deliveredMessages) {\n                    messageUnackedByConsumer = deliveredMessages.contains(md);\n                }\n                if (messageUnackedByConsumer) {\n                    ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n                }\n            }\n            else {\n                throw new IllegalStateException(\"Invalid session state.\");\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.isAutoAcknowledgeEach": "    private boolean isAutoAcknowledgeEach() {\n        return session.isAutoAcknowledge() || ( session.isDupsOkAcknowledge() && getDestination().isQueue() );\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.createActiveMQMessage": "    private ActiveMQMessage createActiveMQMessage(final MessageDispatch md) throws JMSException {\n        ActiveMQMessage m = (ActiveMQMessage)md.getMessage().copy();\n        if (m.getDataStructureType()==CommandTypes.ACTIVEMQ_BLOB_MESSAGE) {\n            ((ActiveMQBlobMessage)m).setBlobDownloader(new BlobDownloader(session.getBlobTransferPolicy()));\n        }\n        if (transformer != null) {\n            Message transformedMessage = transformer.consumerTransform(session, this, m);\n            if (transformedMessage != null) {\n                m = ActiveMQMessageTransformation.transformMessage(transformedMessage, session.connection);\n            }\n        }\n        if (session.isClientAcknowledge()) {\n            m.setAcknowledgeCallback(new Callback() {\n                @Override\n                public void execute() throws Exception {\n                    session.checkClosed();\n                    session.acknowledge();\n                }\n            });\n        } else if (session.isIndividualAcknowledge()) {\n            m.setAcknowledgeCallback(new Callback() {\n                @Override\n                public void execute() throws Exception {\n                    session.checkClosed();\n                    acknowledge(md);\n                }\n            });\n        }\n        return m;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.beforeMessageIsConsumed": "    private void beforeMessageIsConsumed(MessageDispatch md) throws JMSException {\n        md.setDeliverySequenceId(session.getNextDeliveryId());\n        lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();\n        if (!isAutoAcknowledgeBatch()) {\n            synchronized(deliveredMessages) {\n                deliveredMessages.addFirst(md);\n            }\n            if (session.getTransacted()) {\n                if (transactedIndividualAck) {\n                    immediateIndividualTransactedAck(md);\n                } else {\n                    ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n                }\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.isBrowser": "    protected boolean isBrowser() {\n        return info.isBrowser();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.getConsumerId": "    public ConsumerId getConsumerId() {\n        return info.getConsumerId();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.isAutoAcknowledgeBatch": "    private boolean isAutoAcknowledgeBatch() {\n        return session.isDupsOkAcknowledge() && !getDestination().isQueue() ;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.immediateIndividualTransactedAck": "    private void immediateIndividualTransactedAck(MessageDispatch md) throws JMSException {\n        // acks accumulate on the broker pending transaction completion to indicate\n        // delivery status\n        registerSync();\n        MessageAck ack = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);\n        ack.setTransactionId(session.getTransactionContext().getTransactionId());\n        session.syncSendPacket(ack);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSessionExecutor.dispatch": "    void dispatch(MessageDispatch message) {\n        // TODO - we should use a Map for this indexed by consumerId\n        for (ActiveMQMessageConsumer consumer : this.session.consumers) {\n            ConsumerId consumerId = message.getConsumerId();\n            if (consumerId.equals(consumer.getConsumerId())) {\n                consumer.dispatch(message);\n                break;\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSessionExecutor.iterate": "    public boolean iterate() {\n\n        // Deliver any messages queued on the consumer to their listeners.\n        for (ActiveMQMessageConsumer consumer : this.session.consumers) {\n            if (consumer.iterate()) {\n                return true;\n            }\n        }\n\n        // No messages left queued on the listeners.. so now dispatch messages\n        // queued on the session\n        MessageDispatch message = messageQueue.dequeueNoWait();\n        if (message == null) {\n            return false;\n        } else {\n            dispatch(message);\n            return !messageQueue.isEmpty();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSessionExecutor.isEmpty": "    public boolean isEmpty() {\n        return messageQueue.isEmpty();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSessionExecutor.dequeueNoWait": "    MessageDispatch dequeueNoWait() {\n        return messageQueue.dequeueNoWait();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.thread.PooledTaskRunner.runTask": "    final void runTask() {\n\n        synchronized (runable) {\n            queued = false;\n            if (shutdown) {\n                iterating = false;\n                runable.notifyAll();\n                return;\n            }\n            iterating = true;\n        }\n\n        // Don't synchronize while we are iterating so that\n        // multiple wakeup() calls can be executed concurrently.\n        boolean done = false;\n        try {\n            for (int i = 0; i < maxIterationsPerRun; i++) {\n                LOG.trace(\"Running task iteration {} - {}\", i, task);\n                if (!task.iterate()) {\n                    done = true;\n                    break;\n                }\n            }\n        } finally {\n            synchronized( runable ) {\n                iterating = false;\n                runable.notifyAll();\n                if (shutdown) {\n                    queued = false;\n                    runable.notifyAll();\n                    return;\n                }\n\n                // If we could not iterate all the items\n                // then we need to re-queue.\n                if (!done) {\n                    queued = true;\n                }\n\n                if (queued) {\n                    executor.execute(runable);\n                }\n\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.thread.PooledTaskRunner.run": "            public void run() {\n                runningThread = Thread.currentThread();\n                try {\n                    runTask();\n                } finally {\n                    LOG.trace(\"Run task done: {}\", task);\n                    runningThread = null;\n                }\n            }",
            "activemq-client.src.main.java.org.apache.activemq.util.BitArray.set": "    public boolean set(int index, boolean flag) {\n        length = Math.max(length, index + 1);\n        boolean oldValue = (bits & BIT_VALUES[index]) != 0;\n        if (flag) {\n            bits |= BIT_VALUES[index];\n        } else if (oldValue) {\n            bits &= ~(BIT_VALUES[index]);\n        }\n        return oldValue;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.thread.task.iterate": "    boolean iterate();\n}"
        },
        "bug_report": {
            "Title": "BitArrayBin doesn't work well with index larger than Integer.MAX_VALUE",
            "Description": "In BitArrayBin class, the index's unit type is long. It also has a variable called firstIndex, which store the index where the window starts. And that firstindex's unit is int. If the index is bigger than Integer.MAX_VALUE, setBit() and getBit() starts to return bad value.\n\nThe defect causes activemq client to perform badly when receiving message that sequence id is bigger than max interger. It spends most of the time to shift window, and also blocks other consumer threads. Below is the jstack log that shows the problem.\n{code}\n\"ActiveMQ Session Task-869879\" prio=10 tid=0x00007f412d6ee000 nid=0x3cbe runnable [0x00007f405b7b6000]\n   java.lang.Thread.State: RUNNABLE\n        at java.util.LinkedList.linkLast(LinkedList.java:140)\n        at java.util.LinkedList.add(LinkedList.java:336)\n        at org.apache.activemq.util.BitArrayBin.getBitArray(BitArrayBin.java:123)\n        at org.apache.activemq.util.BitArrayBin.setBit(BitArrayBin.java:59)\n        at org.apache.activemq.ActiveMQMessage AuditNoSync.isDuplicate(ActiveMQMessageAuditNoSyn c.java:160)\n        at org.apache.activemq.ActiveMQMessageAudit.isDuplicate(ActiveMQMessageAudit.java:59)\n        - locked <0x00007f46a0138ab0> (a org.apache.activemq.ActiveMQMessageAudit)\n        at org.apache.activemq.ActiveMQMessage AuditNoSync.isDuplicate(ActiveMQMessageAuditNoSyn c.java:140)\n        at org.apache.activemq.ConnectionAudit.isDuplicate(ConnectionAudit.java:52)\n        - locked <0x00007f4881e6b968> (a org.apache.activemq.ConnectionAudit)\n        at org.apache.activemq.ActiveMQConnection.isDuplicate(ActiveMQConnection.java:2291)\n        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1223)\n        - locked <0x00007f45db222fb8> (a java.lang.Object)\n        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:134)\n        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:205)\n        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:127)\n        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:48)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n        at java.lang.Thread.run(Thread.java:722)\n{code}\n"
        }
    },
    {
        "filename": "AMQ-4407.json",
        "creation_time": "2013-03-26T15:41:15.000+0000",
        "stack_trace": "java.lang.IllegalStateException: PageFile is not loaded\n\tat org.apache.activemq.store.kahadb.disk.page.PageFile.assertLoaded(PageFile.java:809)\n\tat org.apache.activemq.store.kahadb.disk.page.PageFile.tx(PageFile.java:303)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.getMessageCount(KahaDBStore.java:478)\n\tat org.apache.activemq.store.ProxyMessageStore.getMessageCount(ProxyMessageStore.java:101)\n\tat org.apache.activemq.store.ProxyMessageStore.getMessageCount(ProxyMessageStore.java:101)\n\tat org.apache.activemq.broker.region.Queue.initialize(Queue.java:376)\n\tat org.apache.activemq.broker.region.DestinationFactoryImpl.createDestination(DestinationFactoryImpl.java:87)\n\tat org.apache.activemq.broker.region.AbstractRegion.createDestination(AbstractRegion.java:526)\n\tat org.apache.activemq.broker.jmx.ManagedQueueRegion.createDestination(ManagedQueueRegion.java:56)\n\tat org.apache.activemq.broker.region.AbstractRegion.addDestination(AbstractRegion.java:136)\n\tat org.apache.activemq.broker.region.RegionBroker.addDestination(RegionBroker.java:277)\n\tat org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)\n\tat org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)\n\tat org.apache.activemq.broker.MutableBrokerFilter.addDestination(MutableBrokerFilter.java:151)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:387)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:282)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:317)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:499)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:749)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:329)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:184)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:45)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:84)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:195)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:321)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:233)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:73)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:680)",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.assertLoaded": "    void assertLoaded() throws IllegalStateException {\n        if (!loaded.get()) {\n            throw new IllegalStateException(\"PageFile is not loaded\");\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.tx": "    public Transaction tx() {\n        assertLoaded();\n        return new Transaction(this);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.getMessageCount": "        public int getMessageCount(String clientId, String subscriptionName) throws IOException {\n            final String subscriptionKey = subscriptionKey(clientId, subscriptionName);\n            indexLock.writeLock().lock();\n            try {\n                return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {\n                    public Integer execute(Transaction tx) throws IOException {\n                        StoredDestination sd = getStoredDestination(dest, tx);\n                        LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);\n                        if (cursorPos == null) {\n                            // The subscription might not exist.\n                            return 0;\n                        }\n\n                        return (int) getStoredMessageCount(tx, sd, subscriptionKey);\n                    }\n                });\n            }finally {\n                indexLock.writeLock().unlock();\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.unlockAsyncJobQueue": "        protected void unlockAsyncJobQueue() {\n            this.localDestinationSemaphore.release(this.maxAsyncJobs);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.execute": "                    public void execute(Transaction tx) throws IOException {\n                        for (Iterator<Entry<String, StoredDestination>> iterator = metadata.destinations.iterator(tx); iterator\n                                .hasNext();) {\n                            Entry<String, StoredDestination> entry = iterator.next();\n                            if (!isEmptyTopic(entry, tx)) {\n                                rc.add(convert(entry.getKey()));\n                            }\n                        }\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.subscriptionKey": "    String subscriptionKey(String clientId, String subscriptionName) {\n        return clientId + \":\" + subscriptionName;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.lockAsyncJobQueue": "        protected void lockAsyncJobQueue() {\n            try {\n                this.localDestinationSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);\n            } catch (Exception e) {\n                LOG.error(\"Failed to lock async jobs for \" + this.destination, e);\n            }\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.store.ProxyMessageStore.getMessageCount": "    public int getMessageCount() throws IOException {\n        return delegate.getMessageCount();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.initialize": "    public void initialize() throws Exception {\n\n        if (this.messages == null) {\n            if (destination.isTemporary() || broker == null || store == null) {\n                this.messages = new VMPendingMessageCursor(isPrioritizedMessages());\n            } else {\n                this.messages = new StoreQueueCursor(broker, this);\n            }\n        }\n\n        // If a VMPendingMessageCursor don't use the default Producer System\n        // Usage\n        // since it turns into a shared blocking queue which can lead to a\n        // network deadlock.\n        // If we are cursoring to disk..it's not and issue because it does not\n        // block due\n        // to large disk sizes.\n        if (messages instanceof VMPendingMessageCursor) {\n            this.systemUsage = brokerService.getSystemUsage();\n            memoryUsage.setParent(systemUsage.getMemoryUsage());\n        }\n\n        this.taskRunner = taskFactory.createTaskRunner(this, \"Queue:\" + destination.getPhysicalName());\n\n        super.initialize();\n        if (store != null) {\n            // Restore the persistent messages.\n            messages.setSystemUsage(systemUsage);\n            messages.setEnableAudit(isEnableAudit());\n            messages.setMaxAuditDepth(getMaxAuditDepth());\n            messages.setMaxProducersToAudit(getMaxProducersToAudit());\n            messages.setUseCache(isUseCache());\n            messages.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());\n            final int messageCount = store.getMessageCount();\n            if (messageCount > 0 && messages.isRecoveryRequired()) {\n                BatchMessageRecoveryListener listener = new BatchMessageRecoveryListener(messageCount);\n                do {\n                   listener.reset();\n                   store.recoverNextMessages(getMaxPageSize(), listener);\n                   listener.processExpired();\n               } while (!listener.done());\n            } else {\n                destinationStatistics.getMessages().setCount(messageCount);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.reset": "        public void reset() {\n            currentBatchCount = recoveredAccumulator;\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getMessages": "    public PendingMessageCursor getMessages() {\n        return this.messages;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.processExpired": "        public void processExpired() {\n            for (Message message: toExpire) {\n                messageExpired(createConnectionContext(), createMessageReference(message));\n                // drop message will decrement so counter\n                // balance here\n                destinationStatistics.getMessages().increment();\n            }\n            toExpire.clear();\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.done": "        void done() {\n            try {\n                browser.decrementQueueRef();\n            } catch (Exception e) {\n                LOG.warn(\"decrement ref on browser: \" + browser, e);\n            }\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.DestinationFactoryImpl.createDestination": "    public Destination createDestination(ConnectionContext context, ActiveMQDestination destination, DestinationStatistics destinationStatistics) throws Exception {\n        if (destination.isQueue()) {\n            if (destination.isTemporary()) {\n                final ActiveMQTempDestination tempDest = (ActiveMQTempDestination)destination;\n                Queue queue = new TempQueue(brokerService, destination, null, destinationStatistics, taskRunnerFactory);\n                configureQueue(queue, destination);\n                queue.initialize();\n                return queue;\n            } else {\n                MessageStore store = persistenceAdapter.createQueueMessageStore((ActiveMQQueue)destination);\n                Queue queue = new Queue(brokerService, destination, store, destinationStatistics, taskRunnerFactory);\n                configureQueue(queue, destination);\n                queue.initialize();\n                return queue;\n            }\n        } else if (destination.isTemporary()) {\n            \n            Topic topic = new Topic(brokerService, destination, null, destinationStatistics, taskRunnerFactory);\n            configureTopic(topic, destination);\n            topic.initialize();\n            return topic;\n        } else {\n            TopicMessageStore store = null;\n            if (!AdvisorySupport.isAdvisoryTopic(destination)) {\n                store = persistenceAdapter.createTopicMessageStore((ActiveMQTopic)destination);\n            }\n            Topic topic = new Topic(brokerService, destination, store, destinationStatistics, taskRunnerFactory);\n            configureTopic(topic, destination);\n            topic.initialize();\n            return topic;\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.DestinationFactoryImpl.configureTopic": "    protected void configureTopic(Topic topic, ActiveMQDestination destination) {\n        if (broker == null) {\n            throw new IllegalStateException(\"broker property is not set\");\n        }\n        if (broker.getDestinationPolicy() != null) {\n            PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);\n            if (entry != null) {\n                entry.configure(broker,topic);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.DestinationFactoryImpl.configureQueue": "    protected void configureQueue(Queue queue, ActiveMQDestination destination) {\n        if (broker == null) {\n            throw new IllegalStateException(\"broker property is not set\");\n        }\n        if (broker.getDestinationPolicy() != null) {\n            PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);\n            if (entry != null) {\n                entry.configure(broker,queue);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.createDestination": "    protected Destination createDestination(ConnectionContext context, ActiveMQDestination destination)\n            throws Exception {\n        return destinationFactory.createDestination(context, destination, destinationStatistics);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.ManagedQueueRegion.createDestination": "    protected Destination createDestination(ConnectionContext context, ActiveMQDestination destination) throws Exception {\n        Destination rc = super.createDestination(context, destination);\n        regionBroker.register(destination, rc);\n        return rc;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,\n            boolean createIfTemporary) throws Exception {\n\n        destinationsLock.writeLock().lock();\n        try {\n            Destination dest = destinations.get(destination);\n            if (dest == null) {\n                if (destination.isTemporary() == false || createIfTemporary) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(broker.getBrokerName() + \" adding destination: \" + destination);\n                    }\n                    dest = createDestination(context, destination);\n                    // intercept if there is a valid interceptor defined\n                    DestinationInterceptor destinationInterceptor = broker.getDestinationInterceptor();\n                    if (destinationInterceptor != null) {\n                        dest = destinationInterceptor.intercept(dest);\n                    }\n                    dest.start();\n                    destinations.put(destination, dest);\n                    destinationMap.put(destination, dest);\n                    addSubscriptionsForDestination(context, dest);\n                }\n                if (dest == null) {\n                    throw new DestinationDoesNotExistException(destination.getQualifiedName());\n                }\n            }\n            return dest;\n        } finally {\n            destinationsLock.writeLock().unlock();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.addSubscriptionsForDestination": "    protected List<Subscription> addSubscriptionsForDestination(ConnectionContext context, Destination dest)\n            throws Exception {\n\n        List<Subscription> rc = new ArrayList<Subscription>();\n        // Add all consumers that are interested in the destination.\n        for (Iterator<Subscription> iter = subscriptions.values().iterator(); iter.hasNext();) {\n            Subscription sub = iter.next();\n            if (sub.matches(dest.getActiveMQDestination())) {\n                dest.addSubscription(context, sub);\n                rc.add(sub);\n            }\n        }\n        return rc;\n\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.start": "    public final void start() throws Exception {\n        started = true;\n\n        Set<ActiveMQDestination> inactiveDests = getInactiveDestinations();\n        for (Iterator<ActiveMQDestination> iter = inactiveDests.iterator(); iter.hasNext();) {\n            ActiveMQDestination dest = iter.next();\n\n            ConnectionContext context = new ConnectionContext();\n            context.setBroker(broker.getBrokerService().getBroker());\n            context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);\n            context.getBroker().addDestination(context, dest, false);\n        }\n        destinationsLock.readLock().lock();\n        try{\n            for (Iterator<Destination> i = destinations.values().iterator(); i.hasNext();) {\n                Destination dest = i.next();\n                dest.start();\n            }\n        } finally {\n            destinationsLock.readLock().unlock();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {\n\n        Destination answer;\n\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n     synchronized (destinations) {\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n        boolean create = true;\n        if (destination.isTemporary())\n            create = createIfTemp;\n        answer = getRegion(destination).addDestination(context, destination, create);\n\n        destinations.put(destination, answer);\n        return answer;\n     }\n\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getRegion": "    protected Region getRegion(ActiveMQDestination destination) throws JMSException {\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            return queueRegion;\n        case ActiveMQDestination.TOPIC_TYPE:\n            return topicRegion;\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            return tempQueueRegion;\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            return tempTopicRegion;\n        default:\n            throw createUnknownDestinationTypeException(destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean createIfTemporary) throws Exception {\n        return next.addDestination(context, destination,createIfTemporary);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean createIfTemporary) throws Exception {\n        return getNext().addDestination(context, destination,createIfTemporary);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        message.setBrokerInTime(System.currentTimeMillis());\n        if (producerExchange.isMutable() || producerExchange.getRegion() == null\n                || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {\n            // ensure the destination is registered with the RegionBroker\n            producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());\n            producerExchange.setRegion(getRegion(destination));\n            producerExchange.setRegionDestination(null);\n        }\n\n        producerExchange.getRegion().send(producerExchange, message);\n\n        // clean up so these references aren't kept (possible leak) in the producer exchange\n        // especially since temps are transitory\n        if (producerExchange.isMutable()) {\n            producerExchange.setRegionDestination(null);\n            producerExchange.setRegion(null);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.isAllowTempAutoCreationOnSend": "    public boolean isAllowTempAutoCreationOnSend() {\n        return allowTempAutoCreationOnSend;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.send": "    public void send(ProducerBrokerExchange exchange, Message message) throws Exception {\n        if (exchange != null && exchange.getProducerState() != null && exchange.getProducerState().getInfo() != null) {\n            ProducerInfo info = exchange.getProducerState().getInfo();\n            if (info.getDestination() == null && info.getProducerId() != null) {\n                ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, exchange.getConnectionContext().getClientId(), info);\n                ProducerView view = this.dynamicDestinationProducers.get(objectName);\n                if (view != null) {\n                    ActiveMQDestination dest = message.getDestination();\n                    if (dest != null) {\n                        view.setLastUsedDestinationName(dest);\n                    }\n                }\n            }\n         }\n        super.send(exchange, message);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.CompositeDestinationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        if (destination.isComposite()) {\n            ActiveMQDestination[] destinations = destination.getCompositeDestinations();\n            for (int i = 0; i < destinations.length; i++) {\n                if (i != 0) {\n                    message = message.copy();\n                    message.setMemoryUsage(null);\n                }\n                message.setOriginalDestination(destination);\n                message.setDestination(destinations[i]);\n                next.send(producerExchange, message);\n            }\n        } else {\n            next.send(producerExchange, message);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        Synchronization sync = null;\n        if (message.getTransactionId() != null) {\n            transaction = getTransaction(context, message.getTransactionId(), false);\n            if (transaction != null) {\n                sync = new Synchronization() {\n\n                    public void afterRollback() {\n                        if (audit != null) {\n                            audit.rollback(message);\n                        }\n                    }\n                };\n                transaction.addSynchronization(sync);\n            }\n        }\n        if (audit == null || !audit.isDuplicate(message)) {\n            context.setTransaction(transaction);\n            try {\n                next.send(producerExchange, message);\n            } finally {\n                context.setTransaction(originalTx);\n            }\n        } else {\n            if (sync != null && transaction != null) {\n                transaction.removeSynchronization(sync);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"IGNORING duplicate message \" + message);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processMessage": "    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getProducerBrokerExchange": "    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.ActiveMQMessage.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessage(this);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        this.sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            this.sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.initialize": "    public void initialize() throws Exception {\n        super.initialize();\n        if (store != null) {\n            // AMQ-2586: Better to leave this stat at zero than to give the user\n            // misleading metrics.\n            // int messageCount = store.getMessageCount();\n            // destinationStatistics.getMessages().setCount(messageCount);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.DestinationInterceptor.intercept": "    Destination intercept(Destination destination);\n    \n    void remove(Destination destination);\n\n    void create(Broker broker, ConnectionContext context, ActiveMQDestination destination) throws Exception;\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.BrokerMBeanSupport.createProducerName": "    public static ObjectName createProducerName(String brokerObjectName, String connectionClientId, ProducerInfo producerInfo) throws MalformedObjectNameException {\n        String objectNameStr = brokerObjectName;\n\n        if (producerInfo.getDestination() == null) {\n            objectNameStr += \",endpoint=dynamicProducer\";\n        } else {\n            objectNameStr += createDestinationProperties(producerInfo.getDestination()) + \",endpoint=Producer\";\n        }\n\n        objectNameStr += \",clientId=\" + JMXSupport.encodeObjectNamePart(connectionClientId);\n        objectNameStr += \",producerId=\" + JMXSupport.encodeObjectNamePart(producerInfo.getProducerId().toString());\n\n        return new ObjectName(objectNameStr);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.BrokerMBeanSupport.createDestinationProperties": "    private static String createDestinationProperties(String type, String name){\n        return \",destinationType=\"+ JMXSupport.encodeObjectNamePart(type) +\n               \",destinationName=\" + JMXSupport.encodeObjectNamePart(name);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.canDispatch": "    public boolean canDispatch(Message messageSend) {\n        boolean canDispatch = true;\n        if (auditProducerSequenceIds && messageSend.isPersistent()) {\n            final long producerSequenceId = messageSend.getMessageId().getProducerSequenceId();\n            if (isNetworkProducer) {\n                //  messages are multiplexed on this producer so we need to query the persistenceAdapter\n                long lastStoredForMessageProducer = getStoredSequenceIdForMessage(messageSend.getMessageId());\n                if (producerSequenceId <= lastStoredForMessageProducer) {\n                    canDispatch = false;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"suppressing duplicate message send  [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] from network producer with producerSequenceId [\"\n                                + producerSequenceId + \"] less than last stored: \"  + lastStoredForMessageProducer);\n                    }\n                }\n            } else if (producerSequenceId <= lastSendSequenceNumber.get()) {\n                canDispatch = false;\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"suppressing duplicate message send [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] with producerSequenceId [\"\n                            + producerSequenceId + \"] less than last stored: \"  + lastSendSequenceNumber);\n                }\n            } else {\n                // track current so we can suppress duplicates later in the stream\n                lastSendSequenceNumber.set(producerSequenceId);\n            }\n        }\n        return canDispatch;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getStoredSequenceIdForMessage": "    private long getStoredSequenceIdForMessage(MessageId messageId) {\n        try {\n            return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());\n       } catch (IOException ignored) {\n            LOG.debug(\"Failed to determine last producer sequence id for: \" +messageId, ignored);\n        }\n        return -1;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "mKahaDB: PageFile is not loaded when recreating queue",
            "Description": "Using mKahaDB, we create a queue, delete it through the admin interface, and attempt to recreate it, receiving the error below on the client. \n\n2013-03-08 10:29:17,903 | WARN  | Async error occurred: java.lang.IllegalStateException: PageFile is not loaded | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: tcp:///0:0:0:0:0:0:0:1%0:65222@61613\njava.lang.IllegalStateException: PageFile is not loaded\n\tat org.apache.activemq.store.kahadb.disk.page.PageFile.assertLoaded(PageFile.java:809)\n\tat org.apache.activemq.store.kahadb.disk.page.PageFile.tx(PageFile.java:303)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.getMessageCount(KahaDBStore.java:478)\n\tat org.apache.activemq.store.ProxyMessageStore.getMessageCount(ProxyMessageStore.java:101)\n\tat org.apache.activemq.store.ProxyMessageStore.getMessageCount(ProxyMessageStore.java:101)\n\tat org.apache.activemq.broker.region.Queue.initialize(Queue.java:376)\n\tat org.apache.activemq.broker.region.DestinationFactoryImpl.createDestination(DestinationFactoryImpl.java:87)\n\tat org.apache.activemq.broker.region.AbstractRegion.createDestination(AbstractRegion.java:526)\n\tat org.apache.activemq.broker.jmx.ManagedQueueRegion.createDestination(ManagedQueueRegion.java:56)\n\tat org.apache.activemq.broker.region.AbstractRegion.addDestination(AbstractRegion.java:136)\n\tat org.apache.activemq.broker.region.RegionBroker.addDestination(RegionBroker.java:277)\n\tat org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)\n\tat org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)\n\tat org.apache.activemq.broker.MutableBrokerFilter.addDestination(MutableBrokerFilter.java:151)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:387)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:282)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:317)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:499)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:749)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:329)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:184)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:45)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:84)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:195)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:321)\n\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:233)\n\tat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:73)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:680)\n2013-03-08 10:29:17,905 | WARN  | Exception occurred processing: \nnull: java.lang.IllegalStateException: PageFile is not loaded | org.apache.activemq.transport.stomp.ProtocolConverter | ActiveMQ Connection Dispatcher: tcp://0:0:0:0:0:0:0:1%0:65222"
        }
    },
    {
        "filename": "AMQ-4221.json",
        "creation_time": "2012-12-13T16:15:04.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.kahadb.index.ListNode.access$200(ListNode.java:37)\n\tat org.apache.kahadb.index.ListNode$NodeMarshaller.writePayload(ListNode.java:265)\n\tat org.apache.kahadb.index.ListNode$NodeMarshaller.writePayload(ListNode.java:255)\n\tat org.apache.kahadb.page.Transaction.store(Transaction.java:248)\n\tat org.apache.kahadb.index.ListIndex.storeNode(ListIndex.java:326)\n\tat org.apache.kahadb.index.ListNode.store(ListNode.java:332)\n\tat org.apache.kahadb.index.ListNode.access$500(ListNode.java:37)\n\tat org.apache.kahadb.index.ListNode$ListIterator.remove(ListNode.java:227)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator$1.execute(PList.java:229)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:771)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator.remove(PList.java:226)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.remove(FilePendingMessageCursor.java:517)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.remove(FilePendingMessageCursor.java:321)\n\tat org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1735)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1948)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1465)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:680)",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.writePayload": "        public void writePayload(ListNode<Key, Value> node, DataOutput os) throws IOException {\n            os.writeLong(node.next);\n            short count = (short) node.entries.size(); // cast may truncate\n                                                       // value...\n            if (count != node.entries.size()) {\n                throw new IOException(\"short over flow, too many entries in list: \" + node.entries.size());\n            }\n\n            os.writeShort(count);\n            KeyValueEntry<Key, Value> entry = node.entries.getHead();\n            while (entry != null) {\n                keyMarshaller.writePayload((Key) entry.getKey(), os);\n                valueMarshaller.writePayload((Value) entry.getValue(), os);\n                entry = entry.getNext();\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getValue": "        public Value getValue() {\n            return value;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getNext": "    public long getNext() {\n        return next;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getKey": "        public Key getKey() {\n            return key;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListIndex.storeNode": "    public void storeNode(Transaction tx, ListNode<Key,Value> node, boolean overflow) throws IOException {\n        tx.store(node.getPage(), marshaller, overflow);\n        flushCache();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListIndex.flushCache": "    private void flushCache() {\n        this.lastGetEntryCache = null;\n        this.lastGetNodeCache = null;\n        this.lastCacheTxSrc.clear();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.store": "    private void store(Transaction tx) throws IOException {\n        getContainingList().storeNode(tx, this, true);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.size": "    public int size(Transaction tx) {\n        return entries.size();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getContainingList": "    public ListIndex<Key, Value> getContainingList() {\n        return containingList;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.split": "    private void split(Transaction tx, boolean isAddFirst) throws IOException {\n        ListNode<Key, Value> extension = getContainingList().createNode(tx);\n        if (isAddFirst) {\n            // head keeps the first entry, insert extension with the rest\n            extension.setEntries(entries.getHead().splitAfter());\n            extension.setNext(this.getNext());\n            extension.store(tx, isAddFirst);\n            this.setNext(extension.getPageId());\n        } else {\n            extension.setEntries(entries.getTail().getPrevious().splitAfter());\n            extension.setNext(this.getNext());\n            extension.store(tx, isAddFirst);\n            getContainingList().setTailPageId(extension.getPageId());\n            this.setNext(extension.getPageId());\n        }\n        store(tx, true);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getPageId": "    public long getPageId() {\n        return page.getPageId();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.remove": "        public void remove() {\n            if (entryToRemove == null) {\n                throw new IllegalStateException(\"can only remove once, call hasNext();next() again\");\n            }\n            try {\n                entryToRemove.unlink();\n                entryToRemove = null;\n                ListNode<Key, Value> toRemoveNode = null;\n                if (currentNode.entries.isEmpty()) {\n                    // may need to free this node\n                    if (currentNode.isHead() && currentNode.isTail()) {\n                        // store empty list\n                    } else if (currentNode.isHead()) {\n                        // merge next node into existing headNode as we don't want to\n                        // change our headPageId b/c that is our identity\n                        ListNode<Key, Value> headNode = currentNode;\n                        nextEntry = getFromNextNode(); // will move currentNode\n\n                        if (currentNode.isTail()) {\n                            targetList.setTailPageId(headNode.getPageId());\n                        }\n                        // copy next/currentNode into head\n                        headNode.setEntries(currentNode.entries);\n                        headNode.setNext(currentNode.getNext());\n                        headNode.store(tx);\n                        toRemoveNode = currentNode;\n                        currentNode = headNode;\n\n                    } else if (currentNode.isTail()) {\n                        toRemoveNode = currentNode;\n                        previousNode.setNext(ListIndex.NOT_SET);\n                        previousNode.store(tx);\n                        targetList.setTailPageId(previousNode.getPageId());\n                    } else {\n                        toRemoveNode = currentNode;\n                        previousNode.setNext(toRemoveNode.getNext());\n                        previousNode.store(tx);\n                    }\n                }\n                targetList.onRemove();\n\n                if (toRemoveNode != null) {\n                    tx.free(toRemoveNode.getPage());\n                } else {\n                    currentNode.store(tx);\n                }\n            } catch (IOException unexpected) {\n                IllegalStateException e = new IllegalStateException(unexpected.getLocalizedMessage());\n                e.initCause(unexpected);\n                throw e;\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.setEntries": "    private void setEntries(LinkedNodeList<KeyValueEntry<Key, Value>> list) {\n        this.entries = list;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.setNext": "    public void setNext(long next) {\n        this.next = next;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getPage": "    public Page<ListNode<Key, Value>> getPage() {\n        return page;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.getFromNextNode": "        private KeyValueEntry<Key, Value> getFromNextNode() {\n            KeyValueEntry<Key, Value> result = null;\n            if (currentNode.getNext() != ListIndex.NOT_SET) {\n                try {\n                    previousNode = currentNode;\n                    currentNode = targetList.loadNode(tx, currentNode.getNext());\n                } catch (IOException unexpected) {\n                    NoSuchElementException e = new NoSuchElementException(unexpected.getLocalizedMessage());\n                    e.initCause(unexpected);\n                    throw e;\n                }\n                result = currentNode.entries.getHead();\n            }\n            return result;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.isTail": "    public boolean isTail() {\n        return getPageId() == containingList.getTailPageId();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.ListNode.isHead": "    public boolean isHead() {\n        return getPageId() == containingList.getHeadPageId();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.PList.remove": "    boolean remove(Object position) throws IOException;\n\n    boolean isEmpty();\n    PListIterator iterator() throws IOException;\n    long size();\n\n    public interface PListIterator extends Iterator<PListEntry> {\n        void release();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.remove": "        public void remove() {\n            iterator.remove();\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.isDiskListEmpty": "    protected boolean isDiskListEmpty() {\n        return diskList == null || diskList.isEmpty();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList": "    public PList getDiskList() {\n        if (diskList == null) {\n            try {\n                diskList = store.getPList(name);\n            } catch (Exception e) {\n                LOG.error(\"Caught an IO Exception getting the DiskList \" + name, e);\n                throw new RuntimeException(e);\n            }\n        }\n        return diskList;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doPageInForDispatch": "    private PendingList doPageInForDispatch(boolean force) throws Exception {\n        List<QueueMessageReference> result = null;\n        PendingList resultList = null;\n\n        int toPageIn = Math.min(getMaxPageSize(), messages.size());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(destination.getPhysicalName() + \" toPageIn: \" + toPageIn + \", Inflight: \"\n                    + destinationStatistics.getInflight().getCount() + \", pagedInMessages.size \"\n                    + pagedInMessages.size() + \", enqueueCount: \" + destinationStatistics.getEnqueues().getCount()\n                    + \", dequeueCount: \" + destinationStatistics.getDequeues().getCount());\n        }\n\n        if (isLazyDispatch() && !force) {\n            // Only page in the minimum number of messages which can be\n            // dispatched immediately.\n            toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);\n        }\n        int pagedInPendingSize = 0;\n        pagedInPendingDispatchLock.readLock().lock();\n        try {\n            pagedInPendingSize = pagedInPendingDispatch.size();\n        } finally {\n            pagedInPendingDispatchLock.readLock().unlock();\n        }\n        if (toPageIn > 0 && (force || (!consumers.isEmpty() && pagedInPendingSize < getMaxPageSize()))) {\n            int count = 0;\n            result = new ArrayList<QueueMessageReference>(toPageIn);\n            messagesLock.writeLock().lock();\n            try {\n                try {\n                    messages.setMaxBatchSize(toPageIn);\n                    messages.reset();\n                    while (messages.hasNext() && count < toPageIn) {\n                        MessageReference node = messages.next();\n                        messages.remove();\n\n                        QueueMessageReference ref = createMessageReference(node.getMessage());\n                        if (ref.isExpired()) {\n                            if (broker.isExpired(ref)) {\n                                messageExpired(createConnectionContext(), ref);\n                            } else {\n                                ref.decrementReferenceCount();\n                            }\n                        } else {\n                            result.add(ref);\n                            count++;\n                        }\n                    }\n                } finally {\n                    messages.release();\n                }\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n            // Only add new messages, not already pagedIn to avoid multiple\n            // dispatch attempts\n            pagedInMessagesLock.writeLock().lock();\n            try {\n                if(isPrioritizedMessages()) {\n                    resultList = new PrioritizedPendingList();\n                } else {\n                    resultList = new OrderedPendingList();\n                }\n                for (QueueMessageReference ref : result) {\n                    if (!pagedInMessages.containsKey(ref.getMessageId())) {\n                        pagedInMessages.put(ref.getMessageId(), ref);\n                        resultList.addMessageLast(ref);\n                    } else {\n                        ref.decrementReferenceCount();\n                    }\n                }\n            } finally {\n                pagedInMessagesLock.writeLock().unlock();\n            }\n        } else {\n            // Avoid return null list, if condition is not validated\n            resultList = new OrderedPendingList();\n        }\n\n        return resultList;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.createMessageReference": "    private QueueMessageReference createMessageReference(Message message) {\n        QueueMessageReference result = new IndirectMessageReference(message);\n        return result;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getMessage": "    public QueueMessageReference getMessage(String id) {\n        MessageId msgId = new MessageId(id);\n        pagedInMessagesLock.readLock().lock();\n        try{\n            QueueMessageReference ref = this.pagedInMessages.get(msgId);\n            if (ref != null) {\n                return ref;\n            }\n        }finally {\n            pagedInMessagesLock.readLock().unlock();\n        }\n        messagesLock.readLock().lock();\n        try{\n            try {\n                messages.reset();\n                while (messages.hasNext()) {\n                    MessageReference mr = messages.next();\n                    QueueMessageReference qmr = createMessageReference(mr.getMessage());\n                    qmr.decrementReferenceCount();\n                    messages.rollback(qmr.getMessageId());\n                    if (msgId.equals(qmr.getMessageId())) {\n                        return qmr;\n                    }\n                }\n            } finally {\n                messages.release();\n            }\n        }finally {\n            messagesLock.readLock().unlock();\n        }\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getConsumerMessageCountBeforeFull": "    private int getConsumerMessageCountBeforeFull() throws Exception {\n        int total = 0;\n        boolean zeroPrefetch = false;\n        consumersLock.readLock().lock();\n        try{\n            for (Subscription s : consumers) {\n                zeroPrefetch |= s.getPrefetchSize() == 0;\n                int countBeforeFull = s.countBeforeFull();\n                total += countBeforeFull;\n            }\n        }finally {\n            consumersLock.readLock().unlock();\n        }\n        if (total == 0 && zeroPrefetch) {\n            total = 1;\n        }\n        return total;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.reset": "        public void reset() {\n            currentBatchCount = recoveredAccumulator;\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message expired: \" + reference);\n        }\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.pageInMessages": "    protected void pageInMessages(boolean force) throws Exception {\n        doDispatch(doPageInForDispatch(force));\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doDispatch": "    private void doDispatch(PendingList list) throws Exception {\n        boolean doWakeUp = false;\n\n        pagedInPendingDispatchLock.writeLock().lock();\n        try {\n            if (!redeliveredWaitingDispatch.isEmpty()) {\n                // Try first to dispatch redelivered messages to keep an\n                // proper order\n                redeliveredWaitingDispatch = doActualDispatch(redeliveredWaitingDispatch);\n            }\n            if (!pagedInPendingDispatch.isEmpty()) {\n                // Next dispatch anything that had not been\n                // dispatched before.\n                pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);\n            }\n            // and now see if we can dispatch the new stuff.. and append to\n            // the pending\n            // list anything that does not actually get dispatched.\n            if (list != null && !list.isEmpty()) {\n                if (pagedInPendingDispatch.isEmpty()) {\n                    pagedInPendingDispatch.addAll(doActualDispatch(list));\n                } else {\n                    for (MessageReference qmr : list) {\n                        if (!pagedInPendingDispatch.contains(qmr)) {\n                            pagedInPendingDispatch.addMessageLast(qmr);\n                        }\n                    }\n                    doWakeUp = true;\n                }\n            }\n        } finally {\n            pagedInPendingDispatchLock.writeLock().unlock();\n        }\n\n        if (doWakeUp) {\n            // avoid lock order contention\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.iterate": "    public boolean iterate() {\n        MDC.put(\"activemq.destination\", getName());\n        boolean pageInMoreMessages = false;\n        synchronized (iteratingMutex) {\n\n            // If optimize dispatch is on or this is a slave this method could be called recursively\n            // we set this state value to short-circuit wakeup in those cases to avoid that as it\n            // could lead to errors.\n            iterationRunning = true;\n\n            // do early to allow dispatch of these waiting messages\n            synchronized (messagesWaitingForSpace) {\n                Iterator<Runnable> it = messagesWaitingForSpace.values().iterator();\n                while (it.hasNext()) {\n                    if (!memoryUsage.isFull()) {\n                        Runnable op = it.next();\n                        it.remove();\n                        op.run();\n                    } else {\n                        registerCallbackForNotFullNotification();\n                        break;\n                    }\n                }\n            }\n\n            if (firstConsumer) {\n                firstConsumer = false;\n                try {\n                    if (consumersBeforeDispatchStarts > 0) {\n                        int timeout = 1000; // wait one second by default if\n                                            // consumer count isn't reached\n                        if (timeBeforeDispatchStarts > 0) {\n                            timeout = timeBeforeDispatchStarts;\n                        }\n                        if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(consumers.size() + \" consumers subscribed. Starting dispatch.\");\n                            }\n                        } else {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(timeout + \" ms elapsed and \" + consumers.size()\n                                        + \" consumers subscribed. Starting dispatch.\");\n                            }\n                        }\n                    }\n                    if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {\n                        iteratingMutex.wait(timeBeforeDispatchStarts);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(timeBeforeDispatchStarts + \" ms elapsed. Starting dispatch.\");\n                        }\n                    }\n                } catch (Exception e) {\n                    LOG.error(e.toString());\n                }\n            }\n\n\n            messagesLock.readLock().lock();\n            try{\n                pageInMoreMessages |= !messages.isEmpty();\n            } finally {\n                messagesLock.readLock().unlock();\n            }\n\n            pagedInPendingDispatchLock.readLock().lock();\n            try {\n                pageInMoreMessages |= !pagedInPendingDispatch.isEmpty();\n            } finally {\n                pagedInPendingDispatchLock.readLock().unlock();\n            }\n\n            // Perhaps we should page always into the pagedInPendingDispatch\n            // list if\n            // !messages.isEmpty(), and then if\n            // !pagedInPendingDispatch.isEmpty()\n            // then we do a dispatch.\n            boolean hasBrowsers = browserDispatches.size() > 0;\n\n            if (pageInMoreMessages || hasBrowsers || !redeliveredWaitingDispatch.isEmpty()) {\n                try {\n                    pageInMessages(hasBrowsers);\n\n                } catch (Throwable e) {\n                    LOG.error(\"Failed to page in more queue messages \", e);\n                }\n            }\n\n            if (hasBrowsers) {\n                ArrayList<QueueMessageReference> alreadyDispatchedMessages = null;\n                pagedInMessagesLock.readLock().lock();\n                try{\n                    alreadyDispatchedMessages = new ArrayList<QueueMessageReference>(pagedInMessages.values());\n                }finally {\n                    pagedInMessagesLock.readLock().unlock();\n                }\n\n                Iterator<BrowserDispatch> browsers = browserDispatches.iterator();\n                while (browsers.hasNext()) {\n                    BrowserDispatch browserDispatch = browsers.next();\n                    try {\n                        MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();\n                        msgContext.setDestination(destination);\n\n                        QueueBrowserSubscription browser = browserDispatch.getBrowser();\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"dispatch to browser: \" + browser\n                                    + \", already dispatched/paged count: \" + alreadyDispatchedMessages.size());\n                        }\n                        boolean added = false;\n                        for (QueueMessageReference node : alreadyDispatchedMessages) {\n                            if (!node.isAcked() && !browser.getPending().getMessageAudit().isDuplicate(node.getMessageId())) {\n                                msgContext.setMessageReference(node);\n                                if (browser.matches(node, msgContext)) {\n                                    browser.add(node);\n                                    added = true;\n                                }\n                            }\n                        }\n                        // are we done browsing? no new messages paged\n                        if (!added) {\n                            browser.decrementQueueRef();\n                            browserDispatches.remove(browserDispatch);\n                        }\n                    } catch (Exception e) {\n                        LOG.warn(\"exception on dispatch to browser: \" + browserDispatch.getBrowser(), e);\n                    }\n                }\n            }\n\n            if (pendingWakeups.get() > 0) {\n                pendingWakeups.decrementAndGet();\n            }\n            MDC.remove(\"activemq.destination\");\n            iterationRunning = false;\n\n            return pendingWakeups.get() > 0;\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getBrowser": "        public QueueBrowserSubscription getBrowser() {\n            return browser;\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.toString": "            public String toString() {\n                return \"MessageIdFilter: \" + messageId;\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.isDuplicate": "        public boolean isDuplicate(MessageId id) {\n            return false;\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.run": "                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message, null);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of :\" + message, e);\n                                    }\n                                }\n                            }",
            "activemq-client.src.main.java.org.apache.activemq.thread.PooledTaskRunner.runTask": "    final void runTask() {\n\n        synchronized (runable) {\n            queued = false;\n            if (shutdown) {\n                iterating = false;\n                runable.notifyAll();\n                return;\n            }\n            iterating = true;\n        }\n\n        // Don't synchronize while we are iterating so that\n        // multiple wakeup() calls can be executed concurrently.\n        boolean done = false;\n        try {\n            for (int i = 0; i < maxIterationsPerRun; i++) {\n                LOG.trace(\"Running task iteration {} - {}\", i, task);\n                if (!task.iterate()) {\n                    done = true;\n                    break;\n                }\n            }\n        } finally {\n            synchronized( runable ) {\n                iterating = false;\n                runable.notifyAll();\n                if (shutdown) {\n                    queued = false;\n                    runable.notifyAll();\n                    return;\n                }\n\n                // If we could not iterate all the items\n                // then we need to re-queue.\n                if (!done) {\n                    queued = true;\n                }\n\n                if (queued) {\n                    executor.execute(runable);\n                }\n\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.thread.PooledTaskRunner.run": "            public void run() {\n                runningThread = Thread.currentThread();\n                try {\n                    runTask();\n                } finally {\n                    LOG.trace(\"Run task done: {}\", task);\n                    runningThread = null;\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getEnqueues": "    public CountStatisticImpl getEnqueues() {\n        return enqueues;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getInflight": "    public CountStatisticImpl getInflight() {\n        return inflight;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getDequeues": "    public CountStatisticImpl getDequeues() {\n        return dequeues;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueBrowserSubscription.matches": "    public boolean matches(MessageReference node, MessageEvaluationContext context) throws IOException {\n        return !browseDone && super.matches(node, context);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueBrowserSubscription.decrementQueueRef": "    synchronized public void decrementQueueRef() throws Exception {\n        if (queueRefs > 0) {\n            queueRefs--;\n        }\n        checkDone();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueBrowserSubscription.checkDone": "    private void checkDone() throws Exception {\n        if( !browseDone && queueRefs == 0 && destinationsAdded) {\n            browseDone=true;\n            add(QueueMessageReference.NULL_MESSAGE);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessageId": "    MessageId getMessageId();\n    Message getMessageHardRef();\n    Message getMessage();\n    boolean isPersistent();\n    \n    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.thread.task.iterate": "    boolean iterate();\n}"
        },
        "bug_report": {
            "Title": "NPE plist (temp) sparse removal - filependingmessagecursor with selector and expiry",
            "Description": "{code}2012-12-13 11:37:27,027 [calhost] Task-1] - ERROR Queue                          - Failed to page in more queue messages \njava.lang.NullPointerException\n\tat org.apache.kahadb.index.ListNode.access$200(ListNode.java:37)\n\tat org.apache.kahadb.index.ListNode$NodeMarshaller.writePayload(ListNode.java:265)\n\tat org.apache.kahadb.index.ListNode$NodeMarshaller.writePayload(ListNode.java:255)\n\tat org.apache.kahadb.page.Transaction.store(Transaction.java:248)\n\tat org.apache.kahadb.index.ListIndex.storeNode(ListIndex.java:326)\n\tat org.apache.kahadb.index.ListNode.store(ListNode.java:332)\n\tat org.apache.kahadb.index.ListNode.access$500(ListNode.java:37)\n\tat org.apache.kahadb.index.ListNode$ListIterator.remove(ListNode.java:227)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator$1.execute(PList.java:229)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:771)\n\tat org.apache.activemq.store.kahadb.plist.PList$PListIterator.remove(PList.java:226)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.remove(FilePendingMessageCursor.java:517)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.remove(FilePendingMessageCursor.java:321)\n\tat org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1735)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1948)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1465)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:680)\n{code}"
        }
    },
    {
        "filename": "AMQ-3622.json",
        "creation_time": "2011-12-06T15:16:49.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy.browse(LastImageSubscriptionRecoveryPolicy.java:63)\n\tat org.apache.activemq.broker.region.Topic.browse(Topic.java:564)\n\tat org.apache.activemq.broker.region.Topic$6.run(Topic.java:659)\n\tat org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)\n\tat java.util.TimerThread.mainLoop(Timer.java:512)\n\tat java.util.TimerThread.run(Timer.java:462)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy.browse": "    public Message[] browse(ActiveMQDestination destination) throws Exception {\n        List<Message> result = new ArrayList<Message>();\n        DestinationFilter filter = DestinationFilter.parseFilter(destination);\n        if (filter.matches(lastImage.getMessage().getDestination())) {\n            result.add(lastImage.getMessage());\n        }\n        return result.toArray(new Message[result.size()]);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy.add": "    public boolean add(ConnectionContext context, MessageReference node) throws Exception {\n        lastImage = node;\n        return true;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.browse": "    public Message[] browse() {\n        final List<Message> result = new ArrayList<Message>();\n        doBrowse(result, getMaxBrowsePageSize());\n        return result.toArray(new Message[result.size()]);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.doBrowse": "    private void doBrowse(final List<Message> browseList, final int max) {\n        try {\n            if (topicStore != null) {\n                final List<Message> toExpire = new ArrayList<Message>();\n                topicStore.recover(new MessageRecoveryListener() {\n                    public boolean recoverMessage(Message message) throws Exception {\n                        if (message.isExpired()) {\n                            toExpire.add(message);\n                        }\n                        browseList.add(message);\n                        return true;\n                    }\n\n                    public boolean recoverMessageReference(MessageId messageReference) throws Exception {\n                        return true;\n                    }\n\n                    public boolean hasSpace() {\n                        return browseList.size() < max;\n                    }\n\n                    public boolean isDuplicate(MessageId id) {\n                        return false;\n                    }\n                });\n                final ConnectionContext connectionContext = createConnectionContext();\n                for (Message message : toExpire) {\n                    for (DurableTopicSubscription sub : durableSubcribers.values()) {\n                        if (!sub.isActive()) {\n                            messageExpired(connectionContext, sub, message);\n                        }\n                    }\n                }\n                Message[] msgs = subscriptionRecoveryPolicy.browse(getActiveMQDestination());\n                if (msgs != null) {\n                    for (int i = 0; i < msgs.length && browseList.size() < max; i++) {\n                        browseList.add(msgs[i]);\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            LOG.warn(\"Failed to browse Topic: \" + getActiveMQDestination().getPhysicalName(), e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.run": "        public void run() {\n            List<Message> browsedMessages = new InsertionCountList<Message>();\n            doBrowse(browsedMessages, getMaxExpirePageSize());\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.doMessageSend": "    synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message)\n            throws IOException, Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        message.setRegionDestination(this);\n        message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n        Future<Object> result = null;\n\n        if (topicStore != null && message.isPersistent() && !canOptimizeOutPersistence()) {\n            if (systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {\n                final String logMessage = \"Persistent store is Full, \" + getStoreUsageHighWaterMark() + \"% of \"\n                        + systemUsage.getStoreUsage().getLimit() + \". Stopping producer (\" + message.getProducerId()\n                        + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                        + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new javax.jms.ResourceAllocationException(logMessage);\n                }\n\n                waitForSpace(context, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);\n            }\n            result = topicStore.asyncAddTopicMessage(context, message);\n        }\n\n        message.incrementReferenceCount();\n\n        if (context.isInTransaction()) {\n            context.getTransaction().addSynchronization(new Synchronization() {\n                @Override\n                public void afterCommit() throws Exception {\n                    // It could take while before we receive the commit\n                    // operation.. by that time the message could have\n                    // expired..\n                    if (broker.isExpired(message)) {\n                        getDestinationStatistics().getExpired().increment();\n                        broker.messageExpired(context, message, null);\n                        message.decrementReferenceCount();\n                        return;\n                    }\n                    try {\n                        dispatch(context, message);\n                    } finally {\n                        message.decrementReferenceCount();\n                    }\n                }\n            });\n\n        } else {\n            try {\n                dispatch(context, message);\n            } finally {\n                message.decrementReferenceCount();\n            }\n        }\n        if (result != null && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        broker.messageExpired(context, reference, subs);\n        // AMQ-2586: Better to leave this stat at zero than to give the user\n        // misleading metrics.\n        // destinationStatistics.getMessages().decrement();\n        destinationStatistics.getEnqueues().decrement();\n        destinationStatistics.getExpired().increment();\n        MessageAck ack = new MessageAck();\n        ack.setAckType(MessageAck.STANDARD_ACK_TYPE);\n        ack.setDestination(destination);\n        ack.setMessageID(reference.getMessageId());\n        try {\n            if (subs instanceof DurableTopicSubscription) {\n                ((DurableTopicSubscription)subs).removePending(reference);\n            }\n            acknowledge(context, subs, ack, reference);\n        } catch (Exception e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.wakeup": "    public final void wakeup() {\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.SchedulerTimerTask.run": "    public void run() {\n        this.task.run();                         \n    }"
        },
        "bug_report": {
            "Title": "NPE in LastImageSubscriptionRecoveryPolicy",
            "Description": "Start up a subscriber when no messages are available and this NPE will eventually get logged:\n\n2011-12-02 15:01:00,588 | WARN  | Failed to browse Topic: xxx | org.apache.activemq.broker.region.Topic | ActiveMQ Broker[xxx] Scheduler\njava.lang.NullPointerException\n\tat org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy.browse(LastImageSubscriptionRecoveryPolicy.java:63)\n\tat org.apache.activemq.broker.region.Topic.browse(Topic.java:564)\n\tat org.apache.activemq.broker.region.Topic$6.run(Topic.java:659)\n\tat org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)\n\tat java.util.TimerThread.mainLoop(Timer.java:512)\n\tat java.util.TimerThread.run(Timer.java:462)\n\nrepeatedly every 30 seconds or so until a message is sent to the topic."
        }
    },
    {
        "filename": "AMQ-6016.json",
        "creation_time": "2015-10-21T12:55:55.000+0000",
        "stack_trace": "java.lang.IllegalArgumentException: Comparison method violates its general contract!\n\tat java.util.TimSort.mergeHi(TimSort.java:868)[:1.7.0_65]\n\tat java.util.TimSort.mergeAt(TimSort.java:485)[:1.7.0_65]\n\tat java.util.TimSort.mergeCollapse(TimSort.java:410)[:1.7.0_65]\n\tat java.util.TimSort.sort(TimSort.java:214)[:1.7.0_65]\n\tat java.util.TimSort.sort(TimSort.java:173)[:1.7.0_65]\n\tat java.util.Arrays.sort(Arrays.java:659)[:1.7.0_65]\n\tat java.util.Collections.sort(Collections.java:217)[:1.7.0_65]\n\tat org.apache.activemq.broker.region.Queue.addToConsumerList(Queue.java:2131)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:2067)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1972)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.Queue.removeSubscription(Queue.java:587)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.DestinationFilter.removeSubscription(DestinationFilter.java:127)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat ......\n\tat java.lang.Thread.run(Thread.java:745)",
        "source_code": {
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.addToConsumerList": "    private void addToConsumerList(Subscription sub) {\n        if (useConsumerPriority) {\n            consumers.add(sub);\n            Collections.sort(consumers, orderedCompare);\n        } else {\n            consumers.add(sub);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doActualDispatch": "    private PendingList doActualDispatch(PendingList list) throws Exception {\n        List<Subscription> consumers;\n        consumersLock.readLock().lock();\n\n        try {\n            if (this.consumers.isEmpty()) {\n                // slave dispatch happens in processDispatchNotification\n                return list;\n            }\n            consumers = new ArrayList<Subscription>(this.consumers);\n        } finally {\n            consumersLock.readLock().unlock();\n        }\n\n        Set<Subscription> fullConsumers = new HashSet<Subscription>(this.consumers.size());\n\n        for (Iterator<MessageReference> iterator = list.iterator(); iterator.hasNext();) {\n\n            MessageReference node = iterator.next();\n            Subscription target = null;\n            for (Subscription s : consumers) {\n                if (s instanceof QueueBrowserSubscription) {\n                    continue;\n                }\n                if (!fullConsumers.contains(s)) {\n                    if (!s.isFull()) {\n                        if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {\n                            // Dispatch it.\n                            s.add(node);\n                            LOG.trace(\"assigned {} to consumer {}\", node.getMessageId(), s.getConsumerInfo().getConsumerId());\n                            iterator.remove();\n                            target = s;\n                            break;\n                        }\n                    } else {\n                        // no further dispatch of list to a full consumer to\n                        // avoid out of order message receipt\n                        fullConsumers.add(s);\n                        LOG.trace(\"Subscription full {}\", s);\n                    }\n                }\n            }\n\n            if (target == null && node.isDropped()) {\n                iterator.remove();\n            }\n\n            // return if there are no consumers or all consumers are full\n            if (target == null && consumers.size() == fullConsumers.size()) {\n                return list;\n            }\n\n            // If it got dispatched, rotate the consumer list to get round robin\n            // distribution.\n            if (target != null && !strictOrderDispatch && consumers.size() > 1\n                    && !dispatchSelector.isExclusiveConsumer(target)) {\n                consumersLock.writeLock().lock();\n                try {\n                    if (removeFromConsumerList(target)) {\n                        addToConsumerList(target);\n                        consumers = new ArrayList<Subscription>(this.consumers);\n                    }\n                } finally {\n                    consumersLock.writeLock().unlock();\n                }\n            }\n        }\n\n        return list;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeFromConsumerList": "    private boolean removeFromConsumerList(Subscription sub) {\n        return consumers.remove(sub);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.assignMessageGroup": "    protected boolean assignMessageGroup(Subscription subscription, QueueMessageReference node) throws Exception {\n        boolean result = true;\n        // Keep message groups together.\n        String groupId = node.getGroupID();\n        int sequence = node.getGroupSequence();\n        if (groupId != null) {\n\n            MessageGroupMap messageGroupOwners = getMessageGroupOwners();\n            // If we can own the first, then no-one else should own the\n            // rest.\n            if (sequence == 1) {\n                assignGroup(subscription, messageGroupOwners, node, groupId);\n            } else {\n\n                // Make sure that the previous owner is still valid, we may\n                // need to become the new owner.\n                ConsumerId groupOwner;\n\n                groupOwner = messageGroupOwners.get(groupId);\n                if (groupOwner == null) {\n                    assignGroup(subscription, messageGroupOwners, node, groupId);\n                } else {\n                    if (groupOwner.equals(subscription.getConsumerInfo().getConsumerId())) {\n                        // A group sequence < 1 is an end of group signal.\n                        if (sequence < 0) {\n                            messageGroupOwners.removeGroup(groupId);\n                            subscription.getConsumerInfo().decrementAssignedGroupCount();\n                        }\n                    } else {\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doDispatch": "    private void doDispatch(PendingList list) throws Exception {\n        boolean doWakeUp = false;\n\n        pagedInPendingDispatchLock.writeLock().lock();\n        try {\n            doActualDispatch(dispatchPendingList);\n            // and now see if we can dispatch the new stuff.. and append to the pending\n            // list anything that does not actually get dispatched.\n            if (list != null && !list.isEmpty()) {\n                if (dispatchPendingList.isEmpty()) {\n                    dispatchPendingList.addAll(doActualDispatch(list));\n                } else {\n                    for (MessageReference qmr : list) {\n                        if (!dispatchPendingList.contains(qmr)) {\n                            dispatchPendingList.addMessageLast(qmr);\n                        }\n                    }\n                    doWakeUp = true;\n                }\n            }\n        } finally {\n            pagedInPendingDispatchLock.writeLock().unlock();\n        }\n\n        if (doWakeUp) {\n            // avoid lock order contention\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.asyncWakeup": "    private void asyncWakeup() {\n        try {\n            pendingWakeups.incrementAndGet();\n            this.taskRunner.wakeup();\n        } catch (InterruptedException e) {\n            LOG.warn(\"Async task runner failed to wakeup \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.addAll": "    private void addAll(Collection<? extends MessageReference> refs, List<Message> l, int max,\n            List<MessageReference> toExpire) throws Exception {\n        for (Iterator<? extends MessageReference> i = refs.iterator(); i.hasNext() && l.size() < max;) {\n            QueueMessageReference ref = (QueueMessageReference) i.next();\n            if (ref.isExpired() && (ref.getLockOwner() == null)) {\n                toExpire.add(ref);\n            } else if (l.contains(ref.getMessage()) == false) {\n                l.add(ref.getMessage());\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeSubscription": "    public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId)\n            throws Exception {\n        super.removeSubscription(context, sub, lastDeliveredSequenceId);\n        // synchronize with dispatch method so that no new messages are sent\n        // while removing up a subscription.\n        pagedInPendingDispatchLock.writeLock().lock();\n        try {\n            LOG.debug(\"{} remove sub: {}, lastDeliveredSeqId: {}, dequeues: {}, dispatched: {}, inflight: {}, groups: {}\", new Object[]{\n                    getActiveMQDestination().getQualifiedName(),\n                    sub,\n                    lastDeliveredSequenceId,\n                    getDestinationStatistics().getDequeues().getCount(),\n                    getDestinationStatistics().getDispatched().getCount(),\n                    getDestinationStatistics().getInflight().getCount(),\n                    sub.getConsumerInfo().getAssignedGroupCount()\n            });\n            consumersLock.writeLock().lock();\n            try {\n                removeFromConsumerList(sub);\n                if (sub.getConsumerInfo().isExclusive()) {\n                    Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();\n                    if (exclusiveConsumer == sub) {\n                        exclusiveConsumer = null;\n                        for (Subscription s : consumers) {\n                            if (s.getConsumerInfo().isExclusive()\n                                    && (exclusiveConsumer == null || s.getConsumerInfo().getPriority() > exclusiveConsumer\n                                            .getConsumerInfo().getPriority())) {\n                                exclusiveConsumer = s;\n\n                            }\n                        }\n                        dispatchSelector.setExclusiveConsumer(exclusiveConsumer);\n                    }\n                } else if (isAllConsumersExclusiveByDefault()) {\n                    Subscription exclusiveConsumer = null;\n                    for (Subscription s : consumers) {\n                        if (exclusiveConsumer == null\n                                || s.getConsumerInfo().getPriority() > exclusiveConsumer\n                                .getConsumerInfo().getPriority()) {\n                            exclusiveConsumer = s;\n                                }\n                    }\n                    dispatchSelector.setExclusiveConsumer(exclusiveConsumer);\n                }\n                ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();\n                getMessageGroupOwners().removeConsumer(consumerId);\n\n                // redeliver inflight messages\n\n                boolean markAsRedelivered = false;\n                MessageReference lastDeliveredRef = null;\n                List<MessageReference> unAckedMessages = sub.remove(context, this);\n\n                // locate last redelivered in unconsumed list (list in delivery rather than seq order)\n                if (lastDeliveredSequenceId > RemoveInfo.LAST_DELIVERED_UNSET) {\n                    for (MessageReference ref : unAckedMessages) {\n                        if (ref.getMessageId().getBrokerSequenceId() == lastDeliveredSequenceId) {\n                            lastDeliveredRef = ref;\n                            markAsRedelivered = true;\n                            LOG.debug(\"found lastDeliveredSeqID: {}, message reference: {}\", lastDeliveredSequenceId, ref.getMessageId());\n                            break;\n                        }\n                    }\n                }\n\n                for (MessageReference ref : unAckedMessages) {\n                    // AMQ-5107: don't resend if the broker is shutting down\n                    if ( this.brokerService.isStopping() ) {\n                        break;\n                    }\n                    QueueMessageReference qmr = (QueueMessageReference) ref;\n                    if (qmr.getLockOwner() == sub) {\n                        qmr.unlock();\n\n                        // have no delivery information\n                        if (lastDeliveredSequenceId == RemoveInfo.LAST_DELIVERED_UNKNOWN) {\n                            qmr.incrementRedeliveryCounter();\n                        } else {\n                            if (markAsRedelivered) {\n                                qmr.incrementRedeliveryCounter();\n                            }\n                            if (ref == lastDeliveredRef) {\n                                // all that follow were not redelivered\n                                markAsRedelivered = false;\n                            }\n                        }\n                    }\n                    if (!qmr.isDropped()) {\n                        dispatchPendingList.addMessageForRedelivery(qmr);\n                    }\n                }\n                if (sub instanceof QueueBrowserSubscription) {\n                    ((QueueBrowserSubscription)sub).decrementQueueRef();\n                    browserDispatches.remove(sub);\n                }\n                // AMQ-5107: don't resend if the broker is shutting down\n                if (dispatchPendingList.hasRedeliveries() && (! this.brokerService.isStopping())) {\n                    doDispatch(new OrderedPendingList());\n                }\n            } finally {\n                consumersLock.writeLock().unlock();\n            }\n            if (!this.optimizedDispatch) {\n                wakeup();\n            }\n        } finally {\n            pagedInPendingDispatchLock.writeLock().unlock();\n        }\n        if (this.optimizedDispatch) {\n            // Outside of dispatchLock() to maintain the lock hierarchy of\n            // iteratingMutex -> dispatchLock. - see\n            // https://issues.apache.org/activemq/browse/AMQ-1878\n            wakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getMessageGroupOwners": "    public MessageGroupMap getMessageGroupOwners() {\n        if (messageGroupOwners == null) {\n            messageGroupOwners = getMessageGroupMapFactory().createMessageGroupMap();\n            messageGroupOwners.setDestination(this);\n        }\n        return messageGroupOwners;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getActiveMQDestination": "    public ActiveMQDestination getActiveMQDestination() {\n        return destination;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.wakeup": "    public void wakeup() {\n        if (optimizedDispatch && !iterationRunning) {\n            iterate();\n            pendingWakeups.incrementAndGet();\n        } else {\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.isAllConsumersExclusiveByDefault": "    public boolean isAllConsumersExclusiveByDefault() {\n        return allConsumersExclusiveByDefault;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.DestinationFilter.removeSubscription": "    public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception {\n        next.removeSubscription(context, sub, lastDeliveredSequenceId);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.isDropped": "    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessageId": "    MessageId getMessageId();\n    Message getMessageHardRef();\n    Message getMessage();\n    boolean isPersistent();\n    \n    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueMessageReference.unlock": "    boolean unlock();\n    \n    LockOwner getLockOwner();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueMessageReference.isDropped": "    boolean isDropped();\n        \n    boolean lock(LockOwner subscription);\n    \n    boolean unlock();\n    \n    LockOwner getLockOwner();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Subscription.remove": "    List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception;\n\n    /**\n     * The ConsumerInfo object that created the subscription.\n     */\n    ConsumerInfo getConsumerInfo();\n\n    /**\n     * The subscription should release as may references as it can to help the garbage collector\n     * reclaim memory.\n     */\n    void gc();\n\n    /**\n     * Used by a Slave Broker to update dispatch infomation\n     * @param mdn\n     * @throws Exception\n     */\n    void processMessageDispatchNotification(MessageDispatchNotification  mdn) throws Exception;\n\n    /**\n     * @return number of messages pending delivery\n     */\n    int getPendingQueueSize();\n\n    /**\n     * @return size of the messages pending delivery\n     */\n    long getPendingMessageSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    int getDispatchedQueueSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    long getDispatchedCounter();\n\n    /**\n     * @return number of messages that matched the subscription\n     */\n    long getEnqueueCounter();\n\n    /**\n     * @return number of messages queued by the client\n     */\n    long getDequeueCounter();\n\n    SubscriptionStatistics getSubscriptionStatistics();\n\n    /**\n     * @return the JMS selector on the current subscription\n     */\n    String getSelector();\n\n    /**\n     * Attempts to change the current active selector on the subscription.\n     * This operation is not supported for persistent topics.\n     */\n    void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException;\n\n    /**\n     * @return the JMX object name that this subscription was registered as if applicable\n     */\n    ObjectName getObjectName();\n\n    /**\n     * Set when the subscription is registered in JMX\n     */\n    void setObjectName(ObjectName objectName);\n\n    /**\n     * @return true when 60% or more room is left for dispatching messages\n     */\n    boolean isLowWaterMark();\n\n    /**\n     * @return true when 10% or less room is left for dispatching messages\n     */\n    boolean isHighWaterMark();\n\n    /**\n     * @return true if there is no space to dispatch messages\n     */\n    boolean isFull();\n\n    /**\n     * inform the MessageConsumer on the client to change it's prefetch\n     * @param newPrefetch\n     */\n    void updateConsumerPrefetch(int newPrefetch);\n\n    /**\n     * Called when the subscription is destroyed.\n     */\n    void destroy();\n\n    /**\n     * @return the prefetch size that is configured for the subscription\n     */\n    int getPrefetchSize();\n\n    /**\n     * @return the number of messages awaiting acknowledgement\n     */\n    int getInFlightSize();\n\n    /**\n     * @return the size in bytes of the messages awaiting acknowledgement\n     */\n    long getInFlightMessageSize();\n\n    /**\n     * @return the in flight messages as a percentage of the prefetch size\n     */\n    int getInFlightUsage();\n\n    /**\n     * Informs the Broker if the subscription needs to intervention to recover it's state\n     * e.g. DurableTopicSubscriber may do\n     * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor\n     * @return true if recovery required\n     */\n    boolean isRecoveryRequired();\n\n    /**\n     * @return true if a browser\n     */\n    boolean isBrowser();\n\n    /**\n     * @return the number of messages this subscription can accept before its full\n     */\n    int countBeforeFull();\n\n    ConnectionContext getContext();\n\n    public int getCursorMemoryHighWaterMark();\n\n    public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n\n    boolean isSlowConsumer();\n\n    void unmatched(MessageReference node) throws IOException;\n\n    /**\n     * Returns the time since the last Ack message was received by this subscription.\n     *\n     * If there has never been an ack this value should be set to the creation time of the\n     * subscription.\n     *\n     * @return time of last received Ack message or Subscription create time if no Acks.\n     */\n    long getTimeOfLastMessageAck();\n\n    long  getConsumedCount();\n\n    void incrementConsumedCount();\n\n    void resetConsumedCount();\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Subscription.getConsumerInfo": "    ConsumerInfo getConsumerInfo();\n\n    /**\n     * The subscription should release as may references as it can to help the garbage collector\n     * reclaim memory.\n     */\n    void gc();\n\n    /**\n     * Used by a Slave Broker to update dispatch infomation\n     * @param mdn\n     * @throws Exception\n     */\n    void processMessageDispatchNotification(MessageDispatchNotification  mdn) throws Exception;\n\n    /**\n     * @return number of messages pending delivery\n     */\n    int getPendingQueueSize();\n\n    /**\n     * @return size of the messages pending delivery\n     */\n    long getPendingMessageSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    int getDispatchedQueueSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    long getDispatchedCounter();\n\n    /**\n     * @return number of messages that matched the subscription\n     */\n    long getEnqueueCounter();\n\n    /**\n     * @return number of messages queued by the client\n     */\n    long getDequeueCounter();\n\n    SubscriptionStatistics getSubscriptionStatistics();\n\n    /**\n     * @return the JMS selector on the current subscription\n     */\n    String getSelector();\n\n    /**\n     * Attempts to change the current active selector on the subscription.\n     * This operation is not supported for persistent topics.\n     */\n    void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException;\n\n    /**\n     * @return the JMX object name that this subscription was registered as if applicable\n     */\n    ObjectName getObjectName();\n\n    /**\n     * Set when the subscription is registered in JMX\n     */\n    void setObjectName(ObjectName objectName);\n\n    /**\n     * @return true when 60% or more room is left for dispatching messages\n     */\n    boolean isLowWaterMark();\n\n    /**\n     * @return true when 10% or less room is left for dispatching messages\n     */\n    boolean isHighWaterMark();\n\n    /**\n     * @return true if there is no space to dispatch messages\n     */\n    boolean isFull();\n\n    /**\n     * inform the MessageConsumer on the client to change it's prefetch\n     * @param newPrefetch\n     */\n    void updateConsumerPrefetch(int newPrefetch);\n\n    /**\n     * Called when the subscription is destroyed.\n     */\n    void destroy();\n\n    /**\n     * @return the prefetch size that is configured for the subscription\n     */\n    int getPrefetchSize();\n\n    /**\n     * @return the number of messages awaiting acknowledgement\n     */\n    int getInFlightSize();\n\n    /**\n     * @return the size in bytes of the messages awaiting acknowledgement\n     */\n    long getInFlightMessageSize();\n\n    /**\n     * @return the in flight messages as a percentage of the prefetch size\n     */\n    int getInFlightUsage();\n\n    /**\n     * Informs the Broker if the subscription needs to intervention to recover it's state\n     * e.g. DurableTopicSubscriber may do\n     * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor\n     * @return true if recovery required\n     */\n    boolean isRecoveryRequired();\n\n    /**\n     * @return true if a browser\n     */\n    boolean isBrowser();\n\n    /**\n     * @return the number of messages this subscription can accept before its full\n     */\n    int countBeforeFull();\n\n    ConnectionContext getContext();\n\n    public int getCursorMemoryHighWaterMark();\n\n    public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n\n    boolean isSlowConsumer();\n\n    void unmatched(MessageReference node) throws IOException;\n\n    /**\n     * Returns the time since the last Ack message was received by this subscription.\n     *\n     * If there has never been an ack this value should be set to the creation time of the\n     * subscription.\n     *\n     * @return time of last received Ack message or Subscription create time if no Acks.\n     */\n    long getTimeOfLastMessageAck();\n\n    long  getConsumedCount();\n\n    void incrementConsumedCount();\n\n    void resetConsumedCount();\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueMessageReference.getLockOwner": "    LockOwner getLockOwner();\n}"
        },
        "bug_report": {
            "Title": "java.lang.IllegalArgumentException: Comparison method violates its general contract!",
            "Description": "The message group balancing is based on state in the consumer that can be shared across destinations in error. Under load this can lead to:{code}\n2015-04-13 10:24:20,034 | WARN  | IO Worker 308792 | Service                          | ivemq.broker.TransportConnection  312 | 121 - org.apache.activemq.activemq-osgi - 5.9.0 | Async error occurred: \njava.lang.IllegalArgumentException: Comparison method violates its general contract!\n\tat java.util.TimSort.mergeHi(TimSort.java:868)[:1.7.0_65]\n\tat java.util.TimSort.mergeAt(TimSort.java:485)[:1.7.0_65]\n\tat java.util.TimSort.mergeCollapse(TimSort.java:410)[:1.7.0_65]\n\tat java.util.TimSort.sort(TimSort.java:214)[:1.7.0_65]\n\tat java.util.TimSort.sort(TimSort.java:173)[:1.7.0_65]\n\tat java.util.Arrays.sort(Arrays.java:659)[:1.7.0_65]\n\tat java.util.Collections.sort(Collections.java:217)[:1.7.0_65]\n\tat org.apache.activemq.broker.region.Queue.addToConsumerList(Queue.java:2131)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:2067)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1972)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.Queue.removeSubscription(Queue.java:587)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat org.apache.activemq.broker.region.DestinationFilter.removeSubscription(DestinationFilter.java:127)[121:org.apache.activemq.activemq-osgi:5.9.0]\n\tat ......\n\tat java.lang.Thread.run(Thread.java:745)[:1.7.0_65]{code}"
        }
    },
    {
        "filename": "AMQ-3490.json",
        "creation_time": "2011-09-08T20:31:57.000+0000",
        "stack_trace": "java.lang.NullPointerExceptionnull\n    at java.io.Writer.write(Writer.java:140)null\n    at java.io.BufferedWriter.newLine(BufferedWriter.java:225)null\n    at java.util.Properties.writeComments(Properties.java:671)null\n    at java.util.Properties.store0(Properties.java:805)null\n    at java.util.Properties.store(Properties.java:796)null\n    at org.apache.kahadb.page.PageFile.storeMetaData(PageFile.java:570)null\n    at org.apache.kahadb.page.PageFile.load(PageFile.java:361)null\n    at org.apache.activemq.store.kahadb.plist.PListStore.intialize(PListStore.java:285)null\n    at org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:218)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:457)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:435)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.onUsageChanged(FilePendingMessageCursor.java:388)null\n    at org.apache.activemq.usage.Usage$1.run(Usage.java:268)null\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)null\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)null\n    at java.lang.Thread.run(Thread.java: 619)",
        "source_code": {
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.storeMetaData": "    private void storeMetaData() throws IOException {\n        // Convert the metadata into a property format\n        metaData.metaDataTxId++;\n        Properties p = new Properties();\n        IntrospectionSupport.getProperties(metaData, p, null);\n        \n        ByteArrayOutputStream os = new ByteArrayOutputStream(PAGE_FILE_HEADER_SIZE);\n        p.store(os, \"\");\n        if( os.size() > PAGE_FILE_HEADER_SIZE/2) { \n            throw new IOException(\"Configuation is to larger than: \"+PAGE_FILE_HEADER_SIZE/2);\n        }\n        // Fill the rest with space...\n        byte[] filler = new byte[(PAGE_FILE_HEADER_SIZE/2)-os.size()];\n        Arrays.fill(filler, (byte)' ');\n        os.write(filler);\n        os.flush();\n        \n        byte[] d = os.toByteArray();\n\n        // So we don't loose it.. write it 2 times...\n        writeFile.seek(0);\n        writeFile.write(d);\n        writeFile.getFD().sync();\n        writeFile.seek(PAGE_FILE_HEADER_SIZE/2);\n        writeFile.write(d);\n        writeFile.getFD().sync();\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.write": "    void write(Collection<Map.Entry<Long, PageWrite>> updates) throws IOException {\n        synchronized( writes ) {\n            if( enabledWriteThread  ) {\n                while( writes.size() >= writeBatchSize && !stopWriter.get() ) {\n                    try {\n                        writes.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        throw new InterruptedIOException();\n                    }\n                }\n            }\n\n            boolean longTx = false;\n\n            for (Map.Entry<Long, PageWrite> entry : updates) {\n                Long key = entry.getKey();\n                PageWrite value = entry.getValue();\n                PageWrite write = writes.get(key);\n                if( write==null ) {\n                    writes.put(key, value);\n                } else {\n                    if (value.currentLocation != -1) {\n                        write.setCurrentLocation(value.page, value.currentLocation, value.length);\n                        write.tmpFile = value.tmpFile;\n                        longTx = true;\n                    } else {\n                        write.setCurrent(value.page, value.current);\n                    }\n                }\n            }\n            \n            // Once we start approaching capacity, notify the writer to start writing\n            // sync immediately for long txs\n            if( longTx || canStartWriteBatch() ) {\n\n                if( enabledWriteThread  ) {\n                    writes.notify();\n                } else {\n                    writeBatch();\n                }\n            }\n        }            \n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.flush": "    public void flush() throws IOException {\n\n        if( enabledWriteThread && stopWriter.get() ) {\n            throw new IOException(\"Page file already stopped: checkpointing is not allowed\");\n        }\n        \n        // Setup a latch that gets notified when all buffered writes hits the disk.\n        CountDownLatch checkpointLatch;\n        synchronized( writes ) {\n            if( writes.isEmpty()) {                \n                return;\n            }\n            if( enabledWriteThread ) {\n                if( this.checkpointLatch == null ) {\n                    this.checkpointLatch = new CountDownLatch(1);\n                }\n                checkpointLatch = this.checkpointLatch;\n                writes.notify();\n            } else {\n                writeBatch();\n                return;\n            }\n        }\n        try {\n            checkpointLatch.await();\n        } catch (InterruptedException e) {\n            throw new InterruptedIOException();\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.load": "    public void load() throws IOException, IllegalStateException {\n        if (loaded.compareAndSet(false, true)) {\n            \n            if( enablePageCaching ) {\n                pageCache = Collections.synchronizedMap(new LRUCache<Long, Page>(pageCacheSize, pageCacheSize, 0.75f, true));\n            }\n            \n            File file = getMainPageFile();\n            IOHelper.mkdirs(file.getParentFile());\n            writeFile = new RandomAccessFile(file, \"rw\");\n            readFile = new RandomAccessFile(file, \"r\");\n            \n            if (readFile.length() > 0) {\n                // Load the page size setting cause that can't change once the file is created.\n                loadMetaData();\n                pageSize = metaData.getPageSize();\n            } else {\n                // Store the page size setting cause that can't change once the file is created.\n                metaData = new MetaData();\n                metaData.setFileType(PageFile.class.getName());\n                metaData.setFileTypeVersion(\"1\");\n                metaData.setPageSize(getPageSize());\n                metaData.setCleanShutdown(true);\n                metaData.setFreePages(-1);\n                metaData.setLastTxId(0);\n                storeMetaData();\n            }\n\n            if( enableRecoveryFile ) {\n                recoveryFile = new RandomAccessFile(getRecoveryFile(), \"rw\");\n            }\n            \n            if(  metaData.isCleanShutdown() ) {\n                nextTxid.set(metaData.getLastTxId()+1);\n                if( metaData.getFreePages()>0 ) {\n                    loadFreeList();\n                } \n            } else {\n                LOG.debug(toString() + \", Recovering page file...\");\n                nextTxid.set(redoRecoveryUpdates());\n                \n                // Scan all to find the free pages.\n                freeList = new SequenceSet();\n                for (Iterator i = tx().iterator(true); i.hasNext();) {\n                    Page page = (Page)i.next();\n                    if( page.getType() == Page.PAGE_FREE_TYPE ) {\n                        freeList.add(page.getPageId());\n                    }\n                }\n                \n            }\n            \n            metaData.setCleanShutdown(false);\n            storeMetaData();\n            getFreeFile().delete();\n            \n            if( writeFile.length() < PAGE_FILE_HEADER_SIZE) {\n                writeFile.setLength(PAGE_FILE_HEADER_SIZE);\n            }\n            nextFreePageId.set((writeFile.length()-PAGE_FILE_HEADER_SIZE)/pageSize);\n            startWriter();\n                \n        } else {\n            throw new IllegalStateException(\"Cannot load the page file when it is allready loaded.\");\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getLastTxId": "        public long getLastTxId() {\n            return lastTxId;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.setFileTypeVersion": "        public void setFileTypeVersion(String version) {\n            this.fileTypeVersion = version;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.setFileType": "        public void setFileType(String fileType) {\n            this.fileType = fileType;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getMainPageFile": "    private File getMainPageFile() {\n        return new File(directory, IOHelper.toFileSystemSafeName(name)+PAGEFILE_SUFFIX);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.setLastTxId": "        public void setLastTxId(long lastTxId) {\n            this.lastTxId = lastTxId;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.loadFreeList": "    private void loadFreeList() throws IOException {\n        freeList.clear();\n        FileInputStream is = new FileInputStream(getFreeFile());\n        DataInputStream dis = new DataInputStream(is);\n        freeList = SequenceSet.Marshaller.INSTANCE.readPayload(dis);\n        dis.close();\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.redoRecoveryUpdates": "    private long redoRecoveryUpdates() throws IOException {\n        if( !enableRecoveryFile ) {\n            return 0;\n        }\n        recoveryPageCount=0;\n        \n        // Are we initializing the recovery file?\n        if( recoveryFile.length() == 0 ) {\n            // Write an empty header..\n            recoveryFile.write(new byte[RECOVERY_FILE_HEADER_SIZE]);\n            // Preallocate the minium size for better performance.\n            recoveryFile.setLength(recoveryFileSizeForPages(recoveryFileMinPageCount));\n            return 0;\n        }\n        \n        // How many recovery pages do we have in the recovery buffer?\n        recoveryFile.seek(0);\n        long nextTxId = recoveryFile.readLong();\n        long expectedChecksum = recoveryFile.readLong();\n        int pageCounter = recoveryFile.readInt();\n        \n        recoveryFile.seek(RECOVERY_FILE_HEADER_SIZE);\n        Checksum checksum = new Adler32();\n        LinkedHashMap<Long, byte[]> batch = new LinkedHashMap<Long, byte[]>();\n        try {\n            for (int i = 0; i < pageCounter; i++) {\n                long offset = recoveryFile.readLong();\n                byte []data = new byte[pageSize];\n                if( recoveryFile.read(data, 0, pageSize) != pageSize ) {\n                    // Invalid recovery record, Could not fully read the data\". Probably due to a partial write to the recovery buffer\n                    return nextTxId;\n                }\n                checksum.update(data, 0, pageSize);\n                batch.put(offset, data);\n            }\n        } catch (Exception e) {\n            // If an error occurred it was cause the redo buffer was not full written out correctly.. so don't redo it. \n            // as the pages should still be consistent.\n            LOG.debug(\"Redo buffer was not fully intact: \", e);\n            return nextTxId;\n        }\n        \n        recoveryPageCount = pageCounter;\n        \n        // If the checksum is not valid then the recovery buffer was partially written to disk.\n        if( checksum.getValue() != expectedChecksum ) {\n            return nextTxId;\n        }\n        \n        // Re-apply all the writes in the recovery buffer.\n        for (Map.Entry<Long, byte[]> e : batch.entrySet()) {\n            writeFile.seek(toOffset(e.getKey()));\n            writeFile.write(e.getValue());\n        }\n        \n        // And sync it to disk\n        writeFile.getFD().sync();\n        return nextTxId;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.startWriter": "    private void startWriter() {\n        synchronized( writes ) {\n            if( enabledWriteThread ) {\n                stopWriter.set(false);\n                writerThread = new Thread(\"KahaDB Page Writer\") {\n                    @Override\n                    public void run() {\n                        pollWrites();\n                    }\n                };\n                writerThread.setPriority(Thread.MAX_PRIORITY);\n                writerThread.setDaemon(true);\n                writerThread.start();\n            }\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getPageSize": "    public int getPageSize() {\n        return this.pageSize;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.isCleanShutdown": "        public boolean isCleanShutdown() {\n            return cleanShutdown;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.toString": "    public String toString() {\n        return \"Page File: \"+getMainPageFile();\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.delete": "    private void delete(File file) throws IOException {\n        if( file.exists() ) {\n            if( !file.delete() ) {\n                throw new IOException(\"Could not delete: \"+file.getPath());\n            }\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.setFreePages": "        public void setFreePages(long value) {\n            this.freePages = value;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getFreeFile": "    public File getFreeFile() {\n        return new File(directory, IOHelper.toFileSystemSafeName(name)+FREE_FILE_SUFFIX);\n    } ",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.loadMetaData": "    private void loadMetaData() throws IOException {\n\n        ByteArrayInputStream is;\n        MetaData v1 = new MetaData();\n        MetaData v2 = new MetaData();\n        try {\n            Properties p = new Properties();\n            byte[] d = new byte[PAGE_FILE_HEADER_SIZE/2];\n            readFile.seek(0);\n            readFile.readFully(d);\n            is = new ByteArrayInputStream(d);\n            p.load(is);\n            IntrospectionSupport.setProperties(v1, p);\n        } catch (IOException e) {\n            v1 = null;\n        }\n        \n        try {\n            Properties p = new Properties();\n            byte[] d = new byte[PAGE_FILE_HEADER_SIZE/2];\n            readFile.seek(PAGE_FILE_HEADER_SIZE/2);\n            readFile.readFully(d);\n            is = new ByteArrayInputStream(d);\n            p.load(is);\n            IntrospectionSupport.setProperties(v2, p);\n        } catch (IOException e) {\n            v2 = null;\n        }\n        \n        if( v1==null && v2==null ) {\n            throw new IOException(\"Could not load page file meta data\");\n        } \n        \n        if( v1 == null || v1.metaDataTxId<0 ) {\n            metaData = v2;\n        } else if( v2==null || v1.metaDataTxId<0 ) {\n            metaData = v1;\n        } else if( v1.metaDataTxId==v2.metaDataTxId ) {\n            metaData = v1; // use the first since the 2nd could be a partial..\n        } else {\n            metaData = v2; // use the second cause the first is probably a partial.\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.tx": "    public Transaction tx() {\n        assertLoaded();\n        return new Transaction(this);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getFreePages": "        public long getFreePages() {\n            return freePages;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getRecoveryFile": "    public File getRecoveryFile() {\n        return new File(directory, IOHelper.toFileSystemSafeName(name)+RECOVERY_FILE_SUFFIX);\n    } ",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.setPageSize": "    public void setPageSize(int pageSize) throws IllegalStateException {\n        assertNotLoaded();\n        this.pageSize = pageSize;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.setCleanShutdown": "        public void setCleanShutdown(boolean cleanShutdown) {\n            this.cleanShutdown = cleanShutdown;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.intialize": "    protected synchronized void intialize() throws Exception {\n        if (isStarted()) {\n            if (this.initialized == false) {\n                this.initialized = true;\n                if (this.directory == null) {\n                    this.directory = new File(IOHelper.getDefaultDataDirectory() + File.pathSeparator + \"delayedDB\");\n                }\n                IOHelper.mkdirs(this.directory);\n                lock();\n                this.journal = new Journal();\n                this.journal.setDirectory(directory);\n                this.journal.setMaxFileLength(getJournalMaxFileLength());\n                this.journal.setWriteBatchSize(getJournalMaxWriteBatchSize());\n                this.journal.start();\n                this.pageFile = new PageFile(directory, \"tmpDB\");\n                this.pageFile.setEnablePageCaching(getIndexEnablePageCaching());\n                this.pageFile.setPageSize(getIndexPageSize());\n                this.pageFile.setWriteBatchSize(getIndexWriteBatchSize());\n                this.pageFile.setPageCacheSize(getIndexCacheSize());\n                this.pageFile.load();\n\n                this.pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                    public void execute(Transaction tx) throws IOException {\n                        if (pageFile.getPageCount() == 0) {\n                            Page<MetaData> page = tx.allocate();\n                            assert page.getPageId() == 0;\n                            page.set(metaData);\n                            metaData.page = page;\n                            metaData.createIndexes(tx);\n                            tx.store(metaData.page, metaDataMarshaller, true);\n\n                        } else {\n                            Page<MetaData> page = tx.load(0, metaDataMarshaller);\n                            metaData = page.get();\n                            metaData.page = page;\n                        }\n                        metaData.load(tx);\n                        metaData.loadLists(tx, persistentLists);\n                    }\n                });\n                this.pageFile.flush();\n\n                if (cleanupInterval > 0) {\n                    if (scheduler == null) {\n                        scheduler = new Scheduler(PListStore.class.getSimpleName());\n                        scheduler.start();\n                    }\n                    scheduler.executePeriodically(this, cleanupInterval);\n                }\n                LOG.info(this + \" initialized\");\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.loadLists": "        void loadLists(Transaction tx, Map<String, PList> lists) throws IOException {\n            for (Iterator<Entry<String, PList>> i = this.lists.iterator(tx); i.hasNext();) {\n                Entry<String, PList> entry = i.next();\n                entry.getValue().load(tx);\n                lists.put(entry.getKey(), entry.getValue());\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getIndexEnablePageCaching": "    public boolean getIndexEnablePageCaching() {\n        return indexEnablePageCaching;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.setDirectory": "    public void setDirectory(File directory) {\n        this.directory = directory;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.load": "        void load(Transaction tx) throws IOException {\n            this.lists.setKeyMarshaller(StringMarshaller.INSTANCE);\n            this.lists.setValueMarshaller(new PListMarshaller(this.store));\n            this.lists.load(tx);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getJournalMaxFileLength": "    public int getJournalMaxFileLength() {\n        return journalMaxFileLength;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.execute": "                    public void execute(Transaction tx) throws IOException {\n                        if (pageFile.getPageCount() == 0) {\n                            Page<MetaData> page = tx.allocate();\n                            assert page.getPageId() == 0;\n                            page.set(metaData);\n                            metaData.page = page;\n                            metaData.createIndexes(tx);\n                            tx.store(metaData.page, metaDataMarshaller, true);\n\n                        } else {\n                            Page<MetaData> page = tx.load(0, metaDataMarshaller);\n                            metaData = page.get();\n                            metaData.page = page;\n                        }\n                        metaData.load(tx);\n                        metaData.loadLists(tx, persistentLists);\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getIndexPageSize": "    public int getIndexPageSize() {\n        return indexPageSize;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getIndexWriteBatchSize": "    public int getIndexWriteBatchSize() {\n        return indexWriteBatchSize;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.createIndexes": "        void createIndexes(Transaction tx) throws IOException {\n            this.lists = new BTreeIndex<String, PList>(pageFile, tx.allocate().getPageId());\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getIndexCacheSize": "    public int getIndexCacheSize() {\n        return indexCacheSize;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getJournalMaxWriteBatchSize": "    public int getJournalMaxWriteBatchSize() {\n        return journalMaxWriteBatchSize;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.lock": "    private void lock() throws IOException {\n        if (lockFile == null) {\n            File lockFileName = new File(directory, \"lock\");\n            lockFile = new LockFile(lockFileName, true);\n            if (failIfDatabaseIsLocked) {\n                lockFile.lock();\n            } else {\n                while (true) {\n                    try {\n                        lockFile.lock();\n                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \" + lockFileName + \" is locked... waiting \"\n                                + (DATABASE_LOCKED_WAIT_DELAY / 1000)\n                                + \" seconds for the database to be unlocked. Reason: \" + e);\n                        try {\n                            Thread.sleep(DATABASE_LOCKED_WAIT_DELAY);\n                        } catch (InterruptedException e1) {\n                        }\n                    }\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getPList": "    public PList getPList(final String name) throws Exception {\n        if (!isStarted()) {\n            throw new IllegalStateException(\"Not started\");\n        }\n        intialize();\n        synchronized (indexLock) {\n            synchronized (this) {\n                PList result = this.persistentLists.get(name);\n                if (result == null) {\n                    final PList pl = new PList(this);\n                    pl.setName(name);\n                    getPageFile().tx().execute(new Transaction.Closure<IOException>() {\n                        public void execute(Transaction tx) throws IOException {\n                            pl.setHeadPageId(tx.allocate().getPageId());\n                            pl.load(tx);\n                            metaData.lists.put(tx, name, pl);\n                        }\n                    });\n                    result = pl;\n                    this.persistentLists.put(name, pl);\n                }\n                final PList toLoad = result;\n                getPageFile().tx().execute(new Transaction.Closure<IOException>() {\n                    public void execute(Transaction tx) throws IOException {\n                        toLoad.load(tx);\n                    }\n                });\n\n                return result;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PListStore.getPageFile": "    PageFile getPageFile() {\n        this.pageFile.isLoaded();\n        return this.pageFile;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList": "    protected PList getDiskList() {\n        if (diskList == null) {\n            try {\n                diskList = store.getPList(name);\n            } catch (Exception e) {\n                LOG.error(\"Caught an IO Exception getting the DiskList \" + name, e);\n                throw new RuntimeException(e);\n            }\n        }\n        return diskList;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk": "    protected synchronized void flushToDisk() {\n        if (!memoryList.isEmpty() && store != null) {\n            long start = 0;\n             if (LOG.isTraceEnabled()) {\n                start = System.currentTimeMillis();\n                LOG.trace(\"\" + name + \", flushToDisk() mem list size: \" +memoryList.size()  + \" \" +  (systemUsage != null ? systemUsage.getMemoryUsage() : \"\") );\n             }\n            while (!memoryList.isEmpty()) {\n                MessageReference node = memoryList.removeFirst();\n                node.decrementReferenceCount();\n                ByteSequence bs;\n                try {\n                    bs = getByteSequence(node.getMessage());\n                    getDiskList().addLast(node.getMessageId().toString(), bs);\n                } catch (IOException e) {\n                    LOG.error(\"Failed to write to disk list\", e);\n                    throw new RuntimeException(e);\n                }\n\n            }\n            memoryList.clear();\n            setCacheEnabled(false);\n             if (LOG.isTraceEnabled()) {\n                LOG.trace(\"\" + name + \", flushToDisk() done - \" + (System.currentTimeMillis() - start) + \"ms \" + (systemUsage != null ? systemUsage.getMemoryUsage() : \"\"));\n             }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.clear": "    public synchronized void clear() {\n        memoryList.clear();\n        if (!isDiskListEmpty()) {\n            try {\n                getDiskList().destroy();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        last = null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.isEmpty": "    public synchronized boolean isEmpty() {\n        if (memoryList.isEmpty() && isDiskListEmpty()) {\n            return true;\n        }\n        for (Iterator<MessageReference> iterator = memoryList.iterator(); iterator.hasNext();) {\n            MessageReference node = iterator.next();\n            if (node == QueueMessageReference.NULL_MESSAGE) {\n                continue;\n            }\n            if (!node.isDropped()) {\n                return false;\n            }\n            // We can remove dropped references.\n            iterator.remove();\n        }\n        return isDiskListEmpty();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.size": "    public synchronized int size() {\n        return memoryList.size() + (isDiskListEmpty() ? 0 : (int)getDiskList().size());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getByteSequence": "    protected ByteSequence getByteSequence(Message message) throws IOException {\n        org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);\n        return new ByteSequence(packet.data, packet.offset, packet.length);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getMessage": "    protected Message getMessage(ByteSequence bs) throws IOException {\n        org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(bs.getData(), bs\n                .getOffset(), bs.getLength());\n        return (Message) this.wireFormat.unmarshal(packet);\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.onUsageChanged": "    public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {\n        if (newPercentUsage >= getMemoryUsageHighWaterMark()) {\n            synchronized (this) {\n                if (!flushRequired && size() != 0) {\n                    flushRequired =true;\n                    if (!iterating) {\n                        expireOldMessages();\n                        if (!hasSpace()) {\n                            flushToDisk();\n                            flushRequired = false;\n                        }\n                    }\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.expireOldMessages": "    protected synchronized void expireOldMessages() {\n        if (!memoryList.isEmpty()) {\n            LinkedList<MessageReference> tmpList = new LinkedList<MessageReference>(this.memoryList);\n            this.memoryList = new LinkedList<MessageReference>();\n            while (!tmpList.isEmpty()) {\n                MessageReference node = tmpList.removeFirst();\n                if (node.isExpired()) {\n                    discard(node);\n                } else {\n                    memoryList.add(node);\n                }\n            }\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.usage.Usage.run": "                public void run() {\n                    synchronized (usageMutex) {\n                        if (percentUsage >= 100) {\n                            callbacks.add(callback);\n                        } else {\n                            callback.run();\n                        }\n                    }\n                }",
            "kahadb.src.main.java.org.apache.kahadb.page.Page.getPageId": "    public long getPageId() {\n        return pageId;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.Page.getType": "    public short getType() {\n        return type;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.setName": "    public void setName(String name) {\n        this.name = name;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.usage.UsageListener.onUsageChanged": "    void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage);\n}"
        },
        "bug_report": {
            "Title": "NPEs during message processing, using FileCursor",
            "Description": "In a scenario where a single-consumer queue for non-presistent messages uses a file cursor to manage a backlog, bursts of messages result in NPEs.\n\nThread dumps for 3 different examples:\n\n2011-09-07 12:43:27,057 ERROR [cursors.FilePendingMessageCursor] [] : [Usage Async Task] Caught an IO Exception getting the DiskList7_PendingCursor:snTableQueue_CHF\njava.lang.NullPointerExceptionnull\n    at java.io.Writer.write(Writer.java:140)null\n    at java.io.BufferedWriter.newLine(BufferedWriter.java:225)null\n    at java.util.Properties.writeComments(Properties.java:671)null\n    at java.util.Properties.store0(Properties.java:805)null\n    at java.util.Properties.store(Properties.java:796)null\n    at org.apache.kahadb.page.PageFile.storeMetaData(PageFile.java:570)null\n    at org.apache.kahadb.page.PageFile.load(PageFile.java:361)null\n    at org.apache.activemq.store.kahadb.plist.PListStore.intialize(PListStore.java:285)null\n    at org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:218)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:457)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:435)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.onUsageChanged(FilePendingMessageCursor.java:388)null\n    at org.apache.activemq.usage.Usage$1.run(Usage.java:268)null\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)null\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)null\n    at java.lang.Thread.run(Thread.java: 619)null\nException in thread \"Usage Async Task\" java.lang.RuntimeException: java.lang.NullPointerException\n\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:460)\n\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:435)\n\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.onUsageChanged(FilePendingMessageCursor.java:388)\n\n    at org.apache.activemq.usage.Usage$1.run(Usage.java:268)\n\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\n    at java.lang.Thread.run(Thread.java:619)\nCaused by: java.lang.NullPointerException\n\n    at java.io.Writer.write(Writer.java:140)\n\n    at java.io.BufferedWriter.newLine(BufferedWriter.java:225)\n\n    at java.util.Properties.writeComments(Properties.java:671)\n\n\n================================================================\n\n2011-09-07 12:43:40,908 ERROR [cursors.FilePendingMessageCursor] [1315421994681] : [ActiveMQ Transport: tcp:///134.242.171.26:35469]\n Caught an IO Exception getting the DiskList 7_PendingCursor:snTableQueue_CHF\njava.lang.NullPointerExceptionnull\n    at org.apache.activemq.store.kahadb.plist.PListStore$1.execute(PListStore.java:229)null\n    at org.apache.kahadb.page.Transaction.execute(Transaction.java:760)null\n    at org.apache.activemq.store.kahadb.plist.PListStore.getPLis\nt(PListStore.java:225)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:457)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast(FilePendingMessageCursor.java:226)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast(FilePendingMessageCursor.java:196)null\n    at org.apache.activemq.broker.region.Queue.sendMessage(Queue.java:1603)null  \n    at org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:715)null\n    at org.apache.activemq.broker.region.Queue.send(Queue.java:647)null\n    at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:409)null\n    at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:543)null\n    at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:301)null\n    at o\nrg.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)null\n    at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)null\n    at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)null\n\n    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)null  \n    at org.apache.activemq.security.AuthorizationBroker.send(AuthorizationBroker.java:192)null\n    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)null  \n    at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)null\n    at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:468)null\n    at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:68\n1)null\n    at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:316)null\n    at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:180)null\n    at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)null\n    at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)null\n\n    at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:216)null\n    at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)null\n    at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:222)null\n    at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:204)null      \n    at java.lang.Thread.run(Thread.java:619)null\n\n=======================================================================================\n\n\n2011-09-07 12:43:41,028 ERROR [cursors.FilePendingMessageCursor] [1315421994681] : [ActiveMQ Transport: tcp:///134.242.171.26:35469]\n Caught an Exception adding a message: ActiveMQObjectMessage {commandId = 82, responseRequired = false, messageId = ID:lgvn-330\n53-1315415867932-0:19:1:1:78, originalDestination = null, originalTransactionId = null, producerId = ID:lgvn-33053-131541586793\n2-0:19:1:1, destination = queue://snTableQueue_CHF, transactionId = null, expiration = 0, timestamp = 1315424620840,\n arrival = 0, brokerInTime = 1315424620881, brokerOutTime = 0, correlationId = null, replyTo = null, persistent = false, type = null\n, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = org.apache.activemq.util.ByteSequence@d42d49, marshalledProperties = org.apache.activemq.util.ByteSequence@1e91c40, dataStructure = null, redeliveryCounter = 0, size = 0, properties = {TO=0, FROM=37, HOST=134.242.171.26, trigger_name=com.foo.receiver.beans.ACTData, version=3.4}, readOnlyProperties = false, readOnlyBody = false, droppable = false} first to FilePendingMessageCursor\njava.lang.RuntimeException: java.lang.NullPointerExceptionnull\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:460)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast(FilePendingMessageCursor.java:226)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast(FilePendingMessageCursor.java:196)null\n    at org.apache.activemq.broker.region.Queue.sendMessage(Queue.java:1603)null  \n    at org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:715)null\n    at org.apache.activemq.broker.region.Queue.send(Queue.java:647)null\n    at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:409)null\n    at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:543)null\n    at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBrok\ner.java:301)null\n    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)null  \n    at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)null\n    at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)null\n    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)null    \n    at org.apache.activemq.security.AuthorizationBroker.send(AuthorizationBroker.java:192)null\n    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)null\n    at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)null      \n    at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:468)null\n    at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)null\n    at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:316)null\n\n    at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:180)null\n    at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)null  \n    at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)null\n    at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:216)null      \n    at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)null    \n    at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:222)null\n    at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:204)null  \n    at java.lang.Thread.run(Thread.java:619)nullCaused by: java.lang.NullPointerExceptionnull    \n    at org.apache.activemq.store.kahadb.plist.PListStore$1.execute(PListStore.java:229)null  \n    at org.apache.kahadb.page.Transaction.execute(Transaction.java:760)null  \n    at org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:225)null\n    at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:457)null  \n\n        ... 26 morenull "
        }
    },
    {
        "filename": "AMQ-6831.json",
        "creation_time": "2017-10-09T10:35:53.000+0000",
        "stack_trace": "java.lang.Error: java.io.IOException: Detected missing/corrupt journal files referenced by:[0:ActiveMQ.DLQ] 3 messages affected.\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148) ~[na:1.8.0_131]\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_131]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_131]\r\nCaused by: java.io.IOException: Detected missing/corrupt journal files referenced by:[0:ActiveMQ.DLQ] 3 messages affected.\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex(MessageDatabase.java:965) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase$5.execute(MessageDatabase.java:717) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.recover(MessageDatabase.java:714) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.open(MessageDatabase.java:473) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.load(MessageDatabase.java:493) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.doStart(MessageDatabase.java:297) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.KahaDBStore.doStart(KahaDBStore.java:219) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.util.ServiceSupport.start(ServiceSupport.java:55) ~[activemq-client-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter.doStart(KahaDBPersistenceAdapter.java:232)",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex": "    protected void recoverIndex(Transaction tx) throws IOException {\n        long start = System.currentTimeMillis();\n        // It is possible index updates got applied before the journal updates..\n        // in that case we need to removed references to messages that are not in the journal\n        final Location lastAppendLocation = journal.getLastAppendLocation();\n        long undoCounter=0;\n\n        // Go through all the destinations to see if they have messages past the lastAppendLocation\n        for (String key : storedDestinations.keySet()) {\n            StoredDestination sd = storedDestinations.get(key);\n\n            final ArrayList<Long> matches = new ArrayList<>();\n            // Find all the Locations that are >= than the last Append Location.\n            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor<Location, Long>(lastAppendLocation) {\n                @Override\n                protected void matched(Location key, Long value) {\n                    matches.add(value);\n                }\n            });\n\n            for (Long sequenceId : matches) {\n                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                if (keys != null) {\n                    sd.locationIndex.remove(tx, keys.location);\n                    sd.messageIdIndex.remove(tx, keys.messageId);\n                    metadata.producerSequenceIdTracker.rollback(keys.messageId);\n                    undoCounter++;\n                    decrementAndSubSizeToStoreStat(key, keys.location.getSize());\n                    // TODO: do we need to modify the ack positions for the pub sub case?\n                }\n            }\n        }\n\n        if (undoCounter > 0) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting\n            // these the end user should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Rolled back \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n\n        undoCounter = 0;\n        start = System.currentTimeMillis();\n\n        // Lets be extra paranoid here and verify that all the datafiles being referenced\n        // by the indexes still exists.\n\n        final SequenceSet ss = new SequenceSet();\n        for (StoredDestination sd : storedDestinations.values()) {\n            // Use a visitor to cut down the number of pages that we load\n            sd.locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                int last=-1;\n\n                @Override\n                public boolean isInterestedInKeysBetween(Location first, Location second) {\n                    if( first==null ) {\n                        return !ss.contains(0, second.getDataFileId());\n                    } else if( second==null ) {\n                        return true;\n                    } else {\n                        return !ss.contains(first.getDataFileId(), second.getDataFileId());\n                    }\n                }\n\n                @Override\n                public void visit(List<Location> keys, List<Long> values) {\n                    for (Location l : keys) {\n                        int fileId = l.getDataFileId();\n                        if( last != fileId ) {\n                            ss.add(fileId);\n                            last = fileId;\n                        }\n                    }\n                }\n\n            });\n        }\n        HashSet<Integer> missingJournalFiles = new HashSet<>();\n        while (!ss.isEmpty()) {\n            missingJournalFiles.add((int) ss.removeFirst());\n        }\n\n        for (Entry<Integer, Set<Integer>> entry : metadata.ackMessageFileMap.entrySet()) {\n            missingJournalFiles.add(entry.getKey());\n            for (Integer i : entry.getValue()) {\n                missingJournalFiles.add(i);\n            }\n        }\n\n        missingJournalFiles.removeAll(journal.getFileMap().keySet());\n\n        if (!missingJournalFiles.isEmpty()) {\n            LOG.warn(\"Some journal files are missing: \" + missingJournalFiles);\n        }\n\n        ArrayList<BTreeVisitor.Predicate<Location>> knownCorruption = new ArrayList<>();\n        ArrayList<BTreeVisitor.Predicate<Location>> missingPredicates = new ArrayList<>();\n        for (Integer missing : missingJournalFiles) {\n            missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(missing, 0), new Location(missing + 1, 0)));\n        }\n\n        if (checkForCorruptJournalFiles) {\n            Collection<DataFile> dataFiles = journal.getFileMap().values();\n            for (DataFile dataFile : dataFiles) {\n                int id = dataFile.getDataFileId();\n                // eof to next file id\n                missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));\n                Sequence seq = dataFile.getCorruptedBlocks().getHead();\n                while (seq != null) {\n                    BTreeVisitor.BetweenVisitor<Location, Long> visitor =\n                        new BTreeVisitor.BetweenVisitor<>(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1));\n                    missingPredicates.add(visitor);\n                    knownCorruption.add(visitor);\n                    seq = seq.getNext();\n                }\n            }\n        }\n\n        if (!missingPredicates.isEmpty()) {\n            for (Entry<String, StoredDestination> sdEntry : storedDestinations.entrySet()) {\n                final StoredDestination sd = sdEntry.getValue();\n                final LinkedHashMap<Long, Location> matches = new LinkedHashMap<>();\n                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor<Location, Long>(missingPredicates) {\n                    @Override\n                    protected void matched(Location key, Long value) {\n                        matches.put(value, key);\n                    }\n                });\n\n                // If some message references are affected by the missing data files...\n                if (!matches.isEmpty()) {\n\n                    // We either 'gracefully' recover dropping the missing messages or\n                    // we error out.\n                    if( ignoreMissingJournalfiles ) {\n                        // Update the index to remove the references to the missing data\n                        for (Long sequenceId : matches.keySet()) {\n                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                            sd.locationIndex.remove(tx, keys.location);\n                            sd.messageIdIndex.remove(tx, keys.messageId);\n                            LOG.info(\"[\" + sdEntry.getKey() + \"] dropped: \" + keys.messageId + \" at corrupt location: \" + keys.location);\n                            undoCounter++;\n                            decrementAndSubSizeToStoreStat(sdEntry.getKey(), keys.location.getSize());\n                            // TODO: do we need to modify the ack positions for the pub sub case?\n                        }\n                    } else {\n                        LOG.error(\"[\" + sdEntry.getKey() + \"] references corrupt locations: \" + matches);\n                        throw new IOException(\"Detected missing/corrupt journal files referenced by:[\" + sdEntry.getKey() + \"] \" +matches.size()+\" messages affected.\");\n                    }\n                }\n            }\n        }\n\n        if (!ignoreMissingJournalfiles) {\n            if (!knownCorruption.isEmpty()) {\n                LOG.error(\"Detected corrupt journal files. \" + knownCorruption);\n                throw new IOException(\"Detected corrupt journal files. \" + knownCorruption);\n            }\n\n            if (!missingJournalFiles.isEmpty()) {\n                LOG.error(\"Detected missing journal files. \" + missingJournalFiles);\n                throw new IOException(\"Detected missing journal files. \" + missingJournalFiles);\n            }\n        }\n\n        if (undoCounter > 0) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user\n            // should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Detected missing/corrupt journal files.  Dropped \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.put": "        MessageKeys put(Transaction tx, int priority, Long key, MessageKeys value) throws IOException {\n            if (priority == javax.jms.Message.DEFAULT_PRIORITY) {\n                return defaultPriorityIndex.put(tx, key, value);\n            } else if (priority > javax.jms.Message.DEFAULT_PRIORITY) {\n                return highPriorityIndex.put(tx, key, value);\n            } else {\n                return lowPriorityIndex.put(tx, key, value);\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.decrementAndSubSizeToStoreStat": "    protected void decrementAndSubSizeToStoreStat(KahaDestination kahaDestination, String subKey, long size) {\n        decrementAndSubSizeToStoreStat(key(kahaDestination), subKey, size);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.execute": "        public void execute(Transaction tx) throws IOException {\n            updateIndex(tx, command, location);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.load": "        void load(Transaction tx) throws IOException {\n            defaultPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            defaultPriorityIndex.setValueMarshaller(messageKeysMarshaller);\n            defaultPriorityIndex.load(tx);\n            lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            lowPriorityIndex.setValueMarshaller(messageKeysMarshaller);\n            lowPriorityIndex.load(tx);\n            highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            highPriorityIndex.setValueMarshaller(messageKeysMarshaller);\n            highPriorityIndex.load(tx);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(JournalCommand<?> data, boolean sync, IndexAware before, Runnable after, Runnable onJournalStoreComplete) throws IOException {\n        try {\n            ByteSequence sequence = toByteSequence(data);\n            Location location;\n\n            checkpointLock.readLock().lock();\n            try {\n\n                long start = System.currentTimeMillis();\n                location = onJournalStoreComplete == null ? journal.write(sequence, sync) : journal.write(sequence, onJournalStoreComplete) ;\n                long start2 = System.currentTimeMillis();\n                //Track the last async update so we know if we need to sync at the next checkpoint\n                if (!sync && journal.isJournalDiskSyncPeriodic()) {\n                    lastAsyncJournalUpdate.set(location);\n                }\n                process(data, location, before);\n\n                long end = System.currentTimeMillis();\n                if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Slow KahaDB access: Journal append took: \"+(start2-start)+\" ms, Index update took \"+(end-start2)+\" ms\");\n                    }\n                }\n            } finally {\n                checkpointLock.readLock().unlock();\n            }\n\n            if (after != null) {\n                after.run();\n            }\n\n            if (scheduler == null && opened.get()) {\n                startCheckpoint();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal, command of type: \" + data.type(), ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.updateIndex": "    void updateIndex(Transaction tx, KahaSubscriptionCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n        final String subscriptionKey = command.getSubscriptionKey();\n\n        // If set then we are creating it.. otherwise we are destroying the sub\n        if (command.hasSubscriptionInfo()) {\n            Location existing = sd.subLocations.get(tx, subscriptionKey);\n            if (existing != null && existing.compareTo(location) == 0) {\n                // replay on recovery, ignore\n                LOG.trace(\"ignoring journal replay of replay of sub from: \" + location);\n                return;\n            }\n\n            sd.subscriptions.put(tx, subscriptionKey, command);\n            sd.subLocations.put(tx, subscriptionKey, location);\n            long ackLocation=NOT_ACKED;\n            if (!command.getRetroactive()) {\n                ackLocation = sd.orderIndex.nextMessageId-1;\n            } else {\n                addAckLocationForRetroactiveSub(tx, sd, subscriptionKey);\n            }\n            sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(ackLocation));\n            sd.subscriptionCache.add(subscriptionKey);\n        } else {\n            // delete the sub...\n            sd.subscriptions.remove(tx, subscriptionKey);\n            sd.subLocations.remove(tx, subscriptionKey);\n            sd.subscriptionAcks.remove(tx, subscriptionKey);\n            sd.subscriptionCache.remove(subscriptionKey);\n            removeAckLocationsForSub(command, tx, sd, subscriptionKey);\n            MessageStoreSubscriptionStatistics subStats = getSubStats(key(command.getDestination()));\n            if (subStats != null) {\n                subStats.removeSubscription(subscriptionKey);\n            }\n\n            if (sd.subscriptions.isEmpty(tx)) {\n                // remove the stored destination\n                KahaRemoveDestinationCommand removeDestinationCommand = new KahaRemoveDestinationCommand();\n                removeDestinationCommand.setDestination(command.getDestination());\n                updateIndex(tx, removeDestinationCommand, null);\n                clearStoreStats(command.getDestination());\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.hasNext": "            public boolean hasNext() {\n                if (currentIterator == null) {\n                    if (highIterator != null) {\n                        if (highIterator.hasNext()) {\n                            currentIterator = highIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    } else {\n                        currentIterator = defaultIterator;\n                        return currentIterator.hasNext();\n                    }\n                }\n                if (highIterator != null) {\n                    if (currentIterator.hasNext()) {\n                        return true;\n                    }\n                    if (currentIterator == highIterator) {\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n\n                    if (currentIterator == defaultIterator) {\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                }\n                return currentIterator.hasNext();\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.sequenceAssignedWithIndexLocked": "        public void sequenceAssignedWithIndexLocked(long index);\n    }\n\n    public String getPreallocationScope() {",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException{\n            return new MessageOrderIterator(tx,m,this);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.allocate": "        void allocate(Transaction tx) throws IOException {\n            defaultPriorityIndex = new BTreeIndex<>(pageFile, tx.allocate());\n            if (metadata.version >= 2) {\n                lowPriorityIndex = new BTreeIndex<>(pageFile, tx.allocate());\n                highPriorityIndex = new BTreeIndex<>(pageFile, tx.allocate());\n            }\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.next": "            public Entry<Long, MessageKeys> next() {\n                Entry<Long, MessageKeys> result = currentIterator.next();\n                if (result != null) {\n                    Long key = result.getKey();\n                    if (highIterator != null) {\n                        if (currentIterator == defaultIterator) {\n                            lastDefaultKey = key;\n                        } else if (currentIterator == highIterator) {\n                            lastHighKey = key;\n                        } else {\n                            lastLowKey = key;\n                        }\n                    } else {\n                        lastDefaultKey = key;\n                    }\n                }\n                return result;\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    Set<Integer> checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {\n        MDC.put(\"activemq.persistenceDir\", getDirectory().getName());\n        LOG.debug(\"Checkpoint started.\");\n\n        // reflect last update exclusive of current checkpoint\n        Location lastUpdate = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit();\n        metadata.ackMessageFileMapLocation = checkpointAckMessageFileMap();\n        Location[] inProgressTxRange = getInProgressTxLocationRange();\n        metadata.firstInProgressTransactionLocation = inProgressTxRange[0];\n        tx.store(metadata.page, metadataMarshaller, true);\n\n        final TreeSet<Integer> gcCandidateSet = new TreeSet<>();\n        if (cleanup) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<>(journal.getFileMap().keySet());\n            gcCandidateSet.addAll(completeFileSet);\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Last update: \" + lastUpdate + \", full gc candidates set: \" + gcCandidateSet);\n            }\n\n            if (lastUpdate != null) {\n                // we won't delete past the last update, ackCompaction journal can be a candidate in error\n                gcCandidateSet.removeAll(new TreeSet<Integer>(gcCandidateSet.tailSet(lastUpdate.getDataFileId())));\n            }\n\n            // Don't GC files under replication\n            if( journalFilesBeingReplicated!=null ) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                int dataFileId = metadata.producerSequenceIdTrackerLocation.getDataFileId();\n                if (gcCandidateSet.contains(dataFileId) && gcCandidateSet.first() == dataFileId) {\n                    // rewrite so we don't prevent gc\n                    metadata.producerSequenceIdTracker.setModified(true);\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"rewriting producerSequenceIdTracker:\" + metadata.producerSequenceIdTrackerLocation);\n                    }\n                }\n                gcCandidateSet.remove(dataFileId);\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after producerSequenceIdTrackerLocation:\" + metadata.producerSequenceIdTrackerLocation + \", \" + gcCandidateSet);\n                }\n            }\n\n            if (metadata.ackMessageFileMapLocation != null) {\n                int dataFileId = metadata.ackMessageFileMapLocation.getDataFileId();\n                gcCandidateSet.remove(dataFileId);\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after ackMessageFileMapLocation:\" + metadata.ackMessageFileMapLocation + \", \" + gcCandidateSet);\n                }\n            }\n\n            // Don't GC files referenced by in-progress tx\n            if (inProgressTxRange[0] != null) {\n                for (int pendingTx=inProgressTxRange[0].getDataFileId(); pendingTx <= inProgressTxRange[1].getDataFileId(); pendingTx++) {\n                    gcCandidateSet.remove(pendingTx);\n                }\n            }\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates after in progress tx range:\" + Arrays.asList(inProgressTxRange) + \", \" + gcCandidateSet);\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if( gcCandidateSet.isEmpty() ) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last=-1;\n                    @Override\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if( first==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if( second==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    @Override\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n\n                // Durable Subscription\n                if (entry.getValue().subLocations != null) {\n                    Iterator<Entry<String, Location>> iter = entry.getValue().subLocations.iterator(tx);\n                    while (iter.hasNext()) {\n                        Entry<String, Location> subscription = iter.next();\n                        int dataFileId = subscription.getValue().getDataFileId();\n\n                        // Move subscription along if it has no outstanding messages that need ack'd\n                        // and its in the last log file in the journal.\n                        if (!gcCandidateSet.isEmpty() && gcCandidateSet.first() == dataFileId) {\n                            final StoredDestination destination = entry.getValue();\n                            final String subscriptionKey = subscription.getKey();\n                            SequenceSet pendingAcks = destination.ackPositions.get(tx, subscriptionKey);\n\n                            // When pending is size one that is the next message Id meaning there\n                            // are no pending messages currently.\n                            if (pendingAcks == null || pendingAcks.isEmpty() ||\n                                (pendingAcks.size() == 1 && pendingAcks.getTail().range() == 1)) {\n\n                                if (LOG.isTraceEnabled()) {\n                                    LOG.trace(\"Found candidate for rewrite: {} from file {}\", entry.getKey(), dataFileId);\n                                }\n\n                                final KahaSubscriptionCommand kahaSub =\n                                    destination.subscriptions.get(tx, subscriptionKey);\n                                destination.subLocations.put(\n                                    tx, subscriptionKey, checkpointSubscriptionCommand(kahaSub));\n\n                                // Skips the remove from candidates if we rewrote the subscription\n                                // in order to prevent duplicate subscription commands on recover.\n                                // If another subscription is on the same file and isn't rewritten\n                                // than it will remove the file from the set.\n                                continue;\n                            }\n                        }\n\n                        gcCandidateSet.remove(dataFileId);\n                    }\n                }\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n                }\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates: \" + gcCandidateSet);\n                LOG.trace(\"ackMessageFileMap: \" +  metadata.ackMessageFileMap);\n            }\n\n            boolean ackMessageFileMapMod = false;\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = metadata.ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidateSet.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don't delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        ackMessageFileMapMod |= (metadata.ackMessageFileMap.remove(candidate) != null);\n                    } else {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"not removing data file: \" + candidate\n                                    + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                        }\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                LOG.debug(\"Cleanup removing the data files: {}\", gcCandidateSet);\n                for (Integer candidate : gcCandidateSet) {\n                    for (Set<Integer> ackFiles : metadata.ackMessageFileMap.values()) {\n                        ackMessageFileMapMod |= ackFiles.remove(candidate);\n                    }\n                }\n                if (ackMessageFileMapMod) {\n                    checkpointUpdate(tx, false);\n                }\n            } else if (isEnableAckCompaction()) {\n                if (++checkPointCyclesWithNoGC >= getCompactAcksAfterNoGC()) {\n                    // First check length of journal to make sure it makes sense to even try.\n                    //\n                    // If there is only one journal file with Acks in it we don't need to move\n                    // it since it won't be chained to any later logs.\n                    //\n                    // If the logs haven't grown since the last time then we need to compact\n                    // otherwise there seems to still be room for growth and we don't need to incur\n                    // the overhead.  Depending on configuration this check can be avoided and\n                    // Ack compaction will run any time the store has not GC'd a journal file in\n                    // the configured amount of cycles.\n                    if (metadata.ackMessageFileMap.size() > 1 &&\n                        (journalLogOnLastCompactionCheck == journal.getCurrentDataFileId() || isCompactAcksIgnoresStoreGrowth())) {\n\n                        LOG.trace(\"No files GC'd checking if threshold to ACK compaction has been met.\");\n                        try {\n                            scheduler.execute(new AckCompactionRunner());\n                        } catch (Exception ex) {\n                            LOG.warn(\"Error on queueing the Ack Compactor\", ex);\n                        }\n                    } else {\n                        LOG.trace(\"Journal activity detected, no Ack compaction scheduled.\");\n                    }\n\n                    checkPointCyclesWithNoGC = 0;\n                } else {\n                    LOG.trace(\"Not yet time to check for compaction: {} of {} cycles\",\n                              checkPointCyclesWithNoGC, getCompactAcksAfterNoGC());\n                }\n\n                journalLogOnLastCompactionCheck = journal.getCurrentDataFileId();\n            }\n        }\n        MDC.remove(\"activemq.persistenceDir\");\n\n        LOG.debug(\"Checkpoint done.\");\n        return gcCandidateSet;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.loadStoredDestination": "    private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {\n        // Try to load the existing indexes..\n        StoredDestination rc = metadata.destinations.get(tx, key);\n        if (rc == null) {\n            // Brand new destination.. allocate indexes for it.\n            rc = new StoredDestination();\n            rc.orderIndex.allocate(tx);\n            rc.locationIndex = new BTreeIndex<>(pageFile, tx.allocate());\n            rc.messageIdIndex = new BTreeIndex<>(pageFile, tx.allocate());\n\n            if (topic) {\n                rc.subscriptions = new BTreeIndex<>(pageFile, tx.allocate());\n                rc.subscriptionAcks = new BTreeIndex<>(pageFile, tx.allocate());\n                rc.ackPositions = new ListIndex<>(pageFile, tx.allocate());\n                rc.subLocations = new ListIndex<>(pageFile, tx.allocate());\n            }\n            metadata.destinations.put(tx, key, rc);\n        }\n\n        // Configure the marshalers and load.\n        rc.orderIndex.load(tx);\n\n        // Figure out the next key using the last entry in the destination.\n        rc.orderIndex.configureLast(tx);\n\n        rc.locationIndex.setKeyMarshaller(new LocationSizeMarshaller());\n        rc.locationIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.locationIndex.load(tx);\n\n        rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);\n        rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.messageIdIndex.load(tx);\n\n        //go through an upgrade old index if older than version 6\n        if (metadata.version < 6) {\n            for (Iterator<Entry<Location, Long>> iterator = rc.locationIndex.iterator(tx); iterator.hasNext(); ) {\n                Entry<Location, Long> entry = iterator.next();\n                // modify so it is upgraded\n                rc.locationIndex.put(tx, entry.getKey(), entry.getValue());\n            }\n            //upgrade the order index\n            for (Iterator<Entry<Long, MessageKeys>> iterator = rc.orderIndex.iterator(tx); iterator.hasNext(); ) {\n                Entry<Long, MessageKeys> entry = iterator.next();\n                //call get so that the last priority is updated\n                rc.orderIndex.get(tx, entry.getKey());\n                rc.orderIndex.put(tx, rc.orderIndex.lastGetPriority(), entry.getKey(), entry.getValue());\n            }\n        }\n\n        // If it was a topic...\n        if (topic) {\n\n            rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);\n            rc.subscriptions.load(tx);\n\n            rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptionAcks.setValueMarshaller(new LastAckMarshaller());\n            rc.subscriptionAcks.load(tx);\n\n            rc.ackPositions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.ackPositions.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);\n            rc.ackPositions.load(tx);\n\n            rc.subLocations.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subLocations.setValueMarshaller(LocationMarshaller.INSTANCE);\n            rc.subLocations.load(tx);\n\n            rc.subscriptionCursors = new HashMap<>();\n\n            if (metadata.version < 3) {\n\n                // on upgrade need to fill ackLocation with available messages past last ack\n                for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                    Entry<String, LastAck> entry = iterator.next();\n                    for (Iterator<Entry<Long, MessageKeys>> orderIterator =\n                            rc.orderIndex.iterator(tx, new MessageOrderCursor(entry.getValue().lastAckedSequence)); orderIterator.hasNext(); ) {\n                        Long sequence = orderIterator.next().getKey();\n                        addAckLocation(tx, rc, sequence, entry.getKey());\n                    }\n                    // modify so it is upgraded\n                    rc.subscriptionAcks.put(tx, entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Configure the message references index\n            Iterator<Entry<String, SequenceSet>> subscriptions = rc.ackPositions.iterator(tx);\n            while (subscriptions.hasNext()) {\n                Entry<String, SequenceSet> subscription = subscriptions.next();\n                SequenceSet pendingAcks = subscription.getValue();\n                if (pendingAcks != null && !pendingAcks.isEmpty()) {\n                    Long lastPendingAck = pendingAcks.getTail().getLast();\n                    for (Long sequenceId : pendingAcks) {\n                        Long current = rc.messageReferences.get(sequenceId);\n                        if (current == null) {\n                            current = new Long(0);\n                        }\n\n                        // We always add a trailing empty entry for the next position to start from\n                        // so we need to ensure we don't count that as a message reference on reload.\n                        if (!sequenceId.equals(lastPendingAck)) {\n                            current = current.longValue() + 1;\n                        } else {\n                            current = Long.valueOf(0L);\n                        }\n\n                        rc.messageReferences.put(sequenceId, current);\n                    }\n                }\n            }\n\n            // Configure the subscription cache\n            for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                Entry<String, LastAck> entry = iterator.next();\n                rc.subscriptionCache.add(entry.getKey());\n            }\n\n            if (rc.orderIndex.nextMessageId == 0) {\n                // check for existing durable sub all acked out - pull next seq from acks as messages are gone\n                if (!rc.subscriptionAcks.isEmpty(tx)) {\n                    for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {\n                        Entry<String, LastAck> entry = iterator.next();\n                        rc.orderIndex.nextMessageId =\n                                Math.max(rc.orderIndex.nextMessageId, entry.getValue().lastAckedSequence +1);\n                    }\n                }\n            } else {\n                // update based on ackPositions for unmatched, last entry is always the next\n                if (!rc.messageReferences.isEmpty()) {\n                    Long nextMessageId = (Long) rc.messageReferences.keySet().toArray()[rc.messageReferences.size() - 1];\n                    rc.orderIndex.nextMessageId =\n                            Math.max(rc.orderIndex.nextMessageId, nextMessageId);\n                }\n            }\n        }\n\n        if (metadata.version < VERSION) {\n            // store again after upgrade\n            metadata.destinations.put(tx, key, rc);\n        }\n        return rc;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recover": "    private void recover() throws IllegalStateException, IOException {\n        this.indexLock.writeLock().lock();\n        try {\n\n            long start = System.currentTimeMillis();\n            boolean requiresJournalReplay = recoverProducerAudit();\n            requiresJournalReplay |= recoverAckMessageFileMap();\n            Location lastIndoubtPosition = getRecoveryPosition();\n            Location recoveryPosition = requiresJournalReplay ? journal.getNextLocation(null) : lastIndoubtPosition;\n            if (recoveryPosition != null) {\n                int redoCounter = 0;\n                int dataFileRotationTracker = recoveryPosition.getDataFileId();\n                LOG.info(\"Recovering from the journal @\" + recoveryPosition);\n                while (recoveryPosition != null) {\n                    try {\n                        JournalCommand<?> message = load(recoveryPosition);\n                        metadata.lastUpdate = recoveryPosition;\n                        process(message, recoveryPosition, lastIndoubtPosition);\n                        redoCounter++;\n                    } catch (IOException failedRecovery) {\n                        if (isIgnoreMissingJournalfiles()) {\n                            LOG.debug(\"Failed to recover data at position:\" + recoveryPosition, failedRecovery);\n                            // track this dud location\n                            journal.corruptRecoveryLocation(recoveryPosition);\n                        } else {\n                            throw new IOException(\"Failed to recover data at position:\" + recoveryPosition, failedRecovery);\n                        }\n                    }\n                    recoveryPosition = journal.getNextLocation(recoveryPosition);\n                    // hold on to the minimum number of open files during recovery\n                    if (recoveryPosition != null && dataFileRotationTracker != recoveryPosition.getDataFileId()) {\n                        dataFileRotationTracker = recoveryPosition.getDataFileId();\n                        journal.cleanup();\n                    }\n                    if (LOG.isInfoEnabled() && redoCounter % 100000 == 0) {\n                        LOG.info(\"@\" + recoveryPosition + \", \" + redoCounter + \" entries recovered ..\");\n                    }\n                }\n                if (LOG.isInfoEnabled()) {\n                    long end = System.currentTimeMillis();\n                    LOG.info(\"Recovery replayed \" + redoCounter + \" operations from the journal in \" + ((end - start) / 1000.0f) + \" seconds.\");\n                }\n            }\n\n            // We may have to undo some index updates.\n            pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                @Override\n                public void execute(Transaction tx) throws IOException {\n                    recoverIndex(tx);\n                }\n            });\n\n            // rollback any recovered inflight local transactions, and discard any inflight XA transactions.\n            Set<TransactionId> toRollback = new HashSet<>();\n            Set<TransactionId> toDiscard = new HashSet<>();\n            synchronized (inflightTransactions) {\n                for (Iterator<TransactionId> it = inflightTransactions.keySet().iterator(); it.hasNext(); ) {\n                    TransactionId id = it.next();\n                    if (id.isLocalTransaction()) {\n                        toRollback.add(id);\n                    } else {\n                        toDiscard.add(id);\n                    }\n                }\n                for (TransactionId tx: toRollback) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"rolling back recovered indoubt local transaction \" + tx);\n                    }\n                    store(new KahaRollbackCommand().setTransactionInfo(TransactionIdConversion.convertToLocal(tx)), false, null, null);\n                }\n                for (TransactionId tx: toDiscard) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"discarding recovered in-flight XA transaction \" + tx);\n                    }\n                    inflightTransactions.remove(tx);\n                }\n            }\n\n            synchronized (preparedTransactions) {\n                for (TransactionId txId : preparedTransactions.keySet()) {\n                    LOG.warn(\"Recovered prepared XA TX: [{}]\", txId);\n                }\n            }\n\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getRecoveryPosition": "    private Location getRecoveryPosition() throws IOException {\n\n        if (!this.forceRecoverIndex) {\n\n            // If we need to recover the transactions..\n            if (metadata.firstInProgressTransactionLocation != null) {\n                return metadata.firstInProgressTransactionLocation;\n            }\n\n            // Perhaps there were no transactions...\n            if( metadata.lastUpdate!=null) {\n                // Start replay at the record after the last one recorded in the index file.\n                return getNextInitializedLocation(metadata.lastUpdate);\n            }\n        }\n        // This loads the first position.\n        return journal.getNextLocation(null);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.remove": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverProducerAudit": "    private boolean recoverProducerAudit() throws IOException {\n        boolean requiresReplay = true;\n        if (metadata.producerSequenceIdTrackerLocation != null) {\n            try {\n                KahaProducerAuditCommand audit = (KahaProducerAuditCommand) load(metadata.producerSequenceIdTrackerLocation);\n                ObjectInputStream objectIn = new ObjectInputStream(audit.getAudit().newInput());\n                int maxNumProducers = getMaxFailoverProducersToTrack();\n                int maxAuditDepth = getFailoverProducersAuditDepth();\n                metadata.producerSequenceIdTracker = (ActiveMQMessageAuditNoSync) objectIn.readObject();\n                metadata.producerSequenceIdTracker.setAuditDepth(maxAuditDepth);\n                metadata.producerSequenceIdTracker.setMaximumNumberOfProducersToTrack(maxNumProducers);\n                requiresReplay = false;\n            } catch (Exception e) {\n                LOG.warn(\"Cannot recover message audit\", e);\n            }\n        }\n        // got no audit stored so got to recreate via replay from start of the journal\n        return requiresReplay;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverAckMessageFileMap": "    private boolean recoverAckMessageFileMap() throws IOException {\n        boolean requiresReplay = true;\n        if (metadata.ackMessageFileMapLocation != null) {\n            try {\n                KahaAckMessageFileMapCommand audit = (KahaAckMessageFileMapCommand) load(metadata.ackMessageFileMapLocation);\n                ObjectInputStream objectIn = new ObjectInputStream(audit.getAckMessageFileMap().newInput());\n                metadata.ackMessageFileMap = (Map<Integer, Set<Integer>>) objectIn.readObject();\n                requiresReplay = false;\n            } catch (Exception e) {\n                LOG.warn(\"Cannot recover ackMessageFileMap\", e);\n            }\n        }\n        // got no ackMessageFileMap stored so got to recreate via replay from start of the journal\n        return requiresReplay;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.isIgnoreMissingJournalfiles": "    public boolean isIgnoreMissingJournalfiles() {\n        return ignoreMissingJournalfiles;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.process": "    protected void process(KahaRewrittenDataFileCommand command, Location location)  throws IOException {\n        final TreeSet<Integer> completeFileSet = new TreeSet<>(journal.getFileMap().keySet());\n\n        // Mark the current journal file as a compacted file so that gc checks can skip\n        // over logs that are smaller compaction type logs.\n        DataFile current = journal.getDataFileById(location.getDataFileId());\n        current.setTypeCode(command.getRewriteType());\n\n        if (completeFileSet.contains(command.getSourceDataFileId()) && command.getSkipIfSourceExists()) {\n            // Move offset so that next location read jumps to next file.\n            location.setOffset(journalMaxFileLength);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.open": "    public void open() throws IOException {\n        if( opened.compareAndSet(false, true) ) {\n            getJournal().start();\n            try {\n                loadPageFile();\n            } catch (Throwable t) {\n                LOG.warn(\"Index corrupted. Recovering the index through journal replay. Cause:\" + t);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Index load failure\", t);\n                }\n                // try to recover index\n                try {\n                    pageFile.unload();\n                } catch (Exception ignore) {}\n                if (archiveCorruptedIndex) {\n                    pageFile.archive();\n                } else {\n                    pageFile.delete();\n                }\n                metadata = createMetadata();\n                //The metadata was recreated after a detect corruption so we need to\n                //reconfigure anything that was configured on the old metadata on startup\n                configureMetadata();\n                pageFile = null;\n                loadPageFile();\n            }\n            recover();\n            startCheckpoint();\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.loadPageFile": "    private void loadPageFile() throws IOException {\n        this.indexLock.writeLock().lock();\n        try {\n            final PageFile pageFile = getPageFile();\n            pageFile.load();\n            pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                @Override\n                public void execute(Transaction tx) throws IOException {\n                    if (pageFile.getPageCount() == 0) {\n                        // First time this is created.. Initialize the metadata\n                        Page<Metadata> page = tx.allocate();\n                        assert page.getPageId() == 0;\n                        page.set(metadata);\n                        metadata.page = page;\n                        metadata.state = CLOSED_STATE;\n                        metadata.destinations = new BTreeIndex<>(pageFile, tx.allocate().getPageId());\n\n                        tx.store(metadata.page, metadataMarshaller, true);\n                    } else {\n                        Page<Metadata> page = tx.load(0, metadataMarshaller);\n                        metadata = page.get();\n                        metadata.page = page;\n                    }\n                    metadata.destinations.setKeyMarshaller(StringMarshaller.INSTANCE);\n                    metadata.destinations.setValueMarshaller(new StoredDestinationMarshaller());\n                    metadata.destinations.load(tx);\n                }\n            });\n            // Load up all the destinations since we need to scan all the indexes to figure out which journal files can be deleted.\n            // Perhaps we should just keep an index of file\n            storedDestinations.clear();\n            pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                @Override\n                public void execute(Transaction tx) throws IOException {\n                    for (Iterator<Entry<String, StoredDestination>> iterator = metadata.destinations.iterator(tx); iterator.hasNext();) {\n                        Entry<String, StoredDestination> entry = iterator.next();\n                        StoredDestination sd = loadStoredDestination(tx, entry.getKey(), entry.getValue().subscriptions!=null);\n                        storedDestinations.put(entry.getKey(), sd);\n\n                        if (checkForCorruptJournalFiles) {\n                            // sanity check the index also\n                            if (!entry.getValue().locationIndex.isEmpty(tx)) {\n                                if (entry.getValue().orderIndex.nextMessageId <= 0) {\n                                    throw new IOException(\"Detected uninitialized orderIndex nextMessageId with pending messages for \" + entry.getKey());\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            pageFile.flush();\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.createMetadata": "    private Metadata createMetadata() {\n        Metadata md = new Metadata();\n        md.producerSequenceIdTracker.setAuditDepth(getFailoverProducersAuditDepth());\n        md.producerSequenceIdTracker.setMaximumNumberOfProducersToTrack(getMaxFailoverProducersToTrack());\n        return md;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.configureMetadata": "    protected abstract void configureMetadata();\n\n    public int getJournalMaxWriteBatchSize() {\n        return journalMaxWriteBatchSize;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getJournal": "    public Journal getJournal() throws IOException {\n        if (journal == null) {\n            journal = createJournal();\n        }\n        return journal;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.startCheckpoint": "    private void startCheckpoint() {\n        if (checkpointInterval == 0 && cleanupInterval == 0) {\n            LOG.info(\"periodic checkpoint/cleanup disabled, will ocurr on clean shutdown/restart\");\n            return;\n        }\n        synchronized (schedulerLock) {\n            if (scheduler == null || scheduler.isShutdown()) {\n                scheduler = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n\n                    @Override\n                    public Thread newThread(Runnable r) {\n                        Thread schedulerThread = new Thread(r);\n\n                        schedulerThread.setName(\"ActiveMQ Journal Checkpoint Worker\");\n                        schedulerThread.setDaemon(true);\n\n                        return schedulerThread;\n                    }\n                });\n\n                // Short intervals for check-point and cleanups\n                long delay;\n                if (journal.isJournalDiskSyncPeriodic()) {\n                    delay = Math.min(journalDiskSyncInterval > 0 ? journalDiskSyncInterval : checkpointInterval, 500);\n                } else {\n                    delay = Math.min(checkpointInterval > 0 ? checkpointInterval : cleanupInterval, 500);\n                }\n\n                scheduler.scheduleWithFixedDelay(new CheckpointRunner(), 0, delay, TimeUnit.MILLISECONDS);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.unload": "    public void unload() throws IOException, InterruptedException {\n        this.indexLock.writeLock().lock();\n        try {\n            if( pageFile != null && pageFile.isLoaded() ) {\n                metadata.state = CLOSED_STATE;\n                metadata.firstInProgressTransactionLocation = getInProgressTxLocationRange()[0];\n\n                if (metadata.page != null) {\n                    pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                        @Override\n                        public void execute(Transaction tx) throws IOException {\n                            tx.store(metadata.page, metadataMarshaller, true);\n                        }\n                    });\n                }\n            }\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n        close();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.doStart": "    public void doStart() throws Exception {\n        load();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.doStart": "    public void doStart() throws Exception {\n        //configure the metadata before start, right now\n        //this is just the open wire version\n        configureMetadata();\n\n        super.doStart();\n\n        if (brokerService != null) {\n            // In case the recovered store used a different OpenWire version log a warning\n            // to assist in determining why journal reads fail.\n            if (metadata.openwireVersion != brokerService.getStoreOpenWireVersion()) {\n                LOG.warn(\"Existing Store uses a different OpenWire version[{}] \" +\n                         \"than the version configured[{}] reverting to the version \" +\n                         \"used by this store, some newer broker features may not work\" +\n                         \"as expected.\",\n                         metadata.openwireVersion, brokerService.getStoreOpenWireVersion());\n\n                // Update the broker service instance to the actual version in use.\n                wireFormat.setVersion(metadata.openwireVersion);\n                brokerService.setStoreOpenWireVersion(metadata.openwireVersion);\n            }\n        }\n\n        this.globalQueueSemaphore = new Semaphore(getMaxAsyncJobs());\n        this.globalTopicSemaphore = new Semaphore(getMaxAsyncJobs());\n        this.asyncQueueJobQueue = new LinkedBlockingQueue<Runnable>(getMaxAsyncJobs());\n        this.asyncTopicJobQueue = new LinkedBlockingQueue<Runnable>(getMaxAsyncJobs());\n        this.queueExecutor = new StoreTaskExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,\n            asyncQueueJobQueue, new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable runnable) {\n                    Thread thread = new Thread(runnable, \"ConcurrentQueueStoreAndDispatch\");\n                    thread.setDaemon(true);\n                    return thread;\n                }\n            });\n        this.topicExecutor = new StoreTaskExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,\n            asyncTopicJobQueue, new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable runnable) {\n                    Thread thread = new Thread(runnable, \"ConcurrentTopicStoreAndDispatch\");\n                    thread.setDaemon(true);\n                    return thread;\n                }\n            });\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.configureMetadata": "    protected void configureMetadata() {\n        if (brokerService != null) {\n            metadata.openwireVersion = brokerService.getStoreOpenWireVersion();\n            wireFormat.setVersion(metadata.openwireVersion);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Store OpenWire version configured as: {}\", metadata.openwireVersion);\n            }\n\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.getMaxAsyncJobs": "    public int getMaxAsyncJobs() {\n        return this.maxAsyncJobs;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.util.ServiceSupport.start": "    public void start() throws Exception {\n        if (started.compareAndSet(false, true)) {\n            boolean success = false;\n            stopped.set(false);\n            try {\n                preStart();\n                doStart();\n                success = true;\n            } finally {\n                started.set(success);\n            }\n            for(ServiceListener l:this.serviceListeners) {\n                l.started(this);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.util.ServiceSupport.doStart": "    protected abstract void doStart() throws Exception;\n}",
            "activemq-client.src.main.java.org.apache.activemq.util.ServiceSupport.preStart": "    protected void preStart() throws Exception {}",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter.doStart": "    public void doStart() throws Exception {\n        this.letter.start();\n\n        if (brokerService != null && brokerService.isUseJmx()) {\n            PersistenceAdapterView view = new PersistenceAdapterView(this);\n            view.setInflightTransactionViewCallable(new Callable<String>() {\n                @Override\n                public String call() throws Exception {\n                    return letter.getTransactions();\n                }\n            });\n            view.setDataViewCallable(new Callable<String>() {\n                @Override\n                public String call() throws Exception {\n                    return letter.getJournal().getFileMap().keySet().toString();\n                }\n            });\n            AnnotatedMBean.registerMBean(brokerService.getManagementContext(), view,\n                    createPersistenceAdapterName(brokerService.getBrokerObjectName().toString(), toString()));\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter.toString": "    public String toString() {\n        String path = getDirectory() != null ? getDirectory().getAbsolutePath() : \"DIRECTORY_NOT_SET\";\n        return \"KahaDBPersistenceAdapter[\" + path + (getIndexDirectory() != null ? \",Index:\" + getIndexDirectory().getAbsolutePath() : \"\") +  \"]\";\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.TransactionIdConversion.convertToLocal": "    static KahaTransactionInfo convertToLocal(TransactionId tx) {\n        KahaTransactionInfo rc = new KahaTransactionInfo();\n        LocalTransactionId t = (LocalTransactionId) tx;\n        KahaLocalTransactionId kahaTxId = new KahaLocalTransactionId();\n        kahaTxId.setConnectionId(t.getConnectionId().getValue());\n        kahaTxId.setTransactionId(t.getValue());\n        rc.setLocalTransactionId(kahaTxId);\n        return rc;\n    }"
        },
        "bug_report": {
            "Title": "Broker fails to start complaining about missing/corrupt journal files after upgrading to 5.15.1",
            "Description": "{code}\r\n2017-10-09 12:29:36.802 ERROR 4197 --- [pool-3-thread-1] org.deku.leoz.node.Application           : java.io.IOException: Detected missing/corrupt journal files referenced by:[0:ActiveMQ.DLQ] 3 messages affected.\r\n\r\njava.lang.Error: java.io.IOException: Detected missing/corrupt journal files referenced by:[0:ActiveMQ.DLQ] 3 messages affected.\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1148) ~[na:1.8.0_131]\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_131]\r\n\tat java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_131]\r\nCaused by: java.io.IOException: Detected missing/corrupt journal files referenced by:[0:ActiveMQ.DLQ] 3 messages affected.\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex(MessageDatabase.java:965) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase$5.execute(MessageDatabase.java:717) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.recover(MessageDatabase.java:714) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.open(MessageDatabase.java:473) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.load(MessageDatabase.java:493) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.MessageDatabase.doStart(MessageDatabase.java:297) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.KahaDBStore.doStart(KahaDBStore.java:219) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.util.ServiceSupport.start(ServiceSupport.java:55) ~[activemq-client-5.15.1.jar:5.15.1]\r\n\tat org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter.doStart(KahaDBPersistenceAdapter.java:232) ~[activemq-kahadb-store-5.15.1.jar:5.15.1]\r\n{code}\r\n\r\nDowngrading to 5.15.0 resolves the problem.\r\nThis is an embedded broker setup, using\r\n\r\n{code:none}\r\n        val pa = brokerService.persistenceAdapter as KahaDBPersistenceAdapter\r\n        pa.isCheckForCorruptJournalFiles = true\r\n        pa.isIgnoreMissingJournalfiles = false\r\n{code}"
        }
    },
    {
        "filename": "AMQ-5525.json",
        "creation_time": "2015-01-19T13:47:50.000+0000",
        "stack_trace": "java.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)\n\tat org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)\n\tat org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)\n\tat org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)\n\tat org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)\n\tat org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)\n\tat org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)\n\tat org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)\n\tat org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:356)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)",
        "source_code": {
            "activemq-karaf.src.main.java.org.apache.activemq.karaf.commands.ActiveMQCommand.convert": "        protected Object convert(Action action, CommandSession commandSession, Object o, Type type) throws Exception {\n            return blueprintConverter.convert(o, new GenericType(type));\n        }",
            "activemq-karaf.src.main.java.org.apache.activemq.karaf.commands.ActiveMQCommand.prepare": "        public boolean prepare(Action action, CommandSession session, List<Object> params) throws Exception\n        {\n            Map<Argument, Field> arguments = new HashMap<Argument, Field>();\n            List<Argument> orderedArguments = new ArrayList<Argument>();\n            // Introspect\n            for (Class type = action.getClass(); type != null; type = type.getSuperclass()) {\n                for (Field field : type.getDeclaredFields()) {\n                    Argument argument = field.getAnnotation(Argument.class);\n                    if (argument != null) {\n                        arguments.put(argument, field);\n                        int index = argument.index();\n                        while (orderedArguments.size() <= index) {\n                            orderedArguments.add(null);\n                        }\n                        if (orderedArguments.get(index) != null) {\n                            throw new IllegalArgumentException(\"Duplicate argument index: \" + index);\n                        }\n                        orderedArguments.set(index, argument);\n                    }\n                }\n            }\n            // Check indexes are correct\n            for (int i = 0; i < orderedArguments.size(); i++) {\n                if (orderedArguments.get(i) == null) {\n                    throw new IllegalArgumentException(\"Missing argument for index: \" + i);\n                }\n            }\n            // Populate\n            Map<Argument, Object> argumentValues = new HashMap<Argument, Object>();\n            int argIndex = 0;\n            for (Iterator<Object> it = params.iterator(); it.hasNext();) {\n                Object param = it.next();\n                if (argIndex >= orderedArguments.size()) {\n                    throw new IllegalArgumentException(\"Too many arguments specified\");\n                }\n                Argument argument = orderedArguments.get(argIndex);\n                if (!argument.multiValued()) {\n                    argIndex++;\n                }\n                if (argument.multiValued()) {\n                    List<Object> l = (List<Object>) argumentValues.get(argument);\n                    if (l == null) {\n                        l = new ArrayList<Object>();\n                        argumentValues.put(argument, l);\n                    }\n                    l.add(param);\n                } else {\n                    argumentValues.put(argument, param);\n                }\n            }\n\n            for (Map.Entry<Argument, Object> entry : argumentValues.entrySet()) {\n                Field field = arguments.get(entry.getKey());\n                Object value = convert(action, session, entry.getValue(), field.getGenericType());\n                field.setAccessible(true);\n                field.set(action, value);\n            }\n            return true;\n        }"
        },
        "bug_report": {
            "Title": "error converting collection entry - activemq:browse karaf command  via itests",
            "Description": "failures:\n{code}  ActiveMQAMQPBrokerFeatureTest>ActiveMQBrokerFeatureTest.test:70->AbstractFeatureTest.withinReason:259 expected:<[JMS_BODY_FIELD:JMSText = 1421674632296]> but was:<[]>\n  ActiveMQBrokerFeatureTest.test:70->AbstractFeatureTest.withinReason:259 expected:<[JMS_BODY_FIELD:JMSText = 1421674680492]> but was:<[]>{code} root cause - somewhere in blueprint converter. \n{code}java.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)\n\tat org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)\n\tat org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)\n\tat org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)\n\tat org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)\n\tat org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)\n\tat org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)\n\tat org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)\n\tat org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:356)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.Exception: Unable to convert value 1421674680492 to type java.lang.String\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:184)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:340)\n\t... 30 more\n2015-01-19 13:38:05,367 | ERROR | Thread-30        | AbstractFeatureTest              | 125 - PAXEXAM-PROBE-a407b767-4b95-4f93-8124-64d04dc65582 - 0.0.0 | Execute: activemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492 - Response:\nactivemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492\njava.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)\n\tat org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)\n\tat org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)\n\tat org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)\n\tat org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)\n\tat org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)\n\tat org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)\n\tat org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)\n\tat org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:356)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.Exception: Unable to convert value 1421674680492 to type java.lang.String\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:184)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:340)\n\t... 30 more\n2015-01-19 13:38:06,379 | ERROR | Thread-30        | AbstractFeatureTest              | 125 - PAXEXAM-PROBE-a407b767-4b95-4f93-8124-64d04dc65582 - 0.0.0 | Execute: activemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492 - Response:\nactivemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492\njava.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)\n\tat org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)\n\tat org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)\n\tat org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)\n\tat org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)\n\tat org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)\n\tat org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)\n\tat org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)\n\tat org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:356)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.Exception: Unable to convert value 1421674680492 to type java.lang.String\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:184)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:340)\n\t... 30 more\n2015-01-19 13:38:07,390 | ERROR | Thread-30        | AbstractFeatureTest              | 125 - PAXEXAM-PROBE-a407b767-4b95-4f93-8124-64d04dc65582 - 0.0.0 | Execute: activemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492 - Response:\nactivemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492\njava.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)\n\tat org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)\n\tat org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)\n\tat org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)\n\tat org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)\n\tat org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)\n\tat org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)\n\tat org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)\n\tat org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:356)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.Exception: Unable to convert value 1421674680492 to type java.lang.String\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:184)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:340)\n\t... 30 more\n2015-01-19 13:38:08,400 | ERROR | Thread-30        | AbstractFeatureTest              | 125 - PAXEXAM-PROBE-a407b767-4b95-4f93-8124-64d04dc65582 - 0.0.0 | Execute: activemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492 - Response:\nactivemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492\njava.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)\n\tat org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)\n\tat org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)\n\tat org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)\n\tat org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)\n\tat org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)\n\tat org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)\n\tat org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)\n\tat org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)\n\tat org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)\n\tat org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:356)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)\n\tat org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.Exception: Unable to convert value 1421674680492 to type java.lang.String\n\tat org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:184)\n\tat org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:340){code}"
        }
    },
    {
        "filename": "AMQ-4118.json",
        "creation_time": "2012-10-19T22:14:13.000+0000",
        "stack_trace": "java.io.EOFException: Chunk stream does not exist, page: 1344 is marked free\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:481)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:458)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:455)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:431)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:388)\n\tat org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)\n\tat org.apache.kahadb.index.BTreeNode.getChild(BTreeNode.java:225)\n\tat org.apache.kahadb.index.BTreeNode.getLeafNode(BTreeNode.java:680)\n\tat org.apache.kahadb.index.BTreeNode.get(BTreeNode.java:562)\n\tat org.apache.kahadb.index.BTreeIndex.get(BTreeIndex.java:184)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.get(MessageDatabase.java:2616)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.updateIndex(MessageDatabase.java:1210)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$15.execute(MessageDatabase.java:1002)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:790)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1000)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:933)\n\tat org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand.visit(KahaRemoveMessageCommand.java:220)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:925)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:837)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:819)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBTopicMessageStore.doAcknowledge(KahaDBStore.java:723)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBTopicMessageStore.acknowledge(KahaDBStore.java:706)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore.acknowledge(KahaDBTransactionStore.java:519)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore$2.acknowledge(KahaDBTransactionStore.java:222)\n\tat org.apache.activemq.broker.region.Topic.acknowledge(Topic.java:528)\n\tat org.apache.activemq.broker.region.DurableTopicSubscription.acknowledge(DurableTopicSubscription.java:279)\n\tat ..{code}\n{code}java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.String\n        at java.lang.String.compareTo(String.java:92)\n        at java.util.Arrays.binarySearch0(Arrays.java:2001)\n        at java.util.Arrays.binarySearch(Arrays.java:1943)\n        at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:371)\n        at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:369)       \n        at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)        \nat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.put(MessageDatabase.java:2592)\n        at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1168)        at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:2082)        at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:1095)        at org.apache.kahadb.page.Transaction.execute(Transaction.java:768)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1092)\n        at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)\n        at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:943)\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:855)\n        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:267)\n        at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)\n...{code}\n{code}java.lang.NullPointerException\n        at org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:264)\n        at org.apache.kahadb.index.BTreeNode.getChild(BTreeNode.java:225)\n        at org.apache.kahadb.index.BTreeNode.getLeafNode(BTreeNode.java:676)\n        at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:369)\n        at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)\n        at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.put(MessageDatabase.java:2592)\n        at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1168)\n        at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:2082)\n        at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:1095)\n        at org.apache.kahadb.page.Transaction.execute(Transaction.java:768)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1092)\n        at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)\n        at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:943)\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:855)\n        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:267)",
        "source_code": {
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeIndex.loadNode": "    BTreeNode<Key,Value> loadNode(Transaction tx, long pageId, BTreeNode<Key,Value> parent) throws IOException {\n        Page<BTreeNode<Key,Value>> page = tx.load(pageId, marshaller);\n        BTreeNode<Key, Value> node = page.get();\n        node.setPage(page);\n        node.setParent(parent);\n        return node;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeIndex.get": "    synchronized public Value get(Transaction tx, Key key) throws IOException {\n        assertLoaded();\n        return getRoot(tx).get(tx, key);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeIndex.load": "    synchronized public void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            LOG.debug(\"loading\");\n            if( keyMarshaller == null ) {\n                throw new IllegalArgumentException(\"The key marshaller must be set before loading the BTreeIndex\");\n            }\n            if( valueMarshaller == null ) {\n                throw new IllegalArgumentException(\"The value marshaller must be set before loading the BTreeIndex\");\n            }\n            \n            final Page<BTreeNode<Key,Value>> p = tx.load(pageId, null);\n            if( p.getType() == Page.PAGE_FREE_TYPE ) {\n                 // Need to initialize it..\n                BTreeNode<Key, Value> root = createNode(p, null);\n                storeNode(tx, root, true);\n            }\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.getChild": "    private BTreeNode<Key,Value> getChild(Transaction tx, int idx) throws IOException {\n        if (isBranch() && idx >= 0 && idx < children.length) {\n            BTreeNode<Key, Value> result = this.index.loadNode(tx, children[idx], this);\n            return result;\n        } else {\n            return null;\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.isBranch": "    private boolean isBranch() {\n        return children!=null;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.getLeafNode": "    private static <Key,Value> BTreeNode<Key, Value> getLeafNode(Transaction tx, final BTreeNode<Key, Value> node, Key key) throws IOException {\n        BTreeNode<Key, Value> current = node;\n        while( true ) {\n            if( current.isBranch() ) {\n                int idx = Arrays.binarySearch(current.keys, key);\n                idx = idx < 0 ? -(idx + 1) : idx + 1;\n                BTreeNode<Key, Value> child = current.getChild(tx, idx);        \n\n                // A little cycle detection for sanity's sake\n                if( child == node ) {\n                    throw new IOException(\"BTree corrupted: Cylce detected.\");\n                }\n                \n                current = child;\n            } else {\n                break;\n            }\n        }\n        return current;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.get": "    public Value get(Transaction tx, Key key) throws IOException {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Key cannot be null\");\n        }\n        if( isBranch() ) {\n            return getLeafNode(tx, this, key).get(tx, key);\n        } else {\n            int idx = Arrays.binarySearch(keys, key);\n            if (idx < 0) {\n                return null;\n            } else {\n                return values[idx];\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.updateIndex": "    void updateIndex(Transaction tx, KahaSubscriptionCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n        final String subscriptionKey = command.getSubscriptionKey();\n\n        // If set then we are creating it.. otherwise we are destroying the sub\n        if (command.hasSubscriptionInfo()) {\n            sd.subscriptions.put(tx, subscriptionKey, command);\n            long ackLocation=NOT_ACKED;\n            if (!command.getRetroactive()) {\n                ackLocation = sd.orderIndex.nextMessageId-1;\n            } else {\n                addAckLocationForRetroactiveSub(tx, sd, subscriptionKey);\n            }\n            sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(ackLocation));\n            sd.subscriptionCache.add(subscriptionKey);\n        } else {\n            // delete the sub...\n            sd.subscriptions.remove(tx, subscriptionKey);\n            sd.subscriptionAcks.remove(tx, subscriptionKey);\n            sd.subscriptionCache.remove(subscriptionKey);\n            removeAckLocationsForSub(tx, sd, subscriptionKey);\n\n            if (sd.subscriptions.isEmpty(tx)) {\n                sd.messageIdIndex.clear(tx);\n                sd.locationIndex.clear(tx);\n                sd.orderIndex.clear(tx);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.addAckLocationForRetroactiveSub": "    private void addAckLocationForRetroactiveSub(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {\n        SequenceSet allOutstanding = new SequenceSet();\n        Iterator<Map.Entry<String, SequenceSet>> iterator = sd.ackPositions.iterator(tx);\n        while (iterator.hasNext()) {\n            SequenceSet set = iterator.next().getValue();\n            for (Long entry : set) {\n                allOutstanding.add(entry);\n            }\n        }\n        sd.ackPositions.put(tx, subscriptionKey, allOutstanding);\n\n        for (Long ackPosition : allOutstanding) {\n            Long count = sd.messageReferences.get(ackPosition);\n            count = count.longValue() + 1;\n            sd.messageReferences.put(ackPosition, count);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getStoredDestination": "    protected StoredDestination getStoredDestination(KahaDestination destination, Transaction tx) throws IOException {\n        String key = key(destination);\n        StoredDestination rc = storedDestinations.get(key);\n        if (rc == null) {\n            boolean topic = destination.getType() == KahaDestination.DestinationType.TOPIC || destination.getType() == KahaDestination.DestinationType.TEMP_TOPIC;\n            rc = loadStoredDestination(tx, key, topic);\n            // Cache it. We may want to remove/unload destinations from the\n            // cache that are not used for a while\n            // to reduce memory usage.\n            storedDestinations.put(key, rc);\n        }\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recordAckMessageReferenceLocation": "    private void recordAckMessageReferenceLocation(Location ackLocation, Location messageLocation) {\n        Set<Integer> referenceFileIds = ackMessageFileMap.get(Integer.valueOf(ackLocation.getDataFileId()));\n        if (referenceFileIds == null) {\n            referenceFileIds = new HashSet<Integer>();\n            referenceFileIds.add(messageLocation.getDataFileId());\n            ackMessageFileMap.put(ackLocation.getDataFileId(), referenceFileIds);\n        } else {\n            Integer id = Integer.valueOf(messageLocation.getDataFileId());\n            if (!referenceFileIds.contains(id)) {\n                referenceFileIds.add(id);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.key": "    private TransactionId key(KahaTransactionInfo transactionInfo) {\n        return TransactionIdConversion.convert(transactionInfo);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.removeAckLocation": "    private void removeAckLocation(Transaction tx, StoredDestination sd, String subscriptionKey, Long messageSequence) throws IOException {\n        // Remove the sub from the previous location set..\n        if (messageSequence != null) {\n            SequenceSet range = sd.ackPositions.get(tx, subscriptionKey);\n            if (range != null && !range.isEmpty()) {\n                range.remove(messageSequence);\n                if (!range.isEmpty()) {\n                    sd.ackPositions.put(tx, subscriptionKey, range);\n                } else {\n                    sd.ackPositions.remove(tx, subscriptionKey);\n                }\n\n                // Check if the message is reference by any other subscription.\n                Long count = sd.messageReferences.get(messageSequence);\n                if (count != null){\n                long references = count.longValue() - 1;\n                    if (references > 0) {\n                        sd.messageReferences.put(messageSequence, Long.valueOf(references));\n                        return;\n                    } else {\n                        sd.messageReferences.remove(messageSequence);\n                    }\n                }\n\n                // Find all the entries that need to get deleted.\n                ArrayList<Entry<Long, MessageKeys>> deletes = new ArrayList<Entry<Long, MessageKeys>>();\n                sd.orderIndex.getDeleteList(tx, deletes, messageSequence);\n\n                // Do the actual deletes.\n                for (Entry<Long, MessageKeys> entry : deletes) {\n                    sd.locationIndex.remove(tx, entry.getValue().location);\n                    sd.messageIdIndex.remove(tx, entry.getValue().messageId);\n                    sd.orderIndex.remove(tx, entry.getKey());\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.removeAckLocationsForSub": "    private void removeAckLocationsForSub(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {\n        if (!sd.ackPositions.isEmpty(tx)) {\n            SequenceSet sequences = sd.ackPositions.remove(tx, subscriptionKey);\n            if (sequences == null || sequences.isEmpty()) {\n                return;\n            }\n\n            ArrayList<Long> unreferenced = new ArrayList<Long>();\n\n            for(Long sequenceId : sequences) {\n                Long references = sd.messageReferences.get(sequenceId);\n                if (references != null) {\n                    references = references.longValue() - 1;\n\n                    if (references.longValue() > 0) {\n                        sd.messageReferences.put(sequenceId, references);\n                    } else {\n                        sd.messageReferences.remove(sequenceId);\n                        unreferenced.add(sequenceId);\n                    }\n                }\n            }\n\n            for(Long sequenceId : unreferenced) {\n                // Find all the entries that need to get deleted.\n                ArrayList<Entry<Long, MessageKeys>> deletes = new ArrayList<Entry<Long, MessageKeys>>();\n                sd.orderIndex.getDeleteList(tx, deletes, sequenceId);\n\n                // Do the actual deletes.\n                for (Entry<Long, MessageKeys> entry : deletes) {\n                    sd.locationIndex.remove(tx, entry.getValue().location);\n                    sd.messageIdIndex.remove(tx, entry.getValue().messageId);\n                    sd.orderIndex.remove(tx, entry.getKey());\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.remove": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.execute": "        public void execute(Transaction tx) throws IOException {\n            updateIndex(tx, command, location);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.put": "        MessageKeys put(Transaction tx, int priority, Long key, MessageKeys value) throws IOException {\n            if (priority == javax.jms.Message.DEFAULT_PRIORITY) {\n                return defaultPriorityIndex.put(tx, key, value);\n            } else if (priority > javax.jms.Message.DEFAULT_PRIORITY) {\n                return highPriorityIndex.put(tx, key, value);\n            } else {\n                return lowPriorityIndex.put(tx, key, value);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex": "    void upadateIndex(Transaction tx, KahaAddMessageCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n\n        // Skip adding the message to the index if this is a topic and there are\n        // no subscriptions.\n        if (sd.subscriptions != null && sd.subscriptions.isEmpty(tx)) {\n            return;\n        }\n\n        // Add the message.\n        int priority = command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY;\n        long id = sd.orderIndex.getNextMessageId(priority);\n        Long previous = sd.locationIndex.put(tx, location, id);\n        if (previous == null) {\n            previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);\n            if (previous == null) {\n                sd.orderIndex.put(tx, priority, id, new MessageKeys(command.getMessageId(), location));\n                if (sd.subscriptions != null && !sd.subscriptions.isEmpty(tx)) {\n                    addAckLocationForNewMessage(tx, sd, id);\n                }\n            } else {\n                // If the message ID as indexed, then the broker asked us to\n                // store a DUP\n                // message. Bad BOY! Don't do it, and log a warning.\n                LOG.warn(\"Duplicate message add attempt rejected. Destination: \" + command.getDestination().getName() + \", Message id: \" + command.getMessageId());\n                sd.messageIdIndex.put(tx, command.getMessageId(), previous);\n                sd.locationIndex.remove(tx, location);\n                rollbackStatsOnDuplicate(command.getDestination());\n            }\n        } else {\n            // restore the previous value.. Looks like this was a redo of a\n            // previously\n            // added message. We don't want to assign it a new id as the other\n            // indexes would\n            // be wrong..\n            //\n            sd.locationIndex.put(tx, location, previous);\n        }\n        // record this id in any event, initial send or recovery\n        metadata.producerSequenceIdTracker.isDuplicate(command.getMessageId());\n        metadata.lastUpdate = location;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.load": "        void load(Transaction tx) throws IOException {\n            defaultPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            defaultPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            defaultPriorityIndex.load(tx);\n            lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            lowPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            lowPriorityIndex.load(tx);\n            highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            highPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            highPriorityIndex.load(tx);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(JournalCommand<?> data, boolean sync, Runnable before,Runnable after, Runnable onJournalStoreComplete) throws IOException {\n        if (before != null) {\n            before.run();\n        }\n        try {\n            ByteSequence sequence = toByteSequence(data);\n            long start = System.currentTimeMillis();\n            Location location = onJournalStoreComplete == null ? journal.write(sequence, sync) :  journal.write(sequence, onJournalStoreComplete) ;\n            long start2 = System.currentTimeMillis();\n            process(data, location, after);\n            long end = System.currentTimeMillis();\n            if( LOG_SLOW_ACCESS_TIME>0 && end-start > LOG_SLOW_ACCESS_TIME) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Slow KahaDB access: Journal append took: \"+(start2-start)+\" ms, Index update took \"+(end-start2)+\" ms\");\n                }\n            }\n\n            if (after != null) {\n                Runnable afterCompletion = null;\n                synchronized (orderedTransactionAfters) {\n                    if (!orderedTransactionAfters.empty()) {\n                        afterCompletion = orderedTransactionAfters.pop();\n                    }\n                }\n                if (afterCompletion != null) {\n                    afterCompletion.run();\n                } else {\n                    // non persistent message case\n                    after.run();\n                }\n            }\n\n            if (checkpointThread != null && !checkpointThread.isAlive()) {\n                startCheckpoint();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal\", ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex": "    protected void recoverIndex(Transaction tx) throws IOException {\n        long start = System.currentTimeMillis();\n        // It is possible index updates got applied before the journal updates..\n        // in that case we need to removed references to messages that are not in the journal\n        final Location lastAppendLocation = journal.getLastAppendLocation();\n        long undoCounter=0;\n\n        // Go through all the destinations to see if they have messages past the lastAppendLocation\n        for (StoredDestination sd : storedDestinations.values()) {\n\n            final ArrayList<Long> matches = new ArrayList<Long>();\n            // Find all the Locations that are >= than the last Append Location.\n            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor<Location, Long>(lastAppendLocation) {\n                @Override\n                protected void matched(Location key, Long value) {\n                    matches.add(value);\n                }\n            });\n\n            for (Long sequenceId : matches) {\n                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                sd.locationIndex.remove(tx, keys.location);\n                sd.messageIdIndex.remove(tx, keys.messageId);\n                metadata.producerSequenceIdTracker.rollback(keys.messageId);\n                undoCounter++;\n                // TODO: do we need to modify the ack positions for the pub sub case?\n            }\n        }\n\n        if( undoCounter > 0 ) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting\n            // these the end user should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Rolled back \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n\n        undoCounter = 0;\n        start = System.currentTimeMillis();\n\n        // Lets be extra paranoid here and verify that all the datafiles being referenced\n        // by the indexes still exists.\n\n        final SequenceSet ss = new SequenceSet();\n        for (StoredDestination sd : storedDestinations.values()) {\n            // Use a visitor to cut down the number of pages that we load\n            sd.locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                int last=-1;\n\n                public boolean isInterestedInKeysBetween(Location first, Location second) {\n                    if( first==null ) {\n                        return !ss.contains(0, second.getDataFileId());\n                    } else if( second==null ) {\n                        return true;\n                    } else {\n                        return !ss.contains(first.getDataFileId(), second.getDataFileId());\n                    }\n                }\n\n                public void visit(List<Location> keys, List<Long> values) {\n                    for (Location l : keys) {\n                        int fileId = l.getDataFileId();\n                        if( last != fileId ) {\n                            ss.add(fileId);\n                            last = fileId;\n                        }\n                    }\n                }\n\n            });\n        }\n        HashSet<Integer> missingJournalFiles = new HashSet<Integer>();\n        while (!ss.isEmpty()) {\n            missingJournalFiles.add((int) ss.removeFirst());\n        }\n        missingJournalFiles.removeAll(journal.getFileMap().keySet());\n\n        if (!missingJournalFiles.isEmpty()) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Some journal files are missing: \" + missingJournalFiles);\n            }\n        }\n\n        ArrayList<BTreeVisitor.Predicate<Location>> missingPredicates = new ArrayList<BTreeVisitor.Predicate<Location>>();\n        for (Integer missing : missingJournalFiles) {\n            missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(missing, 0), new Location(missing + 1, 0)));\n        }\n\n        if (checkForCorruptJournalFiles) {\n            Collection<DataFile> dataFiles = journal.getFileMap().values();\n            for (DataFile dataFile : dataFiles) {\n                int id = dataFile.getDataFileId();\n                missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));\n                Sequence seq = dataFile.getCorruptedBlocks().getHead();\n                while (seq != null) {\n                    missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1)));\n                    seq = seq.getNext();\n                }\n            }\n        }\n\n        if (!missingPredicates.isEmpty()) {\n            for (StoredDestination sd : storedDestinations.values()) {\n\n                final ArrayList<Long> matches = new ArrayList<Long>();\n                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor<Location, Long>(missingPredicates) {\n                    @Override\n                    protected void matched(Location key, Long value) {\n                        matches.add(value);\n                    }\n                });\n\n                // If somes message references are affected by the missing data files...\n                if (!matches.isEmpty()) {\n\n                    // We either 'gracefully' recover dropping the missing messages or\n                    // we error out.\n                    if( ignoreMissingJournalfiles ) {\n                        // Update the index to remove the references to the missing data\n                        for (Long sequenceId : matches) {\n                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                            sd.locationIndex.remove(tx, keys.location);\n                            sd.messageIdIndex.remove(tx, keys.messageId);\n                            undoCounter++;\n                            // TODO: do we need to modify the ack positions for the pub sub case?\n                        }\n\n                    } else {\n                        throw new IOException(\"Detected missing/corrupt journal files. \"+matches.size()+\" messages affected.\");\n                    }\n                }\n            }\n        }\n\n        if( undoCounter > 0 ) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user\n            // should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Detected missing/corrupt journal files.  Dropped \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.hasNext": "            public boolean hasNext() {\n                if (currentIterator == null) {\n                    if (highIterator != null) {\n                        if (highIterator.hasNext()) {\n                            currentIterator = highIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    } else {\n                        currentIterator = defaultIterator;\n                        return currentIterator.hasNext();\n                    }\n                }\n                if (highIterator != null) {\n                    if (currentIterator.hasNext()) {\n                        return true;\n                    }\n                    if (currentIterator == highIterator) {\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n\n                    if (currentIterator == defaultIterator) {\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                }\n                return currentIterator.hasNext();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException{\n            return new MessageOrderIterator(tx,m);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.allocate": "        void allocate(Transaction tx) throws IOException {\n            defaultPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            if (metadata.version >= 2) {\n                lowPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n                highPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.next": "            public Entry<Long, MessageKeys> next() {\n                Entry<Long, MessageKeys> result = currentIterator.next();\n                if (result != null) {\n                    Long key = result.getKey();\n                    if (highIterator != null) {\n                        if (currentIterator == defaultIterator) {\n                            lastDefaultKey = key;\n                        } else if (currentIterator == highIterator) {\n                            lastHighKey = key;\n                        } else {\n                            lastLowKey = key;\n                        }\n                    } else {\n                        lastDefaultKey = key;\n                    }\n                }\n                return result;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    void checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {\n        LOG.debug(\"Checkpoint started.\");\n\n        // reflect last update exclusive of current checkpoint\n        Location firstTxLocation = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit();\n        metadata.firstInProgressTransactionLocation = getFirstInProgressTxLocation();\n        tx.store(metadata.page, metadataMarshaller, true);\n        pageFile.flush();\n\n        if( cleanup ) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n            final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Last update: \" + firstTxLocation + \", full gc candidates set: \" + gcCandidateSet);\n            }\n\n            // Don't GC files under replication\n            if( journalFilesBeingReplicated!=null ) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                gcCandidateSet.remove(metadata.producerSequenceIdTrackerLocation.getDataFileId());\n            }\n\n            // Don't GC files after the first in progress tx\n            if( metadata.firstInProgressTransactionLocation!=null ) {\n                if (metadata.firstInProgressTransactionLocation.getDataFileId() < firstTxLocation.getDataFileId()) {\n                    firstTxLocation = metadata.firstInProgressTransactionLocation;\n                }\n            }\n\n            if( firstTxLocation!=null ) {\n                while( !gcCandidateSet.isEmpty() ) {\n                    Integer last = gcCandidateSet.last();\n                    if( last >= firstTxLocation.getDataFileId() ) {\n                        gcCandidateSet.remove(last);\n                    } else {\n                        break;\n                    }\n                }\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after first tx:\" + firstTxLocation + \", \" + gcCandidateSet);\n                }\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if( gcCandidateSet.isEmpty() ) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last=-1;\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if( first==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if( second==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n                }\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates: \" + gcCandidateSet);\n            }\n            final TreeSet<Integer> gcCandidates = new TreeSet<Integer>(gcCandidateSet);\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidates.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don't delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        ackMessageFileMap.remove(candidate);\n                    } else {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"not removing data file: \" + candidate\n                                    + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                        }\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cleanup removing the data files: \" + gcCandidateSet);\n                }\n                journal.removeDataFiles(gcCandidateSet);\n            }\n        }\n\n        LOG.debug(\"Checkpoint done.\");\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.loadStoredDestination": "    private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {\n        // Try to load the existing indexes..\n        StoredDestination rc = metadata.destinations.get(tx, key);\n        if (rc == null) {\n            // Brand new destination.. allocate indexes for it.\n            rc = new StoredDestination();\n            rc.orderIndex.allocate(tx);\n            rc.locationIndex = new BTreeIndex<Location, Long>(pageFile, tx.allocate());\n            rc.messageIdIndex = new BTreeIndex<String, Long>(pageFile, tx.allocate());\n\n            if (topic) {\n                rc.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, tx.allocate());\n                rc.subscriptionAcks = new BTreeIndex<String, LastAck>(pageFile, tx.allocate());\n                rc.ackPositions = new ListIndex<String, SequenceSet>(pageFile, tx.allocate());\n            }\n            metadata.destinations.put(tx, key, rc);\n        }\n\n        // Configure the marshalers and load.\n        rc.orderIndex.load(tx);\n\n        // Figure out the next key using the last entry in the destination.\n        rc.orderIndex.configureLast(tx);\n\n        rc.locationIndex.setKeyMarshaller(org.apache.kahadb.util.LocationMarshaller.INSTANCE);\n        rc.locationIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.locationIndex.load(tx);\n\n        rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);\n        rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.messageIdIndex.load(tx);\n\n        // If it was a topic...\n        if (topic) {\n\n            rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);\n            rc.subscriptions.load(tx);\n\n            rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptionAcks.setValueMarshaller(new LastAckMarshaller());\n            rc.subscriptionAcks.load(tx);\n\n            rc.ackPositions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.ackPositions.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);\n            rc.ackPositions.load(tx);\n\n            rc.subscriptionCursors = new HashMap<String, MessageOrderCursor>();\n\n            if (metadata.version < 3) {\n\n                // on upgrade need to fill ackLocation with available messages past last ack\n                for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                    Entry<String, LastAck> entry = iterator.next();\n                    for (Iterator<Entry<Long, MessageKeys>> orderIterator =\n                            rc.orderIndex.iterator(tx, new MessageOrderCursor(entry.getValue().lastAckedSequence)); orderIterator.hasNext(); ) {\n                        Long sequence = orderIterator.next().getKey();\n                        addAckLocation(tx, rc, sequence, entry.getKey());\n                    }\n                    // modify so it is upgraded\n                    rc.subscriptionAcks.put(tx, entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Configure the message references index\n            Iterator<Entry<String, SequenceSet>> subscriptions = rc.ackPositions.iterator(tx);\n            while (subscriptions.hasNext()) {\n                Entry<String, SequenceSet> subscription = subscriptions.next();\n                SequenceSet pendingAcks = subscription.getValue();\n                if (pendingAcks != null && !pendingAcks.isEmpty()) {\n                    Long lastPendingAck = pendingAcks.getTail().getLast();\n                    for(Long sequenceId : pendingAcks) {\n                        Long current = rc.messageReferences.get(sequenceId);\n                        if (current == null) {\n                            current = new Long(0);\n                        }\n\n                        // We always add a trailing empty entry for the next position to start from\n                        // so we need to ensure we don't count that as a message reference on reload.\n                        if (!sequenceId.equals(lastPendingAck)) {\n                            current = current.longValue() + 1;\n                        }\n\n                        rc.messageReferences.put(sequenceId, current);\n                    }\n                }\n            }\n\n            // Configure the subscription cache\n            for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                Entry<String, LastAck> entry = iterator.next();\n                rc.subscriptionCache.add(entry.getKey());\n            }\n\n            if (rc.orderIndex.nextMessageId == 0) {\n                // check for existing durable sub all acked out - pull next seq from acks as messages are gone\n                if (!rc.subscriptionAcks.isEmpty(tx)) {\n                    for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {\n                        Entry<String, LastAck> entry = iterator.next();\n                        rc.orderIndex.nextMessageId =\n                                Math.max(rc.orderIndex.nextMessageId, entry.getValue().lastAckedSequence +1);\n                    }\n                }\n            } else {\n                // update based on ackPositions for unmatched, last entry is always the next\n                if (!rc.messageReferences.isEmpty()) {\n                    Long nextMessageId = (Long) rc.messageReferences.keySet().toArray()[rc.messageReferences.size() - 1];\n                    rc.orderIndex.nextMessageId =\n                            Math.max(rc.orderIndex.nextMessageId, nextMessageId);\n                }\n            }\n        }\n\n        if (metadata.version < VERSION) {\n            // store again after upgrade\n            metadata.destinations.put(tx, key, rc);\n        }\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.process": "    protected void process(KahaRollbackCommand command, Location location)  throws IOException {\n        TransactionId key = TransactionIdConversion.convert(command.getTransactionInfo());\n        List<Operation> updates = null;\n        synchronized (inflightTransactions) {\n            updates = inflightTransactions.remove(key);\n            if (updates == null) {\n                updates = preparedTransactions.remove(key);\n            }\n        }\n        if (isRewriteOnRedelivery()) {\n            persistRedeliveryCount(updates);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.visit": "                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.push": "    private void push(Runnable after) {\n        if (after != null) {\n            synchronized (orderedTransactionAfters) {\n                orderedTransactionAfters.push(after);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.isRewriteOnRedelivery": "    public boolean isRewriteOnRedelivery() {\n        return rewriteOnRedelivery;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.persistRedeliveryCount": "    private void persistRedeliveryCount(List<Operation> updates)  throws IOException {\n        if (updates != null) {\n            for (Operation operation : updates) {\n                operation.getCommand().visit(new Visitor() {\n                    @Override\n                    public void visit(KahaRemoveMessageCommand command) throws IOException {\n                        incrementRedeliveryAndReWrite(command.getMessageId(), command.getDestination());\n                    }\n                });\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.run": "        public void run() {\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.processLocation": "    protected void processLocation(final Location location) {\n        this.indexLock.writeLock().lock();\n        try {\n            metadata.lastUpdate = location;\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getInflightTx": "    private List<Operation> getInflightTx(KahaTransactionInfo info, Location location) {\n        TransactionId key = TransactionIdConversion.convert(info);\n        List<Operation> tx;\n        synchronized (inflightTransactions) {\n            tx = inflightTransactions.get(key);\n            if (tx == null) {\n                tx = Collections.synchronizedList(new ArrayList<Operation>());\n                inflightTransactions.put(key, tx);\n            }\n        }\n        return tx;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.doAcknowledge": "        protected void doAcknowledge(ConnectionContext context, String subscriptionKey, MessageId messageId, MessageAck ack)\n                throws IOException {\n            KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();\n            command.setDestination(dest);\n            command.setSubscriptionKey(subscriptionKey);\n            command.setMessageId(messageId.toString());\n            command.setTransactionInfo(ack != null ? transactionIdTransformer.transform(ack.getTransactionId()) : null);\n            if (ack != null && ack.isUnmatchedAck()) {\n                command.setAck(UNMATCHED);\n            } else {\n                org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);\n                command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));\n            }\n            store(command, false, null, null);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.transform": "            public KahaTransactionInfo transform(TransactionId txid) {\n                return TransactionIdConversion.convert(txid);\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.toString": "        public String toString() {\n            return destination.getPhysicalName() + \"-\" + id;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.acknowledge": "        public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,\n                                MessageId messageId, MessageAck ack)\n                throws IOException {\n            String subscriptionKey = subscriptionKey(clientId, subscriptionName).toString();\n            if (isConcurrentStoreAndDispatchTopics()) {\n                AsyncJobKey key = new AsyncJobKey(messageId, getDestination());\n                StoreTopicTask task = null;\n                synchronized (asyncTaskMap) {\n                    task = (StoreTopicTask) asyncTaskMap.get(key);\n                }\n                if (task != null) {\n                    if (task.addSubscriptionKey(subscriptionKey)) {\n                        removeTopicTask(this, messageId);\n                        if (task.cancel()) {\n                            synchronized (asyncTaskMap) {\n                                asyncTaskMap.remove(key);\n                            }\n                        }\n                    }\n                } else {\n                    doAcknowledge(context, subscriptionKey, messageId, ack);\n                }\n            } else {\n                doAcknowledge(context, subscriptionKey, messageId, ack);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.cancel": "        public boolean cancel() {\n            if (this.done.compareAndSet(false, true)) {\n                return this.future.cancel(false);\n            }\n            return false;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.isConcurrentStoreAndDispatchTopics": "    public boolean isConcurrentStoreAndDispatchTopics() {\n        return this.concurrentStoreAndDispatchTopics;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.getDestination": "        public ActiveMQDestination getDestination() {\n            return destination;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.addSubscriptionKey": "        public boolean addSubscriptionKey(String key) {\n            synchronized (this.subscriptionKeys) {\n                this.subscriptionKeys.add(key);\n            }\n            return this.subscriptionKeys.size() >= this.subscriptionCount;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.subscriptionKey": "    String subscriptionKey(String clientId, String subscriptionName) {\n        return clientId + \":\" + subscriptionName;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.removeTopicTask": "    protected StoreTopicTask removeTopicTask(KahaDBTopicMessageStore store, MessageId id) {\n        StoreTopicTask task = null;\n        synchronized (store.asyncTaskMap) {\n            task = (StoreTopicTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));\n        }\n        return task;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.acknowledge": "    final void acknowledge(ConnectionContext context, final TopicMessageStore destination, final String clientId, final String subscriptionName,\n                           final MessageId messageId, final MessageAck ack) throws IOException {\n\n        if (ack.isInTransaction()) {\n            if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {\n                destination.acknowledge(context, clientId, subscriptionName, messageId, ack);\n            } else {\n                Tx tx = getTx(ack.getTransactionId());\n                tx.add(new RemoveMessageCommand(context) {\n                    public MessageAck getMessageAck() {\n                        return ack;\n                    }\n\n                    public Future<Object> run(ConnectionContext ctx) throws IOException {\n                        destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                        return AbstractMessageStore.FUTURE;\n                    }\n                });\n            }\n        } else {\n            destination.acknowledge(context, clientId, subscriptionName, messageId, ack);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.getTx": "    public Tx getTx(Object txid) {\n        Tx tx = inflightTransactions.get(txid);\n        if (tx == null) {\n            tx = new Tx();\n            inflightTransactions.put(txid, tx);\n        }\n        return tx;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.add": "        public void add(RemoveMessageCommand ack) {\n            acks.add(ack);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Topic.acknowledge": "    public void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack,\n            final MessageReference node) throws IOException {\n        if (topicStore != null && node.isPersistent()) {\n            DurableTopicSubscription dsub = (DurableTopicSubscription) sub;\n            SubscriptionKey key = dsub.getSubscriptionKey();\n            topicStore.acknowledge(context, key.getClientId(), key.getSubscriptionName(), node.getMessageId(),\n                    convertToNonRangedAck(ack, node));\n        }\n        messageConsumed(context, node);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.DurableTopicSubscription.acknowledge": "    protected void acknowledge(ConnectionContext context, MessageAck ack, MessageReference node) throws IOException {\n        node.getRegionDestination().acknowledge(context, this, ack, node);\n        redeliveredMessages.remove(node.getMessageId());\n        node.decrementReferenceCount();\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.put": "    public Value put(Transaction tx, Key key, Value value) throws IOException {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Key cannot be null\");\n        }\n\n        if( isBranch() ) {\n            return getLeafNode(tx, this, key).put(tx, key, value);\n        } else {\n            int idx = Arrays.binarySearch(keys, key);\n            \n            Value oldValue=null;\n            if (idx >= 0) {\n                // Key was found... Overwrite\n                oldValue = values[idx];\n                values[idx] = value;\n                setLeafData(keys, values);\n            } else {\n                // Key was not found, Insert it\n                idx = -(idx + 1);\n                setLeafData(arrayInsert(keys, key, idx), arrayInsert(values, value, idx));\n            }\n            \n            try {\n                index.storeNode(tx, this, allowOverflow());\n            } catch ( Transaction.PageOverflowIOException e ) {\n                // If we get an overflow \n                split(tx);\n            }\n            \n            return oldValue;\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.setLeafData": "    private void setLeafData(Key[] keys, Value[] values) {\n        this.keys = keys;\n        this.values = values;\n        this.children = null;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.arrayInsert": "    static private long[] arrayInsert(long[] vals, long val, int idx) {\n        \n        long[] newVals = new long[vals.length + 1];\n        if (idx > 0) {\n            System.arraycopy(vals, 0, newVals, 0, idx);\n        }\n        newVals[idx] = val;\n        if (idx < vals.length) {\n            System.arraycopy(vals, idx, newVals, idx + 1, vals.length - idx);\n        }\n        return newVals;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.split": "    private void split(Transaction tx) throws IOException {\n        Key[] leftKeys;\n        Key[] rightKeys;\n        Value[] leftValues=null;\n        Value[] rightValues=null;\n        long[] leftChildren=null;\n        long[] rightChildren=null;\n        Key separator;\n\n        int vc = keys.length;\n        int pivot = vc / 2;\n\n        // Split the node into two nodes\n        if( isBranch() ) {\n\n            leftKeys = createKeyArray(pivot);\n            leftChildren = new long[leftKeys.length + 1];\n            rightKeys = createKeyArray(vc - (pivot + 1));\n            rightChildren = new long[rightKeys.length + 1];\n\n            System.arraycopy(keys, 0, leftKeys, 0, leftKeys.length);\n            System.arraycopy(children, 0, leftChildren, 0, leftChildren.length);\n            System.arraycopy(keys, leftKeys.length + 1, rightKeys, 0, rightKeys.length);\n            System.arraycopy(children, leftChildren.length, rightChildren, 0, rightChildren.length);\n\n            // Is it a Simple Prefix BTree??\n            Prefixer<Key> prefixer = index.getPrefixer();\n            if(prefixer!=null) {\n                separator = prefixer.getSimplePrefix(leftKeys[leftKeys.length - 1], rightKeys[0]);\n            } else {\n                separator = keys[leftKeys.length];\n            }\n                \n            \n        } else {\n\n            leftKeys = createKeyArray(pivot);\n            leftValues = createValueArray(leftKeys.length);\n            rightKeys = createKeyArray(vc - pivot);\n            rightValues = createValueArray(rightKeys.length);\n\n            System.arraycopy(keys, 0, leftKeys, 0, leftKeys.length);\n            System.arraycopy(values, 0, leftValues, 0, leftValues.length);\n            System.arraycopy(keys, leftKeys.length, rightKeys, 0, rightKeys.length);\n            System.arraycopy(values, leftValues.length, rightValues, 0, rightValues.length);\n\n            // separator = getSeparator(leftVals[leftVals.length - 1],\n            // rightVals[0]);\n            separator = rightKeys[0];\n\n        }\n\n        // Promote the pivot to the parent branch\n        if (parent == null) {\n            \n            // This can only happen if this is the root\n            BTreeNode<Key,Value> rNode = this.index.createNode(tx, this);\n            BTreeNode<Key,Value> lNode = this.index.createNode(tx, this);\n\n            if( isBranch() ) {\n                rNode.setBranchData(rightKeys, rightChildren);\n                lNode.setBranchData(leftKeys, leftChildren);\n            } else {\n                rNode.setLeafData(rightKeys, rightValues);\n                lNode.setLeafData(leftKeys, leftValues);\n                lNode.setNext(rNode.getPageId());\n            }\n\n            Key[] v = createKeyArray(1);\n            v[0]=separator;\n            setBranchData(v, new long[] { lNode.getPageId(), rNode.getPageId() });\n\n            index.storeNode(tx, this, true);\n            index.storeNode(tx, rNode, true);\n            index.storeNode(tx, lNode, true);\n            \n        } else {\n            BTreeNode<Key,Value> rNode = this.index.createNode(tx, parent);\n            \n            if( isBranch() ) {\n                setBranchData(leftKeys, leftChildren);\n                rNode.setBranchData(rightKeys, rightChildren);\n            } else {\n                rNode.setNext(next);\n                next = rNode.getPageId();\n                setLeafData(leftKeys, leftValues);\n                rNode.setLeafData(rightKeys, rightValues);\n            }\n\n            index.storeNode(tx, this, true);\n            index.storeNode(tx, rNode, true);\n            parent.promoteValue(tx, separator, rNode.getPageId());\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.allowOverflow": "    private boolean allowOverflow() {\n        // Only allow page overflow if there are <= 3 keys in the node.  Otherwise a split will occur on overflow\n        return this.keys.length<=3;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeIndex.put": "    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n        assertLoaded();\n        return getRoot(tx).put(tx, key, value);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeIndex.getRoot": "    private BTreeNode<Key,Value> getRoot(Transaction tx) throws IOException {\n        return loadNode(tx, pageId, null);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeIndex.assertLoaded": "    private void assertLoaded() throws IllegalStateException {\n        if( !loaded.get() ) {\n            throw new IllegalStateException(\"The BTreeIndex is not loaded\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit": "    public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit)\n            throws IOException {\n        if (txid != null) {\n            if (!txid.isXATransaction() && theStore.isConcurrentStoreAndDispatchTransactions()) {\n                if (preCommit != null) {\n                    preCommit.run();\n                }\n                Tx tx = inflightTransactions.remove(txid);\n                if (tx != null) {\n                    List<Future<Object>> results = tx.commit();\n                    boolean doneSomething = false;\n                    for (Future<Object> result : results) {\n                        try {\n                            result.get();\n                        } catch (InterruptedException e) {\n                            theStore.brokerService.handleIOException(new IOException(e.getMessage()));\n                        } catch (ExecutionException e) {\n                            theStore.brokerService.handleIOException(new IOException(e.getMessage()));\n                        }catch(CancellationException e) {\n                        }\n                        if (!result.isCancelled()) {\n                            doneSomething = true;\n                        }\n                    }\n                    if (postCommit != null) {\n                        postCommit.run();\n                    }\n                    if (doneSomething) {\n                        KahaTransactionInfo info = getTransactionInfo(txid);\n                        theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, null, null);\n                    }\n                }else {\n                    //The Tx will be null for failed over clients - lets run their post commits\n                    if (postCommit != null) {\n                        postCommit.run();\n                    }\n                }\n\n            } else {\n                KahaTransactionInfo info = getTransactionInfo(txid);\n                theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, preCommit, postCommit);\n                forgetRecoveredAcks(txid);\n            }\n        }else {\n           LOG.error(\"Null transaction passed on commit\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.run": "                    public Future<Object> run(ConnectionContext ctx) throws IOException {\n                        destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                        return AbstractMessageStore.FUTURE;\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.getTransactionInfo": "    private KahaTransactionInfo getTransactionInfo(TransactionId txid) {\n        return theStore.getTransactionIdTransformer().transform(txid);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.forgetRecoveredAcks": "    protected void forgetRecoveredAcks(TransactionId txid) throws IOException {\n        if (txid.isXATransaction()) {\n            XATransactionId xaTid = ((XATransactionId) txid);\n            theStore.forgetRecoveredAcks(xaTid.getPreparedAcks());\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.getMessage": "                    public Message getMessage() {\n                        return message;\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.transaction.XATransaction.storeCommit": "    private void storeCommit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit)\n            throws XAException, IOException {\n        try {\n            transactionStore.commit(getTransactionId(), wasPrepared, preCommitTask, postCommitTask);\n            waitPostCommitDone(postCommitTask);\n        } catch (XAException xae) {\n            throw xae;\n        } catch (Throwable t) {\n            LOG.warn(\"Store COMMIT FAILED: \", t);\n            rollback();\n            XAException xae = new XAException(\"STORE COMMIT FAILED: Transaction rolled back.\");\n            xae.errorCode = XAException.XA_RBOTHER;\n            xae.initCause(t);\n            throw xae;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transaction.XATransaction.commit": "    public void commit(boolean onePhase) throws XAException, IOException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"XA Transaction commit onePhase:\" + onePhase + \", xid: \" + xid);\n        }\n\n        switch (getState()) {\n        case START_STATE:\n            // 1 phase commit, no work done.\n            checkForPreparedState(onePhase);\n            setStateFinished();\n            break;\n        case IN_USE_STATE:\n            // 1 phase commit, work done.\n            checkForPreparedState(onePhase);\n            doPrePrepare();\n            setStateFinished();\n            storeCommit(getTransactionId(), false, preCommitTask, postCommitTask);\n            break;\n        case PREPARED_STATE:\n            // 2 phase commit, work done.\n            // We would record commit here.\n            setStateFinished();\n            storeCommit(getTransactionId(), true, preCommitTask, postCommitTask);\n            break;\n        default:\n            illegalStateTransition(\"commit\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transaction.XATransaction.rollback": "    public void rollback() throws XAException, IOException {\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"XA Transaction rollback: \" + xid);\n        }\n\n        switch (getState()) {\n        case START_STATE:\n            // 1 phase rollback no work done.\n            setStateFinished();\n            break;\n        case IN_USE_STATE:\n            // 1 phase rollback work done.\n            setStateFinished();\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        case PREPARED_STATE:\n            // 2 phase rollback work done.\n            setStateFinished();\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        case FINISHED_STATE:\n            // failure to commit\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        default:\n            throw new XAException(\"Invalid state\");\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transaction.XATransaction.getTransactionId": "    public TransactionId getTransactionId() {\n        return xid;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.setPage": "    public void setPage(Page<BTreeNode<Key, Value>> page) {\n        this.page = page;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.index.BTreeNode.setParent": "    public void setParent(BTreeNode<Key, Value> parent) {\n        this.parent = parent;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.TransactionIdConversion.convert": "    static TransactionId convert(KahaTransactionInfo transactionInfo) {\n        if (transactionInfo.hasLocalTransactionId()) {\n            KahaLocalTransactionId tx = transactionInfo.getLocalTransactionId();\n            LocalTransactionId rc = new LocalTransactionId();\n            rc.setConnectionId(new ConnectionId(tx.getConnectionId()));\n            rc.setValue(tx.getTransactionId());\n            return rc;\n        } else {\n            KahaXATransactionId tx = transactionInfo.getXaTransactionId();\n            XATransactionId rc = new XATransactionId();\n            rc.setBranchQualifier(tx.getBranchQualifier().toByteArray());\n            rc.setGlobalTransactionId(tx.getGlobalTransactionId().toByteArray());\n            rc.setFormatId(tx.getFormatId());\n            return rc;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.TransactionIdConversion.convertToLocal": "    static KahaTransactionInfo convertToLocal(TransactionId tx) {\n        KahaTransactionInfo rc = new KahaTransactionInfo();\n        LocalTransactionId t = (LocalTransactionId) tx;\n        KahaLocalTransactionId kahaTxId = new KahaLocalTransactionId();\n        kahaTxId.setConnectionId(t.getConnectionId().getValue());\n        kahaTxId.setTransactionId(t.getValue());\n        rc.setLocalTransactionId(kahaTxId);\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.DurableTopicSubscription.getSubscriptionKey": "    public SubscriptionKey getSubscriptionKey() {\n        return subscriptionKey;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.getRegionDestination": "    Destination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessageId": "    MessageId getMessageId();\n    Message getMessageHardRef();\n    Message getMessage();\n    boolean isPersistent();\n    \n    Destination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.decrementReferenceCount": "    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}"
        },
        "bug_report": {
            "Title": "Index page overflow (when a value does not fit in a page) can lead to duplicate calls to free",
            "Description": "An overflowed chain is release when it is no longer needed, but the new end page was not stored in the cache, the old value as a part page is reused and freed again. boom. Keeping the cache in sync sorts this.\nA workaround is to disable the index page cache with a small indexCacheSize.\nDurable subs make this more visible, but the failure symptoms vary with usage. A typical scenario is a classcast when the page is reused in the wrong context or a npe when the free page is loaded from disk.\nWith durable subs with selectors and large backlogs, the sequence set expansion and shrinkage produces values that can overflow easily. This scenario produced a nice test.\n\nSome resultant stack traces that are symptomatic:\n{code}2012-10-19 22:25:11,928 [exPageUsage#5-2] - ERROR MessageDatabase                - KahaDB failed to store to Journal\njava.io.EOFException: Chunk stream does not exist, page: 1344 is marked free\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:481)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:458)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:455)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:431)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:388)\n\tat org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)\n\tat org.apache.kahadb.index.BTreeNode.getChild(BTreeNode.java:225)\n\tat org.apache.kahadb.index.BTreeNode.getLeafNode(BTreeNode.java:680)\n\tat org.apache.kahadb.index.BTreeNode.get(BTreeNode.java:562)\n\tat org.apache.kahadb.index.BTreeIndex.get(BTreeIndex.java:184)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.get(MessageDatabase.java:2616)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.updateIndex(MessageDatabase.java:1210)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$15.execute(MessageDatabase.java:1002)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:790)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1000)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:933)\n\tat org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand.visit(KahaRemoveMessageCommand.java:220)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:925)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:837)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:819)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBTopicMessageStore.doAcknowledge(KahaDBStore.java:723)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBTopicMessageStore.acknowledge(KahaDBStore.java:706)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore.acknowledge(KahaDBTransactionStore.java:519)\n\tat org.apache.activemq.store.kahadb.KahaDBTransactionStore$2.acknowledge(KahaDBTransactionStore.java:222)\n\tat org.apache.activemq.broker.region.Topic.acknowledge(Topic.java:528)\n\tat org.apache.activemq.broker.region.DurableTopicSubscription.acknowledge(DurableTopicSubscription.java:279)\n\tat ..{code}\n{code}java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.String\n        at java.lang.String.compareTo(String.java:92)\n        at java.util.Arrays.binarySearch0(Arrays.java:2001)\n        at java.util.Arrays.binarySearch(Arrays.java:1943)\n        at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:371)\n        at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:369)       \n        at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)        \nat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.put(MessageDatabase.java:2592)\n        at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1168)        at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:2082)        at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:1095)        at org.apache.kahadb.page.Transaction.execute(Transaction.java:768)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1092)\n        at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)\n        at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:943)\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:855)\n        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:267)\n        at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)\n...{code}\n{code}java.lang.NullPointerException\n        at org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:264)\n        at org.apache.kahadb.index.BTreeNode.getChild(BTreeNode.java:225)\n        at org.apache.kahadb.index.BTreeNode.getLeafNode(BTreeNode.java:676)\n        at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:369)\n        at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)\n        at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.put(MessageDatabase.java:2592)\n        at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1168)\n        at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:2082)\n        at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:1095)\n        at org.apache.kahadb.page.Transaction.execute(Transaction.java:768)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1092)\n        at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)\n        at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)\n        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:943)\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:855)\n        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:267){code}"
        }
    },
    {
        "filename": "AMQ-4092.json",
        "creation_time": "2012-10-04T02:56:44.000+0000",
        "stack_trace": "java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException\njava.util.concurrent.ExecutionException: java.util.ConcurrentModificationException\n\tat java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:222)\n\tat java.util.concurrent.FutureTask.get(FutureTask.java:83)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:785)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:707)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:407)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:503)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:305)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:453)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)\n\tat org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:231)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:680)\nCaused by: java.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)\n\tat java.util.HashMap$KeyIterator.next(HashMap.java:828)\n\tat org.apache.activemq.util.MarshallingSupport.marshalPrimitiveMap(MarshallingSupport.java:64)\n\tat org.apache.activemq.command.Message.beforeMarshall(Message.java:210)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.beforeMarshall(ActiveMQObjectMessage.java:199)\n\tat org.apache.activemq.openwire.v6.MessageMarshaller.looseMarshal(MessageMarshaller.java:277)\n\tat org.apache.activemq.openwire.v6.ActiveMQMessageMarshaller.looseMarshal(ActiveMQMessageMarshaller.java:111)\n\tat org.apache.activemq.openwire.v6.ActiveMQObjectMessageMarshaller.looseMarshal(ActiveMQObjectMessageMarshaller.java:111)\n\tat org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:168)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.addMessage(KahaDBStore.java:429)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$StoreQueueTask.run(KahaDBStore.java:1177)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doMessageSend": "    void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,\n            Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Future<Object> result = null;\n\n        checkUsage(context, message);\n        sendLock.lockInterruptibly();\n        try {\n            if (store != null && message.isPersistent()) {\n                message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n                if (messages.isCacheEnabled()) {\n                    result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());\n                } else {\n                    store.addMessage(context, message);\n                }\n                if (isReduceMemoryFootprint()) {\n                    message.clearMarshalledState();\n                }\n            }\n            if (context.isInTransaction()) {\n                // If this is a transacted message.. increase the usage now so that\n                // a big TX does not blow up\n                // our memory. This increment is decremented once the tx finishes..\n                message.incrementReferenceCount();\n\n                context.getTransaction().addSynchronization(new Synchronization() {\n                    @Override\n                    public void afterCommit() throws Exception {\n                        sendLock.lockInterruptibly();\n                        try {\n                            // It could take while before we receive the commit\n                            // op, by that time the message could have expired..\n                            if (broker.isExpired(message)) {\n                                broker.messageExpired(context, message, null);\n                                destinationStatistics.getExpired().increment();\n                                return;\n                            }\n                            sendMessage(message);\n                        } finally {\n                            sendLock.unlock();\n                            message.decrementReferenceCount();\n                        }\n                        messageSent(context, message);\n                    }\n                    @Override\n                    public void afterRollback() throws Exception {\n                        message.decrementReferenceCount();\n                    }\n                });\n            } else {\n                // Add to the pending list, this takes care of incrementing the\n                // usage manager.\n                sendMessage(message);\n            }\n        } finally {\n            sendLock.unlock();\n        }\n        if (!context.isInTransaction()) {\n            messageSent(context, message);\n        }\n        if (result != null && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.sendMessage": "    final void sendMessage(final Message msg) throws Exception {\n        messagesLock.writeLock().lock();\n        try{\n            messages.addMessageLast(msg);\n        }finally {\n            messagesLock.writeLock().unlock();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message expired: \" + reference);\n        }\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.messageSent": "    final void messageSent(final ConnectionContext context, final Message msg) throws Exception {\n        destinationStatistics.getEnqueues().increment();\n        destinationStatistics.getMessages().increment();\n        messageDelivered(context, msg);\n        consumersLock.readLock().lock();\n        try {\n            if (consumers.isEmpty()) {\n                onMessageWithNoConsumers(context, msg);\n            }\n        }finally {\n            consumersLock.readLock().unlock();\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(broker.getBrokerName() + \" Message \" + msg.getMessageId() + \" sent to \" + this.destination);\n        }\n        wakeup();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.isOptimizeStorage": "    protected boolean isOptimizeStorage(){\n        boolean result = false;\n        if (isDoOptimzeMessageStorage()){\n            consumersLock.readLock().lock();\n            try{\n                if (consumers.isEmpty()==false){\n                    result = true;\n                    for (Subscription s : consumers) {\n                        if (s.getPrefetchSize()==0){\n                            result = false;\n                            break;\n                        }\n                        if (s.isSlowConsumer()){\n                            result = false;\n                            break;\n                        }\n                        if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){\n                            result = false;\n                            break;\n                        }\n                    }\n                }\n            }finally {\n                consumersLock.readLock().unlock();\n            }\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.checkUsage": "    private void checkUsage(ConnectionContext context, Message message) throws ResourceAllocationException, IOException, InterruptedException {\n        if (message.isPersistent()) {\n            if (store != null && systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {\n                final String logMessage = \"Persistent store is Full, \" + getStoreUsageHighWaterMark() + \"% of \"\n                    + systemUsage.getStoreUsage().getLimit() + \". Stopping producer (\"\n                    + message.getProducerId() + \") to prevent flooding \"\n                    + getActiveMQDestination().getQualifiedName() + \".\"\n                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n\n                waitForSpace(context, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);\n            }\n        } else if (messages.getSystemUsage() != null && systemUsage.getTempUsage().isFull()) {\n            final String logMessage = \"Temp Store is Full (\"\n                    + systemUsage.getTempUsage().getPercentUsage() + \"% of \" + systemUsage.getTempUsage().getLimit()\n                    +\"). Stopping producer (\" + message.getProducerId()\n                + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n\n            waitForSpace(context, messages.getSystemUsage().getTempUsage(), logMessage);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.send": "    public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        // There is delay between the client sending it and it arriving at the\n        // destination.. it may have expired.\n        message.setRegionDestination(this);\n        ProducerState state = producerExchange.getProducerState();\n        if (state == null) {\n            LOG.warn(\"Send failed for: \" + message + \",  missing producer state for: \" + producerExchange);\n            throw new JMSException(\"Cannot send message to \" + getActiveMQDestination() + \" with invalid (null) producer state\");\n        }\n        final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();\n        final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0\n                && !context.isInRecoveryMode();\n        if (message.isExpired()) {\n            // message not stored - or added to stats yet - so chuck here\n            broker.getRoot().messageExpired(context, message, null);\n            if (sendProducerAck) {\n                ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n                context.getConnection().dispatchAsync(ack);\n            }\n            return;\n        }\n        if (memoryUsage.isFull()) {\n            isFull(context, memoryUsage);\n            fastProducer(context, producerInfo);\n            if (isProducerFlowControl() && context.isProducerFlowControl()) {\n                if (warnOnProducerFlowControl) {\n                    warnOnProducerFlowControl = false;\n                    LOG\n                            .info(\"Usage Manager Memory Limit (\"\n                                    + memoryUsage.getLimit()\n                                    + \") reached on \"\n                                    + getActiveMQDestination().getQualifiedName()\n                                    + \". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it.\"\n                                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new ResourceAllocationException(\"Usage Manager Memory Limit reached. Stopping producer (\"\n                            + message.getProducerId() + \") to prevent flooding \"\n                            + getActiveMQDestination().getQualifiedName() + \".\"\n                            + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                // We can avoid blocking due to low usage if the producer is\n                // sending\n                // a sync message or if it is using a producer window\n                if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {\n                    // copy the exchange state since the context will be\n                    // modified while we are waiting\n                    // for space.\n                    final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy();\n                    synchronized (messagesWaitingForSpace) {\n                     // Start flow control timeout task\n                        // Prevent trying to start it multiple times\n                        if (!flowControlTimeoutTask.isAlive()) {\n                            flowControlTimeoutTask.setName(getName()+\" Producer Flow Control Timeout Task\");\n                            flowControlTimeoutTask.start();\n                        }\n                        messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {\n                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message, null);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of :\" + message, e);\n                                    }\n                                }\n                            }\n                        });\n\n                        if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {\n                            flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage\n                                    .getSendFailIfNoSpaceAfterTimeout()));\n                        }\n\n                        registerCallbackForNotFullNotification();\n                        context.setDontSendReponse(true);\n                        return;\n                    }\n\n                } else {\n\n                    if (memoryUsage.isFull()) {\n                        waitForSpace(context, memoryUsage, \"Usage Manager Memory Limit reached. Producer (\"\n                                + message.getProducerId() + \") stopped to prevent flooding \"\n                                + getActiveMQDestination().getQualifiedName() + \".\"\n                                + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                    }\n\n                    // The usage manager could have delayed us by the time\n                    // we unblock the message could have expired..\n                    if (message.isExpired()) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Expired message: \" + message);\n                        }\n                        broker.getRoot().messageExpired(context, message, null);\n                        return;\n                    }\n                }\n            }\n        }\n        doMessageSend(producerExchange, message);\n        if (sendProducerAck) {\n            ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n            context.getConnection().dispatchAsync(ack);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.start": "    public void start() throws Exception {\n        if (memoryUsage != null) {\n            memoryUsage.start();\n        }\n        if (systemUsage.getStoreUsage() != null) {\n            systemUsage.getStoreUsage().start();\n        }\n        systemUsage.getMemoryUsage().addUsageListener(this);\n        messages.start();\n        if (getExpireMessagesPeriod() > 0) {\n            scheduler.schedualPeriodically(expireMessagesTask, getExpireMessagesPeriod());\n        }\n        doPageIn(false);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getActiveMQDestination": "    public ActiveMQDestination getActiveMQDestination() {\n        return destination;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.send": "    public void send(final ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n\n        if (producerExchange.isMutable() || producerExchange.getRegionDestination() == null) {\n            final Destination regionDestination = lookup(context, messageSend.getDestination(),false);\n            producerExchange.setRegionDestination(regionDestination);\n        }\n\n        producerExchange.getRegionDestination().send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.lookup": "    protected Destination lookup(ConnectionContext context, ActiveMQDestination destination,boolean createTemporary) throws Exception {\n        Destination dest = null;\n\n        destinationsLock.readLock().lock();\n        try {\n            dest = destinations.get(destination);\n        } finally {\n            destinationsLock.readLock().unlock();\n        }\n\n        if (dest == null) {\n            if (isAutoCreateDestinations()) {\n                // Try to auto create the destination... re-invoke broker\n                // from the\n                // top so that the proper security checks are performed.\n                try {\n                    context.getBroker().addDestination(context, destination, createTemporary);\n                    dest = addDestination(context, destination, false);\n                } catch (DestinationAlreadyExistsException e) {\n                    // if the destination already exists then lets ignore\n                    // this error\n                }\n                // We should now have the dest created.\n                destinationsLock.readLock().lock();\n                try {\n                    dest = destinations.get(destination);\n                } finally {\n                    destinationsLock.readLock().unlock();\n                }\n            }\n\n            if (dest == null) {\n                throw new JMSException(\"The destination \" + destination + \" does not exist.\");\n            }\n        }\n        return dest;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        message.setBrokerInTime(System.currentTimeMillis());\n        if (producerExchange.isMutable() || producerExchange.getRegion() == null\n                || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {\n            ActiveMQDestination destination = message.getDestination();\n            // ensure the destination is registered with the RegionBroker\n            producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());\n            Region region;\n            switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                region = queueRegion;\n                break;\n            case ActiveMQDestination.TOPIC_TYPE:\n                region = topicRegion;\n                break;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                region = tempQueueRegion;\n                break;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                region = tempTopicRegion;\n                break;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n            }\n            producerExchange.setRegion(region);\n            producerExchange.setRegionDestination(null);\n        }\n\n        producerExchange.getRegion().send(producerExchange, message);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.createUnknownDestinationTypeException": "    protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {\n        return new JMSException(\"Unknown destination type: \" + destination.getDestinationType());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {\n\n        Destination answer;\n\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n     synchronized (destinations) {\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            answer = queueRegion.addDestination(context, destination,true);\n            break;\n        case ActiveMQDestination.TOPIC_TYPE:\n            answer = topicRegion.addDestination(context, destination,true);\n            break;\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            answer = tempQueueRegion.addDestination(context, destination, createIfTemp);\n            break;\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            answer = tempTopicRegion.addDestination(context, destination, createIfTemp);\n            break;\n        default:\n            throw createUnknownDestinationTypeException(destination);\n        }\n\n        destinations.put(destination, answer);\n        return answer;\n     }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.isAllowTempAutoCreationOnSend": "    public boolean isAllowTempAutoCreationOnSend() {\n        return allowTempAutoCreationOnSend;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.send": "    public void send(ProducerBrokerExchange exchange, Message message) throws Exception {\n        if (exchange != null && exchange.getProducerState() != null && exchange.getProducerState().getInfo() != null) {\n            ProducerInfo info = exchange.getProducerState().getInfo();\n            if (info.getDestination() == null && info.getProducerId() != null) {\n                ObjectName objectName = createObjectName(info, exchange.getConnectionContext().getClientId());\n                ProducerView view = this.dynamicDestinationProducers.get(objectName);\n                if (view != null) {\n                    ActiveMQDestination dest = message.getDestination();\n                    if (dest != null) {\n                        view.setLastUsedDestinationName(dest);\n                    }\n                }\n            }\n         }\n        super.send(exchange, message);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.createObjectName": "    private ObjectName createObjectName(AbortSlowConsumerStrategy strategy) throws MalformedObjectNameException{\n        Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();\n        ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + \":\" + \"BrokerName=\" + map.get(\"BrokerName\") + \",\"\n                            + \"Type=SlowConsumerStrategy,\" + \"InstanceName=\" + JMXSupport.encodeObjectNamePart(strategy.getName()));\n        return objectName;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        next.send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.CompositeDestinationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        if (destination.isComposite()) {\n            ActiveMQDestination[] destinations = destination.getCompositeDestinations();\n            for (int i = 0; i < destinations.length; i++) {\n                if (i != 0) {\n                    message = message.copy();\n                    message.setMemoryUsage(null);\n                }\n                message.setOriginalDestination(destination);\n                message.setDestination(destinations[i]);\n                next.send(producerExchange, message);\n            }\n        } else {\n            next.send(producerExchange, message);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        Synchronization sync = null;\n        if (message.getTransactionId() != null) {\n            transaction = getTransaction(context, message.getTransactionId(), false);\n            if (transaction != null) {\n                sync = new Synchronization() {\n\n                    public void afterRollback() {\n                        if (audit != null) {\n                            audit.rollback(message);\n                        }\n                    }\n                };\n                transaction.addSynchronization(sync);\n            }\n        }\n        if (audit == null || !audit.isDuplicate(message)) {\n            context.setTransaction(transaction);\n            try {\n                next.send(producerExchange, message);\n            } finally {\n                context.setTransaction(originalTx);\n            }\n        } else {\n            if (sync != null && transaction != null) {\n                transaction.removeSynchronization(sync);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"IGNORING duplicate message \" + message);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processMessage": "    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.getProducerBrokerExchange": "    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.ActiveMQMessage.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessage(this);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exption notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.ResponseCorrelator.onCommand": "    public void onCommand(Object o) {\n        Command command = null;\n        if (o instanceof Command) {\n            command = (Command)o;\n        } else {\n            throw new ClassCastException(\"Object cannot be converted to a Command,  Object: \" + o);\n        }\n        if (command.isResponse()) {\n            Response response = (Response)command;\n            FutureResponse future = null;\n            synchronized (requestMap) {\n                future = requestMap.remove(Integer.valueOf(response.getCorrelationId()));\n            }\n            if (future != null) {\n                future.set(response);\n            } else {\n                if (debug) {\n                    LOG.debug(\"Received unexpected response: {\" + command + \"}for command id: \" + response.getCorrelationId());\n                }\n            }\n        } else {\n            getTransportListener().onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.iterate": "    public boolean iterate() {\n\n        final TransportListener tl = transportListener;\n\n        LinkedBlockingQueue<Object> mq;\n        try {\n            mq = getMessageQueue();\n        } catch (TransportDisposedIOException e) {\n            return false;\n        }\n\n        Object command = mq.poll();\n        if (command != null && !disposed.get()) {\n            if( command == DISCONNECT ) {\n                tl.onException(new TransportDisposedIOException(\"Peer (\" + peer.toString() + \") disposed.\"));\n            } else {\n                tl.onCommand(command);\n            }\n            return !mq.isEmpty() && !disposed.get();\n        } else {\n            if(disposed.get()) {\n                mq.clear();\n            }\n            return false;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.getMessageQueue": "    public LinkedBlockingQueue<Object> getMessageQueue() throws TransportDisposedIOException {\n        LinkedBlockingQueue<Object> result = messageQueue;\n        if (result == null) {\n            synchronized (this) {\n                result = messageQueue;\n                if (result == null) {\n                    if (disposed.get()) {\n                        throw new TransportDisposedIOException(\"The Transport has been disposed\");\n                    }\n\n                    messageQueue = result = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);\n                }\n            }\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.toString": "    public String toString() {\n        return location + \"#\" + id;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.PooledTaskRunner.runTask": "    final void runTask() {\n\n        synchronized (runable) {\n            queued = false;\n            if (shutdown) {\n                iterating = false;\n                runable.notifyAll();\n                return;\n            }\n            iterating = true;\n        }\n\n        // Don't synchronize while we are iterating so that\n        // multiple wakeup() calls can be executed concurrently.\n        boolean done = false;\n        try {\n            for (int i = 0; i < maxIterationsPerRun; i++) {\n                LOG.trace(\"Running task iteration {} - {}\", i, task);\n                if (!task.iterate()) {\n                    done = true;\n                    break;\n                }\n            }\n        } finally {\n            synchronized( runable ) {\n                iterating = false;\n                runable.notifyAll();\n                if (shutdown) {\n                    queued = false;\n                    runable.notifyAll();\n                    return;\n                }\n\n                // If we could not iterate all the items\n                // then we need to re-queue.\n                if (!done) {\n                    queued = true;\n                }\n\n                if (queued) {\n                    executor.execute(runable);\n                }\n\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.PooledTaskRunner.run": "            public void run() {\n                runningThread = Thread.currentThread();\n                try {\n                    runTask();\n                } finally {\n                    LOG.trace(\"Run task done: {}\", task);\n                    runningThread = null;\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.util.MarshallingSupport.marshalPrimitiveMap": "    public static void marshalPrimitiveMap(Map map, DataOutputStream out) throws IOException {\n        if (map == null) {\n            out.writeInt(-1);\n        } else {\n            out.writeInt(map.size());\n            for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {\n                String name = (String)iter.next();\n                out.writeUTF(name);\n                Object value = map.get(name);\n                marshalPrimitive(out, value);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.util.MarshallingSupport.marshalPrimitive": "    public static void marshalPrimitive(DataOutputStream out, Object value) throws IOException {\n        if (value == null) {\n            marshalNull(out);\n        } else if (value.getClass() == Boolean.class) {\n            marshalBoolean(out, ((Boolean)value).booleanValue());\n        } else if (value.getClass() == Byte.class) {\n            marshalByte(out, ((Byte)value).byteValue());\n        } else if (value.getClass() == Character.class) {\n            marshalChar(out, ((Character)value).charValue());\n        } else if (value.getClass() == Short.class) {\n            marshalShort(out, ((Short)value).shortValue());\n        } else if (value.getClass() == Integer.class) {\n            marshalInt(out, ((Integer)value).intValue());\n        } else if (value.getClass() == Long.class) {\n            marshalLong(out, ((Long)value).longValue());\n        } else if (value.getClass() == Float.class) {\n            marshalFloat(out, ((Float)value).floatValue());\n        } else if (value.getClass() == Double.class) {\n            marshalDouble(out, ((Double)value).doubleValue());\n        } else if (value.getClass() == byte[].class) {\n            marshalByteArray(out, (byte[])value);\n        } else if (value.getClass() == String.class) {\n            marshalString(out, (String)value);\n        } else if (value instanceof Map) {\n            out.writeByte(MAP_TYPE);\n            marshalPrimitiveMap((Map)value, out);\n        } else if (value instanceof List) {\n            out.writeByte(LIST_TYPE);\n            marshalPrimitiveList((List)value, out);\n        } else {\n            throw new IOException(\"Object is not a primitive: \" + value);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.ActiveMQObjectMessage.beforeMarshall": "    public void beforeMarshall(WireFormat wireFormat) throws IOException {\n        super.beforeMarshall(wireFormat);\n        // may have initiated on vm transport with deferred marshalling\n        storeContent();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.ActiveMQObjectMessage.storeContent": "    public void storeContent() {\n        ByteSequence bodyAsBytes = getContent();\n        if (bodyAsBytes == null && object != null) {\n            try {\n                ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n                OutputStream os = bytesOut;\n                ActiveMQConnection connection = getConnection();\n                if (connection != null && connection.isUseCompression()) {\n                    compressed = true;\n                    os = new DeflaterOutputStream(os);\n                }\n                DataOutputStream dataOut = new DataOutputStream(os);\n                ObjectOutputStream objOut = new ObjectOutputStream(dataOut);\n                objOut.writeObject(object);\n                objOut.flush();\n                objOut.reset();\n                objOut.close();\n                setContent(bytesOut.toByteSequence());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe.getMessage(), ioe);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.v6.MessageMarshaller.looseMarshal": "    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {\n\n        Message info = (Message)o;\n\n        info.beforeMarshall(wireFormat);\n\n        super.looseMarshal(wireFormat, o, dataOut);\n        looseMarshalCachedObject(wireFormat, (DataStructure)info.getProducerId(), dataOut);\n        looseMarshalCachedObject(wireFormat, (DataStructure)info.getDestination(), dataOut);\n        looseMarshalCachedObject(wireFormat, (DataStructure)info.getTransactionId(), dataOut);\n        looseMarshalCachedObject(wireFormat, (DataStructure)info.getOriginalDestination(), dataOut);\n        looseMarshalNestedObject(wireFormat, (DataStructure)info.getMessageId(), dataOut);\n        looseMarshalCachedObject(wireFormat, (DataStructure)info.getOriginalTransactionId(), dataOut);\n        looseMarshalString(info.getGroupID(), dataOut);\n        dataOut.writeInt(info.getGroupSequence());\n        looseMarshalString(info.getCorrelationId(), dataOut);\n        dataOut.writeBoolean(info.isPersistent());\n        looseMarshalLong(wireFormat, info.getExpiration(), dataOut);\n        dataOut.writeByte(info.getPriority());\n        looseMarshalNestedObject(wireFormat, (DataStructure)info.getReplyTo(), dataOut);\n        looseMarshalLong(wireFormat, info.getTimestamp(), dataOut);\n        looseMarshalString(info.getType(), dataOut);\n        looseMarshalByteSequence(wireFormat, info.getContent(), dataOut);\n        looseMarshalByteSequence(wireFormat, info.getMarshalledProperties(), dataOut);\n        looseMarshalNestedObject(wireFormat, (DataStructure)info.getDataStructure(), dataOut);\n        looseMarshalCachedObject(wireFormat, (DataStructure)info.getTargetConsumerId(), dataOut);\n        dataOut.writeBoolean(info.isCompressed());\n        dataOut.writeInt(info.getRedeliveryCounter());\n        looseMarshalObjectArray(wireFormat, info.getBrokerPath(), dataOut);\n        looseMarshalLong(wireFormat, info.getArrival(), dataOut);\n        looseMarshalString(info.getUserID(), dataOut);\n        dataOut.writeBoolean(info.isRecievedByDFBridge());\n        dataOut.writeBoolean(info.isDroppable());\n        looseMarshalObjectArray(wireFormat, info.getCluster(), dataOut);\n        looseMarshalLong(wireFormat, info.getBrokerInTime(), dataOut);\n        looseMarshalLong(wireFormat, info.getBrokerOutTime(), dataOut);\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.v6.ActiveMQMessageMarshaller.looseMarshal": "    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {\n\n        super.looseMarshal(wireFormat, o, dataOut);\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.v6.ActiveMQObjectMessageMarshaller.looseMarshal": "    public void looseMarshal(OpenWireFormat wireFormat, Object o, DataOutput dataOut) throws IOException {\n\n        super.looseMarshal(wireFormat, o, dataOut);\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.OpenWireFormat.marshal": "    public synchronized void marshal(Object o, DataOutput dataOut) throws IOException {\n\n        if (cacheEnabled) {\n            runMarshallCacheEvictionSweep();\n        }\n\n        int size = 1;\n        if (o != null) {\n\n            DataStructure c = (DataStructure)o;\n            byte type = c.getDataStructureType();\n            DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];\n            if (dsm == null) {\n                throw new IOException(\"Unknown data type: \" + type);\n            }\n            if (tightEncodingEnabled) {\n                BooleanStream bs = new BooleanStream();\n                size += dsm.tightMarshal1(this, c, bs);\n                size += bs.marshalledSize();\n\n                if (!sizePrefixDisabled) {\n                    dataOut.writeInt(size);\n                }\n\n                dataOut.writeByte(type);\n                bs.marshal(dataOut);\n                dsm.tightMarshal2(this, c, dataOut, bs);\n\n            } else {\n                DataOutput looseOut = dataOut;\n\n                if (!sizePrefixDisabled) {\n                    bytesOut.restart();\n                    looseOut = bytesOut;\n                }\n\n                looseOut.writeByte(type);\n                dsm.looseMarshal(this, c, looseOut);\n\n                if (!sizePrefixDisabled) {\n                    ByteSequence sequence = bytesOut.toByteSequence();\n                    dataOut.writeInt(sequence.getLength());\n                    dataOut.write(sequence.getData(), sequence.getOffset(), sequence.getLength());\n                }\n\n            }\n\n        } else {\n            if (!sizePrefixDisabled) {\n            \tdataOut.writeInt(size);\n            }\n            dataOut.writeByte(NULL_TYPE);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.OpenWireFormat.tightMarshal1": "    public int tightMarshal1(Object o, BooleanStream bs) throws IOException {\n        int size = 1;\n        if (o != null) {\n            DataStructure c = (DataStructure)o;\n            byte type = c.getDataStructureType();\n            DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];\n            if (dsm == null) {\n                throw new IOException(\"Unknown data type: \" + type);\n            }\n\n            size += dsm.tightMarshal1(this, c, bs);\n            size += bs.marshalledSize();\n        }\n        return size;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.OpenWireFormat.runMarshallCacheEvictionSweep": "    public void runMarshallCacheEvictionSweep() {\n        // Do we need to start evicting??\n        while (marshallCacheMap.size() > marshallCache.length - MARSHAL_CACHE_FREE_SPACE) {\n\n            marshallCacheMap.remove(marshallCache[nextMarshallCacheEvictionIndex]);\n            marshallCache[nextMarshallCacheEvictionIndex] = null;\n\n            nextMarshallCacheEvictionIndex++;\n            if (nextMarshallCacheEvictionIndex >= marshallCache.length) {\n                nextMarshallCacheEvictionIndex = 0;\n            }\n\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.OpenWireFormat.tightMarshal2": "    public void tightMarshal2(Object o, DataOutput ds, BooleanStream bs) throws IOException {\n        if (cacheEnabled) {\n            runMarshallCacheEvictionSweep();\n        }\n\n        if (o != null) {\n            DataStructure c = (DataStructure)o;\n            byte type = c.getDataStructureType();\n            DataStreamMarshaller dsm = (DataStreamMarshaller)dataMarshallers[type & 0xFF];\n            if (dsm == null) {\n                throw new IOException(\"Unknown data type: \" + type);\n            }\n            ds.writeByte(type);\n            bs.marshal(ds);\n            dsm.tightMarshal2(this, c, ds, bs);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.addMessage": "        public void addMessage(ConnectionContext context, Message message) throws IOException {\n            KahaAddMessageCommand command = new KahaAddMessageCommand();\n            command.setDestination(dest);\n            command.setMessageId(message.getMessageId().toString());\n            command.setTransactionInfo(transactionIdTransformer.transform(message.getTransactionId()));\n            command.setPriority(message.getPriority());\n            command.setPrioritySupported(isPrioritizedMessages());\n            org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);\n            command.setMessage(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));\n            store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), null, null);\n\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.toString": "        public String toString() {\n            return destination.getPhysicalName() + \"-\" + id;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.transform": "            public KahaTransactionInfo transform(TransactionId txid) {\n                return TransactionIdConversion.convert(txid);\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.run": "        public void run() {\n            this.store.doneTasks++;\n            try {\n                if (this.done.compareAndSet(false, true)) {\n                    this.topicStore.addMessage(context, message);\n                    // apply any acks we have\n                    synchronized (this.subscriptionKeys) {\n                        for (String key : this.subscriptionKeys) {\n                            this.topicStore.doAcknowledge(context, key, this.message.getMessageId(), null);\n\n                        }\n                    }\n                    removeTopicTask(this.topicStore, this.message.getMessageId());\n                    this.future.complete();\n                } else if (cancelledTaskModMetric > 0 && this.store.canceledTasks++ % cancelledTaskModMetric == 0) {\n                    System.err.println(this.store.dest.getName() + \" cancelled: \"\n                            + (this.store.canceledTasks / this.store.doneTasks) * 100);\n                    this.store.canceledTasks = this.store.doneTasks = 0;\n                }\n            } catch (Exception e) {\n                this.future.setException(e);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.removeQueueTask": "    protected StoreQueueTask removeQueueTask(KahaDBMessageStore store, MessageId id) {\n        StoreQueueTask task = null;\n        synchronized (store.asyncTaskMap) {\n            task = (StoreQueueTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));\n        }\n        return task;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.doAcknowledge": "        protected void doAcknowledge(ConnectionContext context, String subscriptionKey, MessageId messageId, MessageAck ack)\n                throws IOException {\n            KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();\n            command.setDestination(dest);\n            command.setSubscriptionKey(subscriptionKey);\n            command.setMessageId(messageId.toString());\n            command.setTransactionInfo(ack != null ? transactionIdTransformer.transform(ack.getTransactionId()) : null);\n            if (ack != null && ack.isUnmatchedAck()) {\n                command.setAck(UNMATCHED);\n            } else {\n                org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);\n                command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));\n            }\n            store(command, false, null, null);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.setException": "            public void setException(final Exception e) {\n                super.setException(e);\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.complete": "            public void complete() {\n                super.set(null);\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.removeTopicTask": "    protected StoreTopicTask removeTopicTask(KahaDBTopicMessageStore store, MessageId id) {\n        StoreTopicTask task = null;\n        synchronized (store.asyncTaskMap) {\n            task = (StoreTopicTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));\n        }\n        return task;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getExpired": "    public CountStatisticImpl getExpired() {\n        return expired;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.canDispatch": "    public boolean canDispatch(Message messageSend) {\n        boolean canDispatch = true;\n        if (auditProducerSequenceIds && messageSend.isPersistent()) {\n            final long producerSequenceId = messageSend.getMessageId().getProducerSequenceId();\n            if (isNetworkProducer) {\n                //  messages are multiplexed on this producer so we need to query the persistenceAdapter\n                long lastStoredForMessageProducer = getStoredSequenceIdForMessage(messageSend.getMessageId());\n                if (producerSequenceId <= lastStoredForMessageProducer) {\n                    canDispatch = false;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"suppressing duplicate message send  [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] from network producer with producerSequenceId [\"\n                                + producerSequenceId + \"] less than last stored: \"  + lastStoredForMessageProducer);\n                    }\n                }\n            } else if (producerSequenceId <= lastSendSequenceNumber.get()) {\n                canDispatch = false;\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"suppressing duplicate message send [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] with producerSequenceId [\"\n                            + producerSequenceId + \"] less than last stored: \"  + lastSendSequenceNumber);\n                }\n            } else {\n                // track current so we can suppress duplicates later in the stream\n                lastSendSequenceNumber.set(producerSequenceId);\n            }\n        }\n        return canDispatch;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getStoredSequenceIdForMessage": "    private long getStoredSequenceIdForMessage(MessageId messageId) {\n        try {\n            return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());\n       } catch (IOException ignored) {\n            LOG.debug(\"Failed to determine last producer sequence id for: \" +messageId, ignored);\n        }\n        return -1;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.FutureResponse.set": "    public void set(Response result) {\n        if (responseSlot.offer(result)) {\n            if (responseCallback != null) {\n                responseCallback.onCompletion(this);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.task.iterate": "    boolean iterate();\n}",
            "activemq-core.src.main.java.org.apache.activemq.openwire.BooleanStream.marshalledSize": "    public int marshalledSize() {\n        if (arrayLimit < 64) {\n            return 1 + arrayLimit;\n        } else if (arrayLimit < 256) {\n            return 2 + arrayLimit;\n        } else {\n            return 3 + arrayLimit;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.openwire.DataStreamMarshaller.looseMarshal": "    void looseMarshal(OpenWireFormat format, Object c, DataOutput ds) throws IOException;\n    void looseUnmarshal(OpenWireFormat format, Object data, DataInput dis) throws IOException;\n    \n}"
        },
        "bug_report": {
            "Title": "ConcurrentModificationException when using message groups",
            "Description": "seeing these WARN messages frequently while consuming (maxConcurrentConsumers=5) from a queue with the message groups header (JMSXGroupID) set.  If I disable the message groups header, these errors go away...  \n\nThat said, I don't see any specific errors with my application (at this point), just these messages in my logs.\n\n2012-10-04 02:34:02,552 |  WARN - Service              - | Async error occurred: java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException\njava.util.concurrent.ExecutionException: java.util.ConcurrentModificationException\n\tat java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:222)\n\tat java.util.concurrent.FutureTask.get(FutureTask.java:83)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:785)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:707)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:407)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:503)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:305)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:453)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)\n\tat org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:231)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:680)\nCaused by: java.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)\n\tat java.util.HashMap$KeyIterator.next(HashMap.java:828)\n\tat org.apache.activemq.util.MarshallingSupport.marshalPrimitiveMap(MarshallingSupport.java:64)\n\tat org.apache.activemq.command.Message.beforeMarshall(Message.java:210)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.beforeMarshall(ActiveMQObjectMessage.java:199)\n\tat org.apache.activemq.openwire.v6.MessageMarshaller.looseMarshal(MessageMarshaller.java:277)\n\tat org.apache.activemq.openwire.v6.ActiveMQMessageMarshaller.looseMarshal(ActiveMQMessageMarshaller.java:111)\n\tat org.apache.activemq.openwire.v6.ActiveMQObjectMessageMarshaller.looseMarshal(ActiveMQObjectMessageMarshaller.java:111)\n\tat org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:168)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.addMessage(KahaDBStore.java:429)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$StoreQueueTask.run(KahaDBStore.java:1177)\n\t... 3 more\n"
        }
    },
    {
        "filename": "AMQ-3887.json",
        "creation_time": "2012-06-18T16:02:55.000+0000",
        "stack_trace": "java.lang.NullPointerException: null\n        at org.apache.activemq.network.DemandForwardingBridgeSupport.configureMessage(DemandForwardingBridgeSupport.java:644) ~[ac\ntivemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.network.DemandForwardingBridgeSupport.serviceLocalCommand(DemandForwardingBridgeSupport.java:675) ~\n[activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.network.DemandForwardingBridgeSupport$1.onCommand(DemandForwardingBridgeSupport.java:139) [activemq\n-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.vm.VMTransport.doDispatch(VMTransport.java:135) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.vm.VMTransport.dispatch(VMTransport.java:124) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.vm.VMTransport.oneway(VMTransport.java:103) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1307) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:837) [activemq-core-5.6.0.jar:5\n.6.0]\n        at org.apache.activemq.broker.TransportConnection.iterate(TransportConnection.java:872) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.configureMessage": "    protected Message configureMessage(MessageDispatch md) {\n        Message message = md.getMessage().copy();\n        // Update the packet to show where it came from.\n        message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(), localBrokerPath));\n        message.setProducerId(producerInfo.getProducerId());\n        message.setDestination(md.getDestination());\n        if (message.getOriginalTransactionId() == null) {\n            message.setOriginalTransactionId(message.getTransactionId());\n        }\n        message.setTransactionId(null);\n        return message;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.appendToBrokerPath": "    protected BrokerId[] appendToBrokerPath(BrokerId[] brokerPath, BrokerId idToAppend) {\n        if (brokerPath == null || brokerPath.length == 0) {\n            return new BrokerId[] { idToAppend };\n        }\n        BrokerId rc[] = new BrokerId[brokerPath.length + 1];\n        System.arraycopy(brokerPath, 0, rc, 0, brokerPath.length);\n        rc[brokerPath.length] = idToAppend;\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.serviceLocalCommand": "    protected void serviceLocalCommand(Command command) {\n        if (!disposed.get()) {\n            try {\n                if (command.isMessageDispatch()) {\n                    enqueueCounter.incrementAndGet();\n                    final MessageDispatch md = (MessageDispatch) command;\n                    final DemandSubscription sub = subscriptionMapByLocalId.get(md.getConsumerId());\n                    if (sub != null && md.getMessage() != null && sub.incrementOutstandingResponses()) {\n\n                        if (suppressMessageDispatch(md, sub)) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(configuration.getBrokerName() + \" message not forwarded to \" + remoteBrokerName + \" because message came from there or fails networkTTL, brokerPath: \" + Arrays.toString(md.getMessage().getBrokerPath()) + \", message: \" + md.getMessage());\n                            }\n                            // still ack as it may be durable\n                            try {\n                                localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));\n                            } finally {\n                                sub.decrementOutstandingResponses();\n                            }\n                            return;\n                        }\n\n                        Message message = configureMessage(md);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"bridging (\" + configuration.getBrokerName() + \" -> \" + remoteBrokerName + \") \" + (LOG.isTraceEnabled() ? message : message.getMessageId()) + \", consumer: \" + md.getConsumerId() + \", destination \" + message.getDestination() + \", brokerPath: \" + Arrays.toString(message.getBrokerPath()) + \", message: \" + message);\n                        }\n\n                        if (!configuration.isAlwaysSyncSend() && !message.isPersistent()) {\n\n                            // If the message was originally sent using async\n                            // send, we will preserve that QOS\n                            // by bridging it using an async send (small chance\n                            // of message loss).\n                            try {\n                                remoteBroker.oneway(message);\n                                localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));\n                                dequeueCounter.incrementAndGet();\n                            } finally {\n                                sub.decrementOutstandingResponses();\n                            }\n\n                        } else {\n\n                            // The message was not sent using async send, so we\n                            // should only ack the local\n                            // broker when we get confirmation that the remote\n                            // broker has received the message.\n                            ResponseCallback callback = new ResponseCallback() {\n                                public void onCompletion(FutureResponse future) {\n                                    try {\n                                        Response response = future.getResult();\n                                        if (response.isException()) {\n                                            ExceptionResponse er = (ExceptionResponse) response;\n                                            serviceLocalException(er.getException());\n                                        } else {\n                                            localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));\n                                            dequeueCounter.incrementAndGet();\n                                        }\n                                    } catch (IOException e) {\n                                        serviceLocalException(e);\n                                    } finally {\n                                        sub.decrementOutstandingResponses();\n                                    }\n                                }\n                            };\n\n                            remoteBroker.asyncRequest(message, callback);\n\n                        }\n                    } else {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"No subscription registered with this network bridge for consumerId \" + md.getConsumerId() + \" for message: \" + md.getMessage());\n                        }\n                    }\n                } else if (command.isBrokerInfo()) {\n                    localBrokerInfo = (BrokerInfo) command;\n                    serviceLocalBrokerInfo(command);\n                } else if (command.isShutdownInfo()) {\n                    LOG.info(configuration.getBrokerName() + \" Shutting down\");\n                    stop();\n                } else if (command.getClass() == ConnectionError.class) {\n                    ConnectionError ce = (ConnectionError) command;\n                    serviceLocalException(ce.getException());\n                } else {\n                    switch (command.getDataStructureType()) {\n                    case WireFormatInfo.DATA_STRUCTURE_TYPE:\n                        break;\n                    default:\n                        LOG.warn(\"Unexpected local command: \" + command);\n                    }\n                }\n            } catch (Throwable e) {\n                LOG.warn(\"Caught an exception processing local command\", e);\n                serviceLocalException(e);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.serviceLocalBrokerInfo": "    protected void serviceLocalBrokerInfo(Command command) throws InterruptedException {\n        synchronized (brokerInfoMutex) {\n            if (remoteBrokerId != null) {\n                if (remoteBrokerId.equals(localBrokerId)) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(configuration.getBrokerName() + \" disconnecting local loop back connection for: \" + remoteBrokerName + \", with id:\" + remoteBrokerId);\n                    }\n                    waitStarted();\n                    ServiceSupport.dispose(this);\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.serviceLocalException": "    public void serviceLocalException(Throwable error) {\n        if (!disposed.get()) {\n            LOG.info(\"Network connection between \" + localBroker + \" and \" + remoteBroker + \" shutdown due to a local error: \" + error);\n            LOG.debug(\"The local Exception was:\" + error, error);\n            asyncTaskRunner.execute(new Runnable() {\n                public void run() {\n                    ServiceSupport.dispose(getControllingService());\n                }\n            });\n            fireBridgeFailed();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.stop": "    public void stop() throws Exception {\n        if (started.compareAndSet(true, false)) {\n            if (disposed.compareAndSet(false, true)) {\n                LOG.debug(\" stopping \" + configuration.getBrokerName() + \" bridge to \" + remoteBrokerName);\n                NetworkBridgeListener l = this.networkBridgeListener;\n                if (l != null) {\n                    l.onStop(this);\n                }\n                try {\n                    remoteBridgeStarted.set(false);\n                    final CountDownLatch sendShutdown = new CountDownLatch(1);\n                    asyncTaskRunner.execute(new Runnable() {\n                        public void run() {\n                            try {\n                                localBroker.oneway(new ShutdownInfo());\n                                sendShutdown.countDown();\n                                remoteBroker.oneway(new ShutdownInfo());\n                            } catch (Throwable e) {\n                                LOG.debug(\"Caught exception sending shutdown\", e);\n                            } finally {\n                                sendShutdown.countDown();\n                            }\n\n                        }\n                    });\n                    if (!sendShutdown.await(10, TimeUnit.SECONDS)) {\n                        LOG.info(\"Network Could not shutdown in a timely manner\");\n                    }\n                } finally {\n                    ServiceStopper ss = new ServiceStopper();\n                    ss.stop(remoteBroker);\n                    ss.stop(localBroker);\n                    // Release the started Latch since another thread could be\n                    // stuck waiting for it to start up.\n                    startedLatch.countDown();\n                    startedLatch.countDown();\n                    localStartedLatch.countDown();\n                    ss.throwFirstException();\n                }\n            }\n            if (remoteBrokerInfo != null) {\n                brokerService.getBroker().removeBroker(null, remoteBrokerInfo);\n                brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);\n                LOG.info(configuration.getBrokerName() + \" bridge to \" + remoteBrokerName + \" stopped\");\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.suppressMessageDispatch": "    private boolean suppressMessageDispatch(MessageDispatch md, DemandSubscription sub) throws Exception {\n        boolean suppress = false;\n        // for durable subs, suppression via filter leaves dangling acks so we need to\n        // check here and allow the ack irrespective\n        if (sub.getLocalInfo().isDurable()) {\n            MessageEvaluationContext messageEvalContext = new MessageEvaluationContext();\n            messageEvalContext.setMessageReference(md.getMessage());\n            messageEvalContext.setDestination(md.getDestination());\n            suppress = !sub.getNetworkBridgeFilter().matches(messageEvalContext);\n        }\n        return suppress;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.onCommand": "                public void onCommand(Object o) {\n                    Command command = (Command) o;\n                    serviceRemoteCommand(command);\n                }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandForwardingBridgeSupport.serviceRemoteCommand": "    protected void serviceRemoteCommand(Command command) {\n        if (!disposed.get()) {\n            try {\n                if (command.isMessageDispatch()) {\n                    waitStarted();\n                    MessageDispatch md = (MessageDispatch) command;\n                    serviceRemoteConsumerAdvisory(md.getMessage().getDataStructure());\n                    ackAdvisory(md.getMessage());\n                } else if (command.isBrokerInfo()) {\n                    lastConnectSucceeded.set(true);\n                    remoteBrokerInfo = (BrokerInfo) command;\n                    Properties props = MarshallingSupport.stringToProperties(remoteBrokerInfo.getNetworkProperties());\n                    try {\n                        IntrospectionSupport.getProperties(configuration, props, null);\n                        if (configuration.getExcludedDestinations() != null) {\n                            excludedDestinations = configuration.getExcludedDestinations().toArray(\n                                    new ActiveMQDestination[configuration.getExcludedDestinations().size()]);\n                        }\n                        if (configuration.getStaticallyIncludedDestinations() != null) {\n                            staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray(\n                                    new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);\n                        }\n                        if (configuration.getDynamicallyIncludedDestinations() != null) {\n                            dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations()\n                                    .toArray(\n                                            new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations()\n                                                    .size()]);\n                        }\n                    } catch (Throwable t) {\n                        LOG.error(\"Error mapping remote destinations\", t);\n                    }\n                    serviceRemoteBrokerInfo(command);\n                    // Let the local broker know the remote broker's ID.\n                    localBroker.oneway(command);\n                    // new peer broker (a consumer can work with remote broker also)\n                    brokerService.getBroker().addBroker(null, remoteBrokerInfo);\n                } else if (command.getClass() == ConnectionError.class) {\n                    ConnectionError ce = (ConnectionError) command;\n                    serviceRemoteException(ce.getException());\n                } else {\n                    if (isDuplex()) {\n                        if (command.isMessage()) {\n                            ActiveMQMessage message = (ActiveMQMessage) command;\n                            if (AdvisorySupport.isConsumerAdvisoryTopic(message.getDestination())\n                                || AdvisorySupport.isDestinationAdvisoryTopic(message.getDestination())) {\n                                serviceRemoteConsumerAdvisory(message.getDataStructure());\n                                ackAdvisory(message);\n                            } else {\n                                if (!isPermissableDestination(message.getDestination(), true)) {\n                                    return;\n                                }\n                                if (message.isResponseRequired()) {\n                                    Response reply = new Response();\n                                    reply.setCorrelationId(message.getCommandId());\n                                    localBroker.oneway(message);\n                                    remoteBroker.oneway(reply);\n                                } else {\n                                    localBroker.oneway(message);\n                                }\n                            }\n                        } else {\n                            switch (command.getDataStructureType()) {\n                            case ConnectionInfo.DATA_STRUCTURE_TYPE:\n                            case SessionInfo.DATA_STRUCTURE_TYPE:\n                            case ProducerInfo.DATA_STRUCTURE_TYPE:\n                                localBroker.oneway(command);\n                                break;\n                            case MessageAck.DATA_STRUCTURE_TYPE:\n                                MessageAck ack = (MessageAck) command;\n                                DemandSubscription localSub = subscriptionMapByRemoteId.get(ack.getConsumerId());\n                                if (localSub != null) {\n                                    ack.setConsumerId(localSub.getLocalInfo().getConsumerId());\n                                    localBroker.oneway(ack);\n                                } else {\n                                    LOG.warn(\"Matching local subscription not found for ack: \" + ack);\n                                }\n                                break;\n                            case ConsumerInfo.DATA_STRUCTURE_TYPE:\n                                localStartedLatch.await();\n                                if (started.get()) {\n                                    if (!addConsumerInfo((ConsumerInfo) command)) {\n                                        if (LOG.isDebugEnabled()) {\n                                            LOG.debug(\"Ignoring ConsumerInfo: \" + command);\n                                        }\n                                    } else {\n                                        if (LOG.isTraceEnabled()) {\n                                            LOG.trace(\"Adding ConsumerInfo: \" + command);\n                                        }\n                                    }\n                                } else {\n                                    // received a subscription whilst stopping\n                                    LOG.warn(\"Stopping - ignoring ConsumerInfo: \" + command);\n                                }\n                                break;\n                            case ShutdownInfo.DATA_STRUCTURE_TYPE:\n                                // initiator is shutting down, controlled case\n                                // abortive close dealt with by inactivity monitor\n                                LOG.info(\"Stopping network bridge on shutdown of remote broker\");\n                                serviceRemoteException(new IOException(command.toString()));\n                                break;\n                            default:\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Ignoring remote command: \" + command);\n                                }\n                            }\n                        }\n                    } else {\n                        switch (command.getDataStructureType()) {\n                        case KeepAliveInfo.DATA_STRUCTURE_TYPE:\n                        case WireFormatInfo.DATA_STRUCTURE_TYPE:\n                        case ShutdownInfo.DATA_STRUCTURE_TYPE:\n                            break;\n                        default:\n                            LOG.warn(\"Unexpected remote command: \" + command);\n                        }\n                    }\n                }\n            } catch (Throwable e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Exception processing remote command: \" + command, e);\n                }\n                serviceRemoteException(e);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.ResponseCorrelator.onCommand": "    public void onCommand(Object o) {\n        Command command = null;\n        if (o instanceof Command) {\n            command = (Command)o;\n        } else {\n            throw new ClassCastException(\"Object cannot be converted to a Command,  Object: \" + o);\n        }\n        if (command.isResponse()) {\n            Response response = (Response)command;\n            FutureResponse future = null;\n            synchronized (requestMap) {\n                future = requestMap.remove(Integer.valueOf(response.getCorrelationId()));\n            }\n            if (future != null) {\n                future.set(response);\n            } else {\n                if (debug) {\n                    LOG.debug(\"Received unexpected response: {\" + command + \"}for command id: \" + response.getCorrelationId());\n                }\n            }\n        } else {\n            getTransportListener().onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            wreiteLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                wreiteLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.doDispatch": "    public void doDispatch(VMTransport transport, TransportListener transportListener, Object command) {\n        if (command == DISCONNECT) {\n            transportListener.onException(new TransportDisposedIOException(\"Peer (\" + peer.toString() + \") disposed.\"));\n        } else {\n            transport.receiveCounter++;\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.toString": "    public String toString() {\n        return location + \"#\" + id;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.dispatch": "    public void dispatch(VMTransport transport, BlockingQueue<Object> pending, Object command) {\n        TransportListener transportListener = transport.getTransportListener();\n        if (transportListener != null) {\n            // Lock here on the target transport's started since we want to wait for its start()\n            // method to finish dispatching out of the queue before we do our own.\n            synchronized (transport.started) {\n\n                // Ensure that no additional commands entered the queue in the small time window\n                // before the start method locks the dispatch lock and the oneway method was in\n                // an put operation.\n                while(pending != null && !pending.isEmpty() && !transport.isDisposed()) {\n                    doDispatch(transport, transportListener, pending.poll());\n                }\n\n                // We are now in sync mode and won't enqueue any more commands to the target\n                // transport so lets clean up its resources.\n                transport.messageQueue = null;\n\n                // Don't dispatch if either end was disposed already.\n                if (command != null && !this.disposed.get() && !transport.isDisposed()) {\n                    doDispatch(transport, transportListener, command);\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.getTransportListener": "    public TransportListener getTransportListener() {\n        return transportListener;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.isDisposed": "    public boolean isDisposed() {\n        return disposed.get();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.oneway": "    public void oneway(Object command) throws IOException {\n\n        if (disposed.get()) {\n            throw new TransportDisposedIOException(\"Transport disposed.\");\n        }\n\n        if (peer == null) {\n            throw new IOException(\"Peer not connected.\");\n        }\n\n        try {\n\n            if (peer.disposed.get()) {\n                throw new TransportDisposedIOException(\"Peer (\" + peer.toString() + \") disposed.\");\n            }\n\n            if (peer.async || !peer.started.get()) {\n                peer.getMessageQueue().put(command);\n                peer.wakeup();\n                return;\n            }\n\n        } catch (InterruptedException e) {\n            InterruptedIOException iioe = new InterruptedIOException(e.getMessage());\n            iioe.initCause(e);\n            throw iioe;\n        }\n\n        dispatch(peer, peer.messageQueue, command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.wakeup": "    protected void wakeup() {\n        if (async && started.get()) {\n            try {\n                getTaskRunner().wakeup();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } catch (TransportDisposedIOException e) {\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.getMessageQueue": "    public LinkedBlockingQueue<Object> getMessageQueue() throws TransportDisposedIOException {\n        LinkedBlockingQueue<Object> result = messageQueue;\n        if (result == null) {\n            synchronized (this) {\n                result = messageQueue;\n                if (result == null) {\n                    if (disposed.get()) {\n                        throw new TransportDisposedIOException(\"The Transport has been disposed\");\n                    }\n\n                    messageQueue = result = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);\n                }\n            }\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.MutexTransport.oneway": "    public void oneway(Object command) throws IOException {\n        wreiteLock.lock();\n        try {\n            next.oneway(command);\n        } finally {\n            wreiteLock.unlock();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.ResponseCorrelator.oneway": "    public void oneway(Object o) throws IOException {\n        Command command = (Command)o;\n        command.setCommandId(sequenceGenerator.getNextSequenceId());\n        command.setResponseRequired(false);\n        next.oneway(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatch": "    protected void dispatch(Command command) throws IOException {\n        try {\n            setMarkedCandidate(true);\n            transport.oneway(command);\n        } finally {\n            setMarkedCandidate(false);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.setMarkedCandidate": "    public void setMarkedCandidate(boolean markedCandidate) {\n        this.markedCandidate = markedCandidate;\n        if (!markedCandidate) {\n            timeStamp = 0;\n            blockedCandidate = false;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processDispatch": "    protected void processDispatch(Command command) throws IOException {\n        final MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);\n        try {\n            if (!stopping.get()) {\n                if (messageDispatch != null) {\n                    broker.preProcessDispatch(messageDispatch);\n                }\n                dispatch(command);\n            }\n        } finally {\n            if (messageDispatch != null) {\n                Runnable sub = messageDispatch.getTransmitCallback();\n                broker.postProcessDispatch(messageDispatch);\n                if (sub != null) {\n                    sub.run();\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.run": "                    public void run() {\n                        serviceLock.writeLock().lock();\n                        try {\n                            doStop();\n                        } catch (Throwable e) {\n                            LOG.debug(\"Error occurred while shutting down a connection \" + this, e);\n                        } finally {\n                            stopped.countDown();\n                            serviceLock.writeLock().unlock();\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.iterate": "    public boolean iterate() {\n        try {\n            if (pendingStop || stopping.get()) {\n                if (dispatchStopped.compareAndSet(false, true)) {\n                    if (transportException.get() == null) {\n                        try {\n                            dispatch(new ShutdownInfo());\n                        } catch (Throwable ignore) {\n                        }\n                    }\n                    dispatchStoppedLatch.countDown();\n                }\n                return false;\n            }\n            if (!dispatchStopped.get()) {\n                Command command = null;\n                synchronized (dispatchQueue) {\n                    if (dispatchQueue.isEmpty()) {\n                        return false;\n                    }\n                    command = dispatchQueue.remove(0);\n                }\n                processDispatch(command);\n                return true;\n            }\n            return false;\n        } catch (IOException e) {\n            if (dispatchStopped.compareAndSet(false, true)) {\n                dispatchStoppedLatch.countDown();\n            }\n            serviceExceptionAsync(e);\n            return false;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceExceptionAsync": "    public void serviceExceptionAsync(final IOException e) {\n        if (asyncException.compareAndSet(false, true)) {\n            new Thread(\"Async Exception Handler\") {\n                @Override\n                public void run() {\n                    serviceException(e);\n                }\n            }.start();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.PooledTaskRunner.runTask": "    final void runTask() {\n\n        synchronized (runable) {\n            queued = false;\n            if (shutdown) {\n                iterating = false;\n                runable.notifyAll();\n                return;\n            }\n            iterating = true;\n        }\n\n        // Don't synchronize while we are iterating so that\n        // multiple wakeup() calls can be executed concurrently.\n        boolean done = false;\n        try {\n            for (int i = 0; i < maxIterationsPerRun; i++) {\n                if (!task.iterate()) {\n                    done = true;\n                    break;\n                }\n            }\n        } finally {\n            synchronized( runable ) {\n                iterating = false;\n                runable.notifyAll();\n                if (shutdown) {\n                    queued = false;\n                    runable.notifyAll();\n                    return;\n                }\n\n                // If we could not iterate all the items\n                // then we need to re-queue.\n                if (!done) {\n                    queued = true;\n                }\n\n                if (queued) {\n                    executor.execute(runable);\n                }\n\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.PooledTaskRunner.run": "            public void run() {\n                runningThread = Thread.currentThread();\n                try {\n                    runTask();\n                } finally {\n                    runningThread = null;\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandSubscription.incrementOutstandingResponses": "    public boolean incrementOutstandingResponses() {\n        dispatched.incrementAndGet();\n        if (activeWaiter.get()) {\n            decrementOutstandingResponses();\n            return false;\n        }\n        return true;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.DemandSubscription.decrementOutstandingResponses": "    public void decrementOutstandingResponses() {\n        if (dispatched.decrementAndGet() == 0 && activeWaiter.get()) {\n            synchronized (activeWaiter) {\n                activeWaiter.notifyAll();\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.FutureResponse.set": "    public void set(Response result) {\n        if (responseSlot.offer(result)) {\n            if (responseCallback != null) {\n                responseCallback.onCompletion(this);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.broker.preProcessDispatch": "    void preProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * Notify the Broker that a dispatch has happened\n     * \n     * @param messageDispatch\n     */\n    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     * \n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     * \n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     * \n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     *\n     * @param context\n     * @param messageReference\n     * @param subscription, may be null\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n\n    /**\n     * A message needs to go the a DLQ\n     * \n     * @param context\n     * @param messageReference\n     * @param subscription, may be null\n     */\n    void sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n    \n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n    \n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub \n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n    \n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination \n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n    \n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo);\n    \n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination \n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n    \n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n    \n    Scheduler getScheduler();\n    \n    ThreadPoolExecutor getExecutor();\n\n    void networkBridgeStarted(BrokerInfo brokerInfo, boolean createdByDuplex, String remoteIp);\n\n    void networkBridgeStopped(BrokerInfo brokerInfo);\n\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.broker.postProcessDispatch": "    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     * \n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     * \n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     * \n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     *\n     * @param context\n     * @param messageReference\n     * @param subscription, may be null\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n\n    /**\n     * A message needs to go the a DLQ\n     * \n     * @param context\n     * @param messageReference\n     * @param subscription, may be null\n     */\n    void sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n    \n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n    \n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub \n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n    \n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination \n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n    \n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo);\n    \n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination \n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n    \n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n    \n    Scheduler getScheduler();\n    \n    ThreadPoolExecutor getExecutor();\n\n    void networkBridgeStarted(BrokerInfo brokerInfo, boolean createdByDuplex, String remoteIp);\n\n    void networkBridgeStopped(BrokerInfo brokerInfo);\n\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.thread.task.iterate": "    boolean iterate();\n}"
        },
        "bug_report": {
            "Title": "Occasional Null Pointer Exception during NetworkConnector connection",
            "Description": "While starting a duplex NetworkConnector an NPE can be observed on the receiving side.\n\n{code}\n2012-06-18 17:34:24,571 INFO  .DemandForwardingBridgeSupport - Network connection between vm://proxy-cbpi001#8 and tcp:///169.254.\n0.5:59412(cbox-56BU101117) has been established. [StartLocalBridge: localBroker=vm://proxy-cbpi001#8]\n2012-06-18 17:34:24,577 WARN  .DemandForwardingBridgeSupport - Caught an exception processing local command [BrokerService[proxy-c\nbpi001] Task-19]\njava.lang.NullPointerException: null\n        at org.apache.activemq.network.DemandForwardingBridgeSupport.configureMessage(DemandForwardingBridgeSupport.java:644) ~[ac\ntivemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.network.DemandForwardingBridgeSupport.serviceLocalCommand(DemandForwardingBridgeSupport.java:675) ~\n[activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.network.DemandForwardingBridgeSupport$1.onCommand(DemandForwardingBridgeSupport.java:139) [activemq\n-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.vm.VMTransport.doDispatch(VMTransport.java:135) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.vm.VMTransport.dispatch(VMTransport.java:124) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.vm.VMTransport.oneway(VMTransport.java:103) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1307) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:837) [activemq-core-5.6.0.jar:5\n.6.0]\n        at org.apache.activemq.broker.TransportConnection.iterate(TransportConnection.java:872) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122) [activemq-core-5.6.0.jar:5.6.0]\n        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43) [activemq-core-5.6.0.jar:5.6.0]\n        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source) [na:1.6.0_20]\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [na:1.6.0_20]\n        at java.lang.Thread.run(Unknown Source) [na:1.6.0_20]\n{code}\n\nThe other broker will eventually connect, but with about a hundred of connecting brokers this occurs too often to ignore.\n\nAs this seems to be a race condition it is quite difficult to reproduce reliably. I assume producerInfo is accessed in configureMessage before it is initialized in startRemoteBridge."
        }
    },
    {
        "filename": "AMQ-6451.json",
        "creation_time": "2016-10-03T17:09:00.000+0000",
        "stack_trace": "java.lang.OutOfMemoryError: Direct buffer memory\n        at java.nio.Bits.reserveMemory(Bits.java:693)[:1.8.0_101]\n        at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)[:1.8.0_101]\n        at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)[:1.8.0_101]\n        at sun.nio.ch.Util.getTemporaryDirectBuffer(Util.java:174)[:1.8.0_101]\n        at sun.nio.ch.IOUtil.write(IOUtil.java:58)[:1.8.0_101]\n        at sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:211)[:1.8.0_101]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationZeros(Journal.java:366)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.preallocateEntireJournalDataFile(Journal.java:333)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.newDataFile(Journal.java:631)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.rotateWriteFile(Journal.java:595)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.getCurrentDataFile(Journal.java:984)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.enqueue(DataFileAppender.java:189)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.storeItem(DataFileAppender.java:128)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.write(Journal.java:890)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:1108)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:1090)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:301)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:70)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:252)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.BrokerFilter.commitTransaction(BrokerFilter.java:113)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.BrokerFilter.commitTransaction(BrokerFilter.java:113)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:535)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:333)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:197)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:300)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.tcp.SslTransport.doConsume(SslTransport.java:108)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)[activemq-client-5.14.0.jar:5.14.0]\n        at java.lang.Thread.run(Thread.java:745)",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationZeros": "    private void doPreallocationZeros(RecoverableRandomAccessFile file) {\n        ByteBuffer buffer = ByteBuffer.allocate(maxFileLength);\n        buffer.put(EOF_RECORD);\n        buffer.rewind();\n        try {\n            FileChannel channel = file.getChannel();\n            channel.write(buffer);\n            channel.force(false);\n            channel.position(0);\n        } catch (ClosedByInterruptException ignored) {\n            LOG.trace(\"Could not preallocate journal file with zeros\", ignored);\n        } catch (IOException e) {\n            LOG.error(\"Could not preallocate journal file with zeros\", e);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.write": "    public Location write(ByteSequence data, Runnable onComplete) throws IOException, IllegalStateException {\n        Location loc = appender.storeItem(data, Location.USER_TYPE, onComplete);\n        return loc;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.preallocateEntireJournalDataFile": "    public void preallocateEntireJournalDataFile(RecoverableRandomAccessFile file) {\n\n        if (PreallocationScope.NONE != preallocationScope) {\n\n            if (PreallocationStrategy.OS_KERNEL_COPY == preallocationStrategy) {\n                doPreallocationKernelCopy(file);\n            } else if (PreallocationStrategy.ZEROS == preallocationStrategy) {\n                doPreallocationZeros(file);\n            } else if (PreallocationStrategy.CHUNKED_ZEROS == preallocationStrategy) {\n                doPreallocationChunkedZeros(file);\n            } else {\n                doPreallocationSparseFile(file);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationSparseFile": "    private void doPreallocationSparseFile(RecoverableRandomAccessFile file) {\n        final ByteBuffer journalEof = ByteBuffer.wrap(EOF_RECORD);\n        try {\n            FileChannel channel = file.getChannel();\n            channel.position(0);\n            channel.write(journalEof);\n            channel.position(maxFileLength - 5);\n            journalEof.rewind();\n            channel.write(journalEof);\n            channel.force(false);\n            channel.position(0);\n        } catch (ClosedByInterruptException ignored) {\n            LOG.trace(\"Could not preallocate journal file with sparse file\", ignored);\n        } catch (IOException e) {\n            LOG.error(\"Could not preallocate journal file with sparse file\", e);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationKernelCopy": "    private void doPreallocationKernelCopy(RecoverableRandomAccessFile file) {\n        try (RandomAccessFile templateRaf = new RandomAccessFile(osKernelCopyTemplateFile, \"rw\");){\n            templateRaf.getChannel().transferTo(0, getMaxFileLength(), file.getChannel());\n        } catch (ClosedByInterruptException ignored) {\n            LOG.trace(\"Could not preallocate journal file with kernel copy\", ignored);\n        } catch (FileNotFoundException e) {\n            LOG.error(\"Could not find the template file on disk at \" + osKernelCopyTemplateFile.getAbsolutePath(), e);\n        } catch (IOException e) {\n            LOG.error(\"Could not transfer the template file to journal, transferFile=\" + osKernelCopyTemplateFile.getAbsolutePath(), e);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationChunkedZeros": "    private void doPreallocationChunkedZeros(RecoverableRandomAccessFile file) {\n\n        ByteBuffer buffer = ByteBuffer.allocate(PREALLOC_CHUNK_SIZE);\n        buffer.put(EOF_RECORD);\n        buffer.rewind();\n\n        try {\n            FileChannel channel = file.getChannel();\n\n            int remLen = maxFileLength;\n            while (remLen > 0) {\n                if (remLen < buffer.remaining()) {\n                    buffer.limit(remLen);\n                }\n                int writeLen = channel.write(buffer);\n                remLen -= writeLen;\n                buffer.rewind();\n            }\n\n            channel.force(false);\n            channel.position(0);\n        } catch (ClosedByInterruptException ignored) {\n            LOG.trace(\"Could not preallocate journal file with zeros\", ignored);\n        } catch (IOException e) {\n            LOG.error(\"Could not preallocate journal file with zeros! Will continue without preallocation\", e);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.newDataFile": "    private DataFile newDataFile() throws IOException {\n        int nextNum = nextDataFileId++;\n        File file = getFile(nextNum);\n        DataFile nextWriteFile = new DataFile(file, nextNum);\n        preallocateEntireJournalDataFile(nextWriteFile.appendRandomAccessFile());\n        return nextWriteFile;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.getFile": "    public File getFile(int nextNum) {\n        String fileName = filePrefix + nextNum + fileSuffix;\n        File file = new File(directory, fileName);\n        return file;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.rotateWriteFile": "    private void rotateWriteFile() throws IOException {\n       synchronized (dataFileIdLock) {\n            DataFile dataFile = nextDataFile;\n            if (dataFile == null) {\n                dataFile = newDataFile();\n            }\n            synchronized (currentDataFile) {\n                fileMap.put(dataFile.getDataFileId(), dataFile);\n                fileByFileMap.put(dataFile.getFile(), dataFile);\n                dataFiles.addLast(dataFile);\n                currentDataFile.set(dataFile);\n            }\n            nextDataFile = null;\n        }\n        if (PreallocationScope.ENTIRE_JOURNAL_ASYNC == preallocationScope) {\n            preAllocateNextDataFileFuture = scheduler.submit(preAllocateNextDataFileTask);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Journal.getCurrentDataFile": "    public DataFile getCurrentDataFile(int capacity) throws IOException {\n        synchronized (currentDataFile) {\n            if (currentDataFile.get().getLength() + capacity >= maxFileLength) {\n                rotateWriteFile();\n            }\n            return currentDataFile.get();\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.enqueue": "    private WriteBatch enqueue(Journal.WriteCommand write) throws IOException {\n        synchronized (enqueueMutex) {\n            if (shutdown) {\n                throw new IOException(\"Async Writer Thread Shutdown\");\n            }\n\n            if (!running) {\n                running = true;\n                thread = new Thread() {\n                    @Override\n                    public void run() {\n                        processQueue();\n                    }\n                };\n                thread.setPriority(Thread.MAX_PRIORITY);\n                thread.setDaemon(true);\n                thread.setName(\"ActiveMQ Data File Writer\");\n                thread.start();\n                firstAsyncException = null;\n            }\n\n            if (firstAsyncException != null) {\n                throw firstAsyncException;\n            }\n\n            while ( true ) {\n                if (nextWriteBatch == null) {\n                    DataFile file = journal.getCurrentDataFile(write.location.getSize());\n                    nextWriteBatch = newWriteBatch(write, file);\n                    enqueueMutex.notifyAll();\n                    break;\n                } else {\n                    // Append to current batch if possible..\n                    if (nextWriteBatch.canAppend(write)) {\n                        nextWriteBatch.append(write);\n                        break;\n                    } else {\n                        // Otherwise wait for the queuedCommand to be null\n                        try {\n                            while (nextWriteBatch != null) {\n                                final long start = System.currentTimeMillis();\n                                enqueueMutex.wait();\n                                if (maxStat > 0) {\n                                    logger.info(\"Waiting for write to finish with full batch... millis: \" +\n                                                (System.currentTimeMillis() - start));\n                               }\n                            }\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException();\n                        }\n                        if (shutdown) {\n                            throw new IOException(\"Async Writer Thread Shutdown\");\n                        }\n                    }\n                }\n            }\n            if (!write.sync) {\n                inflightWrites.put(new Journal.WriteKey(write.location), write);\n            }\n            return nextWriteBatch;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.append": "        public void append(Journal.WriteCommand write) throws IOException {\n            this.writes.addLast(write);\n            write.location.setDataFileId(dataFile.getDataFileId());\n            write.location.setOffset(offset+size);\n            int s = write.location.getSize();\n            size += s;\n            dataFile.incrementLength(s);\n            journal.addToTotalLength(s);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.canAppend": "        public boolean canAppend(Journal.WriteCommand write) {\n            int newSize = size + write.location.getSize();\n            if (newSize >= maxWriteBatchSize || offset+newSize > journal.getMaxFileLength() ) {\n                return false;\n            }\n            return true;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.newWriteBatch": "    protected WriteBatch newWriteBatch(Journal.WriteCommand write, DataFile file) throws IOException {\n        return new WriteBatch(file, file.getLength(), write);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.processQueue": "    protected void processQueue() {\n        DataFile dataFile = null;\n        RecoverableRandomAccessFile file = null;\n        WriteBatch wb = null;\n        try (DataByteArrayOutputStream buff = new DataByteArrayOutputStream(maxWriteBatchSize);) {\n\n            while (true) {\n\n                // Block till we get a command.\n                synchronized (enqueueMutex) {\n                    while (true) {\n                        if (nextWriteBatch != null) {\n                            wb = nextWriteBatch;\n                            nextWriteBatch = null;\n                            break;\n                        }\n                        if (shutdown) {\n                            return;\n                        }\n                        enqueueMutex.wait();\n                    }\n                    enqueueMutex.notifyAll();\n                }\n\n                if (dataFile != wb.dataFile) {\n                    if (file != null) {\n                        if (periodicSync) {\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Syning file {} on rotate\", dataFile.getFile().getName());\n                            }\n                            file.sync();\n                        }\n                        dataFile.closeRandomAccessFile(file);\n                    }\n                    dataFile = wb.dataFile;\n                    file = dataFile.appendRandomAccessFile();\n                }\n\n                Journal.WriteCommand write = wb.writes.getHead();\n\n                // Write an empty batch control record.\n                buff.reset();\n                buff.write(EMPTY_BATCH_CONTROL_RECORD);\n\n                boolean forceToDisk = false;\n                while (write != null) {\n                    forceToDisk |= write.sync | (syncOnComplete && write.onComplete != null);\n                    buff.writeInt(write.location.getSize());\n                    buff.writeByte(write.location.getType());\n                    buff.write(write.data.getData(), write.data.getOffset(), write.data.getLength());\n                    write = write.getNext();\n                }\n\n                // append 'unset', zero length next batch so read can always find eof\n                buff.write(Journal.EOF_RECORD);\n\n                ByteSequence sequence = buff.toByteSequence();\n\n                // Now we can fill in the batch control record properly.\n                buff.reset();\n                buff.skip(RECORD_HEAD_SPACE + Journal.BATCH_CONTROL_RECORD_MAGIC.length);\n                buff.writeInt(sequence.getLength() - Journal.BATCH_CONTROL_RECORD_SIZE - Journal.EOF_RECORD.length);\n                if( journal.isChecksum() ) {\n                    Checksum checksum = new Adler32();\n                    checksum.update(sequence.getData(), sequence.getOffset()+Journal.BATCH_CONTROL_RECORD_SIZE, sequence.getLength()-Journal.BATCH_CONTROL_RECORD_SIZE-Journal.EOF_RECORD.length);\n                    buff.writeLong(checksum.getValue());\n                }\n\n                // Now do the 1 big write.\n                file.seek(wb.offset);\n                if (maxStat > 0) {\n                    if (statIdx < maxStat) {\n                        stats[statIdx++] = sequence.getLength();\n                    } else {\n                        long all = 0;\n                        for (;statIdx > 0;) {\n                            all+= stats[--statIdx];\n                        }\n                        logger.info(\"Ave writeSize: \" + all/maxStat);\n                    }\n                }\n                file.write(sequence.getData(), sequence.getOffset(), sequence.getLength());\n\n                ReplicationTarget replicationTarget = journal.getReplicationTarget();\n                if( replicationTarget!=null ) {\n                    replicationTarget.replicate(wb.writes.getHead().location, sequence, forceToDisk);\n                }\n\n                if (forceToDisk) {\n                    file.sync();\n                }\n\n                Journal.WriteCommand lastWrite = wb.writes.getTail();\n                journal.setLastAppendLocation(lastWrite.location);\n\n                signalDone(wb);\n            }\n        } catch (IOException e) {\n            logger.info(\"Journal failed while writing at: \" + wb.offset);\n            synchronized (enqueueMutex) {\n                firstAsyncException = e;\n                if (wb != null) {\n                    wb.exception.set(e);\n                    wb.latch.countDown();\n                }\n                if (nextWriteBatch != null) {\n                    nextWriteBatch.exception.set(e);\n                    nextWriteBatch.latch.countDown();\n                }\n            }\n        } catch (InterruptedException e) {\n        } finally {\n            try {\n                if (file != null) {\n                    if (periodicSync) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Syning file {} on close\", dataFile.getFile().getName());\n                        }\n                        file.sync();\n                    }\n                    dataFile.closeRandomAccessFile(file);\n                }\n            } catch (Throwable ignore) {\n            }\n            shutdownDone.countDown();\n            running = false;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.storeItem": "    public Location storeItem(ByteSequence data, byte type, Runnable onComplete) throws IOException {\n        // Write the packet our internal buffer.\n        int size = data.getLength() + RECORD_HEAD_SPACE;\n\n        final Location location = new Location();\n        location.setSize(size);\n        location.setType(type);\n\n        Journal.WriteCommand write = new Journal.WriteCommand(location, data, onComplete);\n\n        WriteBatch batch = enqueue(write);\n\n        location.setLatch(batch.latch);\n        return location;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(JournalCommand<?> data, boolean sync, IndexAware before, Runnable after, Runnable onJournalStoreComplete) throws IOException {\n        try {\n            ByteSequence sequence = toByteSequence(data);\n            Location location;\n\n            checkpointLock.readLock().lock();\n            try {\n\n                long start = System.currentTimeMillis();\n                location = onJournalStoreComplete == null ? journal.write(sequence, sync) : journal.write(sequence, onJournalStoreComplete) ;\n                long start2 = System.currentTimeMillis();\n                //Track the last async update so we know if we need to sync at the next checkpoint\n                if (!sync && journal.isJournalDiskSyncPeriodic()) {\n                    lastAsyncJournalUpdate.set(location);\n                }\n                process(data, location, before);\n\n                long end = System.currentTimeMillis();\n                if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Slow KahaDB access: Journal append took: \"+(start2-start)+\" ms, Index update took \"+(end-start2)+\" ms\");\n                    }\n                }\n            } finally {\n                checkpointLock.readLock().unlock();\n            }\n\n            if (after != null) {\n                after.run();\n            }\n\n            if (scheduler == null && opened.get()) {\n                startCheckpoint();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal\", ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.run": "        public void run() {\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.toByteSequence": "    public ByteSequence toByteSequence(JournalCommand<?> data) throws IOException {\n        int size = data.serializedSizeFramed();\n        DataByteArrayOutputStream os = new DataByteArrayOutputStream(size + 1);\n        os.writeByte(data.type().getNumber());\n        data.writeFramed(os);\n        return os.toByteSequence();\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.process": "    protected void process(KahaRewrittenDataFileCommand command, Location location)  throws IOException {\n        final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n\n        // Mark the current journal file as a compacted file so that gc checks can skip\n        // over logs that are smaller compaction type logs.\n        DataFile current = journal.getDataFileById(location.getDataFileId());\n        current.setTypeCode(command.getRewriteType());\n\n        if (completeFileSet.contains(command.getSourceDataFileId()) && command.getSkipIfSourceExists()) {\n            // Move offset so that next location read jumps to next file.\n            location.setOffset(journalMaxFileLength);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.startCheckpoint": "    private void startCheckpoint() {\n        if (checkpointInterval == 0 && cleanupInterval == 0) {\n            LOG.info(\"periodic checkpoint/cleanup disabled, will ocurr on clean shutdown/restart\");\n            return;\n        }\n        synchronized (schedulerLock) {\n            if (scheduler == null || scheduler.isShutdown()) {\n                scheduler = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n\n                    @Override\n                    public Thread newThread(Runnable r) {\n                        Thread schedulerThread = new Thread(r);\n\n                        schedulerThread.setName(\"ActiveMQ Journal Checkpoint Worker\");\n                        schedulerThread.setDaemon(true);\n\n                        return schedulerThread;\n                    }\n                });\n\n                // Short intervals for check-point and cleanups\n                long delay;\n                if (journal.isJournalDiskSyncPeriodic()) {\n                    delay = Math.min(journalDiskSyncInterval > 0 ? journalDiskSyncInterval : checkpointInterval, 500);\n                } else {\n                    delay = Math.min(checkpointInterval > 0 ? checkpointInterval : cleanupInterval, 500);\n                }\n\n                scheduler.scheduleWithFixedDelay(new CheckpointRunner(), 0, delay, TimeUnit.MILLISECONDS);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.write": "        public void write(DataOutput os) throws IOException {\n            os.writeInt(state);\n            os.writeLong(destinations.getPageId());\n\n            if (lastUpdate != null) {\n                os.writeBoolean(true);\n                LocationMarshaller.INSTANCE.writePayload(lastUpdate, os);\n            } else {\n                os.writeBoolean(false);\n            }\n\n            if (firstInProgressTransactionLocation != null) {\n                os.writeBoolean(true);\n                LocationMarshaller.INSTANCE.writePayload(firstInProgressTransactionLocation, os);\n            } else {\n                os.writeBoolean(false);\n            }\n\n            if (producerSequenceIdTrackerLocation != null) {\n                os.writeBoolean(true);\n                LocationMarshaller.INSTANCE.writePayload(producerSequenceIdTrackerLocation, os);\n            } else {\n                os.writeBoolean(false);\n            }\n            os.writeInt(VERSION);\n            if (ackMessageFileMapLocation != null) {\n                os.writeBoolean(true);\n                LocationMarshaller.INSTANCE.writePayload(ackMessageFileMapLocation, os);\n            } else {\n                os.writeBoolean(false);\n            }\n            os.writeInt(this.openwireVersion);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit": "    public void commit(TransactionId txid, boolean wasPrepared, final Runnable preCommit, Runnable postCommit)\n            throws IOException {\n        if (txid != null) {\n            if (!txid.isXATransaction() && theStore.isConcurrentStoreAndDispatchTransactions()) {\n                if (preCommit != null) {\n                    preCommit.run();\n                }\n                Tx tx = inflightTransactions.remove(txid);\n                if (tx != null) {\n                    List<Future<Object>> results = tx.commit();\n                    boolean doneSomething = false;\n                    for (Future<Object> result : results) {\n                        try {\n                            result.get();\n                        } catch (InterruptedException e) {\n                            theStore.brokerService.handleIOException(new IOException(e.getMessage()));\n                        } catch (ExecutionException e) {\n                            theStore.brokerService.handleIOException(new IOException(e.getMessage()));\n                        }catch(CancellationException e) {\n                        }\n                        if (!result.isCancelled()) {\n                            doneSomething = true;\n                        }\n                    }\n                    if (postCommit != null) {\n                        postCommit.run();\n                    }\n                    if (doneSomething) {\n                        KahaTransactionInfo info = getTransactionInfo(txid);\n                        theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, null);\n                    }\n                }else {\n                    //The Tx will be null for failed over clients - lets run their post commits\n                    if (postCommit != null) {\n                        postCommit.run();\n                    }\n                }\n\n            } else {\n                KahaTransactionInfo info = getTransactionInfo(txid);\n                if (preCommit != null) {\n                    preCommit.run();\n                }\n                theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, postCommit);\n                forgetRecoveredAcks(txid, false);\n            }\n        }else {\n           LOG.error(\"Null transaction passed on commit\");\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.run": "                    public Future<Object> run(ConnectionContext ctx) throws IOException {\n                        destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                        return AbstractMessageStore.FUTURE;\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.getTransactionInfo": "    private KahaTransactionInfo getTransactionInfo(TransactionId txid) {\n        return TransactionIdConversion.convert(theStore.getTransactionIdTransformer().transform(txid));\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.forgetRecoveredAcks": "    protected void forgetRecoveredAcks(TransactionId txid, boolean isRollback) throws IOException {\n        if (txid.isXATransaction()) {\n            XATransactionId xaTid = ((XATransactionId) txid);\n            theStore.forgetRecoveredAcks(xaTid.getPreparedAcks(), isRollback);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.getMessage": "                    public Message getMessage() {\n                        return message;\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBTransactionStore.add": "        public void add(RemoveMessageCommand ack) {\n            acks.add(ack);\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.LocalTransaction.commit": "    public void commit(boolean onePhase) throws XAException, IOException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"commit: \"  + xid\n                    + \" syncCount: \" + size());\n        }\n        \n        // Get ready for commit.\n        try {\n            prePrepare();\n        } catch (XAException e) {\n            throw e;\n        } catch (Throwable e) {\n            LOG.warn(\"COMMIT FAILED: \", e);\n            rollback();\n            // Let them know we rolled back.\n            XAException xae = new XAException(\"COMMIT FAILED: Transaction rolled back\");\n            xae.errorCode = XAException.XA_RBOTHER;\n            xae.initCause(e);\n            throw xae;\n        }\n\n        setState(Transaction.FINISHED_STATE);\n        context.getTransactions().remove(xid);\n        try {\n            transactionStore.commit(getTransactionId(), false, preCommitTask, postCommitTask);\n            this.waitPostCommitDone(postCommitTask);\n        } catch (Throwable t) {\n            LOG.warn(\"Store COMMIT FAILED: \", t);\n            rollback();\n            XAException xae = new XAException(\"STORE COMMIT FAILED: Transaction rolled back\");\n            xae.errorCode = XAException.XA_RBOTHER;\n            xae.initCause(t);\n            throw xae;\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.LocalTransaction.rollback": "    public void rollback() throws XAException, IOException {\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"rollback: \"  + xid\n                    + \" syncCount: \" + size());\n        }\n        setState(Transaction.FINISHED_STATE);\n        context.getTransactions().remove(xid);\n        transactionStore.rollback(getTransactionId());\n        try {\n            fireAfterRollback();\n        } catch (Throwable e) {\n            LOG.warn(\"POST ROLLBACK FAILED: \", e);\n            XAException xae = new XAException(\"POST ROLLBACK FAILED\");\n            xae.errorCode = XAException.XAER_RMERR;\n            xae.initCause(e);\n            throw xae;\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.LocalTransaction.getTransactionId": "    public TransactionId getTransactionId() {\n        return xid;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.commitTransaction": "    public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {\n        Transaction transaction = getTransaction(context, xid, true);\n        transaction.commit(onePhase);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Transaction transaction = null;\n        if (xid.isXATransaction()) {\n            synchronized (xaTransactions) {\n                transaction = xaTransactions.get(xid);\n            }\n        } else {\n            transaction = context.getTransactions().get(xid);\n        }\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = XATransaction.newXAException(\"Transaction '\" + xid + \"' has not been started.\", XAException.XAER_NOTA);\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.commitTransaction": "    public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {\n        next.commitTransaction(context, xid, onePhase);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.commitTransaction": "    public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {\n        getNext().commitTransaction(context, xid, onePhase);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase": "    public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        cs.removeTransactionState(info.getTransactionId());\n        broker.commitTransaction(context, info.getTransactionId(), true);\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.lookupConnectionState": "    public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getConnectionId": "    public String getConnectionId() {\n        List<TransportConnectionState> connectionStates = listConnectionStates();\n        for (TransportConnectionState cs : connectionStates) {\n            if (cs.getInfo().getClientId() != null) {\n                return cs.getInfo().getClientId();\n            }\n            return cs.getInfo().getConnectionId().toString();\n        }\n        return null;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.TransactionInfo.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        switch (type) {\n        case TransactionInfo.BEGIN:\n            return visitor.processBeginTransaction(this);\n        case TransactionInfo.END:\n            return visitor.processEndTransaction(this);\n        case TransactionInfo.PREPARE:\n            return visitor.processPrepareTransaction(this);\n        case TransactionInfo.COMMIT_ONE_PHASE:\n            return visitor.processCommitTransactionOnePhase(this);\n        case TransactionInfo.COMMIT_TWO_PHASE:\n            return visitor.processCommitTransactionTwoPhase(this);\n        case TransactionInfo.ROLLBACK:\n            return visitor.processRollbackTransaction(this);\n        case TransactionInfo.RECOVER:\n            return visitor.processRecoverTransactions(this);\n        case TransactionInfo.FORGET:\n            return visitor.processForgetTransaction(this);\n        default:\n            throw new IOException(\"Transaction info type unknown: \" + type);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(transportException.get());\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred on connection to: {}, {}\",\n                            transport.getRemoteAddress(), e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.forceRollbackOnlyOnFailedAsyncTransactionOp": "    private void forceRollbackOnlyOnFailedAsyncTransactionOp(Throwable e, Command command) {\n        if (brokerService.isRollbackOnlyOnAsyncException() && !(e instanceof IOException) && isInTransaction(command)) {\n            Transaction transaction = getActiveTransaction(command);\n            if (transaction != null && !transaction.isRollbackOnly()) {\n                LOG.debug(\"on async exception, force rollback of transaction for: \" + command, e);\n                transaction.setRollbackOnly(e);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getRemoteAddress": "    public String getRemoteAddress() {\n        return transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                transportException.set(e);\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Async error occurred: \" + e, e);\n                } else {\n                    SERVICELOG.warn(\"Async error occurred: \" + e);\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.isStopping": "    public boolean isStopping() {\n        return stopping.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.SslTransport.doConsume": "    public void doConsume(Object command) {\n        // The instanceof can be avoided, but that would require modifying the\n        // Command clas tree and that would require too much effort right\n        // now.\n        if (command instanceof ConnectionInfo) {\n            ConnectionInfo connectionInfo = (ConnectionInfo)command;\n            connectionInfo.setTransportContext(getPeerCertificates());\n        }\n        super.doConsume(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.SslTransport.getPeerCertificates": "    public X509Certificate[] getPeerCertificates() {\n\n        SSLSocket sslSocket = (SSLSocket)this.socket;\n\n        SSLSession sslSession = sslSocket.getSession();\n\n        X509Certificate[] clientCertChain;\n        try {\n            clientCertChain = (X509Certificate[])sslSession.getPeerCertificates();\n        } catch (SSLPeerUnverifiedException e) {\n            clientCertChain = null;\n        }\n\n        return clientCertChain;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFile.appendRandomAccessFile": "    public synchronized RecoverableRandomAccessFile appendRandomAccessFile() throws IOException {\n        if (appendRandomAccessFile == null) {\n            appendRandomAccessFile = new RecoverableRandomAccessFile(file.getCanonicalPath(), \"rw\");\n        }\n        return appendRandomAccessFile;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.DataFile.getDataFileId": "    public Integer getDataFileId() {\n        return dataFileId;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.journal.getCurrentDataFile": "    public DataFile getCurrentDataFile(int capacity) throws IOException {\n        synchronized (currentDataFile) {\n            if (currentDataFile.get().getLength() + capacity >= maxFileLength) {\n                rotateWriteFile();\n            }\n            return currentDataFile.get();\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.journal.rotateWriteFile": "    private void rotateWriteFile() throws IOException {\n       synchronized (dataFileIdLock) {\n            DataFile dataFile = nextDataFile;\n            if (dataFile == null) {\n                dataFile = newDataFile();\n            }\n            synchronized (currentDataFile) {\n                fileMap.put(dataFile.getDataFileId(), dataFile);\n                fileByFileMap.put(dataFile.getFile(), dataFile);\n                dataFiles.addLast(dataFile);\n                currentDataFile.set(dataFile);\n            }\n            nextDataFile = null;\n        }\n        if (PreallocationScope.ENTIRE_JOURNAL_ASYNC == preallocationScope) {\n            preAllocateNextDataFileFuture = scheduler.submit(preAllocateNextDataFileTask);\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Location.setType": "    public void setType(byte type) {\n        this.type = type;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Location.setSize": "    public void setSize(int size) {\n        this.size = size;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.journal.Location.setLatch": "    public void setLatch(CountDownLatch latch) {\n        this.latch = latch;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnectionState.getContext": "    public ConnectionContext getContext() {\n        return context;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.broker.commitTransaction": "    void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception;\n\n    /**\n     * Forgets a transaction.\n     *\n     * @param context\n     * @param transactionId\n     * @throws Exception\n     */\n    void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception;\n\n    /**\n     * Get the BrokerInfo's of any connected Brokers\n     *\n     * @return array of peer BrokerInfos\n     */\n    BrokerInfo[] getPeerBrokerInfos();\n\n    /**\n     * Notify the Broker that a dispatch is going to happen\n     *\n     * @param messageDispatch\n     */\n    void preProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * Notify the Broker that a dispatch has happened\n     *\n     * @param messageDispatch\n     */\n    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     *\n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     *\n     * @param context\n     * @param info\n     *\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     *\n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     *\n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     *\n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     *\n     * @param context\n     * @param messageReference\n     * @param subscription (may be null)\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n\n    /**\n     * A message needs to go the a DLQ\n     *\n     *\n     * @param context\n     * @param messageReference\n     * @param poisonCause reason for dlq submission, may be null\n     * @return true if Message was placed in a DLQ false if discarded.\n     */\n    boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause);\n\n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n\n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub\n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     * @param destination\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo,ActiveMQDestination destination);\n\n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination\n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n\n    void virtualDestinationAdded(ConnectionContext context, VirtualDestination virtualDestination);\n\n    void virtualDestinationRemoved(ConnectionContext context, VirtualDestination virtualDestination);\n\n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n\n    Scheduler getScheduler();\n\n    ThreadPoolExecutor getExecutor();\n\n    void networkBridgeStarted(BrokerInfo brokerInfo, boolean createdByDuplex, String remoteIp);\n\n    void networkBridgeStopped(BrokerInfo brokerInfo);\n\n\n}",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "Preallocation strategy of zeros can leak file descriptors causing crash",
            "Description": "If the preallocationStrategy is set to 'zeros', ActiveMQ can intermittently become unable to allocate direct buffer memory with the default JVM settings. The exception isn't handled, and ends up both creating an empty journal file and, more importantly, leaking a file descriptor.\n\nActiveMQ eventually runs out of file descriptors and crashes.\n\nIn addition to handling this condition, perhaps the default ACTIVEMQ_OPTS_MEMORY settings should configure enough direct memory to allow some multiple of log files to be created near simultaneously, or at least this possibility documented in the KahaDB settings.\n\nRelevant logs:\n\n{noformat}\n2016-10-03 12:47:24,154 | WARN  | Async error occurred: java.lang.OutOfMemoryError: Direct buffer memory | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: ssl:///x.x.x.x:60805\n2016-10-03 12:47:24,818 | WARN  | Async error occurred: java.lang.OutOfMemoryError: Direct buffer memory | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: ssl:///x.x.x.x:60811\n2016-10-03 12:47:25,477 | WARN  | Async error occurred: java.lang.OutOfMemoryError: Direct buffer memory | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: ssl:///x.x.x.x:49830\n2016-10-03 12:47:26,146 | WARN  | Store COMMIT FAILED:  | org.apache.activemq.transaction.LocalTransaction | ActiveMQ Transport: ssl:///x.x.x.x:65534\njava.lang.OutOfMemoryError: Direct buffer memory\n        at java.nio.Bits.reserveMemory(Bits.java:693)[:1.8.0_101]\n        at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)[:1.8.0_101]\n        at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)[:1.8.0_101]\n        at sun.nio.ch.Util.getTemporaryDirectBuffer(Util.java:174)[:1.8.0_101]\n        at sun.nio.ch.IOUtil.write(IOUtil.java:58)[:1.8.0_101]\n        at sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:211)[:1.8.0_101]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationZeros(Journal.java:366)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.preallocateEntireJournalDataFile(Journal.java:333)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.newDataFile(Journal.java:631)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.rotateWriteFile(Journal.java:595)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.getCurrentDataFile(Journal.java:984)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.enqueue(DataFileAppender.java:189)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.storeItem(DataFileAppender.java:128)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.disk.journal.Journal.write(Journal.java:890)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:1108)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:1090)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:301)[activemq-kahadb-store-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:70)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:252)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.BrokerFilter.commitTransaction(BrokerFilter.java:113)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.BrokerFilter.commitTransaction(BrokerFilter.java:113)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:535)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:333)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:197)[activemq-broker-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:300)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.tcp.SslTransport.doConsume(SslTransport.java:108)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)[activemq-client-5.14.0.jar:5.14.0]\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)[activemq-client-5.14.0.jar:5.14.0]\n        at java.lang.Thread.run(Thread.java:745)[:1.8.0_101]\n{noformat}\n\nEmpty journal files:\n\n{noformat}\n-rw-r--r-- 1 activemq activemq         0 Oct  3 12:47 db-51425.log\n-rw-r--r-- 1 activemq activemq         0 Oct  3 12:47 db-51426.log\n-rw-r--r-- 1 activemq activemq         0 Oct  3 12:47 db-51427.log\n-rw-r--r-- 1 activemq activemq         0 Oct  3 12:47 db-51428.log\n-rw-r--r-- 1 activemq activemq         0 Oct  3 12:47 db-51429.log\n{noformat}\n\nlsof output:\n\n{noformat}\njava    29263 activemq  452u      REG             202,48         0       160 /activemq/kahadb/db-51425.log\njava    29263 activemq  455u      REG             202,48         0       153 /activemq/kahadb/db-51426.log\njava    29263 activemq  456u      REG             202,48         0       133 /activemq/kahadb/db-51427.log\njava    29263 activemq  462u      REG             202,48         0       157 /activemq/kahadb/db-51428.log\n{noformat}\n"
        }
    },
    {
        "filename": "AMQ-3393.json",
        "creation_time": "2011-07-05T14:31:31.000+0000",
        "stack_trace": "javax.management.InstanceAlreadyExistsException: org.apache.activemq:BrokerName=xx,Type=Connection,ConnectorName=stomp,ViewType=address,Name=/xx_52170\n\tat com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:453)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.internal_addObject(DefaultMBeanServerInterceptor.java:1484)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:963)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:917)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:312)\n\tat com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:482)\n\tat org.apache.activemq.broker.jmx.ManagementContext.registerMBean(ManagementContext.java:299)\n\tat org.apache.activemq.broker.jmx.AnnotatedMBean.registerMBean(AnnotatedMBean.java:65)\n\tat org.apache.activemq.broker.jmx.ManagedTransportConnection.registerMBean(ManagedTransportConnection.java:99)\n\tat org.apache.activemq.broker.jmx.ManagedTransportConnection.<init>(ManagedTransportConnection.java:57)\n\tat org.apache.activemq.broker.jmx.ManagedTransportConnector.createConnection(ManagedTransportConnector.java:52)\n\tat org.apache.activemq.broker.TransportConnector$1$1.run(TransportConnector.java:216)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagementContext.registerMBean": "    public ObjectInstance registerMBean(Object bean, ObjectName name) throws Exception{\n        ObjectInstance result = getMBeanServer().registerMBean(bean, name);\n        this.registeredMBeanNames.add(name);\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagementContext.getMBeanServer": "    protected MBeanServer getMBeanServer() {\n        if (this.beanServer == null) {\n            this.beanServer = findMBeanServer();\n        }\n        return beanServer;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.AnnotatedMBean.registerMBean": "  public static void registerMBean(ManagementContext context, Object object, ObjectName objectName) \n    throws Exception {\n\n    String mbeanName = object.getClass().getName() + \"MBean\";\n    \n    for (Class c : object.getClass().getInterfaces()) {\n      if (mbeanName.equals(c.getName())) {\n        context.registerMBean(new AnnotatedMBean(object, c), objectName);\n        return;\n      }\n    }\n\n    context.registerMBean(object, objectName);\n  }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagedTransportConnection.registerMBean": "    protected void registerMBean(ObjectName name) {\n        if (name != null) {\n            try {\n                AnnotatedMBean.registerMBean(managementContext, mbean, name);\n            } catch (Throwable e) {\n                LOG.warn(\"Failed to register MBean: \" + name);\n                LOG.debug(\"Failure reason: \" + e, e);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagedTransportConnector.createConnection": "    protected Connection createConnection(Transport transport) throws IOException {\n        return new ManagedTransportConnection(this, transport, getBroker(), isDisableAsyncDispatch() ? null : getTaskRunnerFactory(), managementContext, connectorName);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnector.run": "                        public void run() {\n                            try {\n                                Connection connection = createConnection(transport);\n                                connection.start();\n                            } catch (Exception e) {\n                                ServiceSupport.dispose(transport);\n                                onAcceptError(e);\n                            }\n                        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnector.createConnection": "    protected Connection createConnection(Transport transport) throws IOException {\n        TransportConnection answer = new TransportConnection(this, transport, broker, disableAsyncDispatch ? null\n                : taskRunnerFactory);\n        boolean statEnabled = this.getStatistics().isEnabled();\n        answer.getStatistics().setEnabled(statEnabled);\n        answer.setMessageAuthorizationPolicy(messageAuthorizationPolicy);\n        return answer;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnector.start": "    public void start() throws Exception {\n        broker = brokerService.getBroker();\n        brokerInfo.setBrokerName(broker.getBrokerName());\n        brokerInfo.setBrokerId(broker.getBrokerId());\n        brokerInfo.setPeerBrokerInfos(broker.getPeerBrokerInfos());\n        brokerInfo.setFaultTolerantConfiguration(broker.isFaultTolerantConfiguration());\n        brokerInfo.setBrokerURL(getServer().getConnectURI().toString());\n        getServer().setAcceptListener(new TransportAcceptListener() {\n            public void onAccept(final Transport transport) {\n                try {\n                    DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable() {\n                        public void run() {\n                            try {\n                                Connection connection = createConnection(transport);\n                                connection.start();\n                            } catch (Exception e) {\n                                ServiceSupport.dispose(transport);\n                                onAcceptError(e);\n                            }\n                        }\n                    });\n                } catch (Exception e) {\n                    String remoteHost = transport.getRemoteAddress();\n                    ServiceSupport.dispose(transport);\n                    onAcceptError(e, remoteHost);\n                }\n            }\n\n            public void onAcceptError(Exception error) {\n                onAcceptError(error, null);\n            }\n\n            private void onAcceptError(Exception error, String remoteHost) {\n                LOG.error(\"Could not accept connection \" + (remoteHost == null ? \"\" : \"from \" + remoteHost) + \": \"\n                        + error);\n                LOG.debug(\"Reason: \" + error, error);\n            }\n        });\n        getServer().setBrokerInfo(brokerInfo);\n        getServer().start();\n\n        DiscoveryAgent da = getDiscoveryAgent();\n        if (da != null) {\n            da.registerService(getPublishableConnectString());\n            da.start();\n        }\n        if (enableStatusMonitor) {\n            this.statusDector = new TransportStatusDetector(this);\n            this.statusDector.start();\n        }\n\n        LOG.info(\"Connector \" + getName() + \" Started\");\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnector.onAcceptError": "            private void onAcceptError(Exception error, String remoteHost) {\n                LOG.error(\"Could not accept connection \" + (remoteHost == null ? \"\" : \"from \" + remoteHost) + \": \"\n                        + error);\n                LOG.debug(\"Reason: \" + error, error);\n            }"
        },
        "bug_report": {
            "Title": "Number of established STOMP connections constantly increasing",
            "Description": "Rapid connect/disconnect can result in dangling stomp transport connection mbeans which eventually accumulate.\nIssue occurs when a disconnect occurs before a broker connection has been fully initiated. The delayed stop, pending start completion was bypassed by a shutdown command from the stomp protocol convertor.\n\nOne potential symptom, when a client side port wrapps around and is reused for the MBean name. There is a registration failure, with {code}2011-06-15 12:27:22,860 [eMQ Task-125034] WARN  ManagedTransportConnection     - Failed to register MBean: org.apache.activemq:BrokerName=xx,Type=Connection,ConnectorName=stomp,ViewType=address,Name=/xx_52170\n2011-06-15 12:27:22,860 [eMQ Task-125034] DEBUG ManagedTransportConnection     - Failure reason: javax.management.InstanceAlreadyExistsException: org.apache.activemq:BrokerName=xx,Type=Connection,ConnectorName=stomp,ViewType=address,Name=/xx_52170\njavax.management.InstanceAlreadyExistsException: org.apache.activemq:BrokerName=xx,Type=Connection,ConnectorName=stomp,ViewType=address,Name=/xx_52170\n\tat com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:453)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.internal_addObject(DefaultMBeanServerInterceptor.java:1484)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:963)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:917)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:312)\n\tat com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:482)\n\tat org.apache.activemq.broker.jmx.ManagementContext.registerMBean(ManagementContext.java:299)\n\tat org.apache.activemq.broker.jmx.AnnotatedMBean.registerMBean(AnnotatedMBean.java:65)\n\tat org.apache.activemq.broker.jmx.ManagedTransportConnection.registerMBean(ManagedTransportConnection.java:99)\n\tat org.apache.activemq.broker.jmx.ManagedTransportConnection.<init>(ManagedTransportConnection.java:57)\n\tat org.apache.activemq.broker.jmx.ManagedTransportConnector.createConnection(ManagedTransportConnector.java:52)\n\tat org.apache.activemq.broker.TransportConnector$1$1.run(TransportConnector.java:216)\n\tat java.lang.Thread.run(Thread){code}\n"
        }
    },
    {
        "filename": "AMQ-5815.json",
        "creation_time": "2015-06-01T12:21:13.000+0000",
        "stack_trace": "java.io.IOException: Input/output error\n        at java.io.RandomAccessFile.write(Native Method)[:1.6.0_30]\n        at java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)[:1.6.0_30]\n        at org.apache.activemq.util.RecoverableRandomAccessFile.writeLong(RecoverableRandomAccessFile.java:305)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.PageFile.writeBatch(PageFile.java:1062)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.PageFile.flush(PageFile.java:516)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1512)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase$17.execute(MessageDatabase.java:1484)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1481)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:929)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:357)[activemq-kahadb-store-5.10.0.jar:5.10.0]",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.util.RecoverableRandomAccessFile.writeLong": "    public void writeLong(long l) throws IOException {\n        try {\n            getRaf().writeLong(l);\n        } catch (IOException ioe) {\n            handleException();\n            throw ioe;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.util.RecoverableRandomAccessFile.handleException": "    protected void handleException() throws IOException {\n        try {\n            if (raf != null) {\n                raf.close();\n            }\n        } catch (Throwable ignore) {\n        } finally {\n            raf = null;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.util.RecoverableRandomAccessFile.getRaf": "    protected RandomAccessFile getRaf() throws IOException {\n        if (raf == null) {\n            raf = new RandomAccessFile(file, mode);\n        }\n        return raf;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.writeBatch": "    private void writeBatch() throws IOException {\n\n        CountDownLatch checkpointLatch;\n        ArrayList<PageWrite> batch;\n        synchronized (writes) {\n            // If there is not enough to write, wait for a notification...\n\n            batch = new ArrayList<PageWrite>(writes.size());\n            // build a write batch from the current write cache.\n            for (PageWrite write : writes.values()) {\n                batch.add(write);\n                // Move the current write to the diskBound write, this lets folks update the\n                // page again without blocking for this write.\n                write.begin();\n                if (write.diskBound == null && write.diskBoundLocation == -1) {\n                    batch.remove(write);\n                }\n            }\n\n            // Grab on to the existing checkpoint latch cause once we do this write we can\n            // release the folks that were waiting for those writes to hit disk.\n            checkpointLatch = this.checkpointLatch;\n            this.checkpointLatch = null;\n        }\n\n        Checksum checksum = new Adler32();\n        if (enableRecoveryFile) {\n            recoveryFile.seek(RECOVERY_FILE_HEADER_SIZE);\n        }\n        for (PageWrite w : batch) {\n            if (enableRecoveryFile) {\n                try {\n                    checksum.update(w.getDiskBound(), 0, pageSize);\n                } catch (Throwable t) {\n                    throw IOExceptionSupport.create(\"Cannot create recovery file. Reason: \" + t, t);\n                }\n                recoveryFile.writeLong(w.page.getPageId());\n                recoveryFile.write(w.getDiskBound(), 0, pageSize);\n            }\n\n            writeFile.seek(toOffset(w.page.getPageId()));\n            writeFile.write(w.getDiskBound(), 0, pageSize);\n            w.done();\n        }\n\n        try {\n            if (enableRecoveryFile) {\n                // Can we shrink the recovery buffer??\n                if (recoveryPageCount > recoveryFileMaxPageCount) {\n                    int t = Math.max(recoveryFileMinPageCount, batch.size());\n                    recoveryFile.setLength(recoveryFileSizeForPages(t));\n                }\n\n                // Record the page writes in the recovery buffer.\n                recoveryFile.seek(0);\n                // Store the next tx id...\n                recoveryFile.writeLong(nextTxid.get());\n                // Store the checksum for thw write batch so that on recovery we\n                // know if we have a consistent\n                // write batch on disk.\n                recoveryFile.writeLong(checksum.getValue());\n                // Write the # of pages that will follow\n                recoveryFile.writeInt(batch.size());\n            }\n\n            if (enableDiskSyncs) {\n                // Sync to make sure recovery buffer writes land on disk..\n                if (enableRecoveryFile) {\n                    recoveryFile.sync();\n                }\n                writeFile.sync();\n            }\n        } finally {\n            synchronized (writes) {\n                for (PageWrite w : batch) {\n                    // If there are no more pending writes, then remove it from\n                    // the write cache.\n                    if (w.isDone()) {\n                        writes.remove(w.page.getPageId());\n                        if (w.tmpFile != null && tmpFilesForRemoval.contains(w.tmpFile)) {\n                            if (!w.tmpFile.delete()) {\n                                throw new IOException(\"Can't delete temporary KahaDB transaction file:\" + w.tmpFile);\n                            }\n                            tmpFilesForRemoval.remove(w.tmpFile);\n                        }\n                    }\n                }\n            }\n\n            if (checkpointLatch != null) {\n                checkpointLatch.countDown();\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.write": "    void write(Collection<Map.Entry<Long, PageWrite>> updates) throws IOException {\n        synchronized (writes) {\n            if (enabledWriteThread) {\n                while (writes.size() >= writeBatchSize && !stopWriter.get()) {\n                    try {\n                        writes.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        throw new InterruptedIOException();\n                    }\n                }\n            }\n\n            boolean longTx = false;\n\n            for (Map.Entry<Long, PageWrite> entry : updates) {\n                Long key = entry.getKey();\n                PageWrite value = entry.getValue();\n                PageWrite write = writes.get(key);\n                if (write == null) {\n                    writes.put(key, value);\n                } else {\n                    if (value.currentLocation != -1) {\n                        write.setCurrentLocation(value.page, value.currentLocation, value.length);\n                        write.tmpFile = value.tmpFile;\n                        longTx = true;\n                    } else {\n                        write.setCurrent(value.page, value.current);\n                    }\n                }\n            }\n\n            // Once we start approaching capacity, notify the writer to start writing\n            // sync immediately for long txs\n            if (longTx || canStartWriteBatch()) {\n\n                if (enabledWriteThread) {\n                    writes.notify();\n                } else {\n                    writeBatch();\n                }\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.getDiskBound": "        public byte[] getDiskBound() throws IOException {\n            if (diskBound == null && diskBoundLocation != -1) {\n                diskBound = new byte[length];\n                RandomAccessFile file = new RandomAccessFile(tmpFile, \"r\");\n                file.seek(diskBoundLocation);\n                file.read(diskBound);\n                file.close();\n                diskBoundLocation = -1;\n            }\n            return diskBound;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.toOffset": "    public long toOffset(long pageId) {\n        return PAGE_FILE_HEADER_SIZE + (pageId * pageSize);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.isDone": "        boolean isDone() {\n            return diskBound == null && diskBoundLocation == -1 && current == null && currentLocation == -1;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.recoveryFileSizeForPages": "    private long recoveryFileSizeForPages(int pageCount) {\n        return RECOVERY_FILE_HEADER_SIZE + ((pageSize + 8) * pageCount);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.getValue": "            public PageWrite getValue() {\n                return write;\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.begin": "        void begin() {\n            if (currentLocation != -1) {\n                diskBoundLocation = currentLocation;\n            } else {\n                diskBound = current;\n            }\n            current = null;\n            currentLocation = -1;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.done": "        boolean done() {\n            diskBoundLocation = -1;\n            diskBound = null;\n            return current == null || currentLocation == -1;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.page.PageFile.flush": "    public void flush() throws IOException {\n\n        if (enabledWriteThread && stopWriter.get()) {\n            throw new IOException(\"Page file already stopped: checkpointing is not allowed\");\n        }\n\n        // Setup a latch that gets notified when all buffered writes hits the disk.\n        CountDownLatch checkpointLatch;\n        synchronized (writes) {\n            if (writes.isEmpty()) {\n                return;\n            }\n            if (enabledWriteThread) {\n                if (this.checkpointLatch == null) {\n                    this.checkpointLatch = new CountDownLatch(1);\n                }\n                checkpointLatch = this.checkpointLatch;\n                writes.notify();\n            } else {\n                writeBatch();\n                return;\n            }\n        }\n        try {\n            checkpointLatch.await();\n        } catch (InterruptedException e) {\n            InterruptedIOException ioe = new InterruptedIOException();\n            ioe.initCause(e);\n            throw ioe;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    void checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {\n        LOG.debug(\"Checkpoint started.\");\n\n        // reflect last update exclusive of current checkpoint\n        Location lastUpdate = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit();\n        metadata.ackMessageFileMapLocation = checkpointAckMessageFileMap();\n        Location[] inProgressTxRange = getInProgressTxLocationRange();\n        metadata.firstInProgressTransactionLocation = inProgressTxRange[0];\n        tx.store(metadata.page, metadataMarshaller, true);\n        pageFile.flush();\n\n        if( cleanup ) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n            final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Last update: \" + lastUpdate + \", full gc candidates set: \" + gcCandidateSet);\n            }\n\n            if (lastUpdate != null) {\n                gcCandidateSet.remove(lastUpdate.getDataFileId());\n            }\n\n            // Don't GC files under replication\n            if( journalFilesBeingReplicated!=null ) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                int dataFileId = metadata.producerSequenceIdTrackerLocation.getDataFileId();\n                if (gcCandidateSet.contains(dataFileId) && gcCandidateSet.first() == dataFileId) {\n                    // rewrite so we don't prevent gc\n                    metadata.producerSequenceIdTracker.setModified(true);\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"rewriting producerSequenceIdTracker:\" + metadata.producerSequenceIdTrackerLocation);\n                    }\n                }\n                gcCandidateSet.remove(dataFileId);\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after producerSequenceIdTrackerLocation:\" + dataFileId + \", \" + gcCandidateSet);\n                }\n            }\n\n            if (metadata.ackMessageFileMapLocation != null) {\n                int dataFileId = metadata.ackMessageFileMapLocation.getDataFileId();\n                gcCandidateSet.remove(dataFileId);\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after ackMessageFileMapLocation:\" + dataFileId + \", \" + gcCandidateSet);\n                }\n            }\n\n            // Don't GC files referenced by in-progress tx\n            if (inProgressTxRange[0] != null) {\n                for (int pendingTx=inProgressTxRange[0].getDataFileId(); pendingTx <= inProgressTxRange[1].getDataFileId(); pendingTx++) {\n                    gcCandidateSet.remove(pendingTx);\n                }\n            }\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates after tx range:\" + Arrays.asList(inProgressTxRange) + \", \" + gcCandidateSet);\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if( gcCandidateSet.isEmpty() ) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last=-1;\n                    @Override\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if( first==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if( second==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    @Override\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n\n                // Durable Subscription\n                if (entry.getValue().subLocations != null) {\n                    Iterator<Entry<String, Location>> iter = entry.getValue().subLocations.iterator(tx);\n                    while (iter.hasNext()) {\n                        Entry<String, Location> subscription = iter.next();\n                        int dataFileId = subscription.getValue().getDataFileId();\n\n                        // Move subscription along if it has no outstanding messages that need ack'd\n                        // and its in the last log file in the journal.\n                        if (!gcCandidateSet.isEmpty() && gcCandidateSet.first() == dataFileId) {\n                            final StoredDestination destination = entry.getValue();\n                            final String subscriptionKey = subscription.getKey();\n                            SequenceSet pendingAcks = destination.ackPositions.get(tx, subscriptionKey);\n\n                            // When pending is size one that is the next message Id meaning there\n                            // are no pending messages currently.\n                            if (pendingAcks == null || pendingAcks.size() <= 1) {\n                                if (LOG.isTraceEnabled()) {\n                                    LOG.trace(\"Found candidate for rewrite: {} from file {}\", entry.getKey(), dataFileId);\n                                }\n\n                                final KahaSubscriptionCommand kahaSub =\n                                    destination.subscriptions.get(tx, subscriptionKey);\n                                destination.subLocations.put(\n                                    tx, subscriptionKey, checkpointSubscriptionCommand(kahaSub));\n\n                                // Skips the remove from candidates if we rewrote the subscription\n                                // in order to prevent duplicate subscription commands on recover.\n                                // If another subscription is on the same file and isn't rewritten\n                                // than it will remove the file from the set.\n                                continue;\n                            }\n                        }\n\n                        gcCandidateSet.remove(dataFileId);\n                    }\n                }\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n                }\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates: \" + gcCandidateSet);\n            }\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = metadata.ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidateSet.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don't delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        metadata.ackMessageFileMap.remove(candidate);\n                    } else {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"not removing data file: \" + candidate\n                                    + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                        }\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cleanup removing the data files: \" + gcCandidateSet);\n                }\n                journal.removeDataFiles(gcCandidateSet);\n            }\n        }\n\n        LOG.debug(\"Checkpoint done.\");\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointSubscriptionCommand": "    private Location checkpointSubscriptionCommand(KahaSubscriptionCommand subscription) throws IOException {\n\n        ByteSequence sequence = toByteSequence(subscription);\n        Location location = journal.write(sequence, nullCompletionCallback) ;\n\n        try {\n            location.getLatch().await();\n        } catch (InterruptedException e) {\n            throw new InterruptedIOException(e.toString());\n        }\n        return location;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointProducerAudit": "    private Location checkpointProducerAudit() throws IOException {\n        if (metadata.producerSequenceIdTracker == null || metadata.producerSequenceIdTracker.modified()) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oout = new ObjectOutputStream(baos);\n            oout.writeObject(metadata.producerSequenceIdTracker);\n            oout.flush();\n            oout.close();\n            // using completion callback allows a disk sync to be avoided when enableJournalDiskSyncs = false\n            Location location = store(new KahaProducerAuditCommand().setAudit(new Buffer(baos.toByteArray())), nullCompletionCallback);\n            try {\n                location.getLatch().await();\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException(e.toString());\n            }\n            return location;\n        }\n        return metadata.producerSequenceIdTrackerLocation;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.remove": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.execute": "        public void execute(Transaction tx) throws IOException {\n            updateIndex(tx, command, location);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getInProgressTxLocationRange": "    public Location[] getInProgressTxLocationRange() {\n        Location[] range = new Location[]{null, null};\n        synchronized (inflightTransactions) {\n            if (!inflightTransactions.isEmpty()) {\n                for (List<Operation> ops : inflightTransactions.values()) {\n                    if (!ops.isEmpty()) {\n                        trackMaxAndMin(range, ops);\n                    }\n                }\n            }\n            if (!preparedTransactions.isEmpty()) {\n                for (List<Operation> ops : preparedTransactions.values()) {\n                    if (!ops.isEmpty()) {\n                        trackMaxAndMin(range, ops);\n                    }\n                }\n            }\n        }\n        return range;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException{\n            return new MessageOrderIterator(tx,m,this);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointAckMessageFileMap": "    private Location checkpointAckMessageFileMap() throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oout = new ObjectOutputStream(baos);\n        oout.writeObject(metadata.ackMessageFileMap);\n        oout.flush();\n        oout.close();\n        // using completion callback allows a disk sync to be avoided when enableJournalDiskSyncs = false\n        Location location = store(new KahaAckMessageFileMapCommand().setAckMessageFileMap(new Buffer(baos.toByteArray())), nullCompletionCallback);\n        try {\n            location.getLatch().await();\n        } catch (InterruptedException e) {\n            throw new InterruptedIOException(e.toString());\n        }\n        return location;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(JournalCommand<?> data, boolean sync, IndexAware before, Runnable after, Runnable onJournalStoreComplete) throws IOException {\n        try {\n            ByteSequence sequence = toByteSequence(data);\n\n            Location location;\n            checkpointLock.readLock().lock();\n            try {\n\n                long start = System.currentTimeMillis();\n                location = onJournalStoreComplete == null ? journal.write(sequence, sync) :  journal.write(sequence, onJournalStoreComplete) ;\n                long start2 = System.currentTimeMillis();\n                process(data, location, before);\n\n                long end = System.currentTimeMillis();\n                if( LOG_SLOW_ACCESS_TIME>0 && end-start > LOG_SLOW_ACCESS_TIME) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Slow KahaDB access: Journal append took: \"+(start2-start)+\" ms, Index update took \"+(end-start2)+\" ms\");\n                    }\n                }\n\n            } finally{\n                checkpointLock.readLock().unlock();\n            }\n            if (after != null) {\n                after.run();\n            }\n\n            if (checkpointThread != null && !checkpointThread.isAlive() && opened.get()) {\n                startCheckpoint();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal\", ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.hasNext": "            public boolean hasNext() {\n                if (currentIterator == null) {\n                    if (highIterator != null) {\n                        if (highIterator.hasNext()) {\n                            currentIterator = highIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    } else {\n                        currentIterator = defaultIterator;\n                        return currentIterator.hasNext();\n                    }\n                }\n                if (highIterator != null) {\n                    if (currentIterator.hasNext()) {\n                        return true;\n                    }\n                    if (currentIterator == highIterator) {\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n\n                    if (currentIterator == defaultIterator) {\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                }\n                return currentIterator.hasNext();\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.visit": "                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.next": "            public Entry<Long, MessageKeys> next() {\n                Entry<Long, MessageKeys> result = currentIterator.next();\n                if (result != null) {\n                    Long key = result.getKey();\n                    if (highIterator != null) {\n                        if (currentIterator == defaultIterator) {\n                            lastDefaultKey = key;\n                        } else if (currentIterator == highIterator) {\n                            lastHighKey = key;\n                        } else {\n                            lastLowKey = key;\n                        }\n                    } else {\n                        lastDefaultKey = key;\n                    }\n                }\n                return result;\n            }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup": "    protected void checkpointCleanup(final boolean cleanup) throws IOException {\n        long start;\n        this.indexLock.writeLock().lock();\n        try {\n            start = System.currentTimeMillis();\n            if( !opened.get() ) {\n                return;\n            }\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n        checkpointUpdate(cleanup);\n        long end = System.currentTimeMillis();\n        if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Slow KahaDB access: cleanup took \" + (end - start));\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.run": "        public void run() {\n        }"
        },
        "bug_report": {
            "Title": "Frequency IOException cast dead lock while using kahadb in high concurrency environment",
            "Description": "When the concurrency is in high level, iops more than 3000/s, we find that most of the amq connections are blocked.We can't either get or push any data through them unless restart.This issue appears *frequency*.\n\nThere is many IOExceptions in the amq logs.\n\n{code}\n2015-05-28 00:37:08,544 | ERROR | Checkpoint failed | org.apache.activemq.store.kahadb.MessageDatabase | ActiveMQ Journal Checkpoint Worker\njava.io.IOException: Input/output error\n        at java.io.RandomAccessFile.write(Native Method)[:1.6.0_30]\n        at java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)[:1.6.0_30]\n        at org.apache.activemq.util.RecoverableRandomAccessFile.writeLong(RecoverableRandomAccessFile.java:305)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.PageFile.writeBatch(PageFile.java:1062)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.PageFile.flush(PageFile.java:516)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1512)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase$17.execute(MessageDatabase.java:1484)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1481)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:929)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:357)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n2015-05-28 00:37:08,547 | INFO  | Ignoring IO exception, java.io.IOException: Input/output error | org.apache.activemq.util.DefaultIOExceptionHandler | ActiveMQ Journal Checkpoint Worker\njava.io.IOException: Input/output error\n        at java.io.RandomAccessFile.write(Native Method)[:1.6.0_30]\n        at java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)[:1.6.0_30]\n        at org.apache.activemq.util.RecoverableRandomAccessFile.writeLong(RecoverableRandomAccessFile.java:305)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.PageFile.writeBatch(PageFile.java:1062)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.PageFile.flush(PageFile.java:516)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1512)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase$17.execute(MessageDatabase.java:1484)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1481)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:929)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:357)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n2015-05-28 00:37:08,580 | INFO  | KahaDB: Recovering checkpoint thread after death | org.apache.activemq.store.kahadb.MessageDatabase | ActiveMQ Transport: tcp:///10.40.50.31:58171@61616\n2015-05-28 00:37:17,285 | INFO  | Journal failed while writing at: 2359276 | org.apache.activemq.store.kahadb.disk.journal.DataFileAppender | ActiveMQ Data File Writer\n2015-05-28 00:37:17,287 | ERROR | KahaDB failed to store to Journal | org.apache.activemq.store.kahadb.MessageDatabase | ActiveMQ Transport: tcp:///10.40.50.17:4487@61616\njava.io.IOException: Input/output error\n        at sun.nio.ch.FileChannelImpl.force0(Native Method)[:1.6.0_30]\n        at sun.nio.ch.FileChannelImpl.force(FileChannelImpl.java:348)[:1.6.0_30]\n        at org.apache.activemq.util.RecoverableRandomAccessFile.sync(RecoverableRandomAccessFile.java:402)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.processQueue(DataFileAppender.java:373)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender$1.run(DataFileAppender.java:193)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n2015-05-28 00:37:17,291 | ERROR | KahaDB failed to store to Journal | org.apache.activemq.store.kahadb.MessageDatabase | ActiveMQ Transport: tcp:///10.40.50.17:4442@61616\njava.io.IOException: Input/output error\n        at sun.nio.ch.FileChannelImpl.force0(Native Method)[:1.6.0_30]\n        at sun.nio.ch.FileChannelImpl.force(FileChannelImpl.java:348)[:1.6.0_30]\n        at org.apache.activemq.util.RecoverableRandomAccessFile.sync(RecoverableRandomAccessFile.java:402)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.processQueue(DataFileAppender.java:373)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender$1.run(DataFileAppender.java:193)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n2015-05-28 00:37:17,293 | INFO  | Ignoring IO exception, java.io.IOException: Input/output error | org.apache.activemq.util.DefaultIOExceptionHandler | ActiveMQ Transport: tcp:///10.40.50.17:4442@61616\njava.io.IOException: Input/output error\n        at sun.nio.ch.FileChannelImpl.force0(Native Method)[:1.6.0_30]\n        at sun.nio.ch.FileChannelImpl.force(FileChannelImpl.java:348)[:1.6.0_30]\n        at org.apache.activemq.util.RecoverableRandomAccessFile.sync(RecoverableRandomAccessFile.java:402)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.processQueue(DataFileAppender.java:373)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n        at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender$1.run(DataFileAppender.java:193)[activemq-kahadb-store-5.10.0.jar:5.10.0]\n{code}\n\n\nWith the aid of jstack ,we find dead lock(How can I upload the whole jtack log?)\nThe blocked connections are all waiting for 0x00007f90500034e0\n{code}\n[01:08:01] \"ActiveMQ Transport: tcp:///10.40.50.17:4479@61616\" daemon prio=10 tid=0x00007f8f8c015000 nid=0x2ece waiting for monitor entry [0x00007f8f1f6e4000]\n[01:08:01]    java.lang.Thread.State: BLOCKED (on object monitor)\n[01:08:01]         at org.apache.activemq.transaction.LocalTransaction.rollback(LocalTransaction.java:94)\n[01:08:01]         - waiting to lock <0x00007f90500034e0> (a org.apache.activemq.store.kahadb.KahaDBTransactionStore)\n[01:08:01]         at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:74)\n[01:08:01]         at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)\n[01:08:01]         at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)\n[01:08:01]         at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:453)\n[01:08:01]         at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)\n[01:08:01]         at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:294)\n[01:08:01]         at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:148)\n[01:08:01]         at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n[01:08:01]         at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n[01:08:01]         at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n[01:08:01]         at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n[01:08:01]         at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n[01:08:01]         at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n[01:08:01]         at java.lang.Thread.run(Thread.java:662)\n{code}\n\nOnly one connection(Thread) get this lock.But it is waiting for another Read lock 0x00007f90530ed8d8\n{code}\n[01:08:01] \"ActiveMQ Transport: tcp:///10.40.50.17:4484@61616\" daemon prio=10 tid=0x00007f8fa8039800 nid=0x2ed2 waiting on condition [0x00007f8f1f2e0000]\n[01:08:01]    java.lang.Thread.State: WAITING (parking)\n[01:08:01]         at sun.misc.Unsafe.park(Native Method)\n[01:08:01]         - parking to wait for  <0x00007f90530ed8d8> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)\n[01:08:01]         at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)\n[01:08:01]         at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)\n[01:08:01]         at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)\n[01:08:01]         at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)\n[01:08:01]         at java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:594)\n[01:08:01]         at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:972)\n[01:08:01]         at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:958)\n[01:08:01]         at org.apache.activemq.store.kahadb.KahaDBTransactionStore.rollback(KahaDBTransactionStore.java:312)\n[01:08:01]         at org.apache.activemq.transaction.LocalTransaction.rollback(LocalTransaction.java:94)\n[01:08:01]         - locked <0x00007f90500034e0> (a org.apache.activemq.store.kahadb.KahaDBTransactionStore)\n[01:08:01]         at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:74)\n[01:08:01]         at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)\n[01:08:01]         at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)\n[01:08:01]         at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:453)\n[01:08:01]         at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)\n[01:08:01]         at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:294)\n[01:08:01]         at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:148)\n[01:08:01]         at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n[01:08:01]         at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n[01:08:01]         at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n[01:08:01]         at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n[01:08:01]         at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n[01:08:01]         at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n[01:08:01]         at java.lang.Thread.run(Thread.java:662)\n{code}\n\nAt last we find 0x00007f90530ed8d8 is in many write lock waiting.But none write lock hodes it. The dead lock occurs.\n{code}\n[01:07:56] \"ActiveMQ Transport: tcp:///10.40.50.47:60701@61616\" daemon prio=10 tid=0x00007f8f7cbc5000 nid=0x3ec8 waiting on condition [0x00007f900d864000]\n[01:07:56]    java.lang.Thread.State: WAITING (parking)\n[01:07:56]         at sun.misc.Unsafe.park(Native Method)\n[01:07:56]         - parking to wait for  <0x00007f90530ed8d8> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)\n[01:07:56]         at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)\n[01:07:56]         at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)\n[01:07:56]         at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)\n[01:07:56]         at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)\n[01:07:56]         at java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:594)\n[01:07:56]         at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:972)\n[01:07:56]         at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:958)\n[01:07:56]         at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeMessage(KahaDBStore.java:453)\n[01:07:56]         at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeAsyncMessage(KahaDBStore.java:407)\n[01:07:56]         at org.apache.activemq.store.kahadb.KahaDBTransactionStore.removeAsyncMessage(KahaDBTransactionStore.java:498)\n[01:07:56]         at org.apache.activemq.store.kahadb.KahaDBTransactionStore$1.removeAsyncMessage(KahaDBTransactionStore.java:185)\n[01:07:56]         at org.apache.activemq.broker.region.Queue.acknowledge(Queue.java:998)\n[01:07:56]         at org.apache.activemq.broker.region.Queue.removeMessage(Queue.java:1781)\n[01:07:56]         at org.apache.activemq.broker.region.QueueSubscription.acknowledge(QueueSubscription.java:63)\n[01:07:56]         at org.apache.activemq.broker.region.PrefetchSubscription.acknowledge(PrefetchSubscription.java:235)\n[01:07:56]         - locked <0x00007f905d10b1e8> (a java.lang.Object)\n[01:07:56]         at org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:446)\n[01:07:56]         at org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:461)\n[01:07:56]         at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:82)\n[01:07:56]         at org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:277)\n[01:07:56]         at org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:92)\n[01:07:56]         at org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:505)\n[01:07:56]         at org.apache.activemq.command.MessageAck.visit(MessageAck.java:245)\n[01:07:56]         at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:294)\n[01:07:56]         at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:148)\n[01:07:56]         at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n[01:07:56]         at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n[01:07:56]         at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n[01:07:56]         at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n[01:07:56]         at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n[01:07:56]         at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n[01:07:56]         at java.lang.Thread.run(Thread.java:662)\n{code}\n\nIn my opinion, IOExceptions may lead to losing persisten messages and so on ,but the broker shouldn't stop service."
        }
    },
    {
        "filename": "AMQ-5141.json",
        "creation_time": "2014-04-11T11:31:51.000+0000",
        "stack_trace": "java.lang.SecurityException: User Test is not authorized to write to: queue://ActiveMQ.DLQ\n\tat org.apache.activemq.security.AuthorizationBroker.send(AuthorizationBroker.java:197)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.util.BrokerSupport.doResend(BrokerSupport.java:68)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.util.BrokerSupport.resendNoCopy(BrokerSupport.java:38)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.RegionBroker.sendToDeadLetterQueue(RegionBroker.java:691)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.advisory.AdvisoryBroker.sendToDeadLetterQueue(AdvisoryBroker.java:413)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.sendToDeadLetterQueue(MutableBrokerFilter.java:274)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.util.RedeliveryPlugin.sendToDeadLetterQueue(RedeliveryPlugin.java:132)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.sendToDeadLetterQueue(MutableBrokerFilter.java:274)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.RegionBroker.messageExpired(RegionBroker.java:659)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.advisory.AdvisoryBroker.messageExpired(AdvisoryBroker.java:283)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageExpired(MutableBrokerFilter.java:269)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageExpired(MutableBrokerFilter.java:269)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.messageExpired(Queue.java:1671)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending(PrefetchSubscription.java:648)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.PrefetchSubscription.add(PrefetchSubscription.java:162)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:1907)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1834)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.removeSubscription(Queue.java:576)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.AbstractRegion.removeConsumer(AbstractRegion.java:380)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.RegionBroker.removeConsumer(RegionBroker.java:364)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.removeConsumer(ManagedRegionBroker.java:247)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.advisory.AdvisoryBroker.removeConsumer(AdvisoryBroker.java:253)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.removeConsumer(MutableBrokerFilter.java:123)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.removeConsumer(MutableBrokerFilter.java:123)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.TransportConnection.processRemoveConsumer(TransportConnection.java:651)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.command.RemoveInfo.visit(RemoveInfo.java:76)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:329)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:184)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)",
        "source_code": {
            "activemq-broker.src.main.java.org.apache.activemq.security.AuthorizationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final SecurityContext securityContext = checkSecurityContext(producerExchange.getConnectionContext());\n\n        if (!securityContext.isBrokerContext() && !securityContext.getAuthorizedWriteDests().contains(messageSend.getDestination())) {\n\n            Set<?> allowedACLs = null;\n            if (!messageSend.getDestination().isTemporary()) {\n                allowedACLs = authorizationMap.getWriteACLs(messageSend.getDestination());\n            } else {\n                allowedACLs = authorizationMap.getTempDestinationWriteACLs();\n            }\n\n            if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {\n                throw new SecurityException(\"User \" + securityContext.getUserName() + \" is not authorized to write to: \" + messageSend.getDestination());\n            }\n            securityContext.getAuthorizedWriteDests().put(messageSend.getDestination(), messageSend.getDestination());\n        }\n\n        super.send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.security.AuthorizationBroker.checkSecurityContext": "    protected SecurityContext checkSecurityContext(ConnectionContext context) throws SecurityException {\n        final SecurityContext securityContext = context.getSecurityContext();\n        if (securityContext == null) {\n            throw new SecurityException(\"User is not authenticated.\");\n        }\n        return securityContext;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.util.BrokerSupport.doResend": "    public static void doResend(final ConnectionContext context, Message originalMessage, ActiveMQDestination deadLetterDestination, boolean copy) throws Exception {       \n        Message message = copy ? originalMessage.copy() : originalMessage;\n        message.setOriginalDestination(message.getDestination());\n        message.setOriginalTransactionId(message.getTransactionId());\n        message.setDestination(deadLetterDestination);\n        message.setTransactionId(null);\n        message.setMemoryUsage(null);\n        message.setRedeliveryCounter(0);\n        boolean originalFlowControl = context.isProducerFlowControl();\n        try {\n            context.setProducerFlowControl(false);\n            ProducerInfo info = new ProducerInfo();\n            ProducerState state = new ProducerState(info);\n            ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setProducerState(state);\n            producerExchange.setMutable(true);\n            producerExchange.setConnectionContext(context);\n            context.getBroker().send(producerExchange, message);\n        } finally {\n            context.setProducerFlowControl(originalFlowControl);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.util.BrokerSupport.resendNoCopy": "    public static void resendNoCopy(final ConnectionContext context, Message originalMessage, ActiveMQDestination deadLetterDestination) throws Exception {\n        doResend(context, originalMessage, deadLetterDestination, false);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.sendToDeadLetterQueue": "    public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference node, Subscription subscription, Throwable poisonCause) {\n        try {\n            if (node != null) {\n                Message message = node.getMessage();\n                if (message != null && node.getRegionDestination() != null) {\n                    DeadLetterStrategy deadLetterStrategy = ((Destination) node.getRegionDestination()).getDeadLetterStrategy();\n                    if (deadLetterStrategy != null) {\n                        if (deadLetterStrategy.isSendToDeadLetterQueue(message)) {\n                            // message may be inflight to other subscriptions so do not modify\n                            message = message.copy();\n                            stampAsExpired(message);\n                            message.setExpiration(0);\n                            if (!message.isPersistent()) {\n                                message.setPersistent(true);\n                                message.setProperty(\"originalDeliveryMode\", \"NON_PERSISTENT\");\n                            }\n                            if (poisonCause != null) {\n                                message.setProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY,\n                                        poisonCause.toString());\n                            }\n                            // The original destination and transaction id do\n                            // not get filled when the message is first sent,\n                            // it is only populated if the message is routed to\n                            // another destination like the DLQ\n                            ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message, subscription);\n                            if (context.getBroker() == null) {\n                                context.setBroker(getRoot());\n                            }\n                            BrokerSupport.resendNoCopy(context, message, deadLetterDestination);\n                            return true;\n                        }\n                    } else {\n                        LOG.debug(\"Dead Letter message with no DLQ strategy in place, message id: {}, destination: {}\", message.getMessageId(), message.getDestination());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Caught an exception sending to DLQ: {}\", node, e);\n        }\n\n        return false;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.stampAsExpired": "    private boolean stampAsExpired(Message message) throws IOException {\n        boolean stamped = false;\n        if (message.getProperty(ORIGINAL_EXPIRATION) == null) {\n            long expiration = message.getExpiration();\n            message.setProperty(ORIGINAL_EXPIRATION, new Long(expiration));\n            stamped = true;\n        }\n        return stamped;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getRoot": "    public Broker getRoot() {\n        try {\n            return getBrokerService().getBroker();\n        } catch (Exception e) {\n            LOG.error(\"Trying to get Root Broker\", e);\n            throw new RuntimeException(\"The broker from the BrokerService should not throw an exception\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue": "    public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference,\n                                         Subscription subscription, Throwable poisonCause) {\n        return next.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.sendToDeadLetterQueue": "    public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference,\n                                         Subscription subscription, Throwable poisonCause) {\n        boolean wasDLQd = super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n        if (wasDLQd) {\n            try {\n                if (!messageReference.isAdvisory()) {\n                    ActiveMQTopic topic = AdvisorySupport.getMessageDLQdAdvisoryTopic(messageReference.getMessage().getDestination());\n                    Message payload = messageReference.getMessage().copy();\n                    payload.clearBody();\n                    fireAdvisory(context, topic, payload);\n                }\n            } catch (Exception e) {\n                handleFireFailure(\"add to DLQ\", e);\n            }\n        }\n\n        return wasDLQd;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory": "    public void fireAdvisory(ConnectionContext context, ActiveMQTopic topic, Command command, ConsumerId targetConsumerId, ActiveMQMessage advisoryMessage) throws Exception {\n        if (getBrokerService().isStarted()) {\n            //set properties\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_NAME, getBrokerName());\n            String id = getBrokerId() != null ? getBrokerId().getValue() : \"NOT_SET\";\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_ID, id);\n\n            String url = getBrokerService().getVmConnectorURI().toString();\n            if (getBrokerService().getDefaultSocketURIString() != null) {\n                url = getBrokerService().getDefaultSocketURIString();\n            }\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_URL, url);\n\n            //set the data structure\n            advisoryMessage.setDataStructure(command);\n            advisoryMessage.setPersistent(false);\n            advisoryMessage.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);\n            advisoryMessage.setMessageId(new MessageId(advisoryProducerId, messageIdGenerator.getNextSequenceId()));\n            advisoryMessage.setTargetConsumerId(targetConsumerId);\n            advisoryMessage.setDestination(topic);\n            advisoryMessage.setResponseRequired(false);\n            advisoryMessage.setProducerId(advisoryProducerId);\n            boolean originalFlowControl = context.isProducerFlowControl();\n            final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setConnectionContext(context);\n            producerExchange.setMutable(true);\n            producerExchange.setProducerState(new ProducerState(new ProducerInfo()));\n            try {\n                context.setProducerFlowControl(false);\n                next.send(producerExchange, advisoryMessage);\n            } finally {\n                context.setProducerFlowControl(originalFlowControl);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.handleFireFailure": "    private void handleFireFailure(String message, Throwable cause) {\n        LOG.warn(\"Failed to fire {} advisory, reason: {}\", message, cause);\n        LOG.debug(\"{} detail: {}\", message, cause);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.sendToDeadLetterQueue": "    public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference,\n                                         Subscription subscription, Throwable poisonCause) {\n        return getNext().sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.util.RedeliveryPlugin.sendToDeadLetterQueue": "    public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause) {\n        if (messageReference.isExpired()) {\n            // there are two uses of  sendToDeadLetterQueue, we are only interested in valid messages\n            return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n        } else {\n            try {\n                Destination regionDestination = (Destination) messageReference.getRegionDestination();\n                final RedeliveryPolicy redeliveryPolicy = redeliveryPolicyMap.getEntryFor(regionDestination.getActiveMQDestination());\n                if (redeliveryPolicy != null) {\n                    final int maximumRedeliveries = redeliveryPolicy.getMaximumRedeliveries();\n                    int redeliveryCount = messageReference.getRedeliveryCounter();\n                    if (RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES == maximumRedeliveries || redeliveryCount < maximumRedeliveries) {\n\n                        long delay = ( redeliveryCount == 0 ?\n                                redeliveryPolicy.getInitialRedeliveryDelay() :\n                                redeliveryPolicy.getNextRedeliveryDelay(getExistingDelay(messageReference)));\n\n                        scheduleRedelivery(context, messageReference, delay, ++redeliveryCount);\n                    } else if (isSendToDlqIfMaxRetriesExceeded()) {\n                        return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n                    } else {\n                        LOG.debug(\"Discarding message that exceeds max redelivery count({}), {}\", maximumRedeliveries, messageReference.getMessageId());\n                    }\n                } else if (isFallbackToDeadLetter()) {\n                    return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n                } else {\n                    LOG.debug(\"Ignoring dlq request for: {}, RedeliveryPolicy not found (and no fallback) for: {}\", messageReference.getMessageId(), regionDestination.getActiveMQDestination());\n                }\n\n                return false;\n            } catch (Exception exception) {\n                // abort the ack, will be effective if client use transactions or individual ack with sync send\n                RuntimeException toThrow =  new RuntimeException(\"Failed to schedule redelivery for: \" + messageReference.getMessageId(), exception);\n                LOG.error(toThrow.toString(), exception);\n                throw toThrow;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.util.RedeliveryPlugin.isFallbackToDeadLetter": "    public boolean isFallbackToDeadLetter() {\n        return fallbackToDeadLetter;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.util.RedeliveryPlugin.scheduleRedelivery": "    private void scheduleRedelivery(ConnectionContext context, MessageReference messageReference, long delay, int redeliveryCount) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            Destination regionDestination = (Destination) messageReference.getRegionDestination();\n            LOG.trace(\"redelivery #{} of: {} with delay: {}, dest: {}\", new Object[]{\n                    redeliveryCount, messageReference.getMessageId(), delay, regionDestination.getActiveMQDestination()\n            });\n        }\n        final Message old = messageReference.getMessage();\n        Message message = old.copy();\n\n        message.setTransactionId(null);\n        message.setMemoryUsage(null);\n        message.removeProperty(ScheduledMessage.AMQ_SCHEDULED_ID);\n\n        message.setProperty(REDELIVERY_DELAY, delay);\n        message.setProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);\n        message.setRedeliveryCounter(redeliveryCount);\n\n        boolean originalFlowControl = context.isProducerFlowControl();\n        try {\n            context.setProducerFlowControl(false);\n            ProducerInfo info = new ProducerInfo();\n            ProducerState state = new ProducerState(info);\n            ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setProducerState(state);\n            producerExchange.setMutable(true);\n            producerExchange.setConnectionContext(context);\n            context.getBroker().send(producerExchange, message);\n        } finally {\n            context.setProducerFlowControl(originalFlowControl);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.util.RedeliveryPlugin.getExistingDelay": "    private int getExistingDelay(MessageReference messageReference) throws IOException {\n        Object val = messageReference.getMessage().getProperty(REDELIVERY_DELAY);\n        if (val instanceof Long) {\n            return ((Long)val).intValue();\n        }\n        return 0;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.util.RedeliveryPlugin.isSendToDlqIfMaxRetriesExceeded": "    public boolean isSendToDlqIfMaxRetriesExceeded() {\n        return sendToDlqIfMaxRetriesExceeded;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.messageExpired": "    public void messageExpired(ConnectionContext context, MessageReference node, Subscription subscription) {\n        LOG.debug(\"Message expired {}\", node);\n        getRoot().sendToDeadLetterQueue(context, node, subscription, new Throwable(\"Message Expired. Expiration:\" + node.getExpiration()));\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.messageExpired": "    public void messageExpired(ConnectionContext context, MessageReference message, Subscription subscription) {\n        next.messageExpired(context, message, subscription);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.messageExpired": "    public void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription) {\n        super.messageExpired(context, messageReference, subscription);\n        try {\n            if (!messageReference.isAdvisory()) {\n                ActiveMQTopic topic = AdvisorySupport.getExpiredMessageTopic(messageReference.getMessage().getDestination());\n                Message payload = messageReference.getMessage().copy();\n                payload.clearBody();\n                ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n                advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_MESSAGE_ID, payload.getMessageId().toString());\n                fireAdvisory(context, topic, payload, null, advisoryMessage);\n            }\n        } catch (Exception e) {\n            handleFireFailure(\"expired\", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.messageExpired": "    public void messageExpired(ConnectionContext context, MessageReference message, Subscription subscription) {\n        getNext().messageExpired(context, message, subscription);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        LOG.debug(\"message expired: {}\", reference);\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n            messagesLock.writeLock().lock();\n            try {\n                messages.rollback(reference.getMessageId());\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.rollback": "        public void rollback() throws XAException, IOException {\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeMessage": "    protected void removeMessage(ConnectionContext context, Subscription sub, final QueueMessageReference reference,\n            MessageAck ack) throws IOException {\n        LOG.trace(\"ack of {} with {}\", reference.getMessageId(), ack);\n        reference.setAcked(true);\n        // This sends the ack the the journal..\n        if (!ack.isInTransaction()) {\n            acknowledge(context, sub, ack, reference);\n            getDestinationStatistics().getDequeues().increment();\n            dropMessage(reference);\n        } else {\n            try {\n                acknowledge(context, sub, ack, reference);\n            } finally {\n                context.getTransaction().addSynchronization(new Synchronization() {\n\n                    @Override\n                    public void afterCommit() throws Exception {\n                        getDestinationStatistics().getDequeues().increment();\n                        dropMessage(reference);\n                        wakeup();\n                    }\n\n                    @Override\n                    public void afterRollback() throws Exception {\n                        reference.setAcked(false);\n                        wakeup();\n                    }\n                });\n            }\n        }\n        if (ack.isPoisonAck() || (sub != null && sub.getConsumerInfo().isNetworkSubscription())) {\n            // message gone to DLQ, is ok to allow redelivery\n            messagesLock.writeLock().lock();\n            try {\n                messages.rollback(reference.getMessageId());\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n        }\n\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending": "    protected void dispatchPending() throws IOException {\n       synchronized(pendingLock) {\n            try {\n                int numberToDispatch = countBeforeFull();\n                if (numberToDispatch > 0) {\n                    setSlowConsumer(false);\n                    setPendingBatchSize(pending, numberToDispatch);\n                    int count = 0;\n                    pending.reset();\n                    while (pending.hasNext() && !isFull() && count < numberToDispatch) {\n                        MessageReference node = pending.next();\n                        if (node == null) {\n                            break;\n                        }\n\n                        // Synchronize between dispatched list and remove of message from pending list\n                        // related to remove subscription action\n                        synchronized(dispatchLock) {\n                            pending.remove();\n                            node.decrementReferenceCount();\n                            if( !isDropped(node) && canDispatch(node)) {\n\n                                // Message may have been sitting in the pending\n                                // list a while waiting for the consumer to ak the message.\n                                if (node!=QueueMessageReference.NULL_MESSAGE && node.isExpired()) {\n                                    //increment number to dispatch\n                                    numberToDispatch++;\n                                    if (broker.isExpired(node)) {\n                                        ((Destination)node.getRegionDestination()).messageExpired(context, this, node);\n                                    }\n                                    continue;\n                                }\n                                dispatch(node);\n                                count++;\n                            }\n                        }\n                    }\n                } else if (!isSlowConsumer()) {\n                    setSlowConsumer(true);\n                    for (Destination dest :destinations) {\n                        dest.slowConsumer(context, this);\n                    }\n                }\n            } finally {\n                pending.release();\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.isFull": "    public boolean isFull() {\n        return dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.canDispatch": "    protected abstract boolean canDispatch(MessageReference node) throws IOException;\n\n    protected abstract boolean isDropped(MessageReference node);\n\n    /**\n     * Used during acknowledgment to remove the message.\n     *\n     * @throws IOException\n     */\n    protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;\n\n\n    public int getMaxProducersToAudit() {\n        return maxProducersToAudit;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.setPendingBatchSize": "    protected void setPendingBatchSize(PendingMessageCursor pending, int numberToDispatch) {\n        pending.setMaxBatchSize(numberToDispatch);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.isDropped": "    protected abstract boolean isDropped(MessageReference node);\n\n    /**\n     * Used during acknowledgment to remove the message.\n     *\n     * @throws IOException\n     */\n    protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;\n\n\n    public int getMaxProducersToAudit() {\n        return maxProducersToAudit;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.remove": "    public List<MessageReference> remove(ConnectionContext context, Destination destination, List<MessageReference> dispatched) throws Exception {\n        List<MessageReference> rc = new ArrayList<MessageReference>();\n        synchronized(pendingLock) {\n            super.remove(context, destination);\n            // Here is a potential problem concerning Inflight stat:\n            // Messages not already committed or rolled back may not be removed from dispatched list at the moment\n            // Except if each commit or rollback callback action comes before remove of subscriber.\n            rc.addAll(pending.remove(context, destination));\n\n            if (dispatched == null) {\n                return rc;\n            }\n\n            // Synchronized to DispatchLock if necessary\n            if (dispatched == this.dispatched) {\n                synchronized(dispatchLock) {\n                    updateDestinationStats(rc, destination, dispatched);\n                }\n            } else {\n                updateDestinationStats(rc, destination, dispatched);\n            }\n        }\n        return rc;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.dispatch": "    protected boolean dispatch(final MessageReference node) throws IOException {\n        final Message message = node.getMessage();\n        if (message == null) {\n            return false;\n        }\n\n        okForAckAsDispatchDone.countDown();\n\n        // No reentrant lock - Patch needed to IndirectMessageReference on method lock\n        MessageDispatch md = createMessageDispatch(node, message);\n        // NULL messages don't count... they don't get Acked.\n        if (node != QueueMessageReference.NULL_MESSAGE) {\n            dispatchCounter++;\n            dispatched.add(node);\n        } else {\n            while (true) {\n                int currentExtension = prefetchExtension.get();\n                int newExtension = Math.max(0, currentExtension - 1);\n                if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {\n                    break;\n                }\n            }\n        }\n        if (info.isDispatchAsync()) {\n            md.setTransmitCallback(new TransmitCallback() {\n\n                @Override\n                public void onSuccess() {\n                    // Since the message gets queued up in async dispatch, we don't want to\n                    // decrease the reference count until it gets put on the wire.\n                    onDispatch(node, message);\n                }\n\n                @Override\n                public void onFailure() {\n                    Destination nodeDest = (Destination) node.getRegionDestination();\n                    if (nodeDest != null) {\n                        if (node != QueueMessageReference.NULL_MESSAGE) {\n                            nodeDest.getDestinationStatistics().getDispatched().increment();\n                            nodeDest.getDestinationStatistics().getInflight().increment();\n                            LOG.trace(\"{} failed to dispatch: {} - {}, dispatched: {}, inflight: {}\", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), dispatchCounter, dispatched.size() });\n                        }\n                    }\n                }\n            });\n            context.getConnection().dispatchAsync(md);\n        } else {\n            context.getConnection().dispatchSync(md);\n            onDispatch(node, message);\n        }\n        return true;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.countBeforeFull": "    public int countBeforeFull() {\n        return info.getPrefetchSize() + prefetchExtension.get() - dispatched.size();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.add": "    public void add(ConnectionContext context, Destination destination) throws Exception {\n        synchronized(pendingLock) {\n            super.add(context, destination);\n            pending.add(context, destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doActualDispatch": "    private PendingList doActualDispatch(PendingList list) throws Exception {\n        List<Subscription> consumers;\n        consumersLock.writeLock().lock();\n\n        try {\n            if (this.consumers.isEmpty()) {\n                // slave dispatch happens in processDispatchNotification\n                return list;\n            }\n            consumers = new ArrayList<Subscription>(this.consumers);\n        } finally {\n            consumersLock.writeLock().unlock();\n        }\n\n        Set<Subscription> fullConsumers = new HashSet<Subscription>(this.consumers.size());\n\n        for (Iterator<MessageReference> iterator = list.iterator(); iterator.hasNext();) {\n\n            MessageReference node = iterator.next();\n            Subscription target = null;\n            for (Subscription s : consumers) {\n                if (s instanceof QueueBrowserSubscription) {\n                    continue;\n                }\n                if (!fullConsumers.contains(s)) {\n                    if (!s.isFull()) {\n                        if (dispatchSelector.canSelect(s, node) && assignMessageGroup(s, (QueueMessageReference)node) && !((QueueMessageReference) node).isAcked() ) {\n                            // Dispatch it.\n                            s.add(node);\n                            LOG.trace(\"assigned {} to consumer {}\", node.getMessageId(), s.getConsumerInfo().getConsumerId());\n                            iterator.remove();\n                            target = s;\n                            break;\n                        }\n                    } else {\n                        // no further dispatch of list to a full consumer to\n                        // avoid out of order message receipt\n                        fullConsumers.add(s);\n                        LOG.trace(\"Subscription full {}\", s);\n                    }\n                }\n            }\n\n            if (target == null && node.isDropped()) {\n                iterator.remove();\n            }\n\n            // return if there are no consumers or all consumers are full\n            if (target == null && consumers.size() == fullConsumers.size()) {\n                return list;\n            }\n\n            // If it got dispatched, rotate the consumer list to get round robin\n            // distribution.\n            if (target != null && !strictOrderDispatch && consumers.size() > 1\n                    && !dispatchSelector.isExclusiveConsumer(target)) {\n                consumersLock.writeLock().lock();\n                try {\n                    if (removeFromConsumerList(target)) {\n                        addToConsumerList(target);\n                        consumers = new ArrayList<Subscription>(this.consumers);\n                    }\n                } finally {\n                    consumersLock.writeLock().unlock();\n                }\n            }\n        }\n\n        return list;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.add": "        public void add(ConnectionContext context, Message message) {\n            additions.add(new MessageContext(context, message));\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeFromConsumerList": "    private boolean removeFromConsumerList(Subscription sub) {\n        return consumers.remove(sub);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.addToConsumerList": "    private void addToConsumerList(Subscription sub) {\n        if (useConsumerPriority) {\n            consumers.add(sub);\n            Collections.sort(consumers, orderedCompare);\n        } else {\n            consumers.add(sub);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.assignMessageGroup": "    protected boolean assignMessageGroup(Subscription subscription, QueueMessageReference node) throws Exception {\n        boolean result = true;\n        // Keep message groups together.\n        String groupId = node.getGroupID();\n        int sequence = node.getGroupSequence();\n        if (groupId != null) {\n\n            MessageGroupMap messageGroupOwners = getMessageGroupOwners();\n            // If we can own the first, then no-one else should own the\n            // rest.\n            if (sequence == 1) {\n                assignGroup(subscription, messageGroupOwners, node, groupId);\n            } else {\n\n                // Make sure that the previous owner is still valid, we may\n                // need to become the new owner.\n                ConsumerId groupOwner;\n\n                groupOwner = messageGroupOwners.get(groupId);\n                if (groupOwner == null) {\n                    assignGroup(subscription, messageGroupOwners, node, groupId);\n                } else {\n                    if (groupOwner.equals(subscription.getConsumerInfo().getConsumerId())) {\n                        // A group sequence < 1 is an end of group signal.\n                        if (sequence < 0) {\n                            messageGroupOwners.removeGroup(groupId);\n                            subscription.getConsumerInfo().setLastDeliveredSequenceId(subscription.getConsumerInfo().getLastDeliveredSequenceId() - 1);\n                        }\n                    } else {\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doDispatch": "    private void doDispatch(PendingList list) throws Exception {\n        boolean doWakeUp = false;\n\n        pagedInPendingDispatchLock.writeLock().lock();\n        try {\n            if (!redeliveredWaitingDispatch.isEmpty()) {\n                // Try first to dispatch redelivered messages to keep an\n                // proper order\n                redeliveredWaitingDispatch = doActualDispatch(redeliveredWaitingDispatch);\n            }\n            if (!pagedInPendingDispatch.isEmpty()) {\n                // Next dispatch anything that had not been\n                // dispatched before.\n                pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);\n            }\n            // and now see if we can dispatch the new stuff.. and append to\n            // the pending\n            // list anything that does not actually get dispatched.\n            if (list != null && !list.isEmpty()) {\n                if (pagedInPendingDispatch.isEmpty()) {\n                    pagedInPendingDispatch.addAll(doActualDispatch(list));\n                } else {\n                    for (MessageReference qmr : list) {\n                        if (!pagedInPendingDispatch.contains(qmr)) {\n                            pagedInPendingDispatch.addMessageLast(qmr);\n                        }\n                    }\n                    doWakeUp = true;\n                }\n            }\n        } finally {\n            pagedInPendingDispatchLock.writeLock().unlock();\n        }\n\n        if (doWakeUp) {\n            // avoid lock order contention\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.addAll": "    private void addAll(Collection<? extends MessageReference> refs, List<Message> l, int max,\n            List<MessageReference> toExpire) throws Exception {\n        for (Iterator<? extends MessageReference> i = refs.iterator(); i.hasNext() && l.size() < max;) {\n            QueueMessageReference ref = (QueueMessageReference) i.next();\n            if (ref.isExpired()) {\n                toExpire.add(ref);\n            } else if (l.contains(ref.getMessage()) == false) {\n                l.add(ref.getMessage());\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.asyncWakeup": "    private void asyncWakeup() {\n        try {\n            pendingWakeups.incrementAndGet();\n            this.taskRunner.wakeup();\n        } catch (InterruptedException e) {\n            LOG.warn(\"Async task runner failed to wakeup \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.removeSubscription": "    public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeiveredSequenceId)\n            throws Exception {\n        super.removeSubscription(context, sub, lastDeiveredSequenceId);\n        // synchronize with dispatch method so that no new messages are sent\n        // while removing up a subscription.\n        pagedInPendingDispatchLock.writeLock().lock();\n        try {\n            LOG.debug(\"{} remove sub: {}, lastDeliveredSeqId: {}, dequeues: {}, dispatched: {}, inflight: {}\", new Object[]{\n                    getActiveMQDestination().getQualifiedName(),\n                    sub,\n                    lastDeiveredSequenceId,\n                    getDestinationStatistics().getDequeues().getCount(),\n                    getDestinationStatistics().getDispatched().getCount(),\n                    getDestinationStatistics().getInflight().getCount()\n            });\n            consumersLock.writeLock().lock();\n            try {\n                removeFromConsumerList(sub);\n                if (sub.getConsumerInfo().isExclusive()) {\n                    Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();\n                    if (exclusiveConsumer == sub) {\n                        exclusiveConsumer = null;\n                        for (Subscription s : consumers) {\n                            if (s.getConsumerInfo().isExclusive()\n                                    && (exclusiveConsumer == null || s.getConsumerInfo().getPriority() > exclusiveConsumer\n                                            .getConsumerInfo().getPriority())) {\n                                exclusiveConsumer = s;\n\n                            }\n                        }\n                        dispatchSelector.setExclusiveConsumer(exclusiveConsumer);\n                    }\n                } else if (isAllConsumersExclusiveByDefault()) {\n                    Subscription exclusiveConsumer = null;\n                    for (Subscription s : consumers) {\n                        if (exclusiveConsumer == null\n                                || s.getConsumerInfo().getPriority() > exclusiveConsumer\n                                .getConsumerInfo().getPriority()) {\n                            exclusiveConsumer = s;\n                                }\n                    }\n                    dispatchSelector.setExclusiveConsumer(exclusiveConsumer);\n                }\n                ConsumerId consumerId = sub.getConsumerInfo().getConsumerId();\n                getMessageGroupOwners().removeConsumer(consumerId);\n\n                // redeliver inflight messages\n\n                boolean markAsRedelivered = false;\n                MessageReference lastDeliveredRef = null;\n                List<MessageReference> unAckedMessages = sub.remove(context, this);\n\n                // locate last redelivered in unconsumed list (list in delivery rather than seq order)\n                if (lastDeiveredSequenceId != 0) {\n                    for (MessageReference ref : unAckedMessages) {\n                        if (ref.getMessageId().getBrokerSequenceId() == lastDeiveredSequenceId) {\n                            lastDeliveredRef = ref;\n                            markAsRedelivered = true;\n                            LOG.debug(\"found lastDeliveredSeqID: {}, message reference: {}\", lastDeiveredSequenceId, ref.getMessageId());\n                            break;\n                        }\n                    }\n                }\n\n                for (MessageReference ref : unAckedMessages) {\n                    // AMQ-5107: don't resend if the broker is shutting down\n                    if ( this.brokerService.isStopping() ) {\n                        break;\n                    }\n                    QueueMessageReference qmr = (QueueMessageReference) ref;\n                    if (qmr.getLockOwner() == sub) {\n                        qmr.unlock();\n\n                        // have no delivery information\n                        if (lastDeiveredSequenceId == 0) {\n                            qmr.incrementRedeliveryCounter();\n                        } else {\n                            if (markAsRedelivered) {\n                                qmr.incrementRedeliveryCounter();\n                            }\n                            if (ref == lastDeliveredRef) {\n                                // all that follow were not redelivered\n                                markAsRedelivered = false;\n                            }\n                        }\n                    }\n                    if (!qmr.isDropped()) {\n                        redeliveredWaitingDispatch.addMessageLast(qmr);\n                    }\n                }\n                if (sub instanceof QueueBrowserSubscription) {\n                    ((QueueBrowserSubscription)sub).decrementQueueRef();\n                    browserDispatches.remove(sub);\n                }\n                // AMQ-5107: don't resend if the broker is shutting down\n                if (!redeliveredWaitingDispatch.isEmpty() && (! this.brokerService.isStopping())) {\n                    doDispatch(new OrderedPendingList());\n                }\n            } finally {\n                consumersLock.writeLock().unlock();\n            }\n            if (!this.optimizedDispatch) {\n                wakeup();\n            }\n        } finally {\n            pagedInPendingDispatchLock.writeLock().unlock();\n        }\n        if (this.optimizedDispatch) {\n            // Outside of dispatchLock() to maintain the lock hierarchy of\n            // iteratingMutex -> dispatchLock. - see\n            // https://issues.apache.org/activemq/browse/AMQ-1878\n            wakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getMessageGroupOwners": "    public MessageGroupMap getMessageGroupOwners() {\n        if (messageGroupOwners == null) {\n            messageGroupOwners = getMessageGroupMapFactory().createMessageGroupMap();\n        }\n        return messageGroupOwners;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getActiveMQDestination": "    public ActiveMQDestination getActiveMQDestination() {\n        return destination;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.wakeup": "    public void wakeup() {\n        if (optimizedDispatch && !iterationRunning) {\n            iterate();\n            pendingWakeups.incrementAndGet();\n        } else {\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.isAllConsumersExclusiveByDefault": "    public boolean isAllConsumersExclusiveByDefault() {\n        return allConsumersExclusiveByDefault;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.removeConsumer": "    public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        LOG.debug(\"{} removing consumer: {} for destination: {}\", new Object[]{ broker.getBrokerName(), info.getConsumerId(), info.getDestination() });\n\n        Subscription sub = subscriptions.remove(info.getConsumerId());\n        // The sub could be removed elsewhere - see ConnectionSplitBroker\n        if (sub != null) {\n\n            // remove the subscription from all the matching queues.\n            List<Destination> removeList = new ArrayList<Destination>();\n            destinationsLock.readLock().lock();\n            try {\n                for (Destination dest : (Set<Destination>) destinationMap.get(info.getDestination())) {\n                    removeList.add(dest);\n                }\n            } finally {\n                destinationsLock.readLock().unlock();\n            }\n            for (Destination dest : removeList) {\n                dest.removeSubscription(context, sub, info.getLastDeliveredSequenceId());\n            }\n\n            destroySubscription(sub);\n        }\n        synchronized (consumerChangeMutexMap) {\n            consumerChangeMutexMap.remove(info.getConsumerId());\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.destroySubscription": "    protected void destroySubscription(Subscription sub) {\n        sub.destroy();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.removeSubscription": "    public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {\n        throw new JMSException(\"Invalid operation.\");\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.removeConsumer": "    public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        ActiveMQDestination destination = info.getDestination();\n        inactiveDestinationsPurgeLock.readLock().lock();\n        try {\n            getRegion(destination).removeConsumer(context, info);\n        } finally {\n            inactiveDestinationsPurgeLock.readLock().unlock();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getRegion": "    protected Region getRegion(ActiveMQDestination destination) throws JMSException {\n        switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                return queueRegion;\n            case ActiveMQDestination.TOPIC_TYPE:\n                return topicRegion;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                return tempQueueRegion;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                return tempTopicRegion;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.removeConsumer": "    public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        for (Subscription sub : subscriptionMap.keySet()) {\n            if (sub.getConsumerInfo().equals(info)) {\n               // unregister all consumer subs\n               unregisterSubscription(subscriptionMap.get(sub), true);\n            }\n        }\n        super.removeConsumer(context, info);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.unregisterSubscription": "    protected void unregisterSubscription(ObjectName key, boolean addToInactive) throws Exception {\n        queueSubscribers.remove(key);\n        topicSubscribers.remove(key);\n        temporaryQueueSubscribers.remove(key);\n        temporaryTopicSubscribers.remove(key);\n        if (registeredMBeans.remove(key)) {\n            try {\n                managementContext.unregisterMBean(key);\n            } catch (Throwable e) {\n                LOG.warn(\"Failed to unregister MBean {}\", key);\n                LOG.debug(\"Failure reason: \", e);\n            }\n        }\n        DurableSubscriptionView view = (DurableSubscriptionView)durableTopicSubscribers.remove(key);\n        if (view != null) {\n            // need to put this back in the inactive list\n            SubscriptionKey subscriptionKey = new SubscriptionKey(view.getClientId(), view.getSubscriptionName());\n            if (addToInactive) {\n                SubscriptionInfo info = new SubscriptionInfo();\n                info.setClientId(subscriptionKey.getClientId());\n                info.setSubscriptionName(subscriptionKey.getSubscriptionName());\n                info.setDestination(new ActiveMQTopic(view.getDestinationName()));\n                info.setSelector(view.getSelector());\n                addInactiveSubscription(subscriptionKey, info, (brokerService.isKeepDurableSubsActive() ? view.subscription : null));\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.removeConsumer": "    public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        next.removeConsumer(context, info);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.removeConsumer": "    public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        super.removeConsumer(context, info);\n\n        // Don't advise advisory topics.\n        ActiveMQDestination dest = info.getDestination();\n        if (!AdvisorySupport.isAdvisoryTopic(dest)) {\n            ActiveMQTopic topic = AdvisorySupport.getConsumerAdvisoryTopic(dest);\n            consumers.remove(info);\n            if (!dest.isTemporary() || destinations.containsKey(dest)) {\n                fireConsumerAdvisory(context, dest, topic, info.createRemoveCommand());\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireConsumerAdvisory": "    protected void fireConsumerAdvisory(ConnectionContext context, ActiveMQDestination consumerDestination, ActiveMQTopic topic, Command command, ConsumerId targetConsumerId) throws Exception {\n        ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n        int count = 0;\n        Set<Destination> set = getDestinations(consumerDestination);\n        if (set != null) {\n            for (Destination dest : set) {\n                count += dest.getDestinationStatistics().getConsumers().getCount();\n            }\n        }\n        advisoryMessage.setIntProperty(AdvisorySupport.MSG_PROPERTY_CONSUMER_COUNT, count);\n\n        fireAdvisory(context, topic, command, targetConsumerId, advisoryMessage);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.removeConsumer": "    public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        getNext().removeConsumer(context, info);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processRemoveConsumer": "    public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {\n        SessionId sessionId = id.getParentId();\n        ConnectionId connectionId = sessionId.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs == null) {\n            throw new IllegalStateException(\"Cannot remove a consumer from a connection that had not been registered: \"\n                    + connectionId);\n        }\n        SessionState ss = cs.getSessionState(sessionId);\n        if (ss == null) {\n            throw new IllegalStateException(\"Cannot remove a consumer from a session that had not been registered: \"\n                    + sessionId);\n        }\n        ConsumerState consumerState = ss.removeConsumer(id);\n        if (consumerState == null) {\n            throw new IllegalStateException(\"Cannot remove a consumer that had not been registered: \" + id);\n        }\n        ConsumerInfo info = consumerState.getInfo();\n        info.setLastDeliveredSequenceId(lastDeliveredSequenceId);\n        broker.removeConsumer(cs.getContext(), consumerState.getInfo());\n        removeConsumerBrokerExchange(id);\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.removeConsumerBrokerExchange": "    private void removeConsumerBrokerExchange(ConsumerId id) {\n        synchronized (consumerExchanges) {\n            consumerExchanges.remove(id);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.lookupConnectionState": "    public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.RemoveInfo.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        switch (objectId.getDataStructureType()) {\n        case ConnectionId.DATA_STRUCTURE_TYPE:\n            return visitor.processRemoveConnection((ConnectionId)objectId, lastDeliveredSequenceId);\n        case SessionId.DATA_STRUCTURE_TYPE:\n            return visitor.processRemoveSession((SessionId)objectId, lastDeliveredSequenceId);\n        case ConsumerId.DATA_STRUCTURE_TYPE:\n            return visitor.processRemoveConsumer((ConsumerId)objectId, lastDeliveredSequenceId);\n        case ProducerId.DATA_STRUCTURE_TYPE:\n            return visitor.processRemoveProducer((ProducerId)objectId);\n        default:\n            throw new IOException(\"Unknown remove command type: \" + objectId.getDataStructureType());\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.RemoveInfo.getDataStructureType": "    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \", e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.isStopping": "    public boolean isStopping() {\n        return stopping.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        this.sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            this.sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-broker.src.main.java.org.apache.activemq.security.SecurityContext.getAuthorizedWriteDests": "    public ConcurrentHashMap<ActiveMQDestination, ActiveMQDestination> getAuthorizedWriteDests() {\n        return authorizedWriteDests;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.security.SecurityContext.isInOneOf": "    public boolean isInOneOf(Set<?> allowedPrincipals) {\n        Iterator<?> allowedIter = allowedPrincipals.iterator();\n        HashSet<?> userPrincipals = new HashSet<Object>(getPrincipals());\n        while (allowedIter.hasNext()) {\n            Iterator<?> userIter = userPrincipals.iterator();\n            Object allowedPrincipal = allowedIter.next();\n            while (userIter.hasNext()) {\n                if (allowedPrincipal.equals(userIter.next()))\n                    return true;\n            }\n        }\n        return false;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.security.SecurityContext.getPrincipals": "    public abstract Set<Principal> getPrincipals();\n\n    public String getUserName() {\n        return userName;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.security.SecurityContext.getUserName": "    public String getUserName() {\n        return userName;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.security.authorizationMap.getTempDestinationWriteACLs": "    Set<?> getTempDestinationWriteACLs();\n\n    /**\n     * Returns the set of all ACLs capable of administering the given\n     * destination\n     */\n    Set<?> getAdminACLs(ActiveMQDestination destination);\n\n    /**\n     * Returns the set of all ACLs capable of reading (consuming from) the given\n     * destination\n     */\n    Set<?> getReadACLs(ActiveMQDestination destination);\n\n    /**\n     * Returns the set of all ACLs capable of writing to the given destination\n     */\n    Set<?> getWriteACLs(ActiveMQDestination destination);\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.security.authorizationMap.getWriteACLs": "    Set<?> getWriteACLs(ActiveMQDestination destination);\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.security.SecurityContext.isBrokerContext": "    public boolean isBrokerContext() {\n        return false;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getMessageDLQdAdvisoryTopic": "    public static ActiveMQTopic getMessageDLQdAdvisoryTopic(ActiveMQDestination destination) {\n        String name = MESSAGE_DLQ_TOPIC_PREFIX + destination.getDestinationTypeAsString() + \".\"\n                + destination.getPhysicalName();\n        return new ActiveMQTopic(name);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getExpiredMessageTopic": "    public static ActiveMQTopic getExpiredMessageTopic(ActiveMQDestination destination) {\n        if (destination.isQueue()) {\n            return getExpiredQueueMessageAdvisoryTopic(destination);\n        }\n        return getExpiredTopicMessageAdvisoryTopic(destination);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getExpiredQueueMessageAdvisoryTopic": "    public static ActiveMQTopic getExpiredQueueMessageAdvisoryTopic(ActiveMQDestination destination) {\n        String name = EXPIRED_QUEUE_MESSAGES_TOPIC_PREFIX + destination.getPhysicalName();\n        return new ActiveMQTopic(name);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getExpiredTopicMessageAdvisoryTopic": "    public static ActiveMQTopic getExpiredTopicMessageAdvisoryTopic(ActiveMQDestination destination) {\n        String name = EXPIRED_TOPIC_MESSAGES_TOPIC_PREFIX + destination.getPhysicalName();\n        return new ActiveMQTopic(name);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getExpired": "    public CountStatisticImpl getExpired() {\n        return expired;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getRegionDestination": "    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.decrementReferenceCount": "    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.isExpired": "    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.isDropped": "    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-client.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessageId": "    MessageId getMessageId();\n    Message getMessageHardRef();\n    Message getMessage();\n    boolean isPersistent();\n    \n    Message.MessageDestination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueMessageReference.unlock": "    boolean unlock();\n    \n    LockOwner getLockOwner();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueMessageReference.isDropped": "    boolean isDropped();\n        \n    boolean lock(LockOwner subscription);\n    \n    boolean unlock();\n    \n    LockOwner getLockOwner();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Subscription.remove": "    List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception;\n\n    /**\n     * The ConsumerInfo object that created the subscription.\n     */\n    ConsumerInfo getConsumerInfo();\n\n    /**\n     * The subscription should release as may references as it can to help the garbage collector\n     * reclaim memory.\n     */\n    void gc();\n\n    /**\n     * Used by a Slave Broker to update dispatch infomation\n     * @param mdn\n     * @throws Exception\n     */\n    void processMessageDispatchNotification(MessageDispatchNotification  mdn) throws Exception;\n\n    /**\n     * @return number of messages pending delivery\n     */\n    int getPendingQueueSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    int getDispatchedQueueSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    long getDispatchedCounter();\n\n    /**\n     * @return number of messages that matched the subscription\n     */\n    long getEnqueueCounter();\n\n    /**\n     * @return number of messages queued by the client\n     */\n    long getDequeueCounter();\n\n    /**\n     * @return the JMS selector on the current subscription\n     */\n    String getSelector();\n\n    /**\n     * Attempts to change the current active selector on the subscription.\n     * This operation is not supported for persistent topics.\n     */\n    void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException;\n\n    /**\n     * @return the JMX object name that this subscription was registered as if applicable\n     */\n    ObjectName getObjectName();\n\n    /**\n     * Set when the subscription is registered in JMX\n     */\n    void setObjectName(ObjectName objectName);\n\n    /**\n     * @return true when 60% or more room is left for dispatching messages\n     */\n    boolean isLowWaterMark();\n\n    /**\n     * @return true when 10% or less room is left for dispatching messages\n     */\n    boolean isHighWaterMark();\n\n    /**\n     * @return true if there is no space to dispatch messages\n     */\n    boolean isFull();\n\n    /**\n     * inform the MessageConsumer on the client to change it's prefetch\n     * @param newPrefetch\n     */\n    void updateConsumerPrefetch(int newPrefetch);\n\n    /**\n     * Called when the subscription is destroyed.\n     */\n    void destroy();\n\n    /**\n     * @return the prefetch size that is configured for the subscription\n     */\n    int getPrefetchSize();\n\n    /**\n     * @return the number of messages awaiting acknowledgement\n     */\n    int getInFlightSize();\n\n    /**\n     * @return the in flight messages as a percentage of the prefetch size\n     */\n    int getInFlightUsage();\n\n    /**\n     * Informs the Broker if the subscription needs to intervention to recover it's state\n     * e.g. DurableTopicSubscriber may do\n     * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor\n     * @return true if recovery required\n     */\n    boolean isRecoveryRequired();\n\n    /**\n     * @return true if a browser\n     */\n    boolean isBrowser();\n\n    /**\n     * @return the number of messages this subscription can accept before its full\n     */\n    int countBeforeFull();\n\n    ConnectionContext getContext();\n\n    public int getCursorMemoryHighWaterMark();\n\n    public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n\n    boolean isSlowConsumer();\n\n    void unmatched(MessageReference node) throws IOException;\n\n    /**\n     * Returns the time since the last Ack message was received by this subscription.\n     *\n     * If there has never been an ack this value should be set to the creation time of the\n     * subscription.\n     *\n     * @return time of last received Ack message or Subscription create time if no Acks.\n     */\n    long getTimeOfLastMessageAck();\n\n    long  getConsumedCount();\n\n    void incrementConsumedCount();\n\n    void resetConsumedCount();\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Subscription.getConsumerInfo": "    ConsumerInfo getConsumerInfo();\n\n    /**\n     * The subscription should release as may references as it can to help the garbage collector\n     * reclaim memory.\n     */\n    void gc();\n\n    /**\n     * Used by a Slave Broker to update dispatch infomation\n     * @param mdn\n     * @throws Exception\n     */\n    void processMessageDispatchNotification(MessageDispatchNotification  mdn) throws Exception;\n\n    /**\n     * @return number of messages pending delivery\n     */\n    int getPendingQueueSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    int getDispatchedQueueSize();\n\n    /**\n     * @return number of messages dispatched to the client\n     */\n    long getDispatchedCounter();\n\n    /**\n     * @return number of messages that matched the subscription\n     */\n    long getEnqueueCounter();\n\n    /**\n     * @return number of messages queued by the client\n     */\n    long getDequeueCounter();\n\n    /**\n     * @return the JMS selector on the current subscription\n     */\n    String getSelector();\n\n    /**\n     * Attempts to change the current active selector on the subscription.\n     * This operation is not supported for persistent topics.\n     */\n    void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException;\n\n    /**\n     * @return the JMX object name that this subscription was registered as if applicable\n     */\n    ObjectName getObjectName();\n\n    /**\n     * Set when the subscription is registered in JMX\n     */\n    void setObjectName(ObjectName objectName);\n\n    /**\n     * @return true when 60% or more room is left for dispatching messages\n     */\n    boolean isLowWaterMark();\n\n    /**\n     * @return true when 10% or less room is left for dispatching messages\n     */\n    boolean isHighWaterMark();\n\n    /**\n     * @return true if there is no space to dispatch messages\n     */\n    boolean isFull();\n\n    /**\n     * inform the MessageConsumer on the client to change it's prefetch\n     * @param newPrefetch\n     */\n    void updateConsumerPrefetch(int newPrefetch);\n\n    /**\n     * Called when the subscription is destroyed.\n     */\n    void destroy();\n\n    /**\n     * @return the prefetch size that is configured for the subscription\n     */\n    int getPrefetchSize();\n\n    /**\n     * @return the number of messages awaiting acknowledgement\n     */\n    int getInFlightSize();\n\n    /**\n     * @return the in flight messages as a percentage of the prefetch size\n     */\n    int getInFlightUsage();\n\n    /**\n     * Informs the Broker if the subscription needs to intervention to recover it's state\n     * e.g. DurableTopicSubscriber may do\n     * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor\n     * @return true if recovery required\n     */\n    boolean isRecoveryRequired();\n\n    /**\n     * @return true if a browser\n     */\n    boolean isBrowser();\n\n    /**\n     * @return the number of messages this subscription can accept before its full\n     */\n    int countBeforeFull();\n\n    ConnectionContext getContext();\n\n    public int getCursorMemoryHighWaterMark();\n\n    public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n\n    boolean isSlowConsumer();\n\n    void unmatched(MessageReference node) throws IOException;\n\n    /**\n     * Returns the time since the last Ack message was received by this subscription.\n     *\n     * If there has never been an ack this value should be set to the creation time of the\n     * subscription.\n     *\n     * @return time of last received Ack message or Subscription create time if no Acks.\n     */\n    long getTimeOfLastMessageAck();\n\n    long  getConsumedCount();\n\n    void incrementConsumedCount();\n\n    void resetConsumedCount();\n\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.QueueMessageReference.getLockOwner": "    LockOwner getLockOwner();\n}",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isAdvisoryTopic": "    public static boolean isAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination != null) {\n            if (destination.isComposite()) {\n                ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n                for (int i = 0; i < compositeDestinations.length; i++) {\n                    if (isAdvisoryTopic(compositeDestinations[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                return destination.isTopic() && destination.getPhysicalName().startsWith(ADVISORY_TOPIC_PREFIX);\n            }\n        }\n        return false;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getConsumerAdvisoryTopic": "    public static ActiveMQTopic getConsumerAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isQueue()) {\n            return new ActiveMQTopic(QUEUE_CONSUMER_ADVISORY_TOPIC_PREFIX + destination.getPhysicalName());\n        } else {\n            return new ActiveMQTopic(TOPIC_CONSUMER_ADVISORY_TOPIC_PREFIX + destination.getPhysicalName());\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnectionState.getContext": "    public ConnectionContext getContext() {\n        return context;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "Message expiry that is done as part of a removeSubscription command should not use the clients credentials.",
            "Description": "If the broker handles a RemoveInfo command it may also kick off a message expiry check for (I presume) any prefetched messages. If messages are to be expired they get sent to ActiveMQ.DLQ by default. See stack trace in next comment.\n\nIf the broker is security enabled with authorization turned on and messages get sent to DLQ as a result of the expiry check then the broker uses the client's security context when sending the messages to DLQ. \nThis implies the client user needs to have write access to ActiveMQ.DLQ. \n\nAs this may happen with any other client, all client users will require write access to ActiveMQ.DLQ, which may not be appropriate from a security point of view. \n\nThe broker regularly runs an expiry check and uses a broker internal security context for this task. In my opinion this same broker internal security context should be used when expiring messages as part of the RemoveInfo command. The broker should not use the client's security context. \n\n[1]\nThe current behavior can raise the following SecurityException if the client user does not have write access to ActiveMQ.DLQ\n\n{code}\n2014-04-11 08:11:22,229 | WARN  | 2.38:61201@61616 | RegionBroker | ivemq.broker.region.RegionBroker  703 | \n105 - org.apache.activemq.activemq-osgi - 5.8.0.redhat-60024 | Caught an exception sending to DLQ: Message \nID:S930A3085-50865-635327964441522304-1:1:363:2:1 dropped=false acked=false locked=true\njava.lang.SecurityException: User Test is not authorized to write to: queue://ActiveMQ.DLQ\n\tat org.apache.activemq.security.AuthorizationBroker.send(AuthorizationBroker.java:197)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.util.BrokerSupport.doResend(BrokerSupport.java:68)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.util.BrokerSupport.resendNoCopy(BrokerSupport.java:38)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.RegionBroker.sendToDeadLetterQueue(RegionBroker.java:691)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.advisory.AdvisoryBroker.sendToDeadLetterQueue(AdvisoryBroker.java:413)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.sendToDeadLetterQueue(MutableBrokerFilter.java:274)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.util.RedeliveryPlugin.sendToDeadLetterQueue(RedeliveryPlugin.java:132)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.sendToDeadLetterQueue(MutableBrokerFilter.java:274)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.RegionBroker.messageExpired(RegionBroker.java:659)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.advisory.AdvisoryBroker.messageExpired(AdvisoryBroker.java:283)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageExpired(MutableBrokerFilter.java:269)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.messageExpired(BrokerFilter.java:257)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageExpired(MutableBrokerFilter.java:269)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.messageExpired(Queue.java:1671)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending(PrefetchSubscription.java:648)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.PrefetchSubscription.add(PrefetchSubscription.java:162)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:1907)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1834)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.Queue.removeSubscription(Queue.java:576)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.AbstractRegion.removeConsumer(AbstractRegion.java:380)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.region.RegionBroker.removeConsumer(RegionBroker.java:364)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.removeConsumer(ManagedRegionBroker.java:247)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.advisory.AdvisoryBroker.removeConsumer(AdvisoryBroker.java:253)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.removeConsumer(MutableBrokerFilter.java:123)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:117)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.MutableBrokerFilter.removeConsumer(MutableBrokerFilter.java:123)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.TransportConnection.processRemoveConsumer(TransportConnection.java:651)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.command.RemoveInfo.visit(RemoveInfo.java:76)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:329)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:184)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)[105:org.apache.activemq.activemq-osgi:5.8.0.redhat-60024]\n\tat java.lang.Thread.run(Unknown Source)[:1.6.0_26]\n{code}\n \n"
        }
    },
    {
        "filename": "AMQ-5854.json",
        "creation_time": "2015-06-19T15:36:33.000+0000",
        "stack_trace": "org.apache.activemq.transport.InactivityIOException: Cannot send, channel has already failed: ***\n               at org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend(AbstractInactivityMonitor.java:297)\n                at org.apache.activemq.transport.AbstractInactivityMonitor.oneway(AbstractInactivityMonitor.java:286)\n                at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:85)\n                at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:104)\n                at org.apache.activemq.transport.failover.FailoverTransport.oneway(FailoverTransport.java:658)\n                at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68)\n                at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)\n                at org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1321)\n                at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1315)\n                at org.apache.activemq.ActiveMQSession.asyncSendPacket(ActiveMQSession.java:1933)\n                at org.apache.activemq.ActiveMQSession.sendAck(ActiveMQSession.java:2099)\n                at org.apache.activemq.ActiveMQSession.sendAck(ActiveMQSession.java:2094)\n                at org.apache.activemq.ActiveMQMessageConsumer.acknowledge(ActiveMQMessageConsumer.java:1083)\n                at org.apache.activemq.ActiveMQMessageConsumer$5.beforeEnd(ActiveMQMessageConsumer.java:1041)\n                at org.apache.activemq.TransactionContext.beforeEnd(TransactionContext.java:202)\n                at org.apache.activemq.TransactionContext.end(TransactionContext.java:409)\n                at com.atomikos.datasource.xa.XAResourceTransaction.suspend(XAResourceTransaction.java:457)\n                at com.atomikos.datasource.xa.XAResourceTransaction.prepare(XAResourceTransaction.java:608)\n                at com.atomikos.icatch.imp.PrepareMessage.send(PrepareMessage.java:61)\n                at com.atomikos.icatch.imp.PropagationMessage.submit(PropagationMessage.java:111)\n                at com.atomikos.icatch.imp.Propagator$PropagatorThread.run(Propagator.java:87)\n                at com.atomikos.icatch.imp.Propagator.submitPropagationMessage(Propagator.java:66)\n                at com.atomikos.icatch.imp.ActiveStateHandler.prepare(ActiveStateHandler.java:173)\n                at com.atomikos.icatch.imp.CoordinatorImp.prepare(CoordinatorImp.java:832)\n                at com.atomikos.icatch.imp.CoordinatorImp.terminate(CoordinatorImp.java:1159)\n                at com.atomikos.icatch.imp.CompositeTerminatorImp.commit(CompositeTerminatorImp.java:92)\n                at com.atomikos.icatch.jta.TransactionImp.commit(TransactionImp.java:236)\n                at com.atomikos.icatch.jta.TransactionManagerImp.commit(TransactionManagerImp.java:498)\n                at com.atomikos.icatch.jta.UserTransactionImp.commit(UserTransactionImp.java:129)\n                at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1011)\n                at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755)\n                at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:724)\n                at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:257)\n                at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1101)\n                at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:995)\n                at java.lang.Thread.run(Thread.java:761)",
        "source_code": {
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend": "    private void doOnewaySend(Object command) throws IOException {\n        if (failed.get()) {\n            throw new InactivityIOException(\"Cannot send, channel has already failed: \" + next.getRemoteAddress());\n        }\n        if (command.getClass() == WireFormatInfo.class) {\n            synchronized (this) {\n                processOutboundWireFormatInfo((WireFormatInfo) command);\n            }\n        }\n        next.oneway(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processOutboundWireFormatInfo": "    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportFilter.oneway": "    public void oneway(Object command) throws IOException {\n        next.oneway(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.oneway": "    public void oneway(Object command) throws IOException {\n        try {\n            if (!readyCountDownLatch.await(negotiateTimeout, TimeUnit.MILLISECONDS)) {\n                throw new IOException(\"Wire format negotiation timeout: peer did not send his wire format.\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new InterruptedIOException();\n        }\n        super.oneway(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.oneway": "    public void oneway(Object o) throws IOException {\n\n        Command command = (Command) o;\n        Exception error = null;\n        try {\n\n            synchronized (reconnectMutex) {\n\n                if (command != null && connectedTransport.get() == null) {\n                    if (command.isShutdownInfo()) {\n                        // Skipping send of ShutdownInfo command when not connected.\n                        return;\n                    } else if (command instanceof RemoveInfo || command.isMessageAck()) {\n                        // Simulate response to RemoveInfo command or MessageAck (as it will be stale)\n                        stateTracker.track(command);\n                        if (command.isResponseRequired()) {\n                            Response response = new Response();\n                            response.setCorrelationId(command.getCommandId());\n                            myTransportListener.onCommand(response);\n                        }\n                        return;\n                    } else if (command instanceof MessagePull) {\n                        // Simulate response to MessagePull if timed as we can't honor that now.\n                        MessagePull pullRequest = (MessagePull) command;\n                        if (pullRequest.getTimeout() != 0) {\n                            MessageDispatch dispatch = new MessageDispatch();\n                            dispatch.setConsumerId(pullRequest.getConsumerId());\n                            dispatch.setDestination(pullRequest.getDestination());\n                            myTransportListener.onCommand(dispatch);\n                        }\n                        return;\n                    }\n                }\n\n                // Keep trying until the message is sent.\n                for (int i = 0; !disposed; i++) {\n                    try {\n\n                        // Wait for transport to be connected.\n                        Transport transport = connectedTransport.get();\n                        long start = System.currentTimeMillis();\n                        boolean timedout = false;\n                        while (transport == null && !disposed && connectionFailure == null\n                                && !Thread.currentThread().isInterrupted()) {\n                            if (LOG.isTraceEnabled()) {\n                                LOG.trace(\"Waiting for transport to reconnect..: \" + command);\n                            }\n                            long end = System.currentTimeMillis();\n                            if (command.isMessage() && timeout > 0 && (end - start > timeout)) {\n                                timedout = true;\n                                if (LOG.isInfoEnabled()) {\n                                    LOG.info(\"Failover timed out after \" + (end - start) + \"ms\");\n                                }\n                                break;\n                            }\n                            try {\n                                reconnectMutex.wait(100);\n                            } catch (InterruptedException e) {\n                                Thread.currentThread().interrupt();\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Interupted: \" + e, e);\n                                }\n                            }\n                            transport = connectedTransport.get();\n                        }\n\n                        if (transport == null) {\n                            // Previous loop may have exited due to use being\n                            // disposed.\n                            if (disposed) {\n                                error = new IOException(\"Transport disposed.\");\n                            } else if (connectionFailure != null) {\n                                error = connectionFailure;\n                            } else if (timedout == true) {\n                                error = new IOException(\"Failover timeout of \" + timeout + \" ms reached.\");\n                            } else {\n                                error = new IOException(\"Unexpected failure.\");\n                            }\n                            break;\n                        }\n\n                        Tracked tracked = null;\n                        try {\n                            tracked = stateTracker.track(command);\n                        } catch (IOException ioe) {\n                            LOG.debug(\"Cannot track the command \" + command, ioe);\n                        }\n                        // If it was a request and it was not being tracked by\n                        // the state tracker,\n                        // then hold it in the requestMap so that we can replay\n                        // it later.\n                        synchronized (requestMap) {\n                            if (tracked != null && tracked.isWaitingForResponse()) {\n                                requestMap.put(Integer.valueOf(command.getCommandId()), tracked);\n                            } else if (tracked == null && command.isResponseRequired()) {\n                                requestMap.put(Integer.valueOf(command.getCommandId()), command);\n                            }\n                        }\n\n                        // Send the message.\n                        try {\n                            transport.oneway(command);\n                            stateTracker.trackBack(command);\n                            if (command.isShutdownInfo()) {\n                                shuttingDown = true;\n                            }\n                        } catch (IOException e) {\n\n                            // If the command was not tracked.. we will retry in\n                            // this method\n                            if (tracked == null) {\n\n                                // since we will retry in this method.. take it\n                                // out of the request\n                                // map so that it is not sent 2 times on\n                                // recovery\n                                if (command.isResponseRequired()) {\n                                    requestMap.remove(Integer.valueOf(command.getCommandId()));\n                                }\n\n                                // Rethrow the exception so it will handled by\n                                // the outer catch\n                                throw e;\n                            } else {\n                                // Handle the error but allow the method to return since the\n                                // tracked commands are replayed on reconnect.\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(\"Send oneway attempt: \" + i + \" failed for command:\" + command);\n                                }\n                                handleTransportFailure(e);\n                            }\n                        }\n\n                        return;\n\n                    } catch (IOException e) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Send oneway attempt: \" + i + \" failed for command:\" + command);\n                        }\n                        handleTransportFailure(e);\n                    }\n                }\n            }\n        } catch (InterruptedException e) {\n            // Some one may be trying to stop our thread.\n            Thread.currentThread().interrupt();\n            throw new InterruptedIOException();\n        }\n\n        if (!disposed) {\n            if (error != null) {\n                if (error instanceof IOException) {\n                    throw (IOException) error;\n                }\n                throw IOExceptionSupport.create(error);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.remove": "    public void remove(boolean rebalance, URI u[]) {\n        for (URI uri : u) {\n            uris.remove(uri);\n        }\n        // rebalance is automatic if any connected to removed/stopped broker\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.onCommand": "            public void onCommand(Object o) {\n                Command command = (Command) o;\n                if (command == null) {\n                    return;\n                }\n                if (command.isResponse()) {\n                    Object object = null;\n                    synchronized (requestMap) {\n                        object = requestMap.remove(Integer.valueOf(((Response) command).getCorrelationId()));\n                    }\n                    if (object != null && object.getClass() == Tracked.class) {\n                        ((Tracked) object).onResponses(command);\n                    }\n                }\n\n                if (command.isConnectionControl()) {\n                    handleConnectionControl((ConnectionControl) command);\n                }\n                else if (command.isConsumerControl()) {\n                    ConsumerControl consumerControl = (ConsumerControl)command;\n                    if (consumerControl.isClose()) {\n                        stateTracker.processRemoveConsumer(consumerControl.getConsumerId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);\n                    }\n\n                }\n                if (transportListener != null) {\n                    transportListener.onCommand(command);\n                }\n            }",
            "activemq-client.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.handleTransportFailure": "    public final void handleTransportFailure(IOException e) throws InterruptedException {\n        if (shuttingDown) {\n            // shutdown info sent and remote socket closed and we see that before a local close\n            // let the close do the work\n            return;\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \" handleTransportFailure: \" + e, e);\n        }\n\n        // could be blocked in write with the reconnectMutex held, but still needs to be whacked\n        Transport transport = connectedTransport.getAndSet(null);\n        if (transport != null) {\n            disposeTransport(transport);\n        }\n\n        synchronized (reconnectMutex) {\n            if (transport != null && connectedTransport.get() == null) {\n\n                boolean reconnectOk = false;\n\n                if (canReconnect()) {\n                    reconnectOk = true;\n                }\n                 LOG.warn(\"Transport (\" + connectedTransportURI + \") failed\"\n                        + (reconnectOk ? \",\" : \", not\") + \" attempting to automatically reconnect\", e);\n\n                failedConnectTransportURI = connectedTransportURI;\n                connectedTransportURI = null;\n                connectedToPriority = false;\n\n                if (reconnectOk) {\n                    // notify before any reconnect attempt so ack state can be whacked\n                    if (transportListener != null) {\n                        transportListener.transportInterupted();\n                    }\n\n                    updated.remove(failedConnectTransportURI);\n                    reconnectTask.wakeup();\n                } else if (!isDisposed()) {\n                    propagateFailureToExceptionListener(e);\n                }\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.getTimeout": "    public long getTimeout() {\n        return timeout;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.oneway": "    public void oneway(Object command) throws IOException {\n        writeLock.lock();\n        try {\n            next.oneway(command);\n        } finally {\n            writeLock.unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.ResponseCorrelator.oneway": "    public void oneway(Object o) throws IOException {\n        Command command = (Command)o;\n        command.setCommandId(sequenceGenerator.getNextSequenceId());\n        command.setResponseRequired(false);\n        next.oneway(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.doAsyncSendPacket": "    private void doAsyncSendPacket(Command command) throws JMSException {\n        try {\n            this.transport.oneway(command);\n        } catch (IOException e) {\n            throw JMSExceptionSupport.create(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.asyncSendPacket": "    public void asyncSendPacket(Command command) throws JMSException {\n        if (isClosed()) {\n            throw new ConnectionClosedException();\n        } else {\n            doAsyncSendPacket(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.isClosed": "    public boolean isClosed() {\n        return closed.get();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.asyncSendPacket": "    public void asyncSendPacket(Command command) throws JMSException {\n        connection.asyncSendPacket(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.sendAck": "    protected void sendAck(MessageAck ack, boolean lazy) throws JMSException {\n        if (lazy || connection.isSendAcksAsync() || getTransacted()) {\n            asyncSendPacket(ack);\n        } else {\n            syncSendPacket(ack);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.syncSendPacket": "    public Response syncSendPacket(Command command) throws JMSException {\n        return connection.syncSendPacket(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.getTransacted": "    public boolean getTransacted() throws JMSException {\n        checkClosed();\n        return isTransacted();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.acknowledge": "    void acknowledge(MessageDispatch md, byte ackType) throws JMSException {\n        MessageAck ack = new MessageAck(md, ackType, 1);\n        session.sendAck(ack);\n        synchronized(deliveredMessages){\n            deliveredMessages.remove(md);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.rollbackOnFailedRecoveryRedelivery": "    private void rollbackOnFailedRecoveryRedelivery() throws JMSException {\n        if (previouslyDeliveredMessages != null) {\n            // if any previously delivered messages was not re-delivered, transaction is invalid and must rollback\n            // as messages have been dispatched else where.\n            int numberNotReplayed = 0;\n            for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {\n                if (!entry.getValue()) {\n                    numberNotReplayed++;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"previously delivered message has not been replayed in transaction: \"\n                                + previouslyDeliveredMessages.transactionId\n                                + \" , messageId: \" + entry.getKey());\n                    }\n                }\n            }\n            if (numberNotReplayed > 0) {\n                String message = \"rolling back transaction (\"\n                    + previouslyDeliveredMessages.transactionId + \") post failover recovery. \" + numberNotReplayed\n                    + \" previously delivered message(s) not replayed to consumer: \" + this.getConsumerId();\n                LOG.warn(message);\n                throw new TransactionRolledBackException(message);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.clearDeliveredList": "    private void clearDeliveredList() {\n        if (clearDeliveredList) {\n            synchronized (deliveredMessages) {\n                if (clearDeliveredList) {\n                    if (!deliveredMessages.isEmpty()) {\n                        if (session.isTransacted()) {\n\n                            if (previouslyDeliveredMessages == null) {\n                                previouslyDeliveredMessages = new PreviouslyDeliveredMap<MessageId, Boolean>(session.getTransactionContext().getTransactionId());\n                            }\n                            for (MessageDispatch delivered : deliveredMessages) {\n                                previouslyDeliveredMessages.put(delivered.getMessage().getMessageId(), false);\n                            }\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(getConsumerId() + \" tracking existing transacted \" + previouslyDeliveredMessages.transactionId +\n                                        \" delivered list (\" + deliveredMessages.size() + \") on transport interrupt\");\n                            }\n                        } else {\n                            if (session.isClientAcknowledge()) {\n                                if (LOG.isDebugEnabled()) {\n                                    LOG.debug(getConsumerId() + \" rolling back delivered list (\" + deliveredMessages.size() + \") on transport interrupt\");\n                                }\n                                // allow redelivery\n                                if (!this.info.isBrowser()) {\n                                    for (MessageDispatch md: deliveredMessages) {\n                                        this.session.connection.rollbackDuplicate(this, md.getMessage());\n                                    }\n                                }\n                            }\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(getConsumerId() + \" clearing delivered list (\" + deliveredMessages.size() + \") on transport interrupt\");\n                            }\n                            deliveredMessages.clear();\n                            pendingAck = null;\n                        }\n                    }\n                    clearDeliveredList = false;\n                }\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.waitForRedeliveries": "    private void waitForRedeliveries() {\n        if (failoverRedeliveryWaitPeriod > 0 && previouslyDeliveredMessages != null) {\n            long expiry = System.currentTimeMillis() + failoverRedeliveryWaitPeriod;\n            int numberNotReplayed;\n            do {\n                numberNotReplayed = 0;\n                synchronized(deliveredMessages) {\n                    if (previouslyDeliveredMessages != null) {\n                        for (Entry<MessageId, Boolean> entry: previouslyDeliveredMessages.entrySet()) {\n                            if (!entry.getValue()) {\n                                numberNotReplayed++;\n                            }\n                        }\n                    }\n                }\n                if (numberNotReplayed > 0) {\n                    LOG.info(\"waiting for redelivery of \" + numberNotReplayed + \" in transaction: \"\n                            + previouslyDeliveredMessages.transactionId +  \", to consumer :\" + this.getConsumerId());\n                    try {\n                        Thread.sleep(Math.max(500, failoverRedeliveryWaitPeriod/4));\n                    } catch (InterruptedException outOfhere) {\n                        break;\n                    }\n                }\n            } while (numberNotReplayed > 0 && expiry < System.currentTimeMillis());\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.makeAckForAllDeliveredMessages": "    private MessageAck makeAckForAllDeliveredMessages(byte type) {\n        synchronized (deliveredMessages) {\n            if (deliveredMessages.isEmpty())\n                return null;\n\n            MessageDispatch md = deliveredMessages.getFirst();\n            MessageAck ack = new MessageAck(md, type, deliveredMessages.size());\n            ack.setFirstMessageId(deliveredMessages.getLast().getMessage().getMessageId());\n            return ack;\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageConsumer.beforeEnd": "                public void beforeEnd() throws Exception {\n                    if (transactedIndividualAck) {\n                        clearDeliveredList();\n                        waitForRedeliveries();\n                        synchronized(deliveredMessages) {\n                            rollbackOnFailedRecoveryRedelivery();\n                        }\n                    } else {\n                        acknowledge();\n                    }\n                    synchronizationRegistered = false;\n                }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.beforeEnd": "    private void beforeEnd() throws JMSException {\n        if (synchronizations == null) {\n            return;\n        }\n\n        int size = synchronizations.size();\n        try {\n            for (;beforeEndIndex < size;) {\n                synchronizations.get(beforeEndIndex++).beforeEnd();\n            }\n        } catch (JMSException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw JMSExceptionSupport.create(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.end": "    public void end(Xid xid, int flags) throws XAException {\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"End: \" + xid + \", flags:\" + flags);\n        }\n\n        if (isInLocalTransaction()) {\n            throw new XAException(XAException.XAER_PROTO);\n        }\n\n        if ((flags & (TMSUSPEND | TMFAIL)) != 0) {\n            // You can only suspend the associated xid.\n            if (!equals(associatedXid, xid)) {\n                throw new XAException(XAException.XAER_PROTO);\n            }\n\n            // TODO: we may want to put the xid in a suspended list.\n            try {\n                beforeEnd();\n            } catch (JMSException e) {\n                throw toXAException(e);\n            } finally {\n                setXid(null);\n            }\n        } else if ((flags & TMSUCCESS) == TMSUCCESS) {\n            // set to null if this is the current xid.\n            // otherwise this could be an asynchronous success call\n            if (equals(associatedXid, xid)) {\n                try {\n                    beforeEnd();\n                } catch (JMSException e) {\n                    throw toXAException(e);\n                } finally {\n                    setXid(null);\n                }\n            }\n        } else {\n            throw new XAException(XAException.XAER_INVAL);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.toXAException": "    private XAException toXAException(JMSException e) {\n        if (e.getCause() != null && e.getCause() instanceof XAException) {\n            XAException original = (XAException)e.getCause();\n            XAException xae = new XAException(original.getMessage());\n            xae.errorCode = original.errorCode;\n            if (xae.errorCode == XA_OK) {\n                // detail not unmarshalled see: org.apache.activemq.openwire.v1.BaseDataStreamMarshaller.createThrowable\n                xae.errorCode = parseFromMessageOr(original.getMessage(), XAException.XAER_RMERR);\n            }\n            xae.initCause(original);\n            return xae;\n        }\n\n        XAException xae = new XAException(e.getMessage());\n        xae.errorCode = XAException.XAER_RMFAIL;\n        xae.initCause(e);\n        return xae;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.equals": "    private boolean equals(Xid xid1, Xid xid2) {\n        if (xid1 == xid2) {\n            return true;\n        }\n        if (xid1 == null ^ xid2 == null) {\n            return false;\n        }\n        return xid1.getFormatId() == xid2.getFormatId() && Arrays.equals(xid1.getBranchQualifier(), xid2.getBranchQualifier())\n               && Arrays.equals(xid1.getGlobalTransactionId(), xid2.getGlobalTransactionId());\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.isInLocalTransaction": "    public boolean isInLocalTransaction() {\n        return transactionId != null && transactionId.isLocalTransaction();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.setXid": "    private void setXid(Xid xid) throws XAException {\n\n        try {\n            this.connection.checkClosedOrFailed();\n            this.connection.ensureConnectionInfoSent();\n        } catch (JMSException e) {\n            disassociate();\n            throw toXAException(e);\n        }\n\n        if (xid != null) {\n            // associate\n            associatedXid = xid;\n            transactionId = new XATransactionId(xid);\n\n            TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);\n            try {\n                this.connection.asyncSendPacket(info);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"{} started XA transaction {} \", this, transactionId);\n                }\n            } catch (JMSException e) {\n                disassociate();\n                throw toXAException(e);\n            }\n\n        } else {\n\n            if (transactionId != null) {\n                TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.END);\n                try {\n                    syncSendPacketWithInterruptionHandling(info);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"{} ended XA transaction {}\", this, transactionId);\n                    }\n                } catch (JMSException e) {\n                    disassociate();\n                    throw toXAException(e);\n                }\n\n                // Add our self to the list of contexts that are interested in\n                // post commit/rollback events.\n\t        \tsynchronized(ENDED_XA_TRANSACTION_CONTEXTS) {\n\t                List<TransactionContext> l = ENDED_XA_TRANSACTION_CONTEXTS.get(transactionId);\n\t                if (l == null) {\n\t                    l = new ArrayList<TransactionContext>(3);\n\t                    ENDED_XA_TRANSACTION_CONTEXTS.put(transactionId, l);\n\t                    l.add(this);\n\t                } else if (!l.contains(this)) {\n\t                    l.add(this);\n\t                }\n\t        \t}\n            }\n\n            disassociate();\n        }\n    }"
        },
        "bug_report": {
            "Title": "Duplicate messages when failover is done during prepare phase of two phase commit.",
            "Description": "Use case :\n                With Spring DMLC, Read a jms message in a queue, produce a jms message in an output queue and write data in database.\n\nProblem description :\n\n                Due to hight CPU usage, the inactity monitor closes connections between clients and broker while 16 messages were processed.\n\n{noformat}\n2015-06-01 04:39:01,130 | WARN  | Transport Connection to: tcp://*** failed: org.apache.activemq.transport.InactivityIOException: Channel was inactive for too (>30000) long: tcp://*** | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ InactivityMonitor Worker\n{noformat}\n                15 messages are rolled back and redilevered to another consummer.\n\n                In the log we got 15 warnings :\n{noformat}\nActiveMQMessageConsumer   |WARN |jmsContainer-173|rolling back transaction (XID:***) post failover recovery. 1 previously delivered message(s) not replayed to consumer: ***\n{noformat}\n                But one message is not rolled back (the transaction commit) and is also redileverd to another consummer. So it's processed twice by two different consummers (two inserts in database and two output JMS messages generated) and is not deduplicated.\n\n                In the activeMq log we got the message :\n\n{noformat}\nWARN  | Async error occurred:  | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: tcp:///***\n                       javax.jms.JMSException: Unmatched acknowledge: MessageAck {commandId = 6665, responseRequired = false, ackType = 2, consumerId = ID:***, firstMessageId = ID:***-50800-1433109620591-1:2:31356:1:1, lastMessageId = ID:***-50800-1433109620591-1:2:31356:1:1, destination = queue://***, transactionId = XID:[1096044365,globalId=47524f55505f3030303038736572766963657472616974656d656e7431363536373030343133,branchId=47524f55505f3030303038736572766963657472616974656d656e743137343737], messageCount = 1, poisonCause = null}; Could not find Message-ID ID:***-50800-1433109620591-1:2:31356:1:1 in dispatched-list (start of ack)\n{noformat}\n\n                For this duplicated message, the failover occur during prepare phase of commit :\n\n{noformat}\n[{2015/06/01 04:39:50,322 |FailoverTransport         |WARN |jmsContainer-152|Transport (tcp://***) failed, reason:  , attempting to automatically reconnect}]\norg.apache.activemq.transport.InactivityIOException: Cannot send, channel has already failed: ***\n                at org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend(AbstractInactivityMonitor.java:297)\n                at org.apache.activemq.transport.AbstractInactivityMonitor.oneway(AbstractInactivityMonitor.java:286)\n                at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:85)\n                at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:104)\n                at org.apache.activemq.transport.failover.FailoverTransport.oneway(FailoverTransport.java:658)\n                at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68)\n                at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)\n                at org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1321)\n                at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1315)\n                at org.apache.activemq.ActiveMQSession.asyncSendPacket(ActiveMQSession.java:1933)\n                at org.apache.activemq.ActiveMQSession.sendAck(ActiveMQSession.java:2099)\n                at org.apache.activemq.ActiveMQSession.sendAck(ActiveMQSession.java:2094)\n                at org.apache.activemq.ActiveMQMessageConsumer.acknowledge(ActiveMQMessageConsumer.java:1083)\n                at org.apache.activemq.ActiveMQMessageConsumer$5.beforeEnd(ActiveMQMessageConsumer.java:1041)\n                at org.apache.activemq.TransactionContext.beforeEnd(TransactionContext.java:202)\n                at org.apache.activemq.TransactionContext.end(TransactionContext.java:409)\n                at com.atomikos.datasource.xa.XAResourceTransaction.suspend(XAResourceTransaction.java:457)\n                at com.atomikos.datasource.xa.XAResourceTransaction.prepare(XAResourceTransaction.java:608)\n                at com.atomikos.icatch.imp.PrepareMessage.send(PrepareMessage.java:61)\n                at com.atomikos.icatch.imp.PropagationMessage.submit(PropagationMessage.java:111)\n                at com.atomikos.icatch.imp.Propagator$PropagatorThread.run(Propagator.java:87)\n                at com.atomikos.icatch.imp.Propagator.submitPropagationMessage(Propagator.java:66)\n                at com.atomikos.icatch.imp.ActiveStateHandler.prepare(ActiveStateHandler.java:173)\n                at com.atomikos.icatch.imp.CoordinatorImp.prepare(CoordinatorImp.java:832)\n                at com.atomikos.icatch.imp.CoordinatorImp.terminate(CoordinatorImp.java:1159)\n                at com.atomikos.icatch.imp.CompositeTerminatorImp.commit(CompositeTerminatorImp.java:92)\n                at com.atomikos.icatch.jta.TransactionImp.commit(TransactionImp.java:236)\n                at com.atomikos.icatch.jta.TransactionManagerImp.commit(TransactionManagerImp.java:498)\n                at com.atomikos.icatch.jta.UserTransactionImp.commit(UserTransactionImp.java:129)\n                at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1011)\n                at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755)\n                at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:724)\n                at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:257)\n                at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1101)\n                at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:995)\n                at java.lang.Thread.run(Thread.java:761)\n{noformat}\n\nOur analysis :\n\n                We think that the duplicate message is caused by the failover during the prepare phase of the commit so we modify the source code to reproduce the case.\n\n                Our modifications in config to produce failovers:\n                               broker : transport.useKeepAlive=false\n                               client : wireFormat.maxInactivityDuration=5000\n\n\n                We add Thread.sleep in the source code of org.apache.activemq.ActiveMQMessageConsumer to force failover to be done exactly where we think it causes problems :\n\n{code:title=org.apache.activemq.ActiveMQMessageConsumer#acknowledge()|borderStyle=solid}                \n\n                    public void acknowledge() throws JMSException {\n                               clearDeliveredList();\n                               waitForRedeliveries();\n                               synchronized(deliveredMessages) {\n\n                                   // BEGIN MODIFIED CODE\n                                   LOG.warn(\"start sleeping 20 seconds to test failover\");\n                                   try{\n                                       Thread.sleep(1000 * 20 );\n                                   }catch (InterruptedException e){\n                                       LOG.error(\"Exception :\",e);\n                                   }\n                                   LOG.warn(\"end sleeping 20 seconds to test failover\");\n                                   // END MODIFIED CODE\n\n                                   // Acknowledge all messages so far.\n                                   MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                   if (ack == null)\n                                       return; // no msgs\n\n                                   if (session.getTransacted()) {\n                                       rollbackOnFailedRecoveryRedelivery();\n                                       session.doStartTransaction();\n                                       ack.setTransactionId(session.getTransactionContext().getTransactionId());\n                                   }\n\n                                   pendingAck = null;\n                                    session.sendAck(ack);\n\n                                   // Adjust the counters\n                                   deliveredCounter = Math.max(0, deliveredCounter - deliveredMessages.size());\n                                   additionalWindowSize = Math.max(0, additionalWindowSize - deliveredMessages.size());\n\n                                   if (!session.getTransacted()) {\n                                       deliveredMessages.clear();\n                                   }\n                               }\n                    }\n{code}                               \n                \n                With these changes on the configuration and the code, the problem is easily reproduced.\n\n                We also try with transactedIndividualAck=true, and we add a Thread.sleep in the code :\n\n{code:title=org.apache.activemq.ActiveMQMessageConsumer#registerSync()|borderStyle=solid}                \n                    private void registerSync() throws JMSException {\n                               session.doStartTransaction();\n                               if (!synchronizationRegistered) {\n                                   synchronizationRegistered = true;\n                                   session.getTransactionContext().addSynchronization(new Synchronization() {\n                                       @Override\n                                       public void beforeEnd() throws Exception {\n                                           if (transactedIndividualAck) {\n                                               clearDeliveredList();\n                                               waitForRedeliveries();\n                                               synchronized(deliveredMessages) {\n                                                   \n                                                   // BEGIN MODIFIED CODE\n                                                   LOG.warn(\"start sleeping 20 seconds to test failover\");\n                                                   try{\n                                                       Thread.sleep(1000 * 20 );\n                                                   }catch (InterruptedException e){\n                                                       LOG.error(\"Exception :\",e);\n                                                   }\n                                                   LOG.warn(\"end sleeping 20 seconds to test failover\");\n                                                   // END MODIFIED CODE                            \n\n                                                   rollbackOnFailedRecoveryRedelivery();\n                                               }\n                                           } else {\n                                               acknowledge();\n                                           }\n                                           synchronizationRegistered = false;\n                                       }\n\n                                       @Override\n                                       public void afterCommit() throws Exception {\n                                           commit();\n                                           synchronizationRegistered = false;\n                                       }\n\n                                       @Override\n                                       public void afterRollback() throws Exception {\n                                           rollback();\n                                           synchronizationRegistered = false;\n                                       }\n                                   });\n                               }\n                    }\n{code}                                               \n                With these modifications, we still get duplicates messages.\n\n                We think that the problem is that the statement synchronized(deliveredMessages) prevents the call of clearDeliveredList() by another ActiveMQConnection thread that clears messages in progress.\n                By adding logs we observe that a thread is waiting deliveredMessages \u2018s lock in clearDeliveredList() method.\n\n                \nQuestion :\n                \n                We tried fixes described in https://issues.apache.org/jira/browse/AMQ-5068 and https://issues.apache.org/jira/browse/AMQ-3519 but it doesn\u2019t help to solve our problem.\n                Is there a workaround or a config parameter that can help to prevent this problem ?\n                \n                We are working on our side to find a correction. An option may be to force rolling back transaction if there is a failover during the prepare phase of commit in ConnectionStateTracker.restoreTransactions().\n\n\n"
        }
    },
    {
        "filename": "AMQ-3056.json",
        "creation_time": "2010-11-26T14:36:24.000+0000",
        "stack_trace": "javax.jms.JMSException: Invalid acknowledgment: MessageAck {commandId = 29455, responseRequired = false, ackType = 3, consumerId = ID:X-2506-1289583778418-0:0:1:1, firstMessageId = ID:X09-51821-634249796434830099-1:5:1:3:313195, lastMessageId = ID:X09-51821-634249796434830099-1:5:1:3:313195, destination = topic://help.Publish.Instance1, transactionId = null, messageCount = 1}\n        at org.apache.activemq.broker.region.TopicSubscription.acknowledge(TopicSubscription.java:286)\n        at org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:383)\n        at org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:544)\n        at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n        at org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:200)\n        at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n        at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n        at org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:87)\n        at org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:469)\n        at org.apache.activemq.command.MessageAck.visit(MessageAck.java:214)\n        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:311)\n        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:185)\n        at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)\n        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n        at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:228)\n        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:220)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:202)\n        at java.lang.Thread.run(Thread.java:619)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.broker.region.TopicSubscription.acknowledge": "    public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {\n        // Handle the standard acknowledgment case.\n        if (ack.isStandardAck() || ack.isPoisonAck() || ack.isIndividualAck()) {\n            if (context.isInTransaction()) {\n                context.getTransaction().addSynchronization(new Synchronization() {\n\n                    @Override\n                    public void afterCommit() throws Exception {\n                       synchronized (TopicSubscription.this) {\n                            if (singleDestination && destination != null) {\n                                destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());\n                            }\n                        }\n                        dequeueCounter.addAndGet(ack.getMessageCount());\n                        dispatchMatched();\n                    }\n                });\n            } else {\n                if (singleDestination && destination != null) {\n                    destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());\n                    destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());\n                }\n                dequeueCounter.addAndGet(ack.getMessageCount());\n            }\n            dispatchMatched();\n            return;\n        } else if (ack.isDeliveredAck()) {\n            // Message was delivered but not acknowledged: update pre-fetch\n            // counters.\n            // also. get these for a consumer expired message.\n            if (destination != null && !ack.isInTransaction()) {\n                destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());\n                destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());   \n            }\n            dequeueCounter.addAndGet(ack.getMessageCount());\n            dispatchMatched();\n            return;\n        }\n        throw new JMSException(\"Invalid acknowledgment: \" + ack);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.TopicSubscription.add": "    public void add(MessageReference node) throws Exception {\n        if (isDuplicate(node)) {\n            return;\n        }\n        enqueueCounter.incrementAndGet();\n        if (!isFull() && matched.isEmpty()  && !isSlave()) {\n            // if maximumPendingMessages is set we will only discard messages which\n            // have not been dispatched (i.e. we allow the prefetch buffer to be filled)\n            dispatch(node);\n            setSlowConsumer(false);\n        } else {\n            //we are slow\n            if(!isSlowConsumer()) {\n                setSlowConsumer(true);\n                for (Destination dest: destinations) {\n                    dest.slowConsumer(getContext(), this);\n                }\n            }\n            if (maximumPendingMessages != 0) {\n                boolean warnedAboutWait = false;\n                while (active) {\n                    synchronized (matchedListMutex) {\n                        while (matched.isFull()) {\n                            if (getContext().getStopping().get()) {\n                                LOG.warn(toString() + \": stopped waiting for space in pendingMessage cursor for: \"\n                                        + node.getMessageId());\n                                enqueueCounter.decrementAndGet();\n                                return;\n                            }\n                            if (!warnedAboutWait) {\n                                LOG.info(toString() + \": Pending message cursor [\" + matched\n                                        + \"] is full, temp usage (\"\n                                        + +matched.getSystemUsage().getTempUsage().getPercentUsage()\n                                        + \"%) or memory usage (\"\n                                        + matched.getSystemUsage().getMemoryUsage().getPercentUsage()\n                                        + \"%) limit reached, blocking message add() pending the release of resources.\");\n                                warnedAboutWait = true;\n                            }\n                            matchedListMutex.wait(20);\n                        }\n                        //Temporary storage could be full - so just try to add the message\n                        //see https://issues.apache.org/activemq/browse/AMQ-2475\n                        if (matched.tryAddMessageLast(node, 10)) {\n                            break;\n                        }\n                    }\n                }\n                synchronized (matchedListMutex) {\n                    \n                    // NOTE - be careful about the slaveBroker!\n                    if (maximumPendingMessages > 0) {\n                        // calculate the high water mark from which point we\n                        // will eagerly evict expired messages\n                        int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();\n                        if (maximumPendingMessages > 0 && maximumPendingMessages < max) {\n                            max = maximumPendingMessages;\n                        }\n                        if (!matched.isEmpty() && matched.size() > max) {\n                            removeExpiredMessages();\n                        }\n                        // lets discard old messages as we are a slow consumer\n                        while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {\n                            int pageInSize = matched.size() - maximumPendingMessages;\n                            // only page in a 1000 at a time - else we could\n                            // blow da memory\n                            pageInSize = Math.max(1000, pageInSize);\n                            LinkedList<MessageReference> list = null;\n                            MessageReference[] oldMessages=null;\n                            synchronized(matched){\n                                list = matched.pageInList(pageInSize);\n                            \toldMessages = messageEvictionStrategy.evictMessages(list);\n                            \tfor (MessageReference ref : list) {\n                            \t    ref.decrementReferenceCount();\n                            \t}\n                            }\n                            int messagesToEvict = 0;\n                            if (oldMessages != null){\n\t                            messagesToEvict = oldMessages.length;\n\t                            for (int i = 0; i < messagesToEvict; i++) {\n\t                                MessageReference oldMessage = oldMessages[i];\n\t                                discard(oldMessage);\n\t                            }\n                            }\n                            // lets avoid an infinite loop if we are given a bad\n                            // eviction strategy\n                            // for a bad strategy lets just not evict\n                            if (messagesToEvict == 0) {\n                                LOG.warn(\"No messages to evict returned from eviction strategy: \" + messageEvictionStrategy);\n                                break;\n                            }\n                        }\n                    }\n                }\n                dispatchMatched();\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.TopicSubscription.dispatchMatched": "    private void dispatchMatched() throws IOException {       \n        synchronized (matchedListMutex) {\n            if (!matched.isEmpty() && !isFull()) {\n                try {\n                    matched.reset();\n                   \n                    while (matched.hasNext() && !isFull()) {\n                        MessageReference message = matched.next();\n                        message.decrementReferenceCount();\n                        matched.remove();\n                        // Message may have been sitting in the matched list a\n                        // while\n                        // waiting for the consumer to ak the message.\n                        if (message.isExpired()) {\n                            discard(message);\n                            continue; // just drop it.\n                        }\n                        dispatch(message);\n                    }\n                } finally {\n                    matched.release();\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        Subscription sub = consumerExchange.getSubscription();\n        if (sub == null) {\n            sub = subscriptions.get(ack.getConsumerId());\n            if (sub == null) {\n                if (!consumerExchange.getConnectionContext().isInRecoveryMode()) {\n                    LOG.warn(\"Ack for non existent subscription, ack:\" + ack);\n                    throw new IllegalArgumentException(\"The subscription does not exist: \" + ack.getConsumerId());\n                } else {\n                    LOG.debug(\"Ack for non existent subscription in recovery, ack:\" + ack);\n                    return;\n                }\n            }\n            consumerExchange.setSubscription(sub);\n        }\n        sub.acknowledge(consumerExchange.getConnectionContext(), ack);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        if (consumerExchange.isWildcard() || consumerExchange.getRegion() == null) {\n            ActiveMQDestination destination = ack.getDestination();\n            Region region;\n            switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                region = queueRegion;\n                break;\n            case ActiveMQDestination.TOPIC_TYPE:\n                region = topicRegion;\n                break;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                region = tempQueueRegion;\n                break;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                region = tempTopicRegion;\n                break;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n            }\n            consumerExchange.setRegion(region);\n        }\n        consumerExchange.getRegion().acknowledge(consumerExchange, ack);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.createUnknownDestinationTypeException": "    protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {\n        return new JMSException(\"Unknown destination type: \" + destination.getDestinationType());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFilter.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        next.acknowledge(consumerExchange, ack);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = consumerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        if (ack.isInTransaction()) {\n            transaction = getTransaction(context, ack.getTransactionId(), false);\n        }\n        context.setTransaction(transaction);\n        try {\n            next.acknowledge(consumerExchange, ack);\n        } finally {\n            context.setTransaction(originalTx);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.acknowledge": "    public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {\n        getNext().acknowledge(consumerExchange, ack);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processMessageAck": "    public Response processMessageAck(MessageAck ack) throws Exception {\n        ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(ack.getConsumerId());\n        broker.acknowledge(consumerExchange, ack);\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.getConsumerBrokerExchange": "    private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id) {\n        ConsumerBrokerExchange result = consumerExchanges.get(id);\n        if (result == null) {\n            synchronized (consumerExchanges) {\n                result = new ConsumerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    ConsumerState cs = ss.getConsumerState(id);\n                    if (cs != null) {\n                        ConsumerInfo info = cs.getInfo();\n                        if (info != null) {\n                            if (info.getDestination() != null && info.getDestination().isPattern()) {\n                                result.setWildcard(true);\n                            }\n                        }\n                    }\n                }\n                consumerExchanges.put(id, result);\n            }\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.MessageAck.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessageAck(this);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            response = command.visit(this);\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        return response;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Wait a little bit to try to get the output buffer to flush\n                // the exption notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchAsync(ce);\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        // getStatistics().getEnqueues().increment();\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportFilter.onCommand": "    public void onCommand(Object command) {\n        transportListener.onCommand(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        IOException error = null;\n                        remoteWireFormatInfo = (WireFormatInfo) command;\n                        try {\n                            startMonitorThreads();\n                        } catch (IOException e) {\n                            error = e;\n                        }\n                        if (error != null) {\n                            onException(error);\n                        }\n                    }\n                }\n                synchronized (readChecker) {\n                    transportListener.onCommand(command);\n                }\n            }\n        } finally {\n\n            inReceive.set(false);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // Disable inactivity monitoring while processing a command.\n        //synchronize this method - its not synchronized\n        //further down the transport stack and gets called by more\n        //than one thread  by this class\n        synchronized(inSend) {\n            inSend.set(true);\n            try {\n\n                if( failed.get() ) {\n                    throw new InactivityIOException(\"Channel was inactive for too long: \"+next.getRemoteAddress());\n                }\n                if (o.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        localWireFormatInfo = (WireFormatInfo)o;\n                        startMonitorThreads();\n                    }\n                }\n                next.oneway(o);\n            } finally {\n                commandSent.set(true);\n                inSend.set(false);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            transportListener.onException(error);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.startMonitorThreads": "    private synchronized void startMonitorThreads() throws IOException {\n        if (monitorStarted.get()) {\n            return;\n        }\n\n        if (!configuredOk()) {\n            return;\n        }\n\n        if (readCheckTime > 0) {\n            monitorStarted.set(true);\n            writeCheckerTask = new SchedulerTimerTask(writeChecker);\n            readCheckerTask = new  SchedulerTimerTask(readChecker);\n            writeCheckTime = readCheckTime>3 ? readCheckTime/3 : readCheckTime;\n            synchronized( InactivityMonitor.class ) {\n                if( CHECKER_COUNTER == 0 ) {\n                    READ_CHECK_TIMER = new Timer(\"InactivityMonitor ReadCheck\",true);\n                    WRITE_CHECK_TIMER = new Timer(\"InactivityMonitor WriteCheck\",true);\n                }\n                CHECKER_COUNTER++;\n                WRITE_CHECK_TIMER.scheduleAtFixedRate(writeCheckerTask, initialDelayTime,writeCheckTime);\n                READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, initialDelayTime,readCheckTime);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        try {\n                            socket.close();\n                        } catch (IOException e) {\n                            LOG.debug(\"Caught exception closing socket\",e);\n                        }finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destination.getDestinationStatistics": "    DestinationStatistics getDestinationStatistics();\n\n    DeadLetterStrategy getDeadLetterStrategy();\n\n    Message[] browse();\n\n    String getName();\n\n    MessageStore getMessageStore();\n\n    boolean isProducerFlowControl();\n\n    void setProducerFlowControl(boolean value);\n\n    /**\n     * Set's the interval at which warnings about producers being blocked by\n     * resource usage will be triggered. Values of 0 or less will disable\n     * warnings\n     * \n     * @param blockedProducerWarningInterval the interval at which warning about\n     *            blocked producers will be triggered.\n     */\n    public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval);\n\n    /**\n     * \n     * @return the interval at which warning about blocked producers will be\n     *         triggered.\n     */\n    public long getBlockedProducerWarningInterval();\n\n    int getMaxProducersToAudit();\n\n    void setMaxProducersToAudit(int maxProducersToAudit);\n\n    int getMaxAuditDepth();\n\n    void setMaxAuditDepth(int maxAuditDepth);\n\n    boolean isEnableAudit();\n\n    void setEnableAudit(boolean enableAudit);\n\n    boolean isActive();\n\n    int getMaxPageSize();\n\n    public void setMaxPageSize(int maxPageSize);\n\n    public int getMaxBrowsePageSize();\n\n    public void setMaxBrowsePageSize(int maxPageSize);\n\n    public boolean isUseCache();\n\n    public void setUseCache(boolean useCache);\n\n    public int getMinimumMessageSize();\n\n    public void setMinimumMessageSize(int minimumMessageSize);\n\n    public int getCursorMemoryHighWaterMark();\n\n    public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n\n    /**\n     * optionally called by a Subscriber - to inform the Destination its ready\n     * for more messages\n     */\n    public void wakeup();\n\n    /**\n     * @return true if lazyDispatch is enabled\n     */\n    public boolean isLazyDispatch();\n\n    /**\n     * set the lazy dispatch - default is false\n     * \n     * @param value\n     */\n    public void setLazyDispatch(boolean value);\n\n    /**\n     * Inform the Destination a message has expired\n     * \n     * @param context\n     * @param subs\n     * @param node\n     */\n    void messageExpired(ConnectionContext context, Subscription subs, MessageReference node);\n\n    /**\n     * called when message is consumed\n     * \n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     * \n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory This will\n     * happen only if the policy is enabled - e.g. non durable topics\n     * \n     * @param context\n     * @param messageReference\n     * @param sub \n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     * \n     * @param context\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     * \n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context, ProducerInfo producerInfo);\n\n    /**\n     * Called when a Usage reaches a limit\n     * \n     * @param context\n     * @param usage\n     */\n    void isFull(ConnectionContext context, Usage usage);\n\n    List<Subscription> getConsumers();\n\n    /**\n     * called on Queues in slave mode to allow dispatch to follow subscription\n     * choice of master\n     * \n     * @param messageDispatchNotification\n     * @throws Exception\n     */\n    void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception;\n    \n    boolean isPrioritizedMessages();\n\n    SlowConsumerStrategy getSlowConsumerStrategy();\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConsumerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "Exception when Redelivery ack is processed by topic subscription",
            "Description": "2010-11-12 17:46:24,124 | WARN  | Async error occurred: javax.jms.JMSException: Invalid acknowledgment: MessageAck {commandId = 29455, responseRequired = false, ackType = 3, consumerId =ID:X-2506-1289583778418-0:0:1:1, firstMessageId =ID:X-51821-634249796434830099-1:5:1:3:313195, lastMessageId = ID:X-51821-634249796434830099-1:5:1:3:313195, destination = topic://help.Publish.Instance1, transactionId = null, messageCount = 1} | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: tcp:///Y:2508\njavax.jms.JMSException: Invalid acknowledgment: MessageAck {commandId = 29455, responseRequired = false, ackType = 3, consumerId = ID:X-2506-1289583778418-0:0:1:1, firstMessageId = ID:X09-51821-634249796434830099-1:5:1:3:313195, lastMessageId = ID:X09-51821-634249796434830099-1:5:1:3:313195, destination = topic://help.Publish.Instance1, transactionId = null, messageCount = 1}\n        at org.apache.activemq.broker.region.TopicSubscription.acknowledge(TopicSubscription.java:286)\n        at org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:383)\n        at org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:544)\n        at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n        at org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:200)\n        at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n        at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)\n        at org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:87)\n        at org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:469)\n        at org.apache.activemq.command.MessageAck.visit(MessageAck.java:214)\n        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:311)\n        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:185)\n        at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)\n        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n        at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:228)\n        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:220)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:202)\n        at java.lang.Thread.run(Thread.java:619)\n"
        }
    },
    {
        "filename": "AMQ-3325.json",
        "creation_time": "2011-05-17T08:58:50.000+0000",
        "stack_trace": "java.io.EOFException: Chunk stream does not exist at page: 198\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:454)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:431)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:428)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:404)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:361)\n\tat org.apache.activemq.store.kahadb.plist.PList.loadEntry(PList.java:468)\n\tat org.apache.activemq.store.kahadb.plist.PList.getNext(PList.java:483)\n\tat org.apache.activemq.store.kahadb.plist.PList$10.execute(PList.java:312)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:728)\n\tat org.apache.activemq.store.kahadb.plist.PList.getNext(PList.java:310)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:500)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:473)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.next(FilePendingMessageCursor.java:293)\n\tat org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1714)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1932)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1440)\n\tat org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:104)\n\tat org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:42)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.loadEntry": "    EntryLocation loadEntry(Transaction tx, long pageId) throws IOException {\n        Page<EntryLocation> page = tx.load(pageId, EntryLocationMarshaller.INSTANCE);\n        EntryLocation entry = page.get();\n        if (entry != null) {\n            entry.setPage(page);\n        }\n        return entry;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.get": "    EntryLocation get(Transaction tx, int position) throws IOException {\n        EntryLocation result = null;\n        long nextId = this.rootId;\n        int count = -1;\n        while (nextId != EntryLocation.NOT_SET) {\n            EntryLocation entry = getNext(tx, nextId);\n            if (entry != null) {\n                if (count == position) {\n                    result = entry;\n                    break;\n                }\n                nextId = entry.getNext();\n            } else {\n                break;\n            }\n            count++;\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.load": "    synchronized void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            final Page<EntryLocation> p = tx.load(this.rootId, null);\n            if (p.getType() == Page.PAGE_FREE_TYPE) {\n                // Need to initialize it..\n                EntryLocation root = createEntry(p, \"root\", EntryLocation.NOT_SET, EntryLocation.NOT_SET);\n\n                storeEntry(tx, root);\n                this.lastId = root.getPage().getPageId();\n            } else {\n                // find last id\n                long nextId = this.rootId;\n                while (nextId != EntryLocation.NOT_SET) {\n                    EntryLocation next = getNext(tx, nextId);\n                    if (next != null) {\n                        this.lastId = next.getPage().getPageId();\n                        nextId = next.getNext();\n                        this.size++;\n                    }\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.getNext": "    EntryLocation getNext(Transaction tx, long next) throws IOException {\n        EntryLocation result = null;\n        if (next != EntryLocation.NOT_SET) {\n            result = loadEntry(tx, next);\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.execute": "                public void execute(Transaction tx) throws IOException {\n                    ref.set(loadEntry(tx, entry.getEntry().getPage().getPageId()));\n                }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.PList.getPayload": "    ByteSequence getPayload(EntryLocation entry) throws IOException {\n        return this.store.getPayload(entry.getLocation());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.next": "        public MessageReference next() {\n            this.current = next;\n            try {\n                ByteSequence bs = this.current.getByteSequence();\n                synchronized (this.list) {\n                    this.current = this.list.refresh(this.current);\n                    this.next = this.list.getNext(this.current);\n                }\n                return getMessage(bs);\n            } catch (IOException e) {\n                LOG.error(\"I/O error\", e);\n                throw new RuntimeException(e);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.isDiskListEmpty": "    protected boolean isDiskListEmpty() {\n        return diskList == null || diskList.isEmpty();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getMessage": "    protected Message getMessage(ByteSequence bs) throws IOException {\n        org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(bs.getData(), bs\n                .getOffset(), bs.getLength());\n        return (Message) this.wireFormat.unmarshal(packet);\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getByteSequence": "    protected ByteSequence getByteSequence(Message message) throws IOException {\n        org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);\n        return new ByteSequence(packet.data, packet.offset, packet.length);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doPageInForDispatch": "    private List<QueueMessageReference> doPageInForDispatch(boolean force) throws Exception {\n        List<QueueMessageReference> result = null;\n        List<QueueMessageReference> resultList = null;\n\n        int toPageIn = Math.min(getMaxPageSize(), messages.size());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(destination.getPhysicalName() + \" toPageIn: \" + toPageIn + \", Inflight: \"\n                    + destinationStatistics.getInflight().getCount() + \", pagedInMessages.size \"\n                    + pagedInMessages.size() + \", enqueueCount: \" + destinationStatistics.getEnqueues().getCount()\n                    + \", dequeueCount: \" + destinationStatistics.getDequeues().getCount());\n        }\n\n        if (isLazyDispatch() && !force) {\n            // Only page in the minimum number of messages which can be\n            // dispatched immediately.\n            toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);\n        }\n        int pagedInPendingSize = 0;\n        pagedInPendingDispatchLock.readLock().lock();\n        try {\n            pagedInPendingSize = pagedInPendingDispatch.size();\n        } finally {\n            pagedInPendingDispatchLock.readLock().unlock();\n        }\n        if (toPageIn > 0 && (force || (!consumers.isEmpty() && pagedInPendingSize < getMaxPageSize()))) {\n            int count = 0;\n            result = new ArrayList<QueueMessageReference>(toPageIn);\n            messagesLock.writeLock().lock();\n            try {\n                try {\n                    messages.setMaxBatchSize(toPageIn);\n                    messages.reset();\n                    while (messages.hasNext() && count < toPageIn) {\n                        MessageReference node = messages.next();\n                        messages.remove();\n\n                        QueueMessageReference ref = createMessageReference(node.getMessage());\n                        if (ref.isExpired()) {\n                            if (broker.isExpired(ref)) {\n                                messageExpired(createConnectionContext(), ref);\n                            } else {\n                                ref.decrementReferenceCount();\n                            }\n                        } else {\n                            result.add(ref);\n                            count++;\n                        }\n                    }\n                } finally {\n                    messages.release();\n                }\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n            // Only add new messages, not already pagedIn to avoid multiple\n            // dispatch attempts\n            pagedInMessagesLock.writeLock().lock();\n            try {\n                resultList = new ArrayList<QueueMessageReference>(result.size());\n                for (QueueMessageReference ref : result) {\n                    if (!pagedInMessages.containsKey(ref.getMessageId())) {            \n                        pagedInMessages.put(ref.getMessageId(), ref);\n                        resultList.add(ref);\n                    } else {\n                        ref.decrementReferenceCount();\n                    }\n                }\n            } finally {\n                pagedInMessagesLock.writeLock().unlock();\n            }\n        } else {\n            // Avoid return null list, if condition is not validated\n            resultList = new ArrayList<QueueMessageReference>();\n        }\n\n        return resultList;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.createMessageReference": "    private QueueMessageReference createMessageReference(Message message) {\n        QueueMessageReference result = new IndirectMessageReference(message);\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getMessage": "    public QueueMessageReference getMessage(String id) {\n        MessageId msgId = new MessageId(id);\n        pagedInMessagesLock.readLock().lock();\n        try{\n            QueueMessageReference ref = this.pagedInMessages.get(msgId);\n            if (ref != null) {\n                return ref;\n            }\n        }finally {\n            pagedInMessagesLock.readLock().unlock();\n        }\n        messagesLock.readLock().lock();\n        try{\n            try {\n                messages.reset();\n                while (messages.hasNext()) {\n                    MessageReference mr = messages.next();\n                    QueueMessageReference qmr = createMessageReference(mr.getMessage());\n                    qmr.decrementReferenceCount();\n                    messages.rollback(qmr.getMessageId());\n                    if (msgId.equals(qmr.getMessageId())) {\n                        return qmr;\n                    }\n                }\n            } finally {\n                messages.release();\n            }\n        }finally {\n            messagesLock.readLock().unlock();\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getConsumerMessageCountBeforeFull": "    private int getConsumerMessageCountBeforeFull() throws Exception {\n        int total = 0;\n        boolean zeroPrefetch = false;\n        consumersLock.readLock().lock();\n        try{\n            for (Subscription s : consumers) {\n                zeroPrefetch |= s.getPrefetchSize() == 0;\n                int countBeforeFull = s.countBeforeFull();\n                total += countBeforeFull;\n            }\n        }finally {\n            consumersLock.readLock().unlock();\n        }\n        if (total == 0 && zeroPrefetch) {\n            total = 1;\n        }\n        return total;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.size": "            public int size() {\n                return size;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.createConnectionContext": "    protected ConnectionContext createConnectionContext() {\n        ConnectionContext answer = new ConnectionContext(new NonCachedMessageEvaluationContext());\n        answer.setBroker(this.broker);\n        answer.getMessageEvaluationContext().setDestination(getActiveMQDestination());\n        answer.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);\n        return answer;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message expired: \" + reference);\n        }\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.add": "            public void add(int index, Message element) {\n                size++;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.pageInMessages": "    protected void pageInMessages(boolean force) throws Exception {\n        doDispatch(doPageInForDispatch(force));\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doDispatch": "    private void doDispatch(List<QueueMessageReference> list) throws Exception {\n        boolean doWakeUp = false;\n\n        pagedInPendingDispatchLock.writeLock().lock();\n        try {\n            if (!redeliveredWaitingDispatch.isEmpty()) {\n                // Try first to dispatch redelivered messages to keep an\n                // proper order\n                redeliveredWaitingDispatch = doActualDispatch(redeliveredWaitingDispatch);\n            }\n            if (!pagedInPendingDispatch.isEmpty()) {\n                // Next dispatch anything that had not been\n                // dispatched before.\n                pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);\n            }\n            // and now see if we can dispatch the new stuff.. and append to\n            // the pending\n            // list anything that does not actually get dispatched.\n            if (list != null && !list.isEmpty()) {\n                if (pagedInPendingDispatch.isEmpty()) {\n                    pagedInPendingDispatch.addAll(doActualDispatch(list));\n                } else {\n                    for (QueueMessageReference qmr : list) {\n                        if (!pagedInPendingDispatch.contains(qmr)) {\n                            pagedInPendingDispatch.add(qmr);\n                        }\n                    }\n                    doWakeUp = true;\n                }\n            }\n        } finally {\n            pagedInPendingDispatchLock.writeLock().unlock();\n        }\n\n        if (doWakeUp) {\n            // avoid lock order contention\n            asyncWakeup();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.iterate": "    public boolean iterate() {\n        MDC.put(\"activemq.destination\", getName());\n        boolean pageInMoreMessages = false;\n        synchronized (iteratingMutex) {\n\n            // do early to allow dispatch of these waiting messages\n            synchronized (messagesWaitingForSpace) {\n                Iterator<Runnable> it = messagesWaitingForSpace.values().iterator();\n                while (it.hasNext()) {\n                    if (!memoryUsage.isFull()) {\n                        Runnable op = it.next();\n                        it.remove();\n                        op.run();\n                    } else {\n                        registerCallbackForNotFullNotification();\n                        break;\n                    }\n                }\n            }\n\n            if (firstConsumer) {\n                firstConsumer = false;\n                try {\n                    if (consumersBeforeDispatchStarts > 0) {\n                        int timeout = 1000; // wait one second by default if\n                                            // consumer count isn't reached\n                        if (timeBeforeDispatchStarts > 0) {\n                            timeout = timeBeforeDispatchStarts;\n                        }\n                        if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(consumers.size() + \" consumers subscribed. Starting dispatch.\");\n                            }\n                        } else {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(timeout + \" ms elapsed and \" + consumers.size()\n                                        + \" consumers subscribed. Starting dispatch.\");\n                            }\n                        }\n                    }\n                    if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {\n                        iteratingMutex.wait(timeBeforeDispatchStarts);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(timeBeforeDispatchStarts + \" ms elapsed. Starting dispatch.\");\n                        }\n                    }\n                } catch (Exception e) {\n                    LOG.error(e.toString());\n                }\n            }\n\n            BrowserDispatch pendingBrowserDispatch = getNextBrowserDispatch();\n\n            messagesLock.readLock().lock();\n            try{\n                pageInMoreMessages |= !messages.isEmpty();\n            }finally {\n                messagesLock.readLock().unlock();\n            }\n\n            pagedInPendingDispatchLock.readLock().lock();\n            try {\n                pageInMoreMessages |= !pagedInPendingDispatch.isEmpty();\n            }finally {\n                pagedInPendingDispatchLock.readLock().unlock();\n            }\n\n            // Perhaps we should page always into the pagedInPendingDispatch\n            // list if\n            // !messages.isEmpty(), and then if\n            // !pagedInPendingDispatch.isEmpty()\n            // then we do a dispatch.\n            if (pageInMoreMessages || pendingBrowserDispatch != null || !redeliveredWaitingDispatch.isEmpty()) {\n                try {\n                    pageInMessages(pendingBrowserDispatch != null);\n\n                } catch (Throwable e) {\n                    LOG.error(\"Failed to page in more queue messages \", e);\n                }\n            }\n\n            if (pendingBrowserDispatch != null) {\n                ArrayList<QueueMessageReference> alreadyDispatchedMessages = null;\n                pagedInMessagesLock.readLock().lock();\n                try{\n                    alreadyDispatchedMessages = new ArrayList<QueueMessageReference>(pagedInMessages.values());\n                }finally {\n                    pagedInMessagesLock.readLock().unlock();\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"dispatch to browser: \" + pendingBrowserDispatch.getBrowser()\n                            + \", already dispatched/paged count: \" + alreadyDispatchedMessages.size());\n                }\n                do {\n                    try {\n                        MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();\n                        msgContext.setDestination(destination);\n\n                        QueueBrowserSubscription browser = pendingBrowserDispatch.getBrowser();\n                        for (QueueMessageReference node : alreadyDispatchedMessages) {\n                            if (!node.isAcked()) {\n                                msgContext.setMessageReference(node);\n                                if (browser.matches(node, msgContext)) {\n                                    browser.add(node);\n                                }\n                            }\n                        }\n                        pendingBrowserDispatch.done();\n                    } catch (Exception e) {\n                        LOG.warn(\"exception on dispatch to browser: \" + pendingBrowserDispatch.getBrowser(), e);\n                    }\n\n                } while ((pendingBrowserDispatch = getNextBrowserDispatch()) != null);\n            }\n\n            if (pendingWakeups.get() > 0) {\n                pendingWakeups.decrementAndGet();\n            }\n            MDC.remove(\"activemq.destination\");\n            return pendingWakeups.get() > 0;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getBrowser": "        public QueueBrowserSubscription getBrowser() {\n            return browser;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.get": "            public Message get(int index) {\n                return null;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.toString": "            public String toString() {\n                return \"MessageIdFilter: \" + messageId;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getNextBrowserDispatch": "    BrowserDispatch getNextBrowserDispatch() {\n        pagedInMessagesLock.readLock().lock();\n        try{\n            if (browserDispatches.isEmpty()) {\n                return null;\n            }\n            return browserDispatches.removeFirst();\n        }finally {\n            pagedInMessagesLock.readLock().unlock();\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.done": "        void done() {\n            try {\n                browser.decrementQueueRef();\n            } catch (Exception e) {\n                LOG.warn(\"decrement ref on browser: \" + browser, e);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.run": "                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message, null);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of :\" + message, e);\n                                    }\n                                }\n                            }",
            "activemq-core.src.main.java.org.apache.activemq.thread.DedicatedTaskRunner.runTask": "    final void runTask() {\n\n        try {\n            while (true) {\n\n                synchronized (mutex) {\n                    pending = false;\n                    if (shutdown) {\n                        return;\n                    }\n                }\n\n                if (!task.iterate()) {\n                    // wait to be notified.\n                    synchronized (mutex) {\n                        if (shutdown) {\n                            return;\n                        }\n                        while (!pending) {\n                            mutex.wait();\n                        }\n                    }\n                }\n\n            }\n\n        } catch (InterruptedException e) {\n            // Someone really wants this thread to die off.\n            Thread.currentThread().interrupt();\n        } finally {\n            // Make sure we notify any waiting threads that thread\n            // has terminated.\n            synchronized (mutex) {\n                threadTerminated = true;\n                mutex.notifyAll();\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.DedicatedTaskRunner.run": "            public void run() {\n                runTask();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.plist.EntryLocation.setPage": "    void setPage(Page<EntryLocation> page) {\n        this.page = page;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getEnqueues": "    public CountStatisticImpl getEnqueues() {\n        return enqueues;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getInflight": "    public CountStatisticImpl getInflight() {\n        return inflight;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getDequeues": "    public CountStatisticImpl getDequeues() {\n        return dequeues;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.QueueBrowserSubscription.matches": "    public boolean matches(MessageReference node, MessageEvaluationContext context) throws IOException {\n        return !browseDone && super.matches(node, context);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.task.iterate": "    boolean iterate();\n}"
        },
        "bug_report": {
            "Title": "PList temp store,  chunk stream does not exist when broker under stress",
            "Description": "apparent concurrency issue, multicore (8 cpu) under load, sporadic occurrence, related to memory limits and dynamic destination creation/deletion. Broker stack trace:\n{code}2011-04-07 08:04:07,295 [Queue:loadq-4  ] ERROR FilePendingMessageCursor       - I/O error\njava.io.EOFException: Chunk stream does not exist at page: 198\n\tat org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:454)\n\tat org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:431)\n\tat org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:428)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:404)\n\tat org.apache.kahadb.page.Transaction.load(Transaction.java:361)\n\tat org.apache.activemq.store.kahadb.plist.PList.loadEntry(PList.java:468)\n\tat org.apache.activemq.store.kahadb.plist.PList.getNext(PList.java:483)\n\tat org.apache.activemq.store.kahadb.plist.PList$10.execute(PList.java:312)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:728)\n\tat org.apache.activemq.store.kahadb.plist.PList.getNext(PList.java:310)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:500)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:473)\n\tat org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.next(FilePendingMessageCursor.java:293)\n\tat org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1714)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1932)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1440)\n\tat org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:104)\n\tat org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:42){code}"
        }
    },
    {
        "filename": "AMQ-2963.json",
        "creation_time": "2010-10-07T06:52:51.000+0000",
        "stack_trace": "com.ibm.msg.client.jms.DetailedInvalidDestinationException: JMSCMQ0005: The destination name '://IBM.TO.ACTIVEMQ' was not valid. The destination name specified does not conform to published destination syntax. Correct the specified destination name and try again.\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n        at com.ibm.msg.client.commonservices.j2se.NLSServices.createException(NLSServices.java:313)\n        at com.ibm.msg.client.commonservices.nls.NLSServices.createException(NLSServices.java:388)\n        at com.ibm.msg.client.wmq.common.internal.WMQDestinationURIParser.setUri(WMQDestinationURIParser.java:524)\n        at com.ibm.msg.client.wmq.common.internal.WMQDestination.<init>(WMQDestination.java:3148)\n        at com.ibm.msg.client.wmq.common.internal.WMQDestination.<init>(WMQDestination.java:3104)\n        at com.ibm.msg.client.wmq.factories.WMQFactoryFactory.createProviderDestination(WMQFactoryFactory.java:444)\n        at com.ibm.msg.client.jms.admin.JmsDestinationImpl.setProviderDestination(JmsDestinationImpl.java:333)\n        at com.ibm.msg.client.jms.admin.JmsDestinationImpl.initialise(JmsDestinationImpl.java:231)\n        at com.ibm.msg.client.jms.admin.JmsDestinationImpl.<init>(JmsDestinationImpl.java:196)\n        at com.ibm.msg.client.jms.admin.JmsJndiDestinationImpl.<init>(JmsJndiDestinationImpl.java:129)\n        at com.ibm.mq.jms.MQDestination.<init>(MQDestination.java:186)\n        at com.ibm.msg.client.wmq.factories.admin.WMQJmsFactory.createDestination(WMQJmsFactory.java:125)\n        at com.ibm.msg.client.jms.internal.JmsMessageImpl.providerDestToJmsDest(JmsMessageImpl.java:2111)\n        at com.ibm.msg.client.jms.internal.JmsMessageImpl.getJMSDestination(JmsMessageImpl.java:686)\n        at com.ibm.jms.JMSMessage.getJMSDestination(JMSMessage.java:605)\n        at org.apache.activemq.ActiveMQMessageTransformation.copyProperties(ActiveMQMessageTransformation.java:206)\n        at org.apache.activemq.ActiveMQMessageTransformation.transformMessage(ActiveMQMessageTransformation.java:188)\n        at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1720)\n        at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:231)\n        at org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:300)\n        at org.apache.activemq.ActiveMQQueueSender.send(ActiveMQQueueSender.java:111)\n        at org.apache.activemq.network.jms.QueueBridge.sendMessage(QueueBridge.java:80)\n        at org.apache.activemq.network.jms.DestinationBridge.onMessage(DestinationBridge.java:129)\n        at com.ibm.mq.jms.MQMessageConsumer$FacadeMessageListener.onMessage(MQMessageConsumer.java:399)\n        at com.ibm.msg.client.jms.internal.JmsMessageConsumerImpl$JmsProviderMessageListener.onMessage(JmsMessageConsumerImpl.java:904)\n        at com.ibm.msg.client.wmq.internal.WMQAsyncConsumerShadow.honourNoLocal(WMQAsyncConsumerShadow.java:550)\n        at com.ibm.msg.client.wmq.internal.WMQAsyncConsumerShadow.consumer(WMQAsyncConsumerShadow.java:384)\n        at com.ibm.mq.jmqi.remote.internal.RemoteAsyncConsume.driveConsumer(RemoteAsyncConsume.java:1478)\n        at com.ibm.mq.jmqi.remote.internal.RemoteDispatchThread.run(RemoteDispatchThread.java:385)\n        at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.runTask(WorkQueueItem.java:209)\n        at com.ibm.msg.client.commonservices.workqueue.SimpleWorkQueueItem.runItem(SimpleWorkQueueItem.java:100)\n        at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.run(WorkQueueItem.java:224)\n        at com.ibm.msg.client.commonservices.workqueue.WorkQueueManager.runWorkQueueItem(WorkQueueManager.java:298)\n        at com.ibm.msg.client.commonservices.j2se.workqueue.WorkQueueManagerImplementation$ThreadPoolWorker.run(WorkQueueManagerImplementation.java:1220)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageTransformation.copyProperties": "    public static void copyProperties(Message fromMessage, Message toMessage) throws JMSException {\n        toMessage.setJMSMessageID(fromMessage.getJMSMessageID());\n        toMessage.setJMSCorrelationID(fromMessage.getJMSCorrelationID());\n        toMessage.setJMSReplyTo(transformDestination(fromMessage.getJMSReplyTo()));\n        toMessage.setJMSDestination(transformDestination(fromMessage.getJMSDestination()));\n        toMessage.setJMSDeliveryMode(fromMessage.getJMSDeliveryMode());\n        toMessage.setJMSRedelivered(fromMessage.getJMSRedelivered());\n        toMessage.setJMSType(fromMessage.getJMSType());\n        toMessage.setJMSExpiration(fromMessage.getJMSExpiration());\n        toMessage.setJMSPriority(fromMessage.getJMSPriority());\n        toMessage.setJMSTimestamp(fromMessage.getJMSTimestamp());\n\n        Enumeration propertyNames = fromMessage.getPropertyNames();\n\n        while (propertyNames.hasMoreElements()) {\n            String name = propertyNames.nextElement().toString();\n            Object obj = fromMessage.getObjectProperty(name);\n            toMessage.setObjectProperty(name, obj);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageTransformation.transformDestination": "    public static ActiveMQDestination transformDestination(Destination destination) throws JMSException {\n        ActiveMQDestination activeMQDestination = null;\n\n        if (destination != null) {\n            if (destination instanceof ActiveMQDestination) {\n                return (ActiveMQDestination)destination;\n\n            } else {\n                if (destination instanceof TemporaryQueue) {\n                    activeMQDestination = new ActiveMQTempQueue(((Queue)destination).getQueueName());\n                } else if (destination instanceof TemporaryTopic) {\n                    activeMQDestination = new ActiveMQTempTopic(((Topic)destination).getTopicName());\n                } else if (destination instanceof Queue) {\n                    activeMQDestination = new ActiveMQQueue(((Queue)destination).getQueueName());\n                } else if (destination instanceof Topic) {\n                    activeMQDestination = new ActiveMQTopic(((Topic)destination).getTopicName());\n                }\n            }\n        }\n\n        return activeMQDestination;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageTransformation.transformMessage": "    public static ActiveMQMessage transformMessage(Message message, ActiveMQConnection connection)\n        throws JMSException {\n        if (message instanceof ActiveMQMessage) {\n            return (ActiveMQMessage)message;\n\n        } else {\n            ActiveMQMessage activeMessage = null;\n\n            if (message instanceof BytesMessage) {\n                BytesMessage bytesMsg = (BytesMessage)message;\n                bytesMsg.reset();\n                ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n                msg.setConnection(connection);\n                try {\n                    for (;;) {\n                        // Reads a byte from the message stream until the stream\n                        // is empty\n                        msg.writeByte(bytesMsg.readByte());\n                    }\n                } catch (MessageEOFException e) {\n                    // if an end of message stream as expected\n                } catch (JMSException e) {\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof MapMessage) {\n                MapMessage mapMsg = (MapMessage)message;\n                ActiveMQMapMessage msg = new ActiveMQMapMessage();\n                msg.setConnection(connection);\n                Enumeration iter = mapMsg.getMapNames();\n\n                while (iter.hasMoreElements()) {\n                    String name = iter.nextElement().toString();\n                    msg.setObject(name, mapMsg.getObject(name));\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof ObjectMessage) {\n                ObjectMessage objMsg = (ObjectMessage)message;\n                ActiveMQObjectMessage msg = new ActiveMQObjectMessage();\n                msg.setConnection(connection);\n                msg.setObject(objMsg.getObject());\n                msg.storeContent();\n                activeMessage = msg;\n            } else if (message instanceof StreamMessage) {\n                StreamMessage streamMessage = (StreamMessage)message;\n                streamMessage.reset();\n                ActiveMQStreamMessage msg = new ActiveMQStreamMessage();\n                msg.setConnection(connection);\n                Object obj = null;\n\n                try {\n                    while ((obj = streamMessage.readObject()) != null) {\n                        msg.writeObject(obj);\n                    }\n                } catch (MessageEOFException e) {\n                    // if an end of message stream as expected\n                } catch (JMSException e) {\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof TextMessage) {\n                TextMessage textMsg = (TextMessage)message;\n                ActiveMQTextMessage msg = new ActiveMQTextMessage();\n                msg.setConnection(connection);\n                msg.setText(textMsg.getText());\n                activeMessage = msg;\n            } else if (message instanceof BlobMessage) {\n            \tBlobMessage blobMessage = (BlobMessage)message;\n            \tActiveMQBlobMessage msg = new ActiveMQBlobMessage();\n            \tmsg.setConnection(connection);\n            \tmsg.setBlobDownloader(new BlobDownloader(connection.getBlobTransferPolicy()));\n            \ttry {\n\t\t\t\t\tmsg.setURL(blobMessage.getURL());\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\n\t\t\t\t}\n            \tactiveMessage = msg;\n            } else {\n                activeMessage = new ActiveMQMessage();\n                activeMessage.setConnection(connection);\n            }\n\n            copyProperties(message, activeMessage);\n\n            return activeMessage;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.send": "    protected void send(ActiveMQMessageProducer producer, ActiveMQDestination destination, Message message, int deliveryMode, int priority, long timeToLive,\n                        MemoryUsage producerWindow, int sendTimeout) throws JMSException {\n\n        checkClosed();\n        if (destination.isTemporary() && connection.isDeleted(destination)) {\n            throw new InvalidDestinationException(\"Cannot publish to a deleted Destination: \" + destination);\n        }\n        synchronized (sendMutex) {\n            // tell the Broker we are about to start a new transaction\n            doStartTransaction();\n            TransactionId txid = transactionContext.getTransactionId();\n            long sequenceNumber = producer.getMessageSequence();\n\n            //Set the \"JMS\" header fields on the orriginal message, see 1.1 spec section 3.4.11\n            message.setJMSDestination(destination);\n            message.setJMSDeliveryMode(deliveryMode);\n            long expiration = 0L;\n            if (!producer.getDisableMessageTimestamp()) {\n                long timeStamp = System.currentTimeMillis();\n                message.setJMSTimestamp(timeStamp);\n                if (timeToLive > 0) {\n                    expiration = timeToLive + timeStamp;\n                }\n            }\n            message.setJMSExpiration(expiration);\n            message.setJMSPriority(priority);\n            message.setJMSRedelivered(false);\n\n            // transform to our own message format here\n            ActiveMQMessage msg = ActiveMQMessageTransformation.transformMessage(message, connection);\n\n            // Set the message id.\n            if (msg == message) {\n                msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));\n            } else {\n                msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));\n                message.setJMSMessageID(msg.getMessageId().toString());\n            }\n            //clear the brokerPath in case we are re-sending this message\n            msg.setBrokerPath(null);\n\n\n            msg.setTransactionId(txid);\n            if (connection.isCopyMessageOnSend()) {\n                msg = (ActiveMQMessage)msg.copy();\n            }\n            msg.setConnection(connection);\n            msg.onSend();\n            msg.setProducerId(msg.getMessageId().getProducerId());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(getSessionId() + \" sending message: \" + msg);\n            }\n            if (sendTimeout <= 0 && !msg.isResponseRequired() && !connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {\n                this.connection.asyncSendPacket(msg);\n                if (producerWindow != null) {\n                    // Since we defer lots of the marshaling till we hit the\n                    // wire, this might not\n                    // provide and accurate size. We may change over to doing\n                    // more aggressive marshaling,\n                    // to get more accurate sizes.. this is more important once\n                    // users start using producer window\n                    // flow control.\n                    int size = msg.getSize();\n                    producerWindow.increaseUsage(size);\n                }\n            } else {\n                if (sendTimeout > 0) {\n                    this.connection.syncSendPacket(msg,sendTimeout);\n                }else {\n                    this.connection.syncSendPacket(msg);\n                }\n            }\n\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.toString": "    public String toString() {\n        return \"ActiveMQSession {id=\" + info.getSessionId() + \",started=\" + started.get() + \"}\";\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.checkClosed": "    protected void checkClosed() throws IllegalStateException {\n        if (closed) {\n            throw new IllegalStateException(\"The Session is closed\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.getSessionId": "    protected SessionId getSessionId() {\n        return info.getSessionId();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.syncSendPacket": "    public Response syncSendPacket(Command command) throws JMSException {\n        return connection.syncSendPacket(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.asyncSendPacket": "    public void asyncSendPacket(Command command) throws JMSException {\n        connection.asyncSendPacket(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.doStartTransaction": "    protected void doStartTransaction() throws JMSException {\n        if (getTransacted() && !transactionContext.isInXATransaction()) {\n            transactionContext.begin();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageProducer.send": "    public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {\n        checkClosed();\n        if (destination == null) {\n            if (info.getDestination() == null) {\n                throw new UnsupportedOperationException(\"A destination must be specified.\");\n            }\n            throw new InvalidDestinationException(\"Don't understand null destinations\");\n        }\n\n        ActiveMQDestination dest;\n        if (destination == info.getDestination()) {\n            dest = (ActiveMQDestination)destination;\n        } else if (info.getDestination() == null) {\n            dest = ActiveMQDestination.transform(destination);\n        } else {\n            throw new UnsupportedOperationException(\"This producer can only send messages to: \" + this.info.getDestination().getPhysicalName());\n        }\n        if (dest == null) {\n            throw new JMSException(\"No destination specified\");\n        }\n\n        if (transformer != null) {\n            Message transformedMessage = transformer.producerTransform(session, this, message);\n            if (transformedMessage != null) {\n                message = transformedMessage;\n            }\n        }\n\n        if (producerWindow != null) {\n            try {\n                producerWindow.waitForSpace();\n            } catch (InterruptedException e) {\n                throw new JMSException(\"Send aborted due to thread interrupt.\");\n            }\n        }\n\n        this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow,sendTimeout);\n\n        stats.onMessage();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageProducer.checkClosed": "    protected void checkClosed() throws IllegalStateException {\n        if (closed) {\n            throw new IllegalStateException(\"The producer is closed\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageProducer.getDestination": "    public Destination getDestination() throws JMSException {\n        checkClosed();\n        return this.info.getDestination();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageProducerSupport.send": "    public void send(Destination destination, Message message) throws JMSException {\n        this.send(destination,\n                  message,\n                  this.defaultDeliveryMode,\n                  this.defaultPriority,\n                  this.defaultTimeToLive);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQQueueSender.send": "    public void send(Queue queue, Message message, int deliveryMode, int priority, long timeToLive)\n        throws JMSException {\n        super.send(queue, message, deliveryMode, priority, timeToLive);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.QueueBridge.sendMessage": "    protected synchronized void sendMessage(Message message) throws JMSException {\n        if (producer == null) {\n            createProducer();\n        }\n        producer.send(producerQueue, message);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.QueueBridge.createProducer": "    protected synchronized MessageProducer createProducer() throws JMSException {\n        producerSession = producerConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);\n        producer = producerSession.createSender(null);\n        return producer;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.DestinationBridge.onMessage": "    public void onMessage(Message message) {\n        int attempt = 0;\n        while (started.get() && message != null) {\n           \n            try {\n                if (attempt > 0) {\n                    restartProducer();\n                }\n                Message converted;\n                if (doHandleReplyTo) {\n                    Destination replyTo = message.getJMSReplyTo();\n                    if (replyTo != null) {\n                        converted = jmsMessageConvertor.convert(message, processReplyToDestination(replyTo));\n                    } else {\n                        converted = jmsMessageConvertor.convert(message);\n                    }\n                } else {\n                    message.setJMSReplyTo(null);\n                    converted = jmsMessageConvertor.convert(message);\n                }\n                sendMessage(converted);\n                message.acknowledge();\n                return;\n            } catch (Exception e) {\n                LOG.error(\"failed to forward message on attempt: \" + (++attempt) + \" reason: \" + e + \" message: \" + message, e);\n                if (maximumRetries > 0 && attempt >= maximumRetries) {\n                    try {\n                        stop();\n                    } catch (Exception e1) {\n                        LOG.warn(\"Failed to stop cleanly\", e1);\n                    }\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.DestinationBridge.processReplyToDestination": "    protected Destination processReplyToDestination(Destination destination) {\n        return jmsConnector.createReplyToBridge(destination, getConnnectionForConsumer(), getConnectionForProducer());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.DestinationBridge.stop": "    public void stop() throws Exception {\n        started.set(false);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.DestinationBridge.sendMessage": "    protected abstract void sendMessage(Message message) throws JMSException;\n\n    protected abstract Connection getConnnectionForConsumer();\n\n    protected abstract Connection getConnectionForProducer();\n\n    protected void restartProducer() throws JMSException, NamingException {\n        try {\n            //don't reconnect immediately\n            Thread.sleep(1000);\n            getConnectionForProducer().close();\n        } catch (Exception e) {\n            LOG.debug(\"Ignoring failure to close producer connection: \" + e, e);\n        }\n        jmsConnector.restartProducerConnection();\n        createProducer();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.network.jms.DestinationBridge.restartProducer": "    protected void restartProducer() throws JMSException, NamingException {\n        try {\n            //don't reconnect immediately\n            Thread.sleep(1000);\n            getConnectionForProducer().close();\n        } catch (Exception e) {\n            LOG.debug(\"Ignoring failure to close producer connection: \" + e, e);\n        }\n        jmsConnector.restartProducerConnection();\n        createProducer();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.BlobMessage.getURL": "    URL getURL() throws MalformedURLException, JMSException;\n\n\n    /**\n     * The MIME type of the BLOB which can be used to apply different content types to messages.\n     */\n    String getMimeType();\n\n    /**\n     * Sets the MIME type of the BLOB so that a consumer can process things nicely with a Java Activation Framework\n     * DataHandler\n     */\n    void setMimeType(String mimeType);\n\n\n    String getName();\n\n    /**\n     * The name of the attachment which can be useful information if transmitting files over ActiveMQ\n     */\n    void setName(String name);\n}",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageProducer.getMessageSequence": "    protected long getMessageSequence() {\n        return messageSequence.incrementAndGet();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transactionContext.getTransactionId": "    public TransactionId getTransactionId() {\n        return transactionId;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQMessageProducer.getProducerInfo": "    protected ProducerInfo getProducerInfo() {\n        return this.info != null ? this.info : null;\n    }"
        },
        "bug_report": {
            "Title": "JMSBridgeConnectors does not work with IBM MQ and ActiveMQ 5.4.0",
            "Description": "We are trying to create a bridge with IBM Websphere Queue and ActiveMQ queue. We have defined a broker in activemq.xml with following jmsBridgeConnectors information:\n\n<jmsBridgeConnectors>\n    <jmsQueueConnector\n      outboundQueueConnectionFactory=\"#remoteFactory\">\n      <inboundQueueBridges>\n        <inboundQueueBridge inboundQueueName=\"IBM.TO.ACTIVEMQ\" localQueueName=\"IBM.TO.ACTIVEMQ\"/>\n      </inboundQueueBridges>\n   </jmsQueueConnector>\n</jmsBridgeConnectors>\n\nWe are getting below error with activemq 5.4.0 and it works fine with version 5.2.0:\n\ncom.ibm.msg.client.jms.DetailedInvalidDestinationException: JMSCMQ0005: The destination name '://IBM.TO.ACTIVEMQ' was not valid. The destination name specified does not conform to published destination syntax. Correct the specified destination name and try again.\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n        at com.ibm.msg.client.commonservices.j2se.NLSServices.createException(NLSServices.java:313)\n        at com.ibm.msg.client.commonservices.nls.NLSServices.createException(NLSServices.java:388)\n        at com.ibm.msg.client.wmq.common.internal.WMQDestinationURIParser.setUri(WMQDestinationURIParser.java:524)\n        at com.ibm.msg.client.wmq.common.internal.WMQDestination.<init>(WMQDestination.java:3148)\n        at com.ibm.msg.client.wmq.common.internal.WMQDestination.<init>(WMQDestination.java:3104)\n        at com.ibm.msg.client.wmq.factories.WMQFactoryFactory.createProviderDestination(WMQFactoryFactory.java:444)\n        at com.ibm.msg.client.jms.admin.JmsDestinationImpl.setProviderDestination(JmsDestinationImpl.java:333)\n        at com.ibm.msg.client.jms.admin.JmsDestinationImpl.initialise(JmsDestinationImpl.java:231)\n        at com.ibm.msg.client.jms.admin.JmsDestinationImpl.<init>(JmsDestinationImpl.java:196)\n        at com.ibm.msg.client.jms.admin.JmsJndiDestinationImpl.<init>(JmsJndiDestinationImpl.java:129)\n        at com.ibm.mq.jms.MQDestination.<init>(MQDestination.java:186)\n        at com.ibm.msg.client.wmq.factories.admin.WMQJmsFactory.createDestination(WMQJmsFactory.java:125)\n        at com.ibm.msg.client.jms.internal.JmsMessageImpl.providerDestToJmsDest(JmsMessageImpl.java:2111)\n        at com.ibm.msg.client.jms.internal.JmsMessageImpl.getJMSDestination(JmsMessageImpl.java:686)\n        at com.ibm.jms.JMSMessage.getJMSDestination(JMSMessage.java:605)\n        at org.apache.activemq.ActiveMQMessageTransformation.copyProperties(ActiveMQMessageTransformation.java:206)\n        at org.apache.activemq.ActiveMQMessageTransformation.transformMessage(ActiveMQMessageTransformation.java:188)\n        at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1720)\n        at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:231)\n        at org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:300)\n        at org.apache.activemq.ActiveMQQueueSender.send(ActiveMQQueueSender.java:111)\n        at org.apache.activemq.network.jms.QueueBridge.sendMessage(QueueBridge.java:80)\n        at org.apache.activemq.network.jms.DestinationBridge.onMessage(DestinationBridge.java:129)\n        at com.ibm.mq.jms.MQMessageConsumer$FacadeMessageListener.onMessage(MQMessageConsumer.java:399)\n        at com.ibm.msg.client.jms.internal.JmsMessageConsumerImpl$JmsProviderMessageListener.onMessage(JmsMessageConsumerImpl.java:904)\n        at com.ibm.msg.client.wmq.internal.WMQAsyncConsumerShadow.honourNoLocal(WMQAsyncConsumerShadow.java:550)\n        at com.ibm.msg.client.wmq.internal.WMQAsyncConsumerShadow.consumer(WMQAsyncConsumerShadow.java:384)\n        at com.ibm.mq.jmqi.remote.internal.RemoteAsyncConsume.driveConsumer(RemoteAsyncConsume.java:1478)\n        at com.ibm.mq.jmqi.remote.internal.RemoteDispatchThread.run(RemoteDispatchThread.java:385)\n        at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.runTask(WorkQueueItem.java:209)\n        at com.ibm.msg.client.commonservices.workqueue.SimpleWorkQueueItem.runItem(SimpleWorkQueueItem.java:100)\n        at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.run(WorkQueueItem.java:224)\n        at com.ibm.msg.client.commonservices.workqueue.WorkQueueManager.runWorkQueueItem(WorkQueueManager.java:298)\n        at com.ibm.msg.client.commonservices.j2se.workqueue.WorkQueueManagerImplementation$ThreadPoolWorker.run(WorkQueueManagerImplementation.java:1220)\n\nI looked at the code for class ActiveMQsession has a method send which was modified after v 5.2.0 and below lines of code were moved before transforming the IBM JMS Message to Active MQ message:\n            message.setJMSDestination(destination);\n            message.setJMSDeliveryMode(deliveryMode);\n            long expiration = 0L;\n            if (!producer.getDisableMessageTimestamp()) {\n                long timeStamp = System.currentTimeMillis();\n                message.setJMSTimestamp(timeStamp);\n                if (timeToLive > 0) {\n                    expiration = timeToLive + timeStamp;\n                }\n            }\n            message.setJMSExpiration(expiration);\n            message.setJMSPriority(priority);\n            message.setJMSRedelivered(false);\n\nNow code sets the ActiveMQDestination as the JMS destination to IBM Message before transformation and we are getting above error when JMS properties are getting copied from IBM Message to ActiveMQMessage inside ActiveMQMessageTransformation."
        }
    },
    {
        "filename": "AMQ-3903.json",
        "creation_time": "2012-06-28T14:09:35.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.activemq.advisory.AdvisorySupport.getFastProducerAdvisoryTopic(AdvisorySupport.java:195)\n\tat org.apache.activemq.advisory.AdvisoryBroker.fastProducer(AdvisoryBroker.java:352)\n\tat org.apache.activemq.broker.BrokerFilter.fastProducer(BrokerFilter.java:275)\n\tat org.apache.activemq.broker.BrokerFilter.fastProducer(BrokerFilter.java:275)\n\tat org.apache.activemq.broker.MutableBrokerFilter.fastProducer(MutableBrokerFilter.java:286)\n\tat org.apache.activemq.broker.region.BaseDestination.fastProducer(BaseDestination.java:512)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:605)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:407)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:503)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:305)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.scheduler.SchedulerBroker.send(SchedulerBroker.java:189)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:453)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)\n\tat org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:231)\n\tat org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)\n\tat org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getFastProducerAdvisoryTopic": "    public static ActiveMQTopic getFastProducerAdvisoryTopic(ActiveMQDestination destination) {\n        String name = FAST_PRODUCER_TOPIC_PREFIX + destination.getDestinationTypeAsString() + \".\"\n                + destination.getPhysicalName();\n        return new ActiveMQTopic(name);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fastProducer": "    public void fastProducer(ConnectionContext context,ProducerInfo producerInfo) {\n        super.fastProducer(context, producerInfo);\n        try {\n            if (!AdvisorySupport.isAdvisoryTopic(producerInfo.getDestination())) {\n                ActiveMQTopic topic = AdvisorySupport.getFastProducerAdvisoryTopic(producerInfo.getDestination());\n                ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n                advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_PRODUCER_ID, producerInfo.getProducerId().toString());\n                fireAdvisory(context, topic, producerInfo, null, advisoryMessage);\n            }\n        } catch (Exception e) {\n            handleFireFailure(\"fast producer\", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory": "    protected void fireAdvisory(ConnectionContext context, ActiveMQTopic topic, Command command, ConsumerId targetConsumerId, ActiveMQMessage advisoryMessage) throws Exception {\n        if (getBrokerService().isStarted()) {\n            //set properties\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_NAME, getBrokerName());\n            String id = getBrokerId() != null ? getBrokerId().getValue() : \"NOT_SET\";\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_ID, id);\n\n            String url = getBrokerService().getVmConnectorURI().toString();\n            if (getBrokerService().getDefaultSocketURIString() != null) {\n                url = getBrokerService().getDefaultSocketURIString();\n            }\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_URL, url);\n\n            //set the data structure\n            advisoryMessage.setDataStructure(command);\n            advisoryMessage.setPersistent(false);\n            advisoryMessage.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);\n            advisoryMessage.setMessageId(new MessageId(advisoryProducerId, messageIdGenerator.getNextSequenceId()));\n            advisoryMessage.setTargetConsumerId(targetConsumerId);\n            advisoryMessage.setDestination(topic);\n            advisoryMessage.setResponseRequired(false);\n            advisoryMessage.setProducerId(advisoryProducerId);\n            boolean originalFlowControl = context.isProducerFlowControl();\n            final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setConnectionContext(context);\n            producerExchange.setMutable(true);\n            producerExchange.setProducerState(new ProducerState(new ProducerInfo()));\n            try {\n                context.setProducerFlowControl(false);\n                next.send(producerExchange, advisoryMessage);\n            } finally {\n                context.setProducerFlowControl(originalFlowControl);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.handleFireFailure": "    private void handleFireFailure(String message, Throwable cause) {\n        LOG.warn(\"Failed to fire \"  + message + \" advisory, reason: \" + cause);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(message + \" detail\", cause);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFilter.fastProducer": "    public void fastProducer(ConnectionContext context,ProducerInfo producerInfo) {\n        next.fastProducer(context, producerInfo);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.fastProducer": "    public void fastProducer(ConnectionContext context,ProducerInfo producerInfo) {\n        getNext().fastProducer(context, producerInfo);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.BaseDestination.fastProducer": "    public void fastProducer(ConnectionContext context, ProducerInfo producerInfo) {\n        if (advisdoryForFastProducers) {\n            broker.fastProducer(context, producerInfo);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.send": "    public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        // There is delay between the client sending it and it arriving at the\n        // destination.. it may have expired.\n        message.setRegionDestination(this);\n        ProducerState state = producerExchange.getProducerState();\n        if (state == null) {\n            LOG.warn(\"Send failed for: \" + message + \",  missing producer state for: \" + producerExchange);\n            throw new JMSException(\"Cannot send message to \" + getActiveMQDestination() + \" with invalid (null) producer state\");\n        }\n        final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();\n        final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0\n                && !context.isInRecoveryMode();\n        if (message.isExpired()) {\n            // message not stored - or added to stats yet - so chuck here\n            broker.getRoot().messageExpired(context, message, null);\n            if (sendProducerAck) {\n                ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n                context.getConnection().dispatchAsync(ack);\n            }\n            return;\n        }\n        if (memoryUsage.isFull()) {\n            isFull(context, memoryUsage);\n            fastProducer(context, producerInfo);\n            if (isProducerFlowControl() && context.isProducerFlowControl()) {\n                if (warnOnProducerFlowControl) {\n                    warnOnProducerFlowControl = false;\n                    LOG\n                            .info(\"Usage Manager Memory Limit (\"\n                                    + memoryUsage.getLimit()\n                                    + \") reached on \"\n                                    + getActiveMQDestination().getQualifiedName()\n                                    + \". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it.\"\n                                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new ResourceAllocationException(\"Usage Manager Memory Limit reached. Stopping producer (\"\n                            + message.getProducerId() + \") to prevent flooding \"\n                            + getActiveMQDestination().getQualifiedName() + \".\"\n                            + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                // We can avoid blocking due to low usage if the producer is\n                // sending\n                // a sync message or if it is using a producer window\n                if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {\n                    // copy the exchange state since the context will be\n                    // modified while we are waiting\n                    // for space.\n                    final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy();\n                    synchronized (messagesWaitingForSpace) {\n                     // Start flow control timeout task\n                        // Prevent trying to start it multiple times\n                        if (!flowControlTimeoutTask.isAlive()) {\n                            flowControlTimeoutTask.setName(getName()+\" Producer Flow Control Timeout Task\");\n                            flowControlTimeoutTask.start();\n                        }\n                        messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {\n                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message, null);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of :\" + message, e);\n                                    }\n                                }\n                            }\n                        });\n\n                        if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {\n                            flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage\n                                    .getSendFailIfNoSpaceAfterTimeout()));\n                        }\n\n                        registerCallbackForNotFullNotification();\n                        context.setDontSendReponse(true);\n                        return;\n                    }\n\n                } else {\n\n                    if (memoryUsage.isFull()) {\n                        waitForSpace(context, memoryUsage, \"Usage Manager Memory Limit reached. Producer (\"\n                                + message.getProducerId() + \") stopped to prevent flooding \"\n                                + getActiveMQDestination().getQualifiedName() + \".\"\n                                + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                    }\n\n                    // The usage manager could have delayed us by the time\n                    // we unblock the message could have expired..\n                    if (message.isExpired()) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Expired message: \" + message);\n                        }\n                        broker.getRoot().messageExpired(context, message, null);\n                        return;\n                    }\n                }\n            }\n        }\n        doMessageSend(producerExchange, message);\n        if (sendProducerAck) {\n            ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n            context.getConnection().dispatchAsync(ack);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doMessageSend": "    void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,\n            Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Future<Object> result = null;\n\n        checkUsage(context, message);\n        sendLock.lockInterruptibly();\n        try {\n            if (store != null && message.isPersistent()) {\n                message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n                if (messages.isCacheEnabled()) {\n                    result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());\n                } else {\n                    store.addMessage(context, message);\n                }\n                if (isReduceMemoryFootprint()) {\n                    message.clearMarshalledState();\n                }\n            }\n            if (context.isInTransaction()) {\n                // If this is a transacted message.. increase the usage now so that\n                // a big TX does not blow up\n                // our memory. This increment is decremented once the tx finishes..\n                message.incrementReferenceCount();\n\n                context.getTransaction().addSynchronization(new Synchronization() {\n                    @Override\n                    public void afterCommit() throws Exception {\n                        sendLock.lockInterruptibly();\n                        try {\n                            // It could take while before we receive the commit\n                            // op, by that time the message could have expired..\n                            if (broker.isExpired(message)) {\n                                broker.messageExpired(context, message, null);\n                                destinationStatistics.getExpired().increment();\n                                return;\n                            }\n                            sendMessage(message);\n                        } finally {\n                            sendLock.unlock();\n                            message.decrementReferenceCount();\n                        }\n                        messageSent(context, message);\n                    }\n                    @Override\n                    public void afterRollback() throws Exception {\n                        message.decrementReferenceCount();\n                    }\n                });\n            } else {\n                // Add to the pending list, this takes care of incrementing the\n                // usage manager.\n                sendMessage(message);\n            }\n        } finally {\n            sendLock.unlock();\n        }\n        if (!context.isInTransaction()) {\n            messageSent(context, message);\n        }\n        if (result != null && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.start": "    public void start() throws Exception {\n        if (memoryUsage != null) {\n            memoryUsage.start();\n        }\n        if (systemUsage.getStoreUsage() != null) {\n            systemUsage.getStoreUsage().start();\n        }\n        systemUsage.getMemoryUsage().addUsageListener(this);\n        messages.start();\n        if (getExpireMessagesPeriod() > 0) {\n            scheduler.schedualPeriodically(expireMessagesTask, getExpireMessagesPeriod());\n        }\n        doPageIn(false);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message expired: \" + reference);\n        }\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getActiveMQDestination": "    public ActiveMQDestination getActiveMQDestination() {\n        return destination;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.send": "    public void send(final ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n\n        if (producerExchange.isMutable() || producerExchange.getRegionDestination() == null) {\n            final Destination regionDestination = lookup(context, messageSend.getDestination(),false);\n            producerExchange.setRegionDestination(regionDestination);\n        }\n\n        producerExchange.getRegionDestination().send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.lookup": "    protected Destination lookup(ConnectionContext context, ActiveMQDestination destination,boolean createTemporary) throws Exception {\n        Destination dest = null;\n\n        destinationsLock.readLock().lock();\n        try {\n            dest = destinations.get(destination);\n        } finally {\n            destinationsLock.readLock().unlock();\n        }\n\n        if (dest == null) {\n            if (isAutoCreateDestinations()) {\n                // Try to auto create the destination... re-invoke broker\n                // from the\n                // top so that the proper security checks are performed.\n                try {\n                    context.getBroker().addDestination(context, destination, createTemporary);\n                    dest = addDestination(context, destination, false);\n                } catch (DestinationAlreadyExistsException e) {\n                    // if the destination already exists then lets ignore\n                    // this error\n                }\n                // We should now have the dest created.\n                destinationsLock.readLock().lock();\n                try {\n                    dest = destinations.get(destination);\n                } finally {\n                    destinationsLock.readLock().unlock();\n                }\n            }\n\n            if (dest == null) {\n                throw new JMSException(\"The destination \" + destination + \" does not exist.\");\n            }\n        }\n        return dest;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        message.setBrokerInTime(System.currentTimeMillis());\n        if (producerExchange.isMutable() || producerExchange.getRegion() == null\n                || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {\n            ActiveMQDestination destination = message.getDestination();\n            // ensure the destination is registered with the RegionBroker\n            producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());\n            Region region;\n            switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                region = queueRegion;\n                break;\n            case ActiveMQDestination.TOPIC_TYPE:\n                region = topicRegion;\n                break;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                region = tempQueueRegion;\n                break;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                region = tempTopicRegion;\n                break;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n            }\n            producerExchange.setRegion(region);\n            producerExchange.setRegionDestination(null);\n        }\n\n        producerExchange.getRegion().send(producerExchange, message);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.createUnknownDestinationTypeException": "    protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {\n        return new JMSException(\"Unknown destination type: \" + destination.getDestinationType());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {\n\n        Destination answer;\n\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n     synchronized (destinations) {\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            answer = queueRegion.addDestination(context, destination,true);\n            break;\n        case ActiveMQDestination.TOPIC_TYPE:\n            answer = topicRegion.addDestination(context, destination,true);\n            break;\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            answer = tempQueueRegion.addDestination(context, destination, createIfTemp);\n            break;\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            answer = tempTopicRegion.addDestination(context, destination, createIfTemp);\n            break;\n        default:\n            throw createUnknownDestinationTypeException(destination);\n        }\n\n        destinations.put(destination, answer);\n        return answer;\n     }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.isAllowTempAutoCreationOnSend": "    public boolean isAllowTempAutoCreationOnSend() {\n        return allowTempAutoCreationOnSend;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.send": "    public void send(ProducerBrokerExchange exchange, Message message) throws Exception {\n        if (exchange != null && exchange.getProducerState() != null && exchange.getProducerState().getInfo() != null) {\n            ProducerInfo info = exchange.getProducerState().getInfo();\n            if (info.getDestination() == null && info.getProducerId() != null) {\n                ObjectName objectName = createObjectName(info, exchange.getConnectionContext().getClientId());\n                ProducerView view = this.dynamicDestinationProducers.get(objectName);\n                if (view != null) {\n                    ActiveMQDestination dest = message.getDestination();\n                    if (dest != null) {\n                        view.setLastUsedDestinationName(dest);\n                    }\n                }\n            }\n         }\n        super.send(exchange, message);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.createObjectName": "    private ObjectName createObjectName(AbortSlowConsumerStrategy strategy) throws MalformedObjectNameException{\n        Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();\n        ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + \":\" + \"BrokerName=\" + map.get(\"BrokerName\") + \",\"\n                            + \"Type=SlowConsumerStrategy,\" + \"InstanceName=\" + JMXSupport.encodeObjectNamePart(strategy.getName()));\n        return objectName;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        next.send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.scheduler.SchedulerBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        long delay = 0;\n        long period = 0;\n        int repeat = 0;\n        String cronEntry = \"\";\n        String jobId = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_ID);\n        Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);\n        Object periodValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD);\n        Object delayValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);\n\n        String physicalName = messageSend.getDestination().getPhysicalName();\n        boolean schedularManage = physicalName.regionMatches(true, 0,\n                ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION, 0,\n                ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION.length());\n\n        if (schedularManage == true) {\n\n            JobScheduler scheduler = getInternalScheduler();\n            ActiveMQDestination replyTo = messageSend.getReplyTo();\n\n            String action = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION);\n\n            if (action != null ) {\n\n                Object startTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME);\n                Object endTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME);\n\n                if (replyTo != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE)) {\n\n                    if( startTime != null && endTime != null ) {\n\n                        long start = (Long) TypeConversionSupport.convert(startTime, Long.class);\n                        long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);\n\n                        for (Job job : scheduler.getAllJobs(start, finish)) {\n                            sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);\n                        }\n                    } else {\n                        for (Job job : scheduler.getAllJobs()) {\n                            sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);\n                        }\n                    }\n                }\n                if (jobId != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE)) {\n                    scheduler.remove(jobId);\n                } else if (action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL)) {\n\n                    if( startTime != null && endTime != null ) {\n\n                        long start = (Long) TypeConversionSupport.convert(startTime, Long.class);\n                        long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);\n\n                        scheduler.removeAllJobs(start, finish);\n                    } else {\n                        scheduler.removeAllJobs();\n                    }\n                }\n            }\n\n        } else if ((cronValue != null || periodValue != null || delayValue != null) && jobId == null) {\n            //clear transaction context\n            Message msg = messageSend.copy();\n            msg.setTransactionId(null);\n            org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(msg);\n            if (cronValue != null) {\n                cronEntry = cronValue.toString();\n            }\n            if (periodValue != null) {\n              period = (Long) TypeConversionSupport.convert(periodValue, Long.class);\n            }\n            if (delayValue != null) {\n                delay = (Long) TypeConversionSupport.convert(delayValue, Long.class);\n            }\n            Object repeatValue = msg.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);\n            if (repeatValue != null) {\n                repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);\n            }\n            getInternalScheduler().schedule(msg.getMessageId().toString(),\n                    new ByteSequence(packet.data, packet.offset, packet.length),cronEntry, delay, period, repeat);\n\n        } else {\n            super.send(producerExchange, messageSend);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.scheduler.SchedulerBroker.getInternalScheduler": "    protected synchronized JobScheduler getInternalScheduler() throws Exception {\n        if (this.started.get()) {\n            if (this.scheduler == null) {\n                this.scheduler = getStore().getJobScheduler(\"JMS\");\n                this.scheduler.addListener(this);\n            }\n            return this.scheduler;\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.scheduler.SchedulerBroker.sendScheduledJob": "    protected void sendScheduledJob(ConnectionContext context, Job job, ActiveMQDestination replyTo)\n            throws Exception {\n\n        org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(job.getPayload());\n        try {\n            Message msg = (Message) this.wireFormat.unmarshal(packet);\n            msg.setOriginalTransactionId(null);\n            msg.setPersistent(false);\n            msg.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);\n            msg.setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));\n            msg.setDestination(replyTo);\n            msg.setResponseRequired(false);\n            msg.setProducerId(this.producerId);\n\n            // Add the jobId as a property\n            msg.setProperty(\"scheduledJobId\", job.getJobId());\n\n            final boolean originalFlowControl = context.isProducerFlowControl();\n            final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setConnectionContext(context);\n            producerExchange.setMutable(true);\n            producerExchange.setProducerState(new ProducerState(new ProducerInfo()));\n            try {\n                context.setProducerFlowControl(false);\n                this.next.send(producerExchange, msg);\n            } finally {\n                context.setProducerFlowControl(originalFlowControl);\n            }\n        } catch (Exception e) {\n            LOG.error(\"Failed to send scheduled message \" + job.getJobId(), e);\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.CompositeDestinationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        if (destination.isComposite()) {\n            ActiveMQDestination[] destinations = destination.getCompositeDestinations();\n            for (int i = 0; i < destinations.length; i++) {\n                if (i != 0) {\n                    message = message.copy();\n                    message.setMemoryUsage(null);\n                }\n                message.setOriginalDestination(destination);\n                message.setDestination(destinations[i]);\n                next.send(producerExchange, message);\n            }\n        } else {\n            next.send(producerExchange, message);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        Synchronization sync = null;\n        if (message.getTransactionId() != null) {\n            transaction = getTransaction(context, message.getTransactionId(), false);\n            if (transaction != null) {\n                sync = new Synchronization() {\n\n                    public void afterRollback() {\n                        if (audit != null) {\n                            audit.rollback(message);\n                        }\n                    }\n                };\n                transaction.addSynchronization(sync);\n            }\n        }\n        if (audit == null || !audit.isDuplicate(message)) {\n            context.setTransaction(transaction);\n            try {\n                next.send(producerExchange, message);\n            } finally {\n                context.setTransaction(originalTx);\n            }\n        } else {\n            if (sync != null && transaction != null) {\n                transaction.removeSynchronization(sync);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"IGNORING duplicate message \" + message);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processMessage": "    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.getProducerBrokerExchange": "    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.ActiveMQMessage.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessage(this);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof java.lang.SecurityException) {\n                // still need to close this down - in case the peer of this transport doesn't play nice\n                delayedStop(2000, \"Failed with SecurityException: \" + e.getLocalizedMessage(), e);\n            }\n\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exption notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.delayedStop": "    public void delayedStop(final int waitTime, final String reason, Throwable cause) {\n        if (waitTime > 0) {\n            synchronized (this) {\n                pendingStop = true;\n                stopError = cause;\n            }\n            try {\n                DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable() {\n                    public void run() {\n                        try {\n                            Thread.sleep(waitTime);\n                            stopAsync();\n                            LOG.info(\"Stopping \" + transport.getRemoteAddress() + \" because \" + reason);\n                        } catch (InterruptedException e) {\n                        }\n                    }\n                }, \"delayedStop:\" + transport.getRemoteAddress());\n            } catch (Throwable t) {\n                LOG.warn(\"cannot create stopAsync :\", t);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.ResponseCorrelator.onCommand": "    public void onCommand(Object o) {\n        Command command = null;\n        if (o instanceof Command) {\n            command = (Command)o;\n        } else {\n            throw new ClassCastException(\"Object cannot be converted to a Command,  Object: \" + o);\n        }\n        if (command.isResponse()) {\n            Response response = (Response)command;\n            FutureResponse future = null;\n            synchronized (requestMap) {\n                future = requestMap.remove(Integer.valueOf(response.getCorrelationId()));\n            }\n            if (future != null) {\n                future.set(response);\n            } else {\n                if (debug) {\n                    LOG.debug(\"Received unexpected response: {\" + command + \"}for command id: \" + response.getCorrelationId());\n                }\n            }\n        } else {\n            getTransportListener().onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            wreiteLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                wreiteLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.iterate": "    public boolean iterate() {\n\n        final TransportListener tl = transportListener;\n\n        LinkedBlockingQueue<Object> mq;\n        try {\n            mq = getMessageQueue();\n        } catch (TransportDisposedIOException e) {\n            return false;\n        }\n\n        Object command = mq.poll();\n        if (command != null && !disposed.get()) {\n            if( command == DISCONNECT ) {\n                tl.onException(new TransportDisposedIOException(\"Peer (\" + peer.toString() + \") disposed.\"));\n            } else {\n                tl.onCommand(command);\n            }\n            return !mq.isEmpty() && !disposed.get();\n        } else {\n            if(disposed.get()) {\n                mq.clear();\n            }\n            return false;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.getMessageQueue": "    public LinkedBlockingQueue<Object> getMessageQueue() throws TransportDisposedIOException {\n        LinkedBlockingQueue<Object> result = messageQueue;\n        if (result == null) {\n            synchronized (this) {\n                result = messageQueue;\n                if (result == null) {\n                    if (disposed.get()) {\n                        throw new TransportDisposedIOException(\"The Transport has been disposed\");\n                    }\n\n                    messageQueue = result = new LinkedBlockingQueue<Object>(this.asyncQueueDepth);\n                }\n            }\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.toString": "    public String toString() {\n        return location + \"#\" + id;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.DedicatedTaskRunner.runTask": "    final void runTask() {\n\n        try {\n            while (true) {\n\n                synchronized (mutex) {\n                    pending = false;\n                    if (shutdown) {\n                        return;\n                    }\n                }\n\n                if (!task.iterate()) {\n                    // wait to be notified.\n                    synchronized (mutex) {\n                        if (shutdown) {\n                            return;\n                        }\n                        while (!pending) {\n                            mutex.wait();\n                        }\n                    }\n                }\n\n            }\n\n        } catch (InterruptedException e) {\n            // Someone really wants this thread to die off.\n            Thread.currentThread().interrupt();\n        } finally {\n            // Make sure we notify any waiting threads that thread\n            // has terminated.\n            synchronized (mutex) {\n                threadTerminated = true;\n                mutex.notifyAll();\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.DedicatedTaskRunner.run": "            public void run() {\n                runTask();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isAdvisoryTopic": "    public static boolean isAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination != null) {\n            if (destination.isComposite()) {\n                ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n                for (int i = 0; i < compositeDestinations.length; i++) {\n                    if (isAdvisoryTopic(compositeDestinations[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                return destination.isTopic() && destination.getPhysicalName().startsWith(ADVISORY_TOPIC_PREFIX);\n            }\n        }\n        return false;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getExpired": "    public CountStatisticImpl getExpired() {\n        return expired;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.scheduler.JobScheduler.remove": "    public abstract void remove(String jobId) throws  Exception;\n    \n    /**\n     * remove all the Jobs from the scheduler\n     * @throws Exception\n     */\n    public abstract void removeAllJobs() throws Exception;\n    \n    /**\n     * remove all the Jobs from the scheduler that are due between the start and finish times\n     * @param start time in milliseconds\n     * @param finish time in milliseconds\n     * @throws Exception\n     */\n    public abstract void removeAllJobs(long start,long finish) throws Exception;\n    \n\n    \n    /**\n     * Get the next time jobs will be fired\n     * @return the time in milliseconds\n     * @throws Exception \n     */\n    public abstract long getNextScheduleTime() throws Exception;\n    \n    /**\n     * Get all the jobs scheduled to run next\n     * @return a list of jobs that will be scheduled next\n     * @throws Exception\n     */\n    public abstract List<Job> getNextScheduleJobs() throws Exception;\n    \n    /**\n     * Get all the outstanding Jobs\n     * @return a  list of all jobs\n     * @throws Exception \n     */\n    public abstract List<Job> getAllJobs() throws Exception;\n    \n    /**\n     * Get all outstanding jobs due to run between start and finish\n     * @param start\n     * @param finish\n     * @return a list of jobs\n     * @throws Exception\n     */\n    public abstract List<Job> getAllJobs(long start,long finish)throws Exception;\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.scheduler.JobScheduler.removeAllJobs": "    public abstract void removeAllJobs(long start,long finish) throws Exception;\n    \n\n    \n    /**\n     * Get the next time jobs will be fired\n     * @return the time in milliseconds\n     * @throws Exception \n     */\n    public abstract long getNextScheduleTime() throws Exception;\n    \n    /**\n     * Get all the jobs scheduled to run next\n     * @return a list of jobs that will be scheduled next\n     * @throws Exception\n     */\n    public abstract List<Job> getNextScheduleJobs() throws Exception;\n    \n    /**\n     * Get all the outstanding Jobs\n     * @return a  list of all jobs\n     * @throws Exception \n     */\n    public abstract List<Job> getAllJobs() throws Exception;\n    \n    /**\n     * Get all outstanding jobs due to run between start and finish\n     * @param start\n     * @param finish\n     * @return a list of jobs\n     * @throws Exception\n     */\n    public abstract List<Job> getAllJobs(long start,long finish)throws Exception;\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.scheduler.JobScheduler.getAllJobs": "    public abstract List<Job> getAllJobs(long start,long finish)throws Exception;\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.canDispatch": "    public boolean canDispatch(Message messageSend) {\n        boolean canDispatch = true;\n        if (auditProducerSequenceIds && messageSend.isPersistent()) {\n            final long producerSequenceId = messageSend.getMessageId().getProducerSequenceId();\n            if (isNetworkProducer) {\n                //  messages are multiplexed on this producer so we need to query the persistenceAdapter\n                long lastStoredForMessageProducer = getStoredSequenceIdForMessage(messageSend.getMessageId());\n                if (producerSequenceId <= lastStoredForMessageProducer) {\n                    canDispatch = false;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"suppressing duplicate message send  [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] from network producer with producerSequenceId [\"\n                                + producerSequenceId + \"] less than last stored: \"  + lastStoredForMessageProducer);\n                    }\n                }\n            } else if (producerSequenceId <= lastSendSequenceNumber.get()) {\n                canDispatch = false;\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"suppressing duplicate message send [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] with producerSequenceId [\"\n                            + producerSequenceId + \"] less than last stored: \"  + lastSendSequenceNumber);\n                }\n            } else {\n                // track current so we can suppress duplicates later in the stream\n                lastSendSequenceNumber.set(producerSequenceId);\n            }\n        }\n        return canDispatch;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getStoredSequenceIdForMessage": "    private long getStoredSequenceIdForMessage(MessageId messageId) {\n        try {\n            return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());\n       } catch (IOException ignored) {\n            LOG.debug(\"Failed to determine last producer sequence id for: \" +messageId, ignored);\n        }\n        return -1;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.FutureResponse.set": "    public void set(Response result) {\n        if (responseSlot.offer(result)) {\n            if (responseCallback != null) {\n                responseCallback.onCompletion(this);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.thread.task.iterate": "    boolean iterate();\n}"
        },
        "bug_report": {
            "Title": "Failed to fire fast producer advisory, reason: java.lang.NullPointerException",
            "Description": "When sending a lot of Messages to Queue via Webconsole and advisdoryForFastProducers=\"true\" (so the advisory triggers)\na exception occurs:\n\njvm 1    |  WARN | Failed to fire fast producer advisory, reason: java.lang.NullPointerException\n\n2012-07-12 11:40:48,623 | DEBUG | fast producer detail | org.apache.activemq.advisory.AdvisoryBroker | VMTransport: vm://localhost#1\njava.lang.NullPointerException\n\tat org.apache.activemq.advisory.AdvisorySupport.getFastProducerAdvisoryTopic(AdvisorySupport.java:195)\n\tat org.apache.activemq.advisory.AdvisoryBroker.fastProducer(AdvisoryBroker.java:352)\n\tat org.apache.activemq.broker.BrokerFilter.fastProducer(BrokerFilter.java:275)\n\tat org.apache.activemq.broker.BrokerFilter.fastProducer(BrokerFilter.java:275)\n\tat org.apache.activemq.broker.MutableBrokerFilter.fastProducer(MutableBrokerFilter.java:286)\n\tat org.apache.activemq.broker.region.BaseDestination.fastProducer(BaseDestination.java:512)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:605)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:407)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:503)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:305)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.scheduler.SchedulerBroker.send(SchedulerBroker.java:189)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:453)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)\n\tat org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:231)\n\tat org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)\n\tat org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)"
        }
    },
    {
        "filename": "AMQ-2693.json",
        "creation_time": "2010-04-12T13:58:58.000+0000",
        "stack_trace": "ActiveMQ Transport: tcp:///127.0.0.1:49284\" daemon prio=3 tid=0x0068f800 nid=0x32 runnable [0x56ffe000]\n   java.lang.Thread.State: RUNNABLE\n\tat java.net.SocketOutputStream.socketWrite0(Native Method)\n\tat java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92)\n\tat java.net.SocketOutputStream.write(SocketOutputStream.java:136)\n\tat org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush(TcpBufferedOutputStream.java:115)\n\tat java.io.DataOutputStream.flush(DataOutputStream.java:106)\n\tat org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:168)\n\tat org.apache.activemq.transport.InactivityMonitor.oneway(InactivityMonitor.java:243)\n\t- locked <0x5c2daab0> (a java.util.concurrent.atomic.AtomicBoolean)\n\tat org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:83)\n\tat org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:104)\n\tat org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:40)\n\t- locked <0x5c2da520> (a java.lang.Object)\n\tat org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1205)\n\tat org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:790)\n\tat org.apache.activemq.broker.TransportConnection.dispatchSync(TransportConnection.java:750)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.dispatch(PrefetchSubscription.java:647)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending(PrefetchSubscription.java:592)\n\t- locked <0x5c2db3a0> (a java.lang.Object)\n\t- locked <0x5c2db3a8> (a java.lang.Object)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.add(PrefetchSubscription.java:158)\n\tat org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:1548)\n\tat org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1500)\n\t- locked <0x5c2db500> (a java.util.ArrayList)\n\t- locked <0x5c2db518> (a java.lang.Object)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1585)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1219)\n\t- locked <0x5c2db520> (a org.apache.activemq.broker.region.Queue$3)\n\tat org.apache.activemq.broker.region.Queue.wakeup(Queue.java:1406)\n\tat org.apache.activemq.broker.region.Queue.addSubscription(Queue.java:377)\n\tat org.apache.activemq.broker.region.AbstractRegion.addConsumer(AbstractRegion.java:279)\n\t- locked <0x5c2db590> (a java.lang.Object)\n\tat org.apache.activemq.broker.region.RegionBroker.addConsumer(RegionBroker.java:380)\n\tat org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:86)\n\tat org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:86)\n\tat org.apache.activemq.advisory.AdvisoryBroker.addConsumer(AdvisoryBroker.java:89)\n\tat org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:86)\n\tat org.apache.activemq.broker.MutableBrokerFilter.addConsumer(MutableBrokerFilter.java:93)\n\tat org.apache.activemq.broker.TransportConnection.processAddConsumer(TransportConnection.java:533)\n\tat org.apache.activemq.command.ConsumerInfo.visit(ConsumerInfo.java:349)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:300)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:178)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:216)\n\t- locked <0x5c2dab30> (a org.apache.activemq.transport.InactivityMonitor$1)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:204)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:186)\n\tat java.lang.Thread.run(Thread.java:619)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush": "    public void flush() throws IOException {\n        if (count > 0 && out != null) {\n            try {\n                writeTimestamp = System.currentTimeMillis();\n                out.write(buffer, 0, count);\n            } finally {\n            \twriteTimestamp = -1;\n            }\n            count = 0;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpBufferedOutputStream.write": "    public void write(byte b[], int off, int len) throws IOException {\n        if (b != null) {\n            if ((bufferlen - count) < len) {\n                flush();\n            }\n            if (buffer.length >= len) {\n                System.arraycopy(b, off, buffer, count, len);\n                count += len;\n            } else {\n                try {\n                    writeTimestamp = System.currentTimeMillis();\n                    out.write(b, off, len);\n                } finally {\n                    writeTimestamp = -1;\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.oneway": "    public void oneway(Object command) throws IOException {\n        checkStarted();\n        wireFormat.marshal(command, dataOut);\n        dataOut.flush();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // Disable inactivity monitoring while processing a command.\n        //synchronize this method - its not synchronized\n        //further down the transport stack and gets called by more\n        //than one thread  by this class\n        synchronized(inSend) {\n            inSend.set(true);\n            try {\n\n                if( failed.get() ) {\n                    throw new InactivityIOException(\"Channel was inactive for too long: \"+next.getRemoteAddress());\n                }\n                if (o.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        localWireFormatInfo = (WireFormatInfo)o;\n                        startMonitorThreads();\n                    }\n                }\n                next.oneway(o);\n            } finally {\n                commandSent.set(true);\n                inSend.set(false);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.startMonitorThreads": "    private synchronized void startMonitorThreads() throws IOException {\n        if (monitorStarted.get()) {\n            return;\n        }\n        if (localWireFormatInfo == null) {\n            return;\n        }\n        if (remoteWireFormatInfo == null) {\n            return;\n        }\n\n        if (!ignoreRemoteWireFormat) {\n            readCheckTime = Math.min(localWireFormatInfo.getMaxInactivityDuration(), remoteWireFormatInfo.getMaxInactivityDuration());\n            initialDelayTime = Math.min(localWireFormatInfo.getMaxInactivityDurationInitalDelay(), remoteWireFormatInfo.getMaxInactivityDurationInitalDelay());\n        } else {\n            readCheckTime = localWireFormatInfo.getMaxInactivityDuration();\n            initialDelayTime = localWireFormatInfo.getMaxInactivityDurationInitalDelay();\n        }\n\n        if (readCheckTime > 0) {\n            monitorStarted.set(true);\n            writeCheckerTask = new SchedulerTimerTask(writeChecker);\n            readCheckerTask = new  SchedulerTimerTask(readChecker);\n            writeCheckTime = readCheckTime>3 ? readCheckTime/3 : readCheckTime;\n            synchronized( InactivityMonitor.class ) {\n                if( CHECKER_COUNTER == 0 ) {\n                    READ_CHECK_TIMER = new Timer(\"InactivityMonitor ReadCheck\",true);\n                    WRITE_CHECK_TIMER = new Timer(\"InactivityMonitor WriteCheck\",true);\n                }\n                CHECKER_COUNTER++;\n                WRITE_CHECK_TIMER.scheduleAtFixedRate(writeCheckerTask, initialDelayTime,writeCheckTime);\n                READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, initialDelayTime,readCheckTime);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportFilter.oneway": "    public void oneway(Object command) throws IOException {\n        next.oneway(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.oneway": "    public void oneway(Object command) throws IOException {\n        try {\n            if (!readyCountDownLatch.await(negotiateTimeout, TimeUnit.MILLISECONDS)) {\n                throw new IOException(\"Wire format negotiation timeout: peer did not send his wire format.\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new InterruptedIOException();\n        }\n        super.oneway(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.MutexTransport.oneway": "    public void oneway(Object command) throws IOException {\n        synchronized (writeMutex) {\n            next.oneway(command);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatch": "    protected void dispatch(Command command) throws IOException {\n        try {\n            setMarkedCandidate(true);\n            transport.oneway(command);\n        } finally {\n            setMarkedCandidate(false);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.setMarkedCandidate": "    public void setMarkedCandidate(boolean markedCandidate) {\n        this.markedCandidate = markedCandidate;\n        if (!markedCandidate) {\n            timeStamp = 0;\n            blockedCandidate = false;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processDispatch": "    protected void processDispatch(Command command) throws IOException {\n        final MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);\n        try {\n            if (!stopping.get()) {\n                if (messageDispatch != null) {\n                    broker.preProcessDispatch(messageDispatch);\n                }\n                dispatch(command);\n            }\n        } finally {\n            if (messageDispatch != null) {\n                Runnable sub = messageDispatch.getTransmitCallback();\n                broker.postProcessDispatch(messageDispatch);\n                if (sub != null) {\n                    sub.run();\n                }\n            }\n            // getStatistics().getDequeues().increment();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.run": "                    public void run() {\n                        serviceLock.writeLock().lock();\n                        try {\n                            doStop();\n                        } catch (Throwable e) {\n                            LOG.debug(\"Error occured while shutting down a connection to '\" + transport.getRemoteAddress()\n                                    + \"': \", e);\n                        } finally {\n                            stopped.countDown();\n                            serviceLock.writeLock().unlock();\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        // getStatistics().getEnqueues().increment();\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceExceptionAsync": "    public void serviceExceptionAsync(final IOException e) {\n        if (asyncException.compareAndSet(false, true)) {\n            new Thread(\"Async Exception Handler\") {\n                @Override\n                public void run() {\n                    serviceException(e);\n                }\n            }.start();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.dispatch": "    protected boolean dispatch(final MessageReference node) throws IOException {\n        final Message message = node.getMessage();\n        if (message == null) {\n            return false;\n        }\n        \n        okForAckAsDispatchDone.countDown();\n        \n        // No reentrant lock - Patch needed to IndirectMessageReference on method lock\n        if (!isSlave()) {\n\n            MessageDispatch md = createMessageDispatch(node, message);\n            // NULL messages don't count... they don't get Acked.\n            if (node != QueueMessageReference.NULL_MESSAGE) {\n                dispatchCounter++;\n                dispatched.add(node);\n            } else {\n                prefetchExtension = Math.max(0, prefetchExtension - 1);\n            }\n            if (info.isDispatchAsync()) {\n                md.setTransmitCallback(new Runnable() {\n\n                    public void run() {\n                        // Since the message gets queued up in async dispatch,\n                        // we don't want to\n                        // decrease the reference count until it gets put on the\n                        // wire.\n                        onDispatch(node, message);\n                    }\n                });\n                context.getConnection().dispatchAsync(md);\n            } else {\n                context.getConnection().dispatchSync(md);\n                onDispatch(node, message);\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.onDispatch": "    protected void onDispatch(final MessageReference node, final Message message) {\n        if (node.getRegionDestination() != null) {\n            if (node != QueueMessageReference.NULL_MESSAGE) {\n                node.getRegionDestination().getDestinationStatistics().getDispatched().increment();\n                node.getRegionDestination().getDestinationStatistics().getInflight().increment();   \n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(info.getConsumerId() + \" dispatched: \" + message.getMessageId() \n                            + \", dispatched: \" + dispatchCounter + \", inflight: \" + dispatched.size());\n                }\n            }\n        }\n        \n        if (info.isDispatchAsync()) {\n            try {\n                dispatchPending();\n            } catch (IOException e) {\n                context.getConnection().serviceExceptionAsync(e);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.add": "   public void add(ConnectionContext context, Destination destination) throws Exception {\n        synchronized(pendingLock) {\n            super.add(context, destination);\n            pending.add(context, destination);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.createMessageDispatch": "    protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {\n        if (node == QueueMessageReference.NULL_MESSAGE) {\n            MessageDispatch md = new MessageDispatch();\n            md.setMessage(null);\n            md.setConsumerId(info.getConsumerId());\n            md.setDestination(null);\n            return md;\n        } else {\n            MessageDispatch md = new MessageDispatch();\n            md.setConsumerId(info.getConsumerId());\n            md.setDestination(node.getRegionDestination().getActiveMQDestination());\n            md.setMessage(message);\n            md.setRedeliveryCounter(node.getRedeliveryCounter());\n            return md;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending": "    protected void dispatchPending() throws IOException {\n        if (!isSlave()) {\n           synchronized(pendingLock) {\n                try {\n                    int numberToDispatch = countBeforeFull();\n                    if (numberToDispatch > 0) {\n                        slowConsumer=false;\n                        pending.setMaxBatchSize(numberToDispatch);\n                        int count = 0;\n                        pending.reset();\n                        while (pending.hasNext() && !isFull()\n                                && count < numberToDispatch) {\n                            MessageReference node = pending.next();\n                            if (node == null) {\n                                break;\n                            }\n                            \n                            // Synchronize between dispatched list and remove of message from pending list\n                            // related to remove subscription action\n                            synchronized(dispatchLock) {\n                                pending.remove();\n                                node.decrementReferenceCount();\n                                if( !isDropped(node) && canDispatch(node)) {\n\n                                    // Message may have been sitting in the pending\n                                    // list a while waiting for the consumer to ak the message.\n                                    if (node!=QueueMessageReference.NULL_MESSAGE && node.isExpired()) {\n                                        //increment number to dispatch\n                                        numberToDispatch++;\n                                        if (broker.isExpired(node)) {\n                                            node.getRegionDestination().messageExpired(context, this, node);\n                                        }\n                                        continue;\n                                    }\n                                    dispatch(node);\n                                    count++;\n                                }\n                            }\n                        }\n                    }else {\n                        if (!slowConsumer) {\n                            slowConsumer=true;\n                            ConnectionContext c = new ConnectionContext();\n                            c.setBroker(context.getBroker());\n                            for (Destination dest :destinations) {\n                                dest.slowConsumer(c,this);\n                            }\n                            \n                        }\n                    }\n                } finally {\n                    pending.release();\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.isFull": "    public boolean isFull() {\n        return dispatched.size() - prefetchExtension >= info.getPrefetchSize();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.canDispatch": "    protected abstract boolean canDispatch(MessageReference node) throws IOException;\n    \n    protected abstract boolean isDropped(MessageReference node);\n\n    /**\n     * Used during acknowledgment to remove the message.\n     * \n     * @throws IOException\n     */\n    protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;\n\n    \n    public int getMaxProducersToAudit() {\n        return maxProducersToAudit;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.isDropped": "    protected abstract boolean isDropped(MessageReference node);\n\n    /**\n     * Used during acknowledgment to remove the message.\n     * \n     * @throws IOException\n     */\n    protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;\n\n    \n    public int getMaxProducersToAudit() {\n        return maxProducersToAudit;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.remove": "    public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {\n        List<MessageReference> rc = new ArrayList<MessageReference>();\n        synchronized(pendingLock) {\n            super.remove(context, destination);\n            // Here is a potential problem concerning Inflight stat:\n            // Messages not already committed or rolled back may not be removed from dispatched list at the moment\n            // Except if each commit or rollback callback action comes before remove of subscriber.\n            rc.addAll(pending.remove(context, destination));\n\n            // Synchronized to DispatchLock\n            synchronized(dispatchLock) {\n\t            for (MessageReference r : dispatched) {\n\t                if( r.getRegionDestination() == destination) {\n\t                \trc.add((QueueMessageReference)r);\n\t                }\n\t            }\n                destination.getDestinationStatistics().getDispatched().subtract(dispatched.size());\n                destination.getDestinationStatistics().getInflight().subtract(dispatched.size());\n                dispatched.clear();\n            }            \n        }\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.PrefetchSubscription.countBeforeFull": "    public int countBeforeFull() {\n        return info.getPrefetchSize() + prefetchExtension - dispatched.size();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doActualDispatch": "    private List<QueueMessageReference> doActualDispatch(List<QueueMessageReference> list) throws Exception {\n        List<Subscription> consumers;\n\n        synchronized (this.consumers) {\n            if (this.consumers.isEmpty() || isSlave()) {\n                // slave dispatch happens in processDispatchNotification\n                return list;\n            }\n            consumers = new ArrayList<Subscription>(this.consumers);\n        }\n\n        List<QueueMessageReference> rc = new ArrayList<QueueMessageReference>(list.size());\n        Set<Subscription> fullConsumers = new HashSet<Subscription>(this.consumers.size());\n\n        for (MessageReference node : list) {\n            Subscription target = null;\n            int interestCount = 0;\n            for (Subscription s : consumers) {\n                if (s instanceof QueueBrowserSubscription) {\n                    interestCount++;\n                    continue;\n                }\n                if (dispatchSelector.canSelect(s, node)) {\n                    if (!fullConsumers.contains(s)) {\n                        if (!s.isFull()) {\n                            // Dispatch it.\n                            s.add(node);\n                            target = s;\n                            break;\n                        } else {\n                            // no further dispatch of list to a full consumer to avoid out of order message receipt \n                            fullConsumers.add(s);\n                        }\n                    }\n                    interestCount++;\n                } else {\n                    // makes sure it gets dispatched again\n                    if (!node.isDropped() && !((QueueMessageReference) node).isAcked() && (!node.isDropped() || s.getConsumerInfo().isBrowser())) {\n                        interestCount++;\n                    }\n                }\n            }\n\n            if ((target == null && interestCount > 0) || consumers.size() == 0) {\n                // This means all subs were full or that there are no consumers...\n                rc.add((QueueMessageReference) node);\n            }\n\n            // If it got dispatched, rotate the consumer list to get round robin distribution. \n            if (target != null && !strictOrderDispatch && consumers.size() > 1 && !dispatchSelector.isExclusiveConsumer(target)) {\n                synchronized (this.consumers) {\n                    if (removeFromConsumerList(target)) {\n                        addToConsumerList(target);\n                        consumers = new ArrayList<Subscription>(this.consumers);\n                    }\n                }\n            }\n        }\n\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.removeFromConsumerList": "    private boolean removeFromConsumerList(Subscription sub) {\n        return consumers.remove(sub);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.addToConsumerList": "    private void addToConsumerList(Subscription sub) {\n        if (useConsumerPriority) {\n            consumers.add(sub);\n            Collections.sort(consumers, orderedCompare);\n        } else {\n            consumers.add(sub);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.add": "            public void add(int index, Message element) {\n                size++;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.isSlave": "    private boolean isSlave() {\n        return broker.getBrokerService().isSlave();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.size": "            public int size() {\n                return size;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doDispatch": "    private void doDispatch(List<QueueMessageReference> list) throws Exception {\n        boolean doWakeUp = false;\n        synchronized (dispatchMutex) {\n\n            synchronized (pagedInPendingDispatch) {\n                if (!pagedInPendingDispatch.isEmpty()) {\n                    // Try to first dispatch anything that had not been\n                    // dispatched before.\n                    pagedInPendingDispatch = doActualDispatch(pagedInPendingDispatch);\n                }\n                // and now see if we can dispatch the new stuff.. and append to the pending\n                // list anything that does not actually get dispatched.\n                if (list != null && !list.isEmpty()) {\n                    if (pagedInPendingDispatch.isEmpty()) {\n                        pagedInPendingDispatch.addAll(doActualDispatch(list));\n                    } else {\n                        for (QueueMessageReference qmr : list) {\n                            if (!pagedInPendingDispatch.contains(qmr)) {\n                                pagedInPendingDispatch.add(qmr);\n                            }\n                        }\n                        doWakeUp = true;\n                    }\n                }\n            }\n        }\n        if (doWakeUp) {\n            // avoid lock order contention\n            asyncWakeup();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.addAll": "    private void addAll(Collection<QueueMessageReference> refs, List<Message> l, int maxBrowsePageSize, List<MessageReference> toExpire) throws Exception {\n        for (Iterator<QueueMessageReference> i = refs.iterator(); i.hasNext() && l.size() < getMaxBrowsePageSize();) {\n            QueueMessageReference ref = i.next();\n            if (ref.isExpired()) {\n                toExpire.add(ref);\n            } else if (l.contains(ref.getMessage()) == false) {\n                l.add(ref.getMessage());\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.asyncWakeup": "    private void asyncWakeup() {\n        try {\n            pendingWakeups.incrementAndGet();\n            this.taskRunner.wakeup();\n        } catch (InterruptedException e) {\n            LOG.warn(\"Async task tunner failed to wakeup \", e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.pageInMessages": "    protected void pageInMessages(boolean force) throws Exception {\n        doDispatch(doPageIn(force));\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.doPageIn": "    private List<QueueMessageReference> doPageIn(boolean force) throws Exception {\n        List<QueueMessageReference> result = null;\n        List<QueueMessageReference> resultList = null;\n        synchronized (dispatchMutex) {\n            int toPageIn = Math.min(getMaxPageSize(), messages.size());\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(destination.getPhysicalName() + \" toPageIn: \" + toPageIn + \", Inflight: \" + destinationStatistics.getInflight().getCount() + \", pagedInMessages.size \"\n                        + pagedInMessages.size() + \", enqueueSize: \" + destinationStatistics.getEnqueues().getCount());\n            }\n\n            if (isLazyDispatch() && !force) {\n                // Only page in the minimum number of messages which can be dispatched immediately.\n                toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);\n            }\n            if (toPageIn > 0 && (force || (!consumers.isEmpty() && pagedInPendingDispatch.size() < getMaxPageSize()))) {\n                int count = 0;\n                result = new ArrayList<QueueMessageReference>(toPageIn);\n                synchronized (messages) {\n                    try {\n                        messages.setMaxBatchSize(toPageIn);\n                        messages.reset();\n                        while (messages.hasNext() && count < toPageIn) {\n                            MessageReference node = messages.next();\n                            messages.remove();\n                            QueueMessageReference ref = createMessageReference(node.getMessage());\n                            if (ref.isExpired()) {\n                                if (broker.isExpired(ref)) {\n                                    messageExpired(createConnectionContext(), ref);\n                                } else {\n                                    ref.decrementReferenceCount();\n                                }\n                            } else {\n                                result.add(ref);\n                                count++;\n                            }\n                        }\n                    } finally {\n                        messages.release();\n                    }\n                }\n                // Only add new messages, not already pagedIn to avoid multiple dispatch attempts\n                synchronized (pagedInMessages) {\n                    resultList = new ArrayList<QueueMessageReference>(result.size());\n                    for (QueueMessageReference ref : result) {\n                        if (!pagedInMessages.containsKey(ref.getMessageId())) {\n                            pagedInMessages.put(ref.getMessageId(), ref);\n                            resultList.add(ref);\n                        } else {\n                            ref.decrementReferenceCount();\n                        }\n                    }\n                }\n            } else {\n                // Avoid return null list, if condition is not validated\n                resultList = new ArrayList<QueueMessageReference>();\n            }\n        }\n        return resultList;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.iterate": "    public boolean iterate() {\n        boolean pageInMoreMessages = false;       \n        synchronized (iteratingMutex) {\n\n            // do early to allow dispatch of these waiting messages\n            synchronized (messagesWaitingForSpace) {\n                Iterator<Runnable> it = messagesWaitingForSpace.values().iterator();\n                while (it.hasNext()) {\n                    if (!memoryUsage.isFull()) {\n                        Runnable op = it.next();\n                        it.remove();\n                        op.run();\n                    } else {\n                        registerCallbackForNotFullNotification();\n                        break;\n                    }\n                }\n            }\n\n            if (firstConsumer) {\n                firstConsumer = false;\n                try {\n                    if (consumersBeforeDispatchStarts > 0) {\n                        int timeout = 1000; // wait one second by default if consumer count isn't reached  \n                        if (timeBeforeDispatchStarts > 0) {\n                            timeout = timeBeforeDispatchStarts;\n                        }\n                        if (consumersBeforeStartsLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(consumers.size() + \" consumers subscribed. Starting dispatch.\");\n                            }\n                        } else {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(timeout + \" ms elapsed and \" + consumers.size() + \" consumers subscribed. Starting dispatch.\");\n                            }\n                        }\n                    }\n                    if (timeBeforeDispatchStarts > 0 && consumersBeforeDispatchStarts <= 0) {\n                        iteratingMutex.wait(timeBeforeDispatchStarts);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(timeBeforeDispatchStarts + \" ms elapsed. Starting dispatch.\");\n                        }\n                    }\n                } catch (Exception e) {\n                    LOG.error(e);\n                }\n            }\n            \n            BrowserDispatch pendingBrowserDispatch = getNextBrowserDispatch();\n\n            synchronized (messages) {\n                pageInMoreMessages |= !messages.isEmpty();\n            }\n\n            // Kinda ugly.. but I think dispatchLock is the only mutex protecting the \n            // pagedInPendingDispatch variable. \t        \n            synchronized (dispatchMutex) {\n                pageInMoreMessages |= !pagedInPendingDispatch.isEmpty();\n            }\n\n            // Perhaps we should page always into the pagedInPendingDispatch list if \n            // !messages.isEmpty(), and then if !pagedInPendingDispatch.isEmpty()\n            // then we do a dispatch.\n            if (pageInMoreMessages || pendingBrowserDispatch != null) {\n                try {\n                    pageInMessages(pendingBrowserDispatch != null);\n\n                } catch (Throwable e) {\n                    LOG.error(\"Failed to page in more queue messages \", e);\n                }\n            }\n            \n            if (pendingBrowserDispatch != null) {\n                ArrayList<QueueMessageReference> alreadyDispatchedMessages = null;\n                synchronized (pagedInMessages) {\n                    alreadyDispatchedMessages = new ArrayList<QueueMessageReference>(pagedInMessages.values());\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"dispatch to browser: \" + pendingBrowserDispatch.getBrowser()\n                            + \", already dispatched/paged count: \" + alreadyDispatchedMessages.size());\n                }\n                do {\n                    try {\n                        MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();\n                        msgContext.setDestination(destination);\n                        \n                        QueueBrowserSubscription browser = pendingBrowserDispatch.getBrowser();\n                        for (QueueMessageReference node : alreadyDispatchedMessages) {\n                            if (!node.isAcked()) {\n                                msgContext.setMessageReference(node);\n                                if (browser.matches(node, msgContext)) {\n                                    browser.add(node);\n                                }\n                            }\n                        }\n                        pendingBrowserDispatch.done();\n                    } catch (Exception e) {\n                        LOG.warn(\"exception on dispatch to browser: \" + pendingBrowserDispatch.getBrowser(), e);\n                    }\n                \n                } while ((pendingBrowserDispatch = getNextBrowserDispatch()) != null);\n            }\n            \n            if (pendingWakeups.get() > 0) {\n                pendingWakeups.decrementAndGet();\n            }\n            return pendingWakeups.get() > 0;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getBrowser": "        public QueueBrowserSubscription getBrowser() {\n            return browser;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.get": "            public Message get(int index) {\n                return null;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getNextBrowserDispatch": "    BrowserDispatch getNextBrowserDispatch() {\n        synchronized (pagedInMessages) {\n            if (browserDispatches.isEmpty()) {\n                return null;\n            }\n            return browserDispatches.removeFirst();\n        }\n\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.done": "        void done() {\n            try {\n                browser.decrementQueueRef();\n            } catch (Exception e) {\n                LOG.warn(\"decrement ref on browser: \" + browser, e);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.run": "                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of :\" + message, e);\n                                    }\n                                }\n                            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.wakeup": "    public void wakeup() {\n        if (optimizedDispatch || isSlave()) {\n            iterate();\n            pendingWakeups.incrementAndGet();\n        } else {\n            asyncWakeup();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.addSubscription": "    public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {\n        // synchronize with dispatch method so that no new messages are sent\n        // while setting up a subscription. avoid out of order messages,\n        // duplicates, etc.\n        synchronized (dispatchMutex) {\n\n            sub.add(context, this);\n            destinationStatistics.getConsumers().increment();\n\n            // needs to be synchronized - so no contention with dispatching\n            synchronized (consumers) {\n\n                // set a flag if this is a first consumer\n                if (consumers.size() == 0) {\n                    firstConsumer = true;\n                    if (consumersBeforeDispatchStarts != 0) {\n                        consumersBeforeStartsLatch = new CountDownLatch(consumersBeforeDispatchStarts - 1);\n                    }\n                } else {\n                    if (consumersBeforeStartsLatch != null) {\n                        consumersBeforeStartsLatch.countDown();\n                    }\n                }\n\n                addToConsumerList(sub);\n                if (sub.getConsumerInfo().isExclusive()) {\n                    Subscription exclusiveConsumer = dispatchSelector.getExclusiveConsumer();\n                    if (exclusiveConsumer == null) {\n                        exclusiveConsumer = sub;\n                    } else if (sub.getConsumerInfo().getPriority() > exclusiveConsumer.getConsumerInfo().getPriority()) {\n                        exclusiveConsumer = sub;\n                    }\n                    dispatchSelector.setExclusiveConsumer(exclusiveConsumer);\n                }\n            }\n\n            if (sub instanceof QueueBrowserSubscription) {\n                // tee up for dispatch in next iterate\n                QueueBrowserSubscription browserSubscription = (QueueBrowserSubscription) sub;\n                synchronized (pagedInMessages) {\n                    BrowserDispatch browserDispatch = new BrowserDispatch(browserSubscription);\n                    browserDispatches.addLast(browserDispatch);\n                }\n            }\n            \n            if (!(this.optimizedDispatch || isSlave())) {\n                wakeup();\n            }\n        }\n        if (this.optimizedDispatch || isSlave()) {\n            // Outside of dispatchLock() to maintain the lock hierarchy of\n            // iteratingMutex -> dispatchLock. - see https://issues.apache.org/activemq/browse/AMQ-1878\n            wakeup();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Queue.getConsumers": "    public List<Subscription> getConsumers() {\n        synchronized (consumers) {\n            return new ArrayList<Subscription>(consumers);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.addConsumer": "    public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        LOG.debug(broker.getBrokerName() + \" adding consumer: \" + info.getConsumerId() + \" for destination: \"\n                + info.getDestination());\n        ActiveMQDestination destination = info.getDestination();\n        if (destination != null && !destination.isPattern() && !destination.isComposite()) {\n            // lets auto-create the destination\n            lookup(context, destination,true);\n        }\n\n        Object addGuard;\n        synchronized (consumerChangeMutexMap) {\n            addGuard = consumerChangeMutexMap.get(info.getConsumerId());\n            if (addGuard == null) {\n                addGuard = new Object();\n                consumerChangeMutexMap.put(info.getConsumerId(), addGuard);\n            }\n        }\n        synchronized (addGuard) {\n            Subscription o = subscriptions.get(info.getConsumerId());\n            if (o != null) {\n                LOG\n                        .warn(\"A duplicate subscription was detected. Clients may be misbehaving. Later warnings you may see about subscription removal are a consequence of this.\");\n                return o;\n            }\n\n            // We may need to add some destinations that are in persistent store\n            // but not active\n            // in the broker.\n            //\n            // TODO: think about this a little more. This is good cause\n            // destinations are not loaded into\n            // memory until a client needs to use the queue, but a management\n            // agent viewing the\n            // broker will not see a destination that exists in persistent\n            // store. We may want to\n            // eagerly load all destinations into the broker but have an\n            // inactive state for the\n            // destination which has reduced memory usage.\n            //\n            DestinationFilter.parseFilter(info.getDestination());\n\n            Subscription sub = createSubscription(context, info);\n\n            subscriptions.put(info.getConsumerId(), sub);\n\n            // At this point we're done directly manipulating subscriptions,\n            // but we need to retain the synchronized block here. Consider\n            // otherwise what would happen if at this point a second\n            // thread added, then removed, as would be allowed with\n            // no mutex held. Remove is only essentially run once\n            // so everything after this point would be leaked.\n\n            // Add the subscription to all the matching queues.\n            // But copy the matches first - to prevent deadlocks\n            List<Destination> addList = new ArrayList<Destination>();\n            synchronized (destinationsMutex) {\n                for (Iterator iter = destinationMap.get(info.getDestination()).iterator(); iter.hasNext();) {\n                    Destination dest = (Destination) iter.next();\n                    addList.add(dest);\n                }\n            }\n\n            for (Destination dest : addList) {\n                dest.addSubscription(context, sub);\n            }\n\n            if (info.isBrowser()) {\n                ((QueueBrowserSubscription) sub).destinationsAdded();\n            }\n\n            return sub;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.lookup": "    protected Destination lookup(ConnectionContext context, ActiveMQDestination destination,boolean createTemporary) throws Exception {\n        Destination dest = null;\n        synchronized (destinationsMutex) {\n            dest = destinations.get(destination);\n        }\n        if (dest == null) {\n            if (isAutoCreateDestinations()) {\n                // Try to auto create the destination... re-invoke broker\n                // from the\n                // top so that the proper security checks are performed.\n                try {\n                    context.getBroker().addDestination(context, destination, createTemporary);\n                    dest = addDestination(context, destination, false);\n                } catch (DestinationAlreadyExistsException e) {\n                    // if the destination already exists then lets ignore\n                    // this error\n                }\n                // We should now have the dest created.\n                synchronized (destinationsMutex) {\n                    dest = destinations.get(destination);\n                }\n            }\n            if (dest == null) {\n                throw new JMSException(\"The destination \" + destination + \" does not exist.\");\n            }\n        }\n        return dest;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.AbstractRegion.createSubscription": "    protected abstract Subscription createSubscription(ConnectionContext context, ConsumerInfo info) throws Exception;\n\n    protected Destination createDestination(ConnectionContext context, ActiveMQDestination destination)\n            throws Exception {\n        return destinationFactory.createDestination(context, destination, destinationStatistics);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.addConsumer": "    public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        ActiveMQDestination destination = info.getDestination();\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            return queueRegion.addConsumer(context, info);\n\n        case ActiveMQDestination.TOPIC_TYPE:\n            return topicRegion.addConsumer(context, info);\n\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            return tempQueueRegion.addConsumer(context, info);\n\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            return tempTopicRegion.addConsumer(context, info);\n\n        default:\n            throw createUnknownDestinationTypeException(destination);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.RegionBroker.createUnknownDestinationTypeException": "    protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {\n        return new JMSException(\"Unknown destination type: \" + destination.getDestinationType());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFilter.addConsumer": "    public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        return next.addConsumer(context, info);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.addConsumer": "    public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        Subscription answer = super.addConsumer(context, info);\n        \n        // Don't advise advisory topics.\n        if (!AdvisorySupport.isAdvisoryTopic(info.getDestination())) {\n            ActiveMQTopic topic = AdvisorySupport.getConsumerAdvisoryTopic(info.getDestination());\n            consumers.put(info.getConsumerId(), info);\n            fireConsumerAdvisory(context, info.getDestination(), topic, info);\n        } else {\n            // We need to replay all the previously collected state objects\n            // for this newly added consumer.\n            if (AdvisorySupport.isConnectionAdvisoryTopic(info.getDestination())) {\n                // Replay the connections.\n                for (Iterator<ConnectionInfo> iter = connections.values().iterator(); iter.hasNext();) {\n                    ConnectionInfo value = iter.next();\n                    ActiveMQTopic topic = AdvisorySupport.getConnectionAdvisoryTopic();\n                    fireAdvisory(context, topic, value, info.getConsumerId());\n                }\n            }\n\n            // We need to replay all the previously collected destination\n            // objects\n            // for this newly added consumer.\n            if (AdvisorySupport.isDestinationAdvisoryTopic(info.getDestination())) {\n                // Replay the destinations.\n                for (Iterator<DestinationInfo> iter = destinations.values().iterator(); iter.hasNext();) {\n                    DestinationInfo value = iter.next();\n                    ActiveMQTopic topic = AdvisorySupport.getDestinationAdvisoryTopic(value.getDestination());\n                    fireAdvisory(context, topic, value, info.getConsumerId());\n                }\n            }\n\n            // Replay the producers.\n            if (AdvisorySupport.isProducerAdvisoryTopic(info.getDestination())) {\n                for (Iterator<ProducerInfo> iter = producers.values().iterator(); iter.hasNext();) {\n                    ProducerInfo value = iter.next();\n                    ActiveMQTopic topic = AdvisorySupport.getProducerAdvisoryTopic(value.getDestination());\n                    fireProducerAdvisory(context, value.getDestination(),topic, value, info.getConsumerId());\n                }\n            }\n\n            // Replay the consumers.\n            if (AdvisorySupport.isConsumerAdvisoryTopic(info.getDestination())) {\n                for (Iterator<ConsumerInfo> iter = consumers.values().iterator(); iter.hasNext();) {\n                    ConsumerInfo value = iter.next();\n                    ActiveMQTopic topic = AdvisorySupport.getConsumerAdvisoryTopic(value.getDestination());\n                    fireConsumerAdvisory(context,value.getDestination(), topic, value, info.getConsumerId());\n                }\n            }\n        }\n        return answer;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireProducerAdvisory": "    protected void fireProducerAdvisory(ConnectionContext context, ActiveMQDestination producerDestination,ActiveMQTopic topic, Command command, ConsumerId targetConsumerId) throws Exception {\n        ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n        int count = 0;\n        if (producerDestination != null) {\n            Set<Destination> set = getDestinations(producerDestination);\n            if (set != null) {\n                for (Destination dest : set) {\n                    count += dest.getDestinationStatistics().getProducers().getCount();\n                }\n            }\n        }\n        advisoryMessage.setIntProperty(\"producerCount\", count);\n        fireAdvisory(context, topic, command, targetConsumerId, advisoryMessage);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireConsumerAdvisory": "    protected void fireConsumerAdvisory(ConnectionContext context, ActiveMQDestination consumerDestination,ActiveMQTopic topic, Command command, ConsumerId targetConsumerId) throws Exception {\n        ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n        int count = 0;\n        Set<Destination>set = getDestinations(consumerDestination);\n        if (set != null) {\n            for (Destination dest:set) {\n                count += dest.getDestinationStatistics().getConsumers().getCount();\n            }\n        }\n        advisoryMessage.setIntProperty(AdvisorySupport.MSG_PROPERTY_CONSUMER_COUNT, count);\n        \n        fireAdvisory(context, topic, command, targetConsumerId, advisoryMessage);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory": "    protected void fireAdvisory(ConnectionContext context, ActiveMQTopic topic, Command command, ConsumerId targetConsumerId, ActiveMQMessage advisoryMessage) throws Exception {\n        if (getBrokerService().isStarted()) {\n            //set properties\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_NAME, getBrokerName());\n            String id = getBrokerId() != null ? getBrokerId().getValue() : \"NOT_SET\";\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_ID, id);\n            \n            String url = getBrokerService().getVmConnectorURI().toString();\n            if (getBrokerService().getDefaultSocketURI() != null) {\n                url = getBrokerService().getDefaultSocketURI().toString();\n            }\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_URL, url);\n            \n            //set the data structure\n            advisoryMessage.setDataStructure(command);\n            advisoryMessage.setPersistent(false);\n            advisoryMessage.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);\n            advisoryMessage.setMessageId(new MessageId(advisoryProducerId, messageIdGenerator.getNextSequenceId()));\n            advisoryMessage.setTargetConsumerId(targetConsumerId);\n            advisoryMessage.setDestination(topic);\n            advisoryMessage.setResponseRequired(false);\n            advisoryMessage.setProducerId(advisoryProducerId);\n            boolean originalFlowControl = context.isProducerFlowControl();\n            final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setConnectionContext(context);\n            producerExchange.setMutable(true);\n            producerExchange.setProducerState(new ProducerState(new ProducerInfo()));\n            try {\n                context.setProducerFlowControl(false);\n                next.send(producerExchange, advisoryMessage);\n            } finally {\n                context.setProducerFlowControl(originalFlowControl);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.addConsumer": "    public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {\n        return getNext().addConsumer(context, info);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.processAddConsumer": "    public Response processAddConsumer(ConsumerInfo info) throws Exception {\n        SessionId sessionId = info.getConsumerId().getParentId();\n        ConnectionId connectionId = sessionId.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        SessionState ss = cs.getSessionState(sessionId);\n        if (ss == null) {\n            throw new IllegalStateException(broker.getBrokerName()\n                    + \" Cannot add a consumer to a session that had not been registered: \" + sessionId);\n        }\n        // Avoid replaying dup commands\n        if (!ss.getConsumerIds().contains(info.getConsumerId())) {\n            broker.addConsumer(cs.getContext(), info);\n            try {\n                ss.addConsumer(info);\n            } catch (IllegalStateException e) {\n                broker.removeConsumer(cs.getContext(), info);\n            }\n        }\n        return null;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.lookupConnectionState": "    protected synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.command.ConsumerInfo.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processAddConsumer(this);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            response = command.visit(this);\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        return response;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Wait a little bit to try to get the output buffer to flush\n                // the exption notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchAsync(ce);\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportFilter.onCommand": "    public void onCommand(Object command) {\n        transportListener.onCommand(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        IOException error = null;\n                        remoteWireFormatInfo = (WireFormatInfo) command;\n                        try {\n                            startMonitorThreads();\n                        } catch (IOException e) {\n                            error = e;\n                        }\n                        if (error != null) {\n                            onException(error);\n                        }\n                    }\n                }\n                synchronized (readChecker) {\n                    transportListener.onCommand(command);\n                }\n            }\n        } finally {\n\n            inReceive.set(false);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            transportListener.onException(error);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        try {\n                            socket.close();\n                        } catch (IOException e) {\n                            LOG.debug(\"Caught exception closing socket\",e);\n                        }finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.broker.preProcessDispatch": "    void preProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * Notify the Broker that a dispatch has happened\n     * \n     * @param messageDispatch\n     */\n    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     * \n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     * \n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     * \n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     * \n     * @param context\n     * @param messageReference\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * A message needs to go the a DLQ\n     * \n     * @param context\n     * @param messageReference\n     */\n    void sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n    \n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub \n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n    \n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination \n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n    \n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo);\n    \n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination \n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n    \n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.broker.postProcessDispatch": "    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     * \n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     * \n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     * \n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     * \n     * @param context\n     * @param messageReference\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * A message needs to go the a DLQ\n     * \n     * @param context\n     * @param messageReference\n     */\n    void sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n    \n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub \n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n    \n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination \n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n    \n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo);\n    \n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination \n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n    \n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.getMessage": "    Message getMessage() throws IOException;\n    boolean isPersistent();\n    \n    Destination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.getRegionDestination": "    Destination getRegionDestination();\n    \n    int getRedeliveryCounter();\n    void incrementRedeliveryCounter();\n    \n    int getReferenceCount();\n    \n    int incrementReferenceCount();\n    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.decrementReferenceCount": "    int decrementReferenceCount();\n    ConsumerId getTargetConsumerId();\n    int getSize();\n    long getExpiration();\n    String getGroupID();\n    int getGroupSequence();\n    \n    /**\n     * Returns true if this message is expired\n     */\n    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.isExpired": "    boolean isExpired();\n\n    /**\n     * Returns true if this message is dropped.\n     */\n    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.MessageReference.isDropped": "    boolean isDropped();\n    \n    /**\n     * @return true if the message is an advisory\n     */\n    boolean isAdvisory();\n    \n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.QueueBrowserSubscription.matches": "    public boolean matches(MessageReference node, MessageEvaluationContext context) throws IOException {\n        return !browseDone && super.matches(node, context);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.region.Subscription.getConsumerInfo": "    ConsumerInfo getConsumerInfo();\n\n    /**\n     * The subscription should release as may references as it can to help the garbage collector\n     * reclaim memory.\n     */\n    void gc();\n    \n    /**\n     * Used by a Slave Broker to update dispatch infomation\n     * @param mdn\n     * @throws Exception \n     */\n    void processMessageDispatchNotification(MessageDispatchNotification  mdn) throws Exception;\n    \n    /**\n     * @return true if the broker is currently in slave mode\n     */\n    boolean isSlave();\n    \n    /**\n     * @return number of messages pending delivery\n     */\n    int getPendingQueueSize();\n    \n    /**\n     * @return number of messages dispatched to the client\n     */\n    int getDispatchedQueueSize();\n        \n    /**\n     * @return number of messages dispatched to the client\n     */\n    long getDispatchedCounter();\n    \n    /**\n     * @return number of messages that matched the subscription\n     */\n    long getEnqueueCounter();\n\n    /**\n     * @return number of messages queued by the client\n     */\n    long getDequeueCounter();\n\n    /**\n     * @return the JMS selector on the current subscription\n     */\n    String getSelector();\n    \n    /**\n     * Attempts to change the current active selector on the subscription.\n     * This operation is not supported for persistent topics.\n     */\n    void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException;\n\n    /**\n     * @return the JMX object name that this subscription was registered as if applicable\n     */\n    ObjectName getObjectName();\n\n    /**\n     * Set when the subscription is registered in JMX\n     */\n    void setObjectName(ObjectName objectName);\n    \n    /**\n     * @return true when 60% or more room is left for dispatching messages\n     */\n    boolean isLowWaterMark();\n    \n    /**\n     * @return true when 10% or less room is left for dispatching messages\n     */\n    boolean isHighWaterMark();\n    \n    /**\n     * @return true if there is no space to dispatch messages\n     */\n    boolean isFull();\n    \n    /**\n     * inform the MessageConsumer on the client to change it's prefetch\n     * @param newPrefetch\n     */\n    void updateConsumerPrefetch(int newPrefetch);\n    \n        \n    /**\n     * Called when the subscription is destroyed.\n     */\n    void destroy();\n\n    /**\n     * @return the prefetch size that is configured for the subscription\n     */\n    int getPrefetchSize();\n    \n    /**\n     * @return the number of messages awaiting acknowledgement\n     */\n    int getInFlightSize();\n    \n    /**\n     * @return the in flight messages as a percentage of the prefetch size\n     */\n    int getInFlightUsage();\n    \n    /**\n     * Informs the Broker if the subscription needs to intervention to recover it's state\n     * e.g. DurableTopicSubscriber may do\n     * @see org.apache.activemq.region.cursors.PendingMessageCursor\n     * @return true if recovery required\n     */\n    boolean isRecoveryRequired();\n    \n    \n    /**\n     * @return true if a browser\n     */\n    boolean isBrowser();\n    \n    /**\n     * @return the number of messages this subscription can accept before its full\n     */\n    int countBeforeFull();\n\n    ConnectionContext getContext();\n    \n    public int getCursorMemoryHighWaterMark();\n\n\tpublic void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark);\n}",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getDestinationAdvisoryTopic": "    public static ActiveMQTopic getDestinationAdvisoryTopic(ActiveMQDestination destination) {\n        switch (destination.getDestinationType()) {\n        case ActiveMQDestination.QUEUE_TYPE:\n            return QUEUE_ADVISORY_TOPIC;\n        case ActiveMQDestination.TOPIC_TYPE:\n            return TOPIC_ADVISORY_TOPIC;\n        case ActiveMQDestination.TEMP_QUEUE_TYPE:\n            return TEMP_QUEUE_ADVISORY_TOPIC;\n        case ActiveMQDestination.TEMP_TOPIC_TYPE:\n            return TEMP_TOPIC_ADVISORY_TOPIC;\n        default:\n            throw new RuntimeException(\"Unknown destination type: \" + destination.getDestinationType());\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isConnectionAdvisoryTopic": "    public static boolean isConnectionAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isComposite()) {\n            ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n            for (int i = 0; i < compositeDestinations.length; i++) {\n                if (isConnectionAdvisoryTopic(compositeDestinations[i])) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return destination.equals(CONNECTION_ADVISORY_TOPIC);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isConsumerAdvisoryTopic": "    public static boolean isConsumerAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isComposite()) {\n            ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n            for (int i = 0; i < compositeDestinations.length; i++) {\n                if (isConsumerAdvisoryTopic(compositeDestinations[i])) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return destination.isTopic() && destination.getPhysicalName().startsWith(CONSUMER_ADVISORY_TOPIC_PREFIX);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getProducerAdvisoryTopic": "    public static ActiveMQTopic getProducerAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isQueue()) {\n            return new ActiveMQTopic(QUEUE_PRODUCER_ADVISORY_TOPIC_PREFIX + destination.getPhysicalName());\n        } else {\n            return new ActiveMQTopic(TOPIC_PRODUCER_ADVISORY_TOPIC_PREFIX + destination.getPhysicalName());\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isProducerAdvisoryTopic": "    public static boolean isProducerAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isComposite()) {\n            ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n            for (int i = 0; i < compositeDestinations.length; i++) {\n                if (isProducerAdvisoryTopic(compositeDestinations[i])) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return destination.isTopic() && destination.getPhysicalName().startsWith(PRODUCER_ADVISORY_TOPIC_PREFIX);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isDestinationAdvisoryTopic": "    public static boolean isDestinationAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isComposite()) {\n            ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n            for (int i = 0; i < compositeDestinations.length; i++) {\n                if (isDestinationAdvisoryTopic(compositeDestinations[i])) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return destination.equals(TEMP_QUEUE_ADVISORY_TOPIC) || destination.equals(TEMP_TOPIC_ADVISORY_TOPIC)\n                    || destination.equals(QUEUE_ADVISORY_TOPIC) || destination.equals(TOPIC_ADVISORY_TOPIC);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.isAdvisoryTopic": "    public static boolean isAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isComposite()) {\n            ActiveMQDestination[] compositeDestinations = destination.getCompositeDestinations();\n            for (int i = 0; i < compositeDestinations.length; i++) {\n                if (isAdvisoryTopic(compositeDestinations[i])) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return destination.isTopic() && destination.getPhysicalName().startsWith(ADVISORY_TOPIC_PREFIX);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getConnectionAdvisoryTopic": "    public static ActiveMQTopic getConnectionAdvisoryTopic() {\n        return CONNECTION_ADVISORY_TOPIC;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getConsumerAdvisoryTopic": "    public static ActiveMQTopic getConsumerAdvisoryTopic(ActiveMQDestination destination) {\n        if (destination.isQueue()) {\n            return new ActiveMQTopic(QUEUE_CONSUMER_ADVISORY_TOPIC_PREFIX + destination.getPhysicalName());\n        } else {\n            return new ActiveMQTopic(TOPIC_CONSUMER_ADVISORY_TOPIC_PREFIX + destination.getPhysicalName());\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.broker.getBrokerName": "    String getBrokerName();\n\n    /**\n     * A remote Broker connects\n     */\n    void addBroker(Connection connection, BrokerInfo info);\n\n    /**\n     * Remove a BrokerInfo\n     * \n     * @param connection\n     * @param info\n     */\n    void removeBroker(Connection connection, BrokerInfo info);\n\n    /**\n     * A client is establishing a connection with the broker.\n     * \n     * @throws Exception TODO\n     */\n    void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception;\n\n    /**\n     * A client is disconnecting from the broker.\n     * \n     * @param context the environment the operation is being executed under.\n     * @param info\n     * @param error null if the client requested the disconnect or the error\n     *                that caused the client to disconnect.\n     * @throws Exception TODO\n     */\n    void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception;\n\n    /**\n     * Adds a session.\n     * \n     * @param context\n     * @param info\n     * @throws Exception TODO\n     */\n    void addSession(ConnectionContext context, SessionInfo info) throws Exception;\n\n    /**\n     * Removes a session.\n     * \n     * @param context\n     * @param info\n     * @throws Exception TODO\n     */\n    void removeSession(ConnectionContext context, SessionInfo info) throws Exception;\n\n    /**\n     * Adds a producer.\n     * \n     * @param context the enviorment the operation is being executed under.\n     * @throws Exception TODO\n     */\n    void addProducer(ConnectionContext context, ProducerInfo info) throws Exception;\n\n    /**\n     * Removes a producer.\n     * \n     * @param context the enviorment the operation is being executed under.\n     * @throws Exception TODO\n     */\n    void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception;\n\n    /**\n     * @return all clients added to the Broker.\n     * @throws Exception TODO\n     */\n    Connection[] getClients() throws Exception;\n\n    /**\n     * @return all destinations added to the Broker.\n     * @throws Exception TODO\n     */\n    ActiveMQDestination[] getDestinations() throws Exception;\n\n    /**\n     * Gets a list of all the prepared xa transactions.\n     * \n     * @param context transaction ids\n     * @return\n     * @throws Exception TODO\n     */\n    TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception;\n\n    /**\n     * Starts a transaction.\n     * \n     * @param context\n     * @param xid\n     * @throws Exception TODO\n     */\n    void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception;\n\n    /**\n     * Prepares a transaction. Only valid for xa transactions.\n     * \n     * @param context\n     * @param xid\n     * @return id\n     * @throws Exception TODO\n     */\n    int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception;\n\n    /**\n     * Rollsback a transaction.\n     * \n     * @param context\n     * @param xid\n     * @throws Exception TODO\n     */\n\n    void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Exception;\n\n    /**\n     * Commits a transaction.\n     * \n     * @param context\n     * @param xid\n     * @param onePhase\n     * @throws Exception TODO\n     */\n    void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception;\n\n    /**\n     * Forgets a transaction.\n     * \n     * @param context\n     * @param transactionId\n     * @throws Exception\n     */\n    void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception;\n\n    /**\n     * Get the BrokerInfo's of any connected Brokers\n     * \n     * @return array of peer BrokerInfos\n     */\n    BrokerInfo[] getPeerBrokerInfos();\n\n    /**\n     * Notify the Broker that a dispatch is going to happen\n     * \n     * @param messageDispatch\n     */\n    void preProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * Notify the Broker that a dispatch has happened\n     * \n     * @param messageDispatch\n     */\n    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     * \n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     * \n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     * \n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     * \n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     * \n     * @param context\n     * @param messageReference\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * A message needs to go the a DLQ\n     * \n     * @param context\n     * @param messageReference\n     */\n    void sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n    \n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n    \n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub \n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n    \n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination \n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n    \n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo);\n    \n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination \n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n    \n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n\n\n}",
            "activemq-core.src.main.java.org.apache.activemq.broker.TransportConnectionState.getContext": "    public ConnectionContext getContext() {\n        return context;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "potential hang with failover, transactions and slow thread creation with outstanding commit - close blocks pending dispatch  FailoverConsumerOutstandingCommitTest intermittent failure",
            "Description": "potential dead lock pending dispatch that is blocked by an outstanding commit after failover.\n\nLog indicates:{code}\nWARN  ActiveMQConnection             - dispatch paused, waiting for outstanding dispatch interruption processing (x) to complete..\n{code}\n\n\nThread Dump:{code}\nFull thread dump Java HotSpot(TM) Server VM (14.0-b16 mixed mode):\n...\n\"ActiveMQ Transport: tcp:///127.0.0.1:49284\" daemon prio=3 tid=0x0068f800 nid=0x32 runnable [0x56ffe000]\n   java.lang.Thread.State: RUNNABLE\n\tat java.net.SocketOutputStream.socketWrite0(Native Method)\n\tat java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92)\n\tat java.net.SocketOutputStream.write(SocketOutputStream.java:136)\n\tat org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush(TcpBufferedOutputStream.java:115)\n\tat java.io.DataOutputStream.flush(DataOutputStream.java:106)\n\tat org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:168)\n\tat org.apache.activemq.transport.InactivityMonitor.oneway(InactivityMonitor.java:243)\n\t- locked <0x5c2daab0> (a java.util.concurrent.atomic.AtomicBoolean)\n\tat org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:83)\n\tat org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:104)\n\tat org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:40)\n\t- locked <0x5c2da520> (a java.lang.Object)\n\tat org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1205)\n\tat org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:790)\n\tat org.apache.activemq.broker.TransportConnection.dispatchSync(TransportConnection.java:750)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.dispatch(PrefetchSubscription.java:647)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending(PrefetchSubscription.java:592)\n\t- locked <0x5c2db3a0> (a java.lang.Object)\n\t- locked <0x5c2db3a8> (a java.lang.Object)\n\tat org.apache.activemq.broker.region.PrefetchSubscription.add(PrefetchSubscription.java:158)\n\tat org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:1548)\n\tat org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1500)\n\t- locked <0x5c2db500> (a java.util.ArrayList)\n\t- locked <0x5c2db518> (a java.lang.Object)\n\tat org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1585)\n\tat org.apache.activemq.broker.region.Queue.iterate(Queue.java:1219)\n\t- locked <0x5c2db520> (a org.apache.activemq.broker.region.Queue$3)\n\tat org.apache.activemq.broker.region.Queue.wakeup(Queue.java:1406)\n\tat org.apache.activemq.broker.region.Queue.addSubscription(Queue.java:377)\n\tat org.apache.activemq.broker.region.AbstractRegion.addConsumer(AbstractRegion.java:279)\n\t- locked <0x5c2db590> (a java.lang.Object)\n\tat org.apache.activemq.broker.region.RegionBroker.addConsumer(RegionBroker.java:380)\n\tat org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:86)\n\tat org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:86)\n\tat org.apache.activemq.advisory.AdvisoryBroker.addConsumer(AdvisoryBroker.java:89)\n\tat org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:86)\n\tat org.apache.activemq.broker.MutableBrokerFilter.addConsumer(MutableBrokerFilter.java:93)\n\tat org.apache.activemq.broker.TransportConnection.processAddConsumer(TransportConnection.java:533)\n\tat org.apache.activemq.command.ConsumerInfo.visit(ConsumerInfo.java:349)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:300)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:178)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:216)\n\t- locked <0x5c2dab30> (a org.apache.activemq.transport.InactivityMonitor$1)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:204)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:186)\n\tat java.lang.Thread.run(Thread.java:619)\n\n\"ActiveMQ Transport: tcp://localhost/127.0.0.1:61616\" prio=3 tid=0x007c9000 nid=0x2e waiting on condition [0x569fe000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for  <0x5c2b1950> (a java.util.concurrent.CountDownLatch$Sync)\n\tat java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos(AbstractQueuedSynchronizer.java:947)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1239)\n\tat java.util.concurrent.CountDownLatch.await(CountDownLatch.java:253)\n\tat org.apache.activemq.ActiveMQConnection.waitForTransportInterruptionProcessing(ActiveMQConnection.java:2248)\n\tat org.apache.activemq.ActiveMQConnection$2.processMessageDispatch(ActiveMQConnection.java:1679)\n\tat org.apache.activemq.command.MessageDispatch.visit(MessageDispatch.java:108)\n\tat org.apache.activemq.ActiveMQConnection.onCommand(ActiveMQConnection.java:1676)\n\tat org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)\n\tat org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)\n\tat org.apache.activemq.transport.failover.FailoverTransport$3.onCommand(FailoverTransport.java:168)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:216)\n\t- locked <0x5c2db138> (a org.apache.activemq.transport.InactivityMonitor$1)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:204)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:186)\n\tat java.lang.Thread.run(Thread.java:619)\n\n\n\"ActiveMQ Session Task\" prio=3 tid=0x0076f000 nid=0x25 waiting on condition [0x55ffe000]\n   java.lang.Thread.State: WAITING (parking)\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for  <0x5c2e3cd0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n\tat java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1925)\n\tat java.util.concurrent.ArrayBlockingQueue.take(ArrayBlockingQueue.java:317)\n\tat org.apache.activemq.transport.FutureResponse.getResult(FutureResponse.java:40)\n\tat org.apache.activemq.transport.ResponseCorrelator.request(ResponseCorrelator.java:87)\n\tat org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1262)\n\tat org.apache.activemq.TransactionContext.syncSendPacketWithInterruptionHandling(TransactionContext.java:666)\n\tat org.apache.activemq.TransactionContext.commit(TransactionContext.java:299)\n\tat org.apache.activemq.ActiveMQSession.commit(ActiveMQSession.java:558)\n\tat org.apache.activemq.transport.failover.FailoverConsumerOutstandingCommitTest$2.onMessage(FailoverConsumerOutstandingCommitTest.java:155)\n\tat org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1204)\n\t- locked <0x5c2c6088> (a java.lang.Object)\n\tat org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)\n\tat org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:619)\n\n\n\"ActiveMQ Scheduler\" daemon prio=3 tid=0x006e4c00 nid=0xf waiting for monitor entry [0x573ff000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat org.apache.activemq.ActiveMQMessageConsumer.clearMessagesInProgress(ActiveMQMessageConsumer.java:661)\n\t- waiting to lock <0x5c2c6088> (a java.lang.Object)\n\tat org.apache.activemq.ActiveMQSession$2.run(ActiveMQSession.java:654)\n\tat org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)\n\tat java.util.TimerThread.mainLoop(Timer.java:512)\n\tat java.util.TimerThread.run(Timer.java:462)\n\n\"main\" prio=3 tid=0x00030800 nid=0x2 waiting for monitor entry [0x7eb7d000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat org.apache.activemq.MessageDispatchChannel.stop(MessageDispatchChannel.java:115)\n\t- waiting to lock <0x5c2c6088> (a java.lang.Object)\n\tat org.apache.activemq.ActiveMQMessageConsumer.stop(ActiveMQMessageConsumer.java:1312)\n\tat org.apache.activemq.ActiveMQSession.stop(ActiveMQSession.java:1643)\n\tat org.apache.activemq.ActiveMQConnection.stop(ActiveMQConnection.java:544)\n\t- locked <0x5c2ae5d8> (a java.util.concurrent.CopyOnWriteArrayList)\n\tat org.apache.activemq.ActiveMQConnection.close(ActiveMQConnection.java:597)\n\tat org.apache.activemq.transport.failover.FailoverConsumerOutstandingCommitTest.doTestFailoverConsumerDups(FailoverConsumerOutstandingCommitTest.java:185)\n\tat org.apache.activemq.transport.failover.FailoverConsumerOutstandingCommitTest.testFailoverConsumerDups(FailoverConsumerOutstandingCommitTest.java:104)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:73)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:46)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:180)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:41)\n\tat org.junit.runners.ParentRunner$1.evaluate(ParentRunner.java:173)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:220)\n\tat org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:62)\n\tat org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140)\n\tat org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:165)\n\tat org.apache.maven.surefire.Surefire.run(Surefire.java:107)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:289)\n\tat org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1005)\n{code}"
        }
    },
    {
        "filename": "AMQ-4643.json",
        "creation_time": "2013-07-19T13:39:19.000+0000",
        "stack_trace": "at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:54)\n\tat org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1391)\n\tat org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1319)\n\tat org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1809)\n\tat org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:289)\n\tat org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:224)\n\tat org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:241)\n\tat org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest.sendMessage(StopDBDuringProducerSendTopicTest.java:150)\n\tat org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest.testProducerWithDBShutdown(StopDBDuringProducerSendTopicTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84)\n\tat org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)\n\tat org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)\n\tat org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)\n\tat org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:81)\n\tat org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)\nCaused by: java.io.IOException: Database &apos;target/derbydb_15&apos; not found.\n\tat org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:45)\n\tat org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:68)\n\tat org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doAddMessage(DefaultJDBCAdapter.java:218)\n\tat org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage(JDBCMessageStore.java:123)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore.addMessage(MemoryTransactionStore.java:327)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore$2.asyncAddTopicMessage(MemoryTransactionStore.java:190)\n\tat org.apache.activemq.broker.region.Topic.doMessageSend(Topic.java:482)\n\tat org.apache.activemq.broker.region.Topic.send(Topic.java:446)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:406)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:431)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:147)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:317)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:152)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:464)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:751)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:294)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:680)\nCaused by: java.sql.SQLException: Database &apos;target/derbydb_15&apos; not found.\n\tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection.newSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection.handleDBNotFound(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection.&lt;init&gt;(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection30.&lt;init&gt;(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection40.&lt;init&gt;(Unknown Source)\n\tat org.apache.derby.jdbc.Driver40.getNewEmbedConnection(Unknown Source)\n\tat org.apache.derby.jdbc.InternalDriver.connect(Unknown Source)\n\tat org.apache.derby.jdbc.EmbeddedDataSource.getConnection(Unknown Source)\n\tat org.apache.derby.jdbc.EmbeddedDataSource.getConnection(Unknown Source)\n\tat org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest$ReconnectingEmbeddedDataSource.getConnection(StopDBDuringProducerSendTopicTest.java:242)\n\tat org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)",
        "source_code": {
            "activemq-client.src.main.java.org.apache.activemq.util.JMSExceptionSupport.create": "    public static JMSException create(Exception cause) {\n        if (cause instanceof JMSException) {\n            return (JMSException)cause;\n        }\n        String msg = cause.getMessage();\n        if (msg == null || msg.length() == 0) {\n            msg = cause.toString();\n        }\n        JMSException exception;\n        if (cause instanceof SecurityException) {\n            exception = new JMSSecurityException(msg);\n        } else {\n            exception = new JMSException(msg);\n        }\n        exception.setLinkedException(cause);\n        exception.initCause(cause);\n        return exception;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.syncSendPacket": "    public Response syncSendPacket(Command command, int timeout) throws JMSException {\n        if (isClosed() || closing.get()) {\n            throw new ConnectionClosedException();\n        } else {\n            return doSyncSendPacket(command, timeout);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.isClosed": "    public boolean isClosed() {\n        return closed.get();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.onException": "    public void onException(final IOException error) {\n        onAsyncException(error);\n        if (!closing.get() && !closed.get()) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    transportFailed(error);\n                    ServiceSupport.dispose(ActiveMQConnection.this.transport);\n                    brokerInfoReceived.countDown();\n                    try {\n                        cleanup();\n                    } catch (JMSException e) {\n                        LOG.warn(\"Exception during connection cleanup, \" + e, e);\n                    }\n                    for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {\n                        TransportListener listener = iter.next();\n                        listener.onException(error);\n                    }\n                }\n            });\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQConnection.doSyncSendPacket": "    private Response doSyncSendPacket(Command command, int timeout)\n            throws JMSException {\n        try {\n            Response response = (Response) (timeout > 0\n                    ? this.transport.request(command, timeout)\n                    : this.transport.request(command));\n            if (response != null && response.isException()) {\n                ExceptionResponse er = (ExceptionResponse)response;\n                if (er.getException() instanceof JMSException) {\n                    throw (JMSException)er.getException();\n                } else {\n                    throw JMSExceptionSupport.create(er.getException());\n                }\n            }\n            return response;\n        } catch (IOException e) {\n            throw JMSExceptionSupport.create(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.send": "    protected void send(ActiveMQMessageProducer producer, ActiveMQDestination destination, Message message, int deliveryMode, int priority, long timeToLive,\n                        MemoryUsage producerWindow, int sendTimeout, AsyncCallback onComplete) throws JMSException {\n\n        checkClosed();\n        if (destination.isTemporary() && connection.isDeleted(destination)) {\n            throw new InvalidDestinationException(\"Cannot publish to a deleted Destination: \" + destination);\n        }\n        synchronized (sendMutex) {\n            // tell the Broker we are about to start a new transaction\n            doStartTransaction();\n            TransactionId txid = transactionContext.getTransactionId();\n            long sequenceNumber = producer.getMessageSequence();\n\n            //Set the \"JMS\" header fields on the original message, see 1.1 spec section 3.4.11\n            message.setJMSDeliveryMode(deliveryMode);\n            long expiration = 0L;\n            if (!producer.getDisableMessageTimestamp()) {\n                long timeStamp = System.currentTimeMillis();\n                message.setJMSTimestamp(timeStamp);\n                if (timeToLive > 0) {\n                    expiration = timeToLive + timeStamp;\n                }\n            }\n            message.setJMSExpiration(expiration);\n            message.setJMSPriority(priority);\n            message.setJMSRedelivered(false);\n\n            // transform to our own message format here\n            ActiveMQMessage msg = ActiveMQMessageTransformation.transformMessage(message, connection);\n            msg.setDestination(destination);\n            msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));\n\n            // Set the message id.\n            if (msg != message) {\n                message.setJMSMessageID(msg.getMessageId().toString());\n                // Make sure the JMS destination is set on the foreign messages too.\n                message.setJMSDestination(destination);\n            }\n            //clear the brokerPath in case we are re-sending this message\n            msg.setBrokerPath(null);\n\n            msg.setTransactionId(txid);\n            if (connection.isCopyMessageOnSend()) {\n                msg = (ActiveMQMessage)msg.copy();\n            }\n            msg.setConnection(connection);\n            msg.onSend();\n            msg.setProducerId(msg.getMessageId().getProducerId());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(getSessionId() + \" sending message: \" + msg);\n            }\n            if (onComplete==null && sendTimeout <= 0 && !msg.isResponseRequired() && !connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {\n                this.connection.asyncSendPacket(msg);\n                if (producerWindow != null) {\n                    // Since we defer lots of the marshaling till we hit the\n                    // wire, this might not\n                    // provide and accurate size. We may change over to doing\n                    // more aggressive marshaling,\n                    // to get more accurate sizes.. this is more important once\n                    // users start using producer window\n                    // flow control.\n                    int size = msg.getSize();\n                    producerWindow.increaseUsage(size);\n                }\n            } else {\n                if (sendTimeout > 0 && onComplete==null) {\n                    this.connection.syncSendPacket(msg,sendTimeout);\n                }else {\n                    this.connection.syncSendPacket(msg, onComplete);\n                }\n            }\n\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.toString": "    public String toString() {\n        return \"ActiveMQSession {id=\" + info.getSessionId() + \",started=\" + started.get() + \"}\";\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.checkClosed": "    protected void checkClosed() throws IllegalStateException {\n        if (closed) {\n            throw new IllegalStateException(\"The Session is closed\");\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.getSessionId": "    protected SessionId getSessionId() {\n        return info.getSessionId();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.syncSendPacket": "    public Response syncSendPacket(Command command) throws JMSException {\n        return connection.syncSendPacket(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.asyncSendPacket": "    public void asyncSendPacket(Command command) throws JMSException {\n        connection.asyncSendPacket(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQSession.doStartTransaction": "    protected void doStartTransaction() throws JMSException {\n        if (getTransacted() && !transactionContext.isInXATransaction()) {\n            transactionContext.begin();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageProducer.send": "    public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive, AsyncCallback onComplete) throws JMSException {\n        checkClosed();\n        if (destination == null) {\n            if (info.getDestination() == null) {\n                throw new UnsupportedOperationException(\"A destination must be specified.\");\n            }\n            throw new InvalidDestinationException(\"Don't understand null destinations\");\n        }\n\n        ActiveMQDestination dest;\n        if (destination.equals(info.getDestination())) {\n            dest = (ActiveMQDestination)destination;\n        } else if (info.getDestination() == null) {\n            dest = ActiveMQDestination.transform(destination);\n        } else {\n            throw new UnsupportedOperationException(\"This producer can only send messages to: \" + this.info.getDestination().getPhysicalName());\n        }\n        if (dest == null) {\n            throw new JMSException(\"No destination specified\");\n        }\n\n        if (transformer != null) {\n            Message transformedMessage = transformer.producerTransform(session, this, message);\n            if (transformedMessage != null) {\n                message = transformedMessage;\n            }\n        }\n\n        if (producerWindow != null) {\n            try {\n                producerWindow.waitForSpace();\n            } catch (InterruptedException e) {\n                throw new JMSException(\"Send aborted due to thread interrupt.\");\n            }\n        }\n\n        this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow, sendTimeout, onComplete);\n\n        stats.onMessage();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageProducer.checkClosed": "    protected void checkClosed() throws IllegalStateException {\n        if (closed) {\n            throw new IllegalStateException(\"The producer is closed\");\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageProducer.getDestination": "    public Destination getDestination() throws JMSException {\n        checkClosed();\n        return this.info.getDestination();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageProducerSupport.send": "    public void send(Destination destination, Message message) throws JMSException {\n        this.send(destination,\n                  message,\n                  this.defaultDeliveryMode,\n                  this.defaultPriority,\n                  this.defaultTimeToLive);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.util.IOExceptionSupport.create": "    public static IOException create(Exception cause) {\n        IOException exception = new IOException(cause.getMessage());\n        exception.initCause(cause);\n        return exception;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.getConnection": "    public ActiveMQConnection getConnection() {\n        return connection;\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doAddMessage": "    public void doAddMessage(TransactionContext c, long sequence, MessageId messageID, ActiveMQDestination destination, byte[] data,\n                             long expiration, byte priority, XATransactionId xid) throws SQLException, IOException {\n        PreparedStatement s = c.getAddMessageStatement();\n        cleanupExclusiveLock.readLock().lock();\n        try {\n            if (s == null) {\n                s = c.getConnection().prepareStatement(this.statements.getAddMessageStatement());\n                if (this.batchStatments) {\n                    c.setAddMessageStatement(s);\n                }\n            }\n            s.setLong(1, sequence);\n            s.setString(2, messageID.getProducerId().toString());\n            s.setLong(3, messageID.getProducerSequenceId());\n            s.setString(4, destination.getQualifiedName());\n            s.setLong(5, expiration);\n            s.setLong(6, priority);\n            setBinaryData(s, 7, data);\n            if (xid != null) {\n                byte[] xidVal = xid.getEncodedXidBytes();\n                xidVal[0] = '+';\n                String xidString = printBase64Binary(xidVal);\n                s.setString(8, xidString);\n            } else {\n                s.setString(8, null);\n            }\n            if (this.batchStatments) {\n                s.addBatch();\n            } else if (s.executeUpdate() != 1) {\n                throw new SQLException(\"Failed add a message\");\n            }\n        } finally {\n            cleanupExclusiveLock.readLock().unlock();\n            if (!this.batchStatments) {\n                if (s != null) {\n                    s.close();\n                }\n            }\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.setBinaryData": "    protected void setBinaryData(PreparedStatement s, int index, byte data[]) throws SQLException {\n        s.setBytes(index, data);\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.close": "    protected static void close(ResultSet rs) {\n        try {\n            rs.close();\n        } catch (Throwable e) {\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage": "    public void addMessage(ConnectionContext context, Message message) throws IOException {\n        MessageId messageId = message.getMessageId();\n        if (audit != null && audit.isDuplicate(message)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(destination.getPhysicalName()\n                    + \" ignoring duplicated (add) message, already stored: \"\n                    + messageId);\n            }\n            return;\n        }\n        \n        long sequenceId = persistenceAdapter.getNextSequenceId();\n        \n        // Serialize the Message..\n        byte data[];\n        try {\n            ByteSequence packet = wireFormat.marshal(message);\n            data = ByteSequenceData.toByteArray(packet);\n        } catch (IOException e) {\n            throw IOExceptionSupport.create(\"Failed to broker message: \" + messageId + \" in container: \" + e, e);\n        }\n\n        // Get a connection and insert the message into the DB.\n        TransactionContext c = persistenceAdapter.getTransactionContext(context);\n        try {      \n            adapter.doAddMessage(c, sequenceId, messageId, destination, data, message.getExpiration(),\n                    this.isPrioritizedMessages() ? message.getPriority() : 0, context != null ? context.getXid() : null);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to broker message: \" + messageId + \" in container: \" + e, e);\n        } finally {\n            c.close();\n        }\n        if (context != null && context.getXid() != null) {\n            message.getMessageId().setEntryLocator(sequenceId);\n        } else {\n            onAdd(messageId, sequenceId, message.getPriority());\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCMessageStore.onAdd": "    protected void onAdd(MessageId messageId, long sequenceId, byte priority) {\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.addMessage": "    void addMessage(final MessageStore destination, final Message message) throws IOException {\n\n        if (doingRecover) {\n            return;\n        }\n\n        if (message.getTransactionId() != null) {\n            Tx tx = getTx(message.getTransactionId());\n            tx.add(new AddMessageCommand() {\n                public Message getMessage() {\n                    return message;\n                }\n\n                @Override\n                public MessageStore getMessageStore() {\n                    return destination;\n                }\n\n                public void run(ConnectionContext ctx) throws IOException {\n                    destination.addMessage(ctx, message);\n                }\n\n            });\n        } else {\n            destination.addMessage(null, message);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.getTx": "    public Tx getTx(Object txid) {\n        Tx tx = inflightTransactions.get(txid);\n        if (tx == null) {\n            tx = new Tx();\n            inflightTransactions.put(txid, tx);\n        }\n        return tx;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.add": "        public void add(RemoveMessageCommand ack) {\n            acks.add(ack);\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.asyncAddTopicMessage": "            public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {\n                MemoryTransactionStore.this.addMessage(getDelegate(), message);\n                return AbstractMessageStore.FUTURE;\n             }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.doMessageSend": "    synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message)\n            throws IOException, Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        message.setRegionDestination(this);\n        message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n        Future<Object> result = null;\n\n        if (topicStore != null && message.isPersistent() && !canOptimizeOutPersistence()) {\n            if (systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {\n                final String logMessage = \"Persistent store is Full, \" + getStoreUsageHighWaterMark() + \"% of \"\n                        + systemUsage.getStoreUsage().getLimit() + \". Stopping producer (\" + message.getProducerId()\n                        + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                        + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new javax.jms.ResourceAllocationException(logMessage);\n                }\n\n                waitForSpace(context,producerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);\n            }\n            result = topicStore.asyncAddTopicMessage(context, message,isOptimizeStorage());\n        }\n\n        message.incrementReferenceCount();\n\n        if (context.isInTransaction()) {\n            context.getTransaction().addSynchronization(new Synchronization() {\n                @Override\n                public void afterCommit() throws Exception {\n                    // It could take while before we receive the commit\n                    // operation.. by that time the message could have\n                    // expired..\n                    if (broker.isExpired(message)) {\n                        getDestinationStatistics().getExpired().increment();\n                        broker.messageExpired(context, message, null);\n                        message.decrementReferenceCount();\n                        return;\n                    }\n                    try {\n                        dispatch(context, message);\n                    } finally {\n                        message.decrementReferenceCount();\n                    }\n                }\n            });\n\n        } else {\n            try {\n                dispatch(context, message);\n            } finally {\n                message.decrementReferenceCount();\n            }\n        }\n\n        if (result != null && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.canOptimizeOutPersistence": "    private boolean canOptimizeOutPersistence() {\n        return durableSubscribers.size() == 0;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.dispatch": "    protected void dispatch(final ConnectionContext context, Message message) throws Exception {\n        // AMQ-2586: Better to leave this stat at zero than to give the user\n        // misleading metrics.\n        // destinationStatistics.getMessages().increment();\n        destinationStatistics.getEnqueues().increment();\n        MessageEvaluationContext msgContext = null;\n\n        dispatchLock.readLock().lock();\n        try {\n            if (!subscriptionRecoveryPolicy.add(context, message)) {\n                return;\n            }\n            synchronized (consumers) {\n                if (consumers.isEmpty()) {\n                    onMessageWithNoConsumers(context, message);\n                    return;\n                }\n            }\n            msgContext = context.getMessageEvaluationContext();\n            msgContext.setDestination(destination);\n            msgContext.setMessageReference(message);\n            if (!dispatchPolicy.dispatch(message, msgContext, consumers)) {\n                onMessageWithNoConsumers(context, message);\n            }\n\n        } finally {\n            dispatchLock.readLock().unlock();\n            if (msgContext != null) {\n                msgContext.clear();\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        broker.messageExpired(context, reference, subs);\n        // AMQ-2586: Better to leave this stat at zero than to give the user\n        // misleading metrics.\n        // destinationStatistics.getMessages().decrement();\n        destinationStatistics.getExpired().increment();\n        MessageAck ack = new MessageAck();\n        ack.setAckType(MessageAck.STANDARD_ACK_TYPE);\n        ack.setDestination(destination);\n        ack.setMessageID(reference.getMessageId());\n        try {\n            if (subs instanceof DurableTopicSubscription) {\n                ((DurableTopicSubscription)subs).removePending(reference);\n            }\n            acknowledge(context, subs, ack, reference);\n        } catch (Exception e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.isOptimizeStorage": "    protected boolean isOptimizeStorage(){\n        boolean result = false;\n\n        if (isDoOptimzeMessageStorage() && durableSubscribers.isEmpty()==false){\n                result = true;\n                for (DurableTopicSubscription s : durableSubscribers.values()) {\n                    if (s.isActive()== false){\n                        result = false;\n                        break;\n                    }\n                    if (s.getPrefetchSize()==0){\n                        result = false;\n                        break;\n                    }\n                    if (s.isSlowConsumer()){\n                        result = false;\n                        break;\n                    }\n                    if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){\n                        result = false;\n                        break;\n                    }\n                }\n        }\n        return result;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.send": "    public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n\n        final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();\n        producerExchange.incrementSend();\n        final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0\n                && !context.isInRecoveryMode();\n\n        // There is delay between the client sending it and it arriving at the\n        // destination.. it may have expired.\n        if (message.isExpired()) {\n            broker.messageExpired(context, message, null);\n            getDestinationStatistics().getExpired().increment();\n            if (sendProducerAck) {\n                ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n                context.getConnection().dispatchAsync(ack);\n            }\n            return;\n        }\n\n        if (memoryUsage.isFull()) {\n            isFull(context, memoryUsage);\n            fastProducer(context, producerInfo);\n\n            if (isProducerFlowControl() && context.isProducerFlowControl()) {\n\n                if (warnOnProducerFlowControl) {\n                    warnOnProducerFlowControl = false;\n                    LOG.info(memoryUsage + \", Usage Manager memory limit reached for \"\n                                    + getActiveMQDestination().getQualifiedName()\n                                    + \". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it.\"\n                                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new javax.jms.ResourceAllocationException(\"Usage Manager memory limit (\"\n                            + memoryUsage.getLimit() + \") reached. Rejecting send for producer (\" + message.getProducerId()\n                            + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                            + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                // We can avoid blocking due to low usage if the producer is sending a sync message or\n                // if it is using a producer window\n                if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {\n                    synchronized (messagesWaitingForSpace) {\n                        messagesWaitingForSpace.add(new Runnable() {\n                            @Override\n                            public void run() {\n                                try {\n\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        broker.messageExpired(context, message, null);\n                                        getDestinationStatistics().getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchange, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n                                }\n                            }\n                        });\n\n                        registerCallbackForNotFullNotification();\n                        context.setDontSendReponse(true);\n                        return;\n                    }\n\n                } else {\n                    // Producer flow control cannot be used, so we have do the flow control\n                    // at the broker by blocking this thread until there is space available.\n\n                    if (memoryUsage.isFull()) {\n                        if (context.isInTransaction()) {\n\n                            int count = 0;\n                            while (!memoryUsage.waitForSpace(1000)) {\n                                if (context.getStopping().get()) {\n                                    throw new IOException(\"Connection closed, send aborted.\");\n                                }\n                                if (count > 2 && context.isInTransaction()) {\n                                    count = 0;\n                                    int size = context.getTransaction().size();\n                                    LOG.warn(\"Waiting for space to send  transacted message - transaction elements = \"\n                                            + size + \" need more space to commit. Message = \" + message);\n                                }\n                                count++;\n                            }\n                        } else {\n                            waitForSpace(\n                                    context,\n                                    producerExchange,\n                                    memoryUsage,\n                                    \"Usage Manager Memory Usage limit reached. Stopping producer (\"\n                                            + message.getProducerId()\n                                            + \") to prevent flooding \"\n                                            + getActiveMQDestination().getQualifiedName()\n                                            + \".\"\n                                            + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                        }\n                    }\n\n                    // The usage manager could have delayed us by the time\n                    // we unblock the message could have expired..\n                    if (message.isExpired()) {\n                        getDestinationStatistics().getExpired().increment();\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Expired message: \" + message);\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n\n        doMessageSend(producerExchange, message);\n        messageDelivered(context, message);\n        if (sendProducerAck) {\n            ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n            context.getConnection().dispatchAsync(ack);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.send": "    public void send(final ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n\n        if (producerExchange.isMutable() || producerExchange.getRegionDestination() == null) {\n            final Destination regionDestination = lookup(context, messageSend.getDestination(),false);\n            producerExchange.setRegionDestination(regionDestination);\n        }\n\n        producerExchange.getRegionDestination().send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.lookup": "    protected Destination lookup(ConnectionContext context, ActiveMQDestination destination,boolean createTemporary) throws Exception {\n        Destination dest = null;\n\n        destinationsLock.readLock().lock();\n        try {\n            dest = destinations.get(destination);\n        } finally {\n            destinationsLock.readLock().unlock();\n        }\n\n        if (dest == null) {\n            if (isAutoCreateDestinations()) {\n                // Try to auto create the destination... re-invoke broker\n                // from the\n                // top so that the proper security checks are performed.\n                context.getBroker().addDestination(context, destination, createTemporary);\n                dest = addDestination(context, destination, false);\n                // We should now have the dest created.\n                destinationsLock.readLock().lock();\n                try {\n                    dest = destinations.get(destination);\n                } finally {\n                    destinationsLock.readLock().unlock();\n                }\n            }\n\n            if (dest == null) {\n                throw new JMSException(\"The destination \" + destination + \" does not exist.\");\n            }\n        }\n        return dest;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        message.setBrokerInTime(System.currentTimeMillis());\n        if (producerExchange.isMutable() || producerExchange.getRegion() == null\n            || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {\n            // ensure the destination is registered with the RegionBroker\n            producerExchange.getConnectionContext().getBroker()\n                .addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());\n            producerExchange.setRegion(getRegion(destination));\n            producerExchange.setRegionDestination(null);\n        }\n\n        producerExchange.getRegion().send(producerExchange, message);\n\n        // clean up so these references aren't kept (possible leak) in the producer exchange\n        // especially since temps are transitory\n        if (producerExchange.isMutable()) {\n            producerExchange.setRegionDestination(null);\n            producerExchange.setRegion(null);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getRegion": "    protected Region getRegion(ActiveMQDestination destination) throws JMSException {\n        switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                return queueRegion;\n            case ActiveMQDestination.TOPIC_TYPE:\n                return topicRegion;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                return tempQueueRegion;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                return tempTopicRegion;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {\n\n        Destination answer;\n\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n        synchronized (destinationGate) {\n            answer = destinations.get(destination);\n            if (answer != null) {\n                return answer;\n            }\n\n            if (destinationGate.get(destination) != null) {\n                // Guard against spurious wakeup.\n                while (destinationGate.containsKey(destination)) {\n                    destinationGate.wait();\n                }\n                answer = destinations.get(destination);\n                if (answer != null) {\n                    return answer;\n                } else {\n                    // In case of intermediate remove or add failure\n                    destinationGate.put(destination, destination);\n                }\n            }\n        }\n\n        try {\n            boolean create = true;\n            if (destination.isTemporary()) {\n                create = createIfTemp;\n            }\n            answer = getRegion(destination).addDestination(context, destination, create);\n            destinations.put(destination, answer);\n        } finally {\n            synchronized (destinationGate) {\n                destinationGate.remove(destination);\n                destinationGate.notifyAll();\n            }\n        }\n\n        return answer;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.isAllowTempAutoCreationOnSend": "    public boolean isAllowTempAutoCreationOnSend() {\n        return allowTempAutoCreationOnSend;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        next.send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.CompositeDestinationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        if (destination.isComposite()) {\n            ActiveMQDestination[] destinations = destination.getCompositeDestinations();\n            for (int i = 0; i < destinations.length; i++) {\n                if (i != 0) {\n                    message = message.copy();\n                    message.setMemoryUsage(null);\n                }\n                message.setOriginalDestination(destination);\n                message.setDestination(destinations[i]);\n                next.send(producerExchange, message);\n            }\n        } else {\n            next.send(producerExchange, message);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        Synchronization sync = null;\n        if (message.getTransactionId() != null) {\n            transaction = getTransaction(context, message.getTransactionId(), false);\n            if (transaction != null) {\n                sync = new Synchronization() {\n\n                    public void afterRollback() {\n                        if (audit != null) {\n                            audit.rollback(message);\n                        }\n                    }\n                };\n                transaction.addSynchronization(sync);\n            }\n        }\n        if (audit == null || !audit.isDuplicate(message)) {\n            context.setTransaction(transaction);\n            try {\n                next.send(producerExchange, message);\n            } finally {\n                context.setTransaction(originalTx);\n            }\n        } else {\n            if (sync != null && transaction != null) {\n                transaction.removeSynchronization(sync);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"IGNORING duplicate message \" + message);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = new XAException(\"Transaction '\" + xid + \"' has not been started.\");\n            e.errorCode = XAException.XAER_NOTA;\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processMessage": "    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getProducerBrokerExchange": "    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.ActiveMQMessage.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessage(this);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (responseRequired) {\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \" + e, e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    Response response = service(command);\n                    if (response != null && !brokerService.isStopping() ) {\n                        dispatchSync(response);\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.isStopping": "    public boolean isStopping() {\n        return stopping.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        this.sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            this.sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageProducer.getMessageSequence": "    protected long getMessageSequence() {\n        return messageSequence.incrementAndGet();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transactionContext.getTransactionId": "    public TransactionId getTransactionId() {\n        return transactionId;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageTransformation.transformMessage": "    public static ActiveMQMessage transformMessage(Message message, ActiveMQConnection connection)\n        throws JMSException {\n        if (message instanceof ActiveMQMessage) {\n            return (ActiveMQMessage)message;\n\n        } else {\n            ActiveMQMessage activeMessage = null;\n\n            if (message instanceof BytesMessage) {\n                BytesMessage bytesMsg = (BytesMessage)message;\n                bytesMsg.reset();\n                ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n                msg.setConnection(connection);\n                try {\n                    for (;;) {\n                        // Reads a byte from the message stream until the stream\n                        // is empty\n                        msg.writeByte(bytesMsg.readByte());\n                    }\n                } catch (MessageEOFException e) {\n                    // if an end of message stream as expected\n                } catch (JMSException e) {\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof MapMessage) {\n                MapMessage mapMsg = (MapMessage)message;\n                ActiveMQMapMessage msg = new ActiveMQMapMessage();\n                msg.setConnection(connection);\n                Enumeration iter = mapMsg.getMapNames();\n\n                while (iter.hasMoreElements()) {\n                    String name = iter.nextElement().toString();\n                    msg.setObject(name, mapMsg.getObject(name));\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof ObjectMessage) {\n                ObjectMessage objMsg = (ObjectMessage)message;\n                ActiveMQObjectMessage msg = new ActiveMQObjectMessage();\n                msg.setConnection(connection);\n                msg.setObject(objMsg.getObject());\n                msg.storeContent();\n                activeMessage = msg;\n            } else if (message instanceof StreamMessage) {\n                StreamMessage streamMessage = (StreamMessage)message;\n                streamMessage.reset();\n                ActiveMQStreamMessage msg = new ActiveMQStreamMessage();\n                msg.setConnection(connection);\n                Object obj = null;\n\n                try {\n                    while ((obj = streamMessage.readObject()) != null) {\n                        msg.writeObject(obj);\n                    }\n                } catch (MessageEOFException e) {\n                    // if an end of message stream as expected\n                } catch (JMSException e) {\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof TextMessage) {\n                TextMessage textMsg = (TextMessage)message;\n                ActiveMQTextMessage msg = new ActiveMQTextMessage();\n                msg.setConnection(connection);\n                msg.setText(textMsg.getText());\n                activeMessage = msg;\n            } else if (message instanceof BlobMessage) {\n            \tBlobMessage blobMessage = (BlobMessage)message;\n            \tActiveMQBlobMessage msg = new ActiveMQBlobMessage();\n            \tmsg.setConnection(connection);\n            \tmsg.setBlobDownloader(new BlobDownloader(connection.getBlobTransferPolicy()));\n            \ttry {\n\t\t\t\t\tmsg.setURL(blobMessage.getURL());\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\n\t\t\t\t}\n            \tactiveMessage = msg;\n            } else {\n                activeMessage = new ActiveMQMessage();\n                activeMessage.setConnection(connection);\n            }\n\n            copyProperties(message, activeMessage);\n\n            return activeMessage;\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageTransformation.copyProperties": "    public static void copyProperties(Message fromMessage, Message toMessage) throws JMSException {\n        toMessage.setJMSMessageID(fromMessage.getJMSMessageID());\n        toMessage.setJMSCorrelationID(fromMessage.getJMSCorrelationID());\n        toMessage.setJMSReplyTo(transformDestination(fromMessage.getJMSReplyTo()));\n        toMessage.setJMSDestination(transformDestination(fromMessage.getJMSDestination()));\n        toMessage.setJMSDeliveryMode(fromMessage.getJMSDeliveryMode());\n        toMessage.setJMSRedelivered(fromMessage.getJMSRedelivered());\n        toMessage.setJMSType(fromMessage.getJMSType());\n        toMessage.setJMSExpiration(fromMessage.getJMSExpiration());\n        toMessage.setJMSPriority(fromMessage.getJMSPriority());\n        toMessage.setJMSTimestamp(fromMessage.getJMSTimestamp());\n\n        Enumeration propertyNames = fromMessage.getPropertyNames();\n\n        while (propertyNames.hasMoreElements()) {\n            String name = propertyNames.nextElement().toString();\n            Object obj = fromMessage.getObjectProperty(name);\n            toMessage.setObjectProperty(name, obj);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.ActiveMQMessageProducer.getProducerInfo": "    protected ProducerInfo getProducerInfo() {\n        return this.info != null ? this.info : null;\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.close": "    public void close() throws IOException {\n        if (!inTx) {\n            try {\n\n                /**\n                 * we are not in a transaction so should not be committing ??\n                 * This was previously commented out - but had adverse affects\n                 * on testing - so it's back!\n                 * \n                 */\n                try {\n                    executeBatch();\n                } finally {\n                    if (connection != null && !connection.getAutoCommit()) {\n                        connection.commit();\n                    }\n                }\n\n            } catch (SQLException e) {\n                JDBCPersistenceAdapter.log(\"Error while closing connection: \", e);\n                throw IOExceptionSupport.create(e);\n            } finally {\n                try {\n                    if (connection != null) {\n                        connection.close();\n                    }\n                } catch (Throwable e) {\n                    LOG.warn(\"Close failed: \" + e.getMessage(), e);\n                } finally {\n                    connection = null;\n                }\n            }\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.commit": "    public void commit() throws IOException {\n        if (!inTx) {\n            throw new IOException(\"Not started.\");\n        }\n        try {\n            executeBatch();\n            if (!connection.getAutoCommit()) {\n                connection.commit();\n            }\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"Commit failed: \", e);\n            \n            this.rollback(); \n            \n            throw IOExceptionSupport.create(e);\n        } finally {\n            inTx = false;\n            close();\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.executeBatch": "    private void executeBatch(PreparedStatement p, String message) throws SQLException {\n        if (p == null) {\n            return;\n        }\n\n        try {\n            int[] rc = p.executeBatch();\n            for (int i = 0; i < rc.length; i++) {\n                int code = rc[i];\n                if (code < 0 && code != Statement.SUCCESS_NO_INFO) {\n                    throw new SQLException(message + \". Response code: \" + code);\n                }\n            }\n        } finally {\n            try {\n                p.close();\n            } catch (Throwable e) {\n            }\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.log": "    public static void log(String msg, SQLException e) {\n        String s = msg + e.getMessage();\n        while (e.getNextException() != null) {\n            e = e.getNextException();\n            s += \", due to: \" + e.getMessage();\n        }\n        LOG.warn(s, e);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.canDispatch": "    public boolean canDispatch(Message messageSend) {\n        boolean canDispatch = true;\n        if (auditProducerSequenceIds && messageSend.isPersistent()) {\n            final long producerSequenceId = messageSend.getMessageId().getProducerSequenceId();\n            if (isNetworkProducer) {\n                //  messages are multiplexed on this producer so we need to query the persistenceAdapter\n                long lastStoredForMessageProducer = getStoredSequenceIdForMessage(messageSend.getMessageId());\n                if (producerSequenceId <= lastStoredForMessageProducer) {\n                    canDispatch = false;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"suppressing duplicate message send  [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] from network producer with producerSequenceId [\"\n                                + producerSequenceId + \"] less than last stored: \" + lastStoredForMessageProducer);\n                    }\n                }\n            } else if (producerSequenceId <= lastSendSequenceNumber.get()) {\n                canDispatch = false;\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"suppressing duplicate message send [\" + (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()) + \"] with producerSequenceId [\"\n                            + producerSequenceId + \"] less than last stored: \" + lastSendSequenceNumber);\n                }\n            } else {\n                // track current so we can suppress duplicates later in the stream\n                lastSendSequenceNumber.set(producerSequenceId);\n            }\n        }\n        return canDispatch;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getStoredSequenceIdForMessage": "    private long getStoredSequenceIdForMessage(MessageId messageId) {\n        try {\n            return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());\n        } catch (IOException ignored) {\n            LOG.debug(\"Failed to determine last producer sequence id for: \" + messageId, ignored);\n        }\n        return -1;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "JDBCPersistence DB stopped during message send with JDBCIOExceptionHandler configured; IOException/SQLException is sent back (sometimes) to the client before the transport connector is shutdown",
            "Description": "This related to AMQ-4636 JIRA for gtully's second point in comment https://issues.apache.org/jira/browse/AMQ-4636?focusedCommentId=13712196&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13712196\n\nScenario:\n- Producer sending persistent message (no transaction)\n- JDBCIOExceptionHandler is configured \n- the underlying DB is shutdown during message send\n\nResult:\nOne of two outcomes can happen:\n1) the broker sends the an IOException/SQLException wrapped in a JMSException (below) back to the client and then shuts down the transport connectors.\n2) the broker shuts down the transport connector when the IOException/SQLException is encountered.\n\nExpected behavior:\nAs the JDBCIOHandler is configured which is handling the SQL exception, it would be good if the transport connectors were shutdown and no IOException/SQLException is reported to producer.\n\n{code}\n2013-07-19 15:22:05,436 [main           ] - ERROR pDBDuringProducerSendTopicTest - unexpected exception caught\njavax.jms.JMSException: Database &apos;target/derbydb_15&apos; not found.\n\tat org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:54)\n\tat org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1391)\n\tat org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1319)\n\tat org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1809)\n\tat org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:289)\n\tat org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:224)\n\tat org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:241)\n\tat org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest.sendMessage(StopDBDuringProducerSendTopicTest.java:150)\n\tat org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest.testProducerWithDBShutdown(StopDBDuringProducerSendTopicTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84)\n\tat org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)\n\tat org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)\n\tat org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)\n\tat org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:81)\n\tat org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)\nCaused by: java.io.IOException: Database &apos;target/derbydb_15&apos; not found.\n\tat org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:45)\n\tat org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:68)\n\tat org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doAddMessage(DefaultJDBCAdapter.java:218)\n\tat org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage(JDBCMessageStore.java:123)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore.addMessage(MemoryTransactionStore.java:327)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore$2.asyncAddTopicMessage(MemoryTransactionStore.java:190)\n\tat org.apache.activemq.broker.region.Topic.doMessageSend(Topic.java:482)\n\tat org.apache.activemq.broker.region.Topic.send(Topic.java:446)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:406)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:431)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:147)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:317)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:152)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:464)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:751)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:294)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:680)\nCaused by: java.sql.SQLException: Database &apos;target/derbydb_15&apos; not found.\n\tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection.newSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection.handleDBNotFound(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection.&lt;init&gt;(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection30.&lt;init&gt;(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedConnection40.&lt;init&gt;(Unknown Source)\n\tat org.apache.derby.jdbc.Driver40.getNewEmbedConnection(Unknown Source)\n\tat org.apache.derby.jdbc.InternalDriver.connect(Unknown Source)\n\tat org.apache.derby.jdbc.EmbeddedDataSource.getConnection(Unknown Source)\n\tat org.apache.derby.jdbc.EmbeddedDataSource.getConnection(Unknown Source)\n\tat org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest$ReconnectingEmbeddedDataSource.getConnection(StopDBDuringProducerSendTopicTest.java:242)\n\tat org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)\n\t... 23 more\nCaused by: java.lang.Throwable: org.apache.derby.impl.jdbc.EmbedSQLException: Database &apos;target/derbydb_15&apos; not found.\n\tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\n\tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\n\t... 38 more\n{code}"
        }
    },
    {
        "filename": "AMQ-2902.json",
        "creation_time": "2010-09-07T11:34:15.000+0000",
        "stack_trace": "at org.apache.activemq.transport.vm.VMTransport.stop(VMTransport.java:159)\n\tat org.apache.activemq.transport.vm.VMTransportServer$1.stop(VMTransportServer.java:81)\n\tat org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)\n\tat org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)\n\tat org.apache.activemq.transport.ResponseCorrelator.stop(ResponseCorrelator.java:132)\n\tat org.apache.activemq.util.ServiceSupport.dispose(ServiceSupport.java:43)\n\tat org.apache.activemq.ActiveMQConnection.close(ActiveMQConnection.java:656)\n\tat org.apache.activemq.ra.ActiveMQManagedConnection.destroy(ActiveMQManagedConnection.java:207)\n\tat org.jboss.resource.connectionmanager.InternalManagedConnectionPool.doDestroy(InternalManagedConnectionPool.java:650)\n\tat org.jboss.resource.connectionmanager.InternalManagedConnectionPool.removeTimedOut(InternalManagedConnectionPool.java:481)\n\tat org.jboss.resource.connectionmanager.IdleRemover$IdleRemoverRunnable.run(IdleRemover.java:164)\n\tat java.lang.Thread.run(Thread.java:619)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.stop": "    public void stop() throws Exception {\n        stopping.set(true);\n        \n        // If stop() is called while being start()ed.. then we can't stop until we return to the start() method.\n        if( enqueueValve.isOn() ) {\n        \t\n            // let the peer know that we are disconnecting..\n            try {\n            \tpeer.transportListener.onException(new TransportDisposedIOException(\"Peer (\" + peer.toString() + \") disposed.\"));\n            } catch (Exception ignore) {\n            }\n        \t\n        \t\n            TaskRunner tr = null;\n            try {\n                enqueueValve.turnOff();\n                if (!disposed) {\n                    started = false;\n                    disposed = true;\n                    if (taskRunner != null) {\n                        tr = taskRunner;\n                        taskRunner = null;\n                    }\n                }\n            } finally {\n                stopping.set(false);\n                enqueueValve.turnOn();\n            }\n            if (tr != null) {\n                tr.shutdown(1000);\n            }\n            \n\n        }\n        \n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransport.toString": "    public String toString() {\n        return location + \"#\" + id;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransportServer.stop": "    public void stop() throws IOException {\n        VMTransportFactory.stopped(this);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportFilter.stop": "    public void stop() throws Exception {\n        next.stop();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.ResponseCorrelator.stop": "    public void stop() throws Exception {\n        dispose(new IOException(\"Stopped.\"));\n        super.stop();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.ResponseCorrelator.dispose": "    private void dispose(IOException error) {\n        ArrayList<FutureResponse> requests=null; \n        synchronized(requestMap) {\n            if( this.error==null) {\n                this.error = error;\n                requests = new ArrayList<FutureResponse>(requestMap.values());\n                requestMap.clear();\n            }\n        }\n        if( requests!=null ) {\n            for (Iterator<FutureResponse> iter = requests.iterator(); iter.hasNext();) {\n                FutureResponse fr = iter.next();\n                fr.set(new ExceptionResponse(error));\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.util.ServiceSupport.dispose": "    public static void dispose(Service service) {\n        try {\n            service.stop();\n        } catch (Exception e) {\n            LOG.debug(\"Could not stop service: \" + service + \". Reason: \" + e, e);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.util.ServiceSupport.stop": "    public void stop() throws Exception {\n        if (stopped.compareAndSet(false, true)) {\n            stopping.set(true);\n            ServiceStopper stopper = new ServiceStopper();\n            try {\n                doStop(stopper);\n            } catch (Exception e) {\n                stopper.onException(this, e);\n            }\n            stopped.set(true);\n            started.set(false);\n            stopping.set(false);\n            for(ServiceListener l:this.serviceListeners) {\n                l.stopped(this);\n            }\n            stopper.throwFirstException();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQConnection.close": "    public void close() throws JMSException {\n        try {\n            // If we were running, lets stop first.\n            if (!closed.get() && !transportFailed.get()) {\n                stop();\n            }\n\n            synchronized (this) {\n                if (!closed.get()) {\n                    closing.set(true);\n\n                    if (destinationSource != null) {\n                        destinationSource.stop();\n                        destinationSource = null;\n                    }\n                    if (advisoryConsumer != null) {\n                        advisoryConsumer.dispose();\n                        advisoryConsumer = null;\n                    }\n                    if (this.scheduler != null) {\n                        try {\n                            this.scheduler.stop();\n                        } catch (Exception e) {\n                            JMSException ex =  JMSExceptionSupport.create(e);\n                            throw ex;\n                        }\n                    }\n\n                    long lastDeliveredSequenceId = 0;\n                    for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {\n                        ActiveMQSession s = i.next();\n                        s.dispose();\n                        lastDeliveredSequenceId = Math.max(lastDeliveredSequenceId, s.getLastDeliveredSequenceId());\n                    }\n                    for (Iterator<ActiveMQConnectionConsumer> i = this.connectionConsumers.iterator(); i.hasNext();) {\n                        ActiveMQConnectionConsumer c = i.next();\n                        c.dispose();\n                    }\n                    for (Iterator<ActiveMQInputStream> i = this.inputStreams.iterator(); i.hasNext();) {\n                        ActiveMQInputStream c = i.next();\n                        c.dispose();\n                    }\n                    for (Iterator<ActiveMQOutputStream> i = this.outputStreams.iterator(); i.hasNext();) {\n                        ActiveMQOutputStream c = i.next();\n                        c.dispose();\n                    }\n\n                    if (isConnectionInfoSentToBroker) {\n                        // If we announced ourselfs to the broker.. Try to let\n                        // the broker\n                        // know that the connection is being shutdown.\n                        RemoveInfo removeCommand = info.createRemoveCommand();\n                        removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);\n                        doSyncSendPacket(info.createRemoveCommand(), closeTimeout);\n                        doAsyncSendPacket(new ShutdownInfo());\n                    }\n\n                    ServiceSupport.dispose(this.transport);\n\n                    started.set(false);\n\n                    // TODO if we move the TaskRunnerFactory to the connection\n                    // factory\n                    // then we may need to call\n                    // factory.onConnectionClose(this);\n                    if (sessionTaskRunner != null) {\n                        sessionTaskRunner.shutdown();\n                    }\n                    closed.set(true);\n                    closing.set(false);\n                }\n            }\n        } finally {\n            try {\n                if (executor != null){\n                    executor.shutdown();\n                }\n            }catch(Throwable e) {\n                LOG.error(\"Error shutting down thread pool \" + e,e);\n            }\n            factoryStats.removeConnection(this);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQConnection.stop": "    public void stop() throws JMSException {\n        checkClosedOrFailed();\n        if (started.compareAndSet(true, false)) {\n            synchronized(sessions) {\n                for (Iterator<ActiveMQSession> i = sessions.iterator(); i.hasNext();) {\n                    ActiveMQSession s = i.next();\n                    s.stop();\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQConnection.doSyncSendPacket": "\tprivate Response doSyncSendPacket(Command command, int timeout)\n\t\t\tthrows JMSException {\n\t\ttry {\n\t\t    Response response = (Response)this.transport.request(command, timeout);\n\t\t    if (response != null && response.isException()) {\n\t\t        ExceptionResponse er = (ExceptionResponse)response;\n\t\t        if (er.getException() instanceof JMSException) {\n\t\t            throw (JMSException)er.getException();\n\t\t        } else {\n\t\t            throw JMSExceptionSupport.create(er.getException());\n\t\t        }\n\t\t    }\n\t\t    return response;\n\t\t} catch (IOException e) {\n\t\t    throw JMSExceptionSupport.create(e);\n\t\t}\n\t}",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQConnection.doAsyncSendPacket": "\tprivate void doAsyncSendPacket(Command command) throws JMSException {\n\t\ttry {\n\t\t    this.transport.oneway(command);\n\t\t} catch (IOException e) {\n\t\t    throw JMSExceptionSupport.create(e);\n\t\t}\n\t}",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransportFactory.stopped": "    public static void stopped(String host) {\n        SERVERS.remove(host);\n        TransportConnector connector = CONNECTORS.remove(host);\n        if (connector != null) {\n            LOG.debug(\"Shutting down VM connectors for broker: \" + host);\n            ServiceSupport.dispose(connector);\n            BrokerService broker = BROKERS.remove(host);\n            if (broker != null) {\n                ServiceSupport.dispose(broker);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.vm.VMTransportFactory.extractHost": "   private static String extractHost(URI location) {\n       String host = location.getHost();\n       if (host == null || host.length() == 0) {\n           host = location.getAuthority();\n           if (host == null || host.length() == 0) {\n               host = \"localhost\";\n           }\n       }\n       return host;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.getLastDeliveredSequenceId": "    public long getLastDeliveredSequenceId() {\n        return lastDeliveredSequenceId;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.dispose": "    public synchronized void dispose() throws JMSException {\n        if (!closed) {\n\n            try {\n                executor.stop();\n\n                for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {\n                    ActiveMQMessageConsumer consumer = iter.next();\n                    consumer.setFailureError(connection.getFirstFailureError());\n                    consumer.dispose();\n                    lastDeliveredSequenceId = Math.max(lastDeliveredSequenceId, consumer.getLastDeliveredSequenceId());\n                }\n                consumers.clear();\n\n                for (Iterator<ActiveMQMessageProducer> iter = producers.iterator(); iter.hasNext();) {\n                    ActiveMQMessageProducer producer = iter.next();\n                    producer.dispose();\n                }\n                producers.clear();\n\n                try {\n                    if (getTransactionContext().isInLocalTransaction()) {\n                        rollback();\n                    }\n                } catch (JMSException e) {\n                }\n\n            } finally {\n                connection.removeSession(this);\n                this.transactionContext = null;\n                closed = true;\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.rollback": "    public void rollback() throws JMSException {\n        checkClosed();\n        if (!getTransacted()) {\n            throw new javax.jms.IllegalStateException(\"Not a transacted session\");\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(getSessionId() + \" Transaction Rollback\");\n        }\n        transactionContext.rollback();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.stop": "    protected void stop() throws JMSException {\n\n        for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {\n            ActiveMQMessageConsumer c = iter.next();\n            c.stop();\n        }\n\n        started.set(false);\n        executor.stop();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQSession.getTransactionContext": "    public TransactionContext getTransactionContext() {\n        return transactionContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.advisoryConsumer.dispose": "    public synchronized void dispose() {\n        if (!closed) {\n            try {\n                this.connection.asyncSendPacket(info.createRemoveCommand());\n            } catch (JMSException e) {\n                LOG.debug(\"Failed to send remove command: \" + e, e);\n            }\n            this.connection.removeDispatcher(info.getConsumerId());\n            closed = true;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.ActiveMQConnectionConsumer.dispose": "    public void dispose() {\n        if (!closed) {\n            this.connection.removeDispatcher(consumerInfo.getConsumerId());\n            this.connection.removeConnectionConsumer(this);\n            closed = true;\n        }\n    }"
        },
        "bug_report": {
            "Title": "ResourceAdapter logs confusing Exception upon pool connection disposal",
            "Description": "After upgrading to 5.4.0 we see many exceptions of the following kind being logged with level INFO:\n{quote}\n2010-09-07 13:23:25,824 INFO  [org.apache.activemq.broker.TransportConnection.Transport] Transport failed: org.apache.activemq.transport.TransportDisposedIOException: Peer (vm://caa.embedded?waitForStart=300000&async=false#13) disposed.\norg.apache.activemq.transport.TransportDisposedIOException: Peer (vm://caa.embedded?waitForStart=300000&async=false#13) disposed.\n\tat org.apache.activemq.transport.vm.VMTransport.stop(VMTransport.java:159)\n\tat org.apache.activemq.transport.vm.VMTransportServer$1.stop(VMTransportServer.java:81)\n\tat org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)\n\tat org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)\n\tat org.apache.activemq.transport.ResponseCorrelator.stop(ResponseCorrelator.java:132)\n\tat org.apache.activemq.util.ServiceSupport.dispose(ServiceSupport.java:43)\n\tat org.apache.activemq.ActiveMQConnection.close(ActiveMQConnection.java:656)\n\tat org.apache.activemq.ra.ActiveMQManagedConnection.destroy(ActiveMQManagedConnection.java:207)\n\tat org.jboss.resource.connectionmanager.InternalManagedConnectionPool.doDestroy(InternalManagedConnectionPool.java:650)\n\tat org.jboss.resource.connectionmanager.InternalManagedConnectionPool.removeTimedOut(InternalManagedConnectionPool.java:481)\n\tat org.jboss.resource.connectionmanager.IdleRemover$IdleRemoverRunnable.run(IdleRemover.java:164)\n\tat java.lang.Thread.run(Thread.java:619)\n{quote}\nI suppose that the cause for the message is actually harmless - hence the INFO level - but the messages are confusing and annoying nonetheless."
        }
    },
    {
        "filename": "AMQ-5665.json",
        "creation_time": "2015-03-16T21:35:15.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory(AdvisoryBroker.java:626)\n\tat org.apache.activemq.advisory.AdvisoryBroker.messageDelivered(AdvisoryBroker.java:397)\n\tat org.apache.activemq.broker.BrokerFilter.messageDelivered(BrokerFilter.java:349)\n\tat org.apache.activemq.broker.BrokerFilter.messageDelivered(BrokerFilter.java:349)\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageDelivered(MutableBrokerFilter.java:360)\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageDelivered(MutableBrokerFilter.java:360)\n\tat org.apache.activemq.broker.region.BaseDestination.messageDelivered(BaseDestination.java:518)\n\tat org.apache.activemq.broker.region.Queue.messageSent(Queue.java:1806)\n\tat org.apache.activemq.broker.region.Queue.doPendingCursorAdditions(Queue.java:794)\n\tat org.apache.activemq.broker.region.Queue.orderedCursorAdd(Queue.java:875)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:854)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:733)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:419)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:468)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:297)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:152)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:307)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:541)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:768)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:334)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:188)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:724)",
        "source_code": {
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory": "    public void fireAdvisory(ConnectionContext context, ActiveMQTopic topic, Command command, ConsumerId targetConsumerId, ActiveMQMessage advisoryMessage) throws Exception {\n        if (getBrokerService().isStarted()) {\n            //set properties\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_NAME, getBrokerName());\n            String id = getBrokerId() != null ? getBrokerId().getValue() : \"NOT_SET\";\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_ID, id);\n\n            String url = getBrokerService().getVmConnectorURI().toString();\n            if (getBrokerService().getDefaultSocketURIString() != null) {\n                url = getBrokerService().getDefaultSocketURIString();\n            }\n            advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_ORIGIN_BROKER_URL, url);\n\n            //set the data structure\n            advisoryMessage.setDataStructure(command);\n            advisoryMessage.setPersistent(false);\n            advisoryMessage.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);\n            advisoryMessage.setMessageId(new MessageId(advisoryProducerId, messageIdGenerator.getNextSequenceId()));\n            advisoryMessage.setTargetConsumerId(targetConsumerId);\n            advisoryMessage.setDestination(topic);\n            advisoryMessage.setResponseRequired(false);\n            advisoryMessage.setProducerId(advisoryProducerId);\n            boolean originalFlowControl = context.isProducerFlowControl();\n            final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();\n            producerExchange.setConnectionContext(context);\n            producerExchange.setMutable(true);\n            producerExchange.setProducerState(new ProducerState(new ProducerInfo()));\n            try {\n                context.setProducerFlowControl(false);\n                next.send(producerExchange, advisoryMessage);\n            } finally {\n                context.setProducerFlowControl(originalFlowControl);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.messageDelivered": "    public void messageDelivered(ConnectionContext context, MessageReference messageReference) {\n        super.messageDelivered(context, messageReference);\n        try {\n            if (!messageReference.isAdvisory()) {\n                ActiveMQTopic topic = AdvisorySupport.getMessageDeliveredAdvisoryTopic(messageReference.getMessage().getDestination());\n                Message payload = messageReference.getMessage().copy();\n                payload.clearBody();\n                ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n                advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_MESSAGE_ID, payload.getMessageId().toString());\n                ActiveMQDestination destination = payload.getDestination();\n                if (destination != null) {\n                    advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_DESTINATION, payload.getMessageId().toString());\n                }\n                fireAdvisory(context, topic, payload, null, advisoryMessage);\n            }\n        } catch (Exception e) {\n            handleFireFailure(\"delivered\", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.advisory.AdvisoryBroker.handleFireFailure": "    private void handleFireFailure(String message, Throwable cause) {\n        LOG.warn(\"Failed to fire {} advisory, reason: {}\", message, cause);\n        LOG.debug(\"{} detail: {}\", message, cause);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.messageDelivered": "    public void messageDelivered(ConnectionContext context,MessageReference messageReference) {\n        next.messageDelivered(context, messageReference);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.messageDelivered": "    public void messageDelivered(ConnectionContext context,MessageReference messageReference) {\n        getNext().messageDelivered(context, messageReference);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.BaseDestination.messageDelivered": "    public void messageDelivered(ConnectionContext context, MessageReference messageReference) {\n        if (advisoryForDelivery) {\n            broker.messageDelivered(context, messageReference);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.messageSent": "    final void messageSent(final ConnectionContext context, final Message msg) throws Exception {\n        destinationStatistics.getEnqueues().increment();\n        destinationStatistics.getMessages().increment();\n        destinationStatistics.getMessageSize().addSize(msg.getSize());\n        messageDelivered(context, msg);\n        consumersLock.readLock().lock();\n        try {\n            if (consumers.isEmpty()) {\n                onMessageWithNoConsumers(context, msg);\n            }\n        }finally {\n            consumersLock.readLock().unlock();\n        }\n        LOG.debug(\"{} Message {} sent to {}\", new Object[]{ broker.getBrokerName(), msg.getMessageId(), this.destination });\n        wakeup();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getMessages": "    public PendingMessageCursor getMessages() {\n        return this.messages;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.wakeup": "    public void wakeup() {\n        if (optimizedDispatch && !iterationRunning) {\n            iterate();\n            pendingWakeups.incrementAndGet();\n        } else {\n            asyncWakeup();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doPendingCursorAdditions": "    private void doPendingCursorAdditions() throws Exception {\n        LinkedList<MessageContext> orderedUpdates = new LinkedList<>();\n        sendLock.lockInterruptibly();\n        try {\n            synchronized (indexOrderedCursorUpdates) {\n                MessageContext candidate = indexOrderedCursorUpdates.peek();\n                while (candidate != null && candidate.message.getMessageId().getFutureOrSequenceLong() != null) {\n                    candidate = indexOrderedCursorUpdates.removeFirst();\n                    // check for duplicate adds suppressed by the store\n                    if (candidate.message.getMessageId().getFutureOrSequenceLong() instanceof Long && ((Long)candidate.message.getMessageId().getFutureOrSequenceLong()).compareTo(-1l) == 0) {\n                        LOG.warn(\"{} messageStore indicated duplicate add attempt for {}, suppressing duplicate dispatch\", this, candidate.message.getMessageId());\n                    } else {\n                        orderedUpdates.add(candidate);\n                    }\n                    candidate = indexOrderedCursorUpdates.peek();\n                }\n            }\n            messagesLock.writeLock().lock();\n            try {\n                for (MessageContext messageContext : orderedUpdates) {\n                    if (!messages.addMessageLast(messageContext.message)) {\n                        // cursor suppressed a duplicate\n                        messageContext.duplicate = true;\n                    }\n                    if (messageContext.onCompletion != null) {\n                        messageContext.onCompletion.run();\n                    }\n                }\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n        } finally {\n            sendLock.unlock();\n        }\n        for (MessageContext messageContext : orderedUpdates) {\n            if (!messageContext.duplicate) {\n                messageSent(messageContext.context, messageContext.message);\n            }\n        }\n        orderedUpdates.clear();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.orderedCursorAdd": "    private void orderedCursorAdd(Message message, ConnectionContext context) throws Exception {\n        if (context.isInTransaction()) {\n            context.getTransaction().addSynchronization(new CursorAddSync(new MessageContext(context, message, null)));\n        } else if (store != null && message.isPersistent()) {\n            doPendingCursorAdditions();\n        } else {\n            // no ordering issue with non persistent messages\n            cursorAdd(message);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.cursorAdd": "    final boolean cursorAdd(final Message msg) throws Exception {\n        messagesLock.writeLock().lock();\n        try {\n            return messages.addMessageLast(msg);\n        } finally {\n            messagesLock.writeLock().unlock();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.doMessageSend": "    void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,\n            Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        ListenableFuture<Object> result = null;\n\n        producerExchange.incrementSend();\n        checkUsage(context, producerExchange, message);\n        sendLock.lockInterruptibly();\n        try {\n            if (store != null && message.isPersistent()) {\n                try {\n                    message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n                    if (messages.isCacheEnabled()) {\n                        result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());\n                        result.addListener(new PendingMarshalUsageTracker(message));\n                    } else {\n                        store.addMessage(context, message);\n                    }\n                    if (isReduceMemoryFootprint()) {\n                        message.clearMarshalledState();\n                    }\n                } catch (Exception e) {\n                    // we may have a store in inconsistent state, so reset the cursor\n                    // before restarting normal broker operations\n                    resetNeeded = true;\n                    throw e;\n                }\n            }\n            orderedCursorAdd(message, context);\n        } finally {\n            sendLock.unlock();\n        }\n        if (store == null || (!context.isInTransaction() && !message.isPersistent())) {\n            messageSent(context, message);\n        }\n        if (result != null && message.isResponseRequired() && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.isOptimizeStorage": "    protected boolean isOptimizeStorage(){\n        boolean result = false;\n        if (isDoOptimzeMessageStorage()){\n            consumersLock.readLock().lock();\n            try{\n                if (consumers.isEmpty()==false){\n                    result = true;\n                    for (Subscription s : consumers) {\n                        if (s.getPrefetchSize()==0){\n                            result = false;\n                            break;\n                        }\n                        if (s.isSlowConsumer()){\n                            result = false;\n                            break;\n                        }\n                        if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){\n                            result = false;\n                            break;\n                        }\n                    }\n                }\n            } finally {\n                consumersLock.readLock().unlock();\n            }\n        }\n        return result;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.checkUsage": "    private void checkUsage(ConnectionContext context,ProducerBrokerExchange producerBrokerExchange, Message message) throws ResourceAllocationException, IOException, InterruptedException {\n        if (message.isPersistent()) {\n            if (store != null && systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {\n                final String logMessage = \"Persistent store is Full, \" + getStoreUsageHighWaterMark() + \"% of \"\n                    + systemUsage.getStoreUsage().getLimit() + \". Stopping producer (\"\n                    + message.getProducerId() + \") to prevent flooding \"\n                    + getActiveMQDestination().getQualifiedName() + \".\"\n                    + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n\n                waitForSpace(context, producerBrokerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);\n            }\n        } else if (messages.getSystemUsage() != null && systemUsage.getTempUsage().isFull()) {\n            final String logMessage = \"Temp Store is Full (\"\n                    + systemUsage.getTempUsage().getPercentUsage() + \"% of \" + systemUsage.getTempUsage().getLimit()\n                    +\"). Stopping producer (\" + message.getProducerId()\n                + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n\n            waitForSpace(context, producerBrokerExchange, messages.getSystemUsage().getTempUsage(), logMessage);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.send": "    public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        // There is delay between the client sending it and it arriving at the\n        // destination.. it may have expired.\n        message.setRegionDestination(this);\n        ProducerState state = producerExchange.getProducerState();\n        if (state == null) {\n            LOG.warn(\"Send failed for: {}, missing producer state for: {}\", message, producerExchange);\n            throw new JMSException(\"Cannot send message to \" + getActiveMQDestination() + \" with invalid (null) producer state\");\n        }\n        final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();\n        final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0\n                && !context.isInRecoveryMode();\n        if (message.isExpired()) {\n            // message not stored - or added to stats yet - so chuck here\n            broker.getRoot().messageExpired(context, message, null);\n            if (sendProducerAck) {\n                ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n                context.getConnection().dispatchAsync(ack);\n            }\n            return;\n        }\n        if (memoryUsage.isFull()) {\n            isFull(context, memoryUsage);\n            fastProducer(context, producerInfo);\n            if (isProducerFlowControl() && context.isProducerFlowControl()) {\n                if (warnOnProducerFlowControl) {\n                    warnOnProducerFlowControl = false;\n                    LOG.info(\"Usage Manager Memory Limit ({}) reached on {}, size {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.\",\n                                    memoryUsage.getLimit(), getActiveMQDestination().getQualifiedName(), destinationStatistics.getMessages().getCount());\n                }\n\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new ResourceAllocationException(\"Usage Manager Memory Limit reached. Stopping producer (\"\n                            + message.getProducerId() + \") to prevent flooding \"\n                            + getActiveMQDestination().getQualifiedName() + \".\"\n                            + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                }\n\n                // We can avoid blocking due to low usage if the producer is\n                // sending\n                // a sync message or if it is using a producer window\n                if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {\n                    // copy the exchange state since the context will be\n                    // modified while we are waiting\n                    // for space.\n                    final ProducerBrokerExchange producerExchangeCopy = producerExchange.copy();\n                    synchronized (messagesWaitingForSpace) {\n                     // Start flow control timeout task\n                        // Prevent trying to start it multiple times\n                        if (!flowControlTimeoutTask.isAlive()) {\n                            flowControlTimeoutTask.setName(getName()+\" Producer Flow Control Timeout Task\");\n                            flowControlTimeoutTask.start();\n                        }\n                        messagesWaitingForSpace.put(message.getMessageId(), new Runnable() {\n                            @Override\n                            public void run() {\n\n                                try {\n                                    // While waiting for space to free up... the\n                                    // message may have expired.\n                                    if (message.isExpired()) {\n                                        LOG.error(\"expired waiting for space..\");\n                                        broker.messageExpired(context, message, null);\n                                        destinationStatistics.getExpired().increment();\n                                    } else {\n                                        doMessageSend(producerExchangeCopy, message);\n                                    }\n\n                                    if (sendProducerAck) {\n                                        ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message\n                                                .getSize());\n                                        context.getConnection().dispatchAsync(ack);\n                                    } else {\n                                        Response response = new Response();\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    }\n\n                                } catch (Exception e) {\n                                    if (!sendProducerAck && !context.isInRecoveryMode() && !brokerService.isStopping()) {\n                                        ExceptionResponse response = new ExceptionResponse(e);\n                                        response.setCorrelationId(message.getCommandId());\n                                        context.getConnection().dispatchAsync(response);\n                                    } else {\n                                        LOG.debug(\"unexpected exception on deferred send of: {}\", message, e);\n                                    }\n                                }\n                            }\n                        });\n\n                        if (!context.isNetworkConnection() && systemUsage.getSendFailIfNoSpaceAfterTimeout() != 0) {\n                            flowControlTimeoutMessages.add(new TimeoutMessage(message, context, systemUsage\n                                    .getSendFailIfNoSpaceAfterTimeout()));\n                        }\n\n                        registerCallbackForNotFullNotification();\n                        context.setDontSendReponse(true);\n                        return;\n                    }\n\n                } else {\n\n                    if (memoryUsage.isFull()) {\n                        waitForSpace(context, producerExchange, memoryUsage, \"Usage Manager Memory Limit reached. Producer (\"\n                                + message.getProducerId() + \") stopped to prevent flooding \"\n                                + getActiveMQDestination().getQualifiedName() + \".\"\n                                + \" See http://activemq.apache.org/producer-flow-control.html for more info\");\n                    }\n\n                    // The usage manager could have delayed us by the time\n                    // we unblock the message could have expired..\n                    if (message.isExpired()) {\n                        LOG.debug(\"Expired message: {}\", message);\n                        broker.getRoot().messageExpired(context, message, null);\n                        return;\n                    }\n                }\n            }\n        }\n        doMessageSend(producerExchange, message);\n        if (sendProducerAck) {\n            ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());\n            context.getConnection().dispatchAsync(ack);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.start": "    public void start() throws Exception {\n        if (started.compareAndSet(false, true)) {\n            if (memoryUsage != null) {\n                memoryUsage.start();\n            }\n            if (systemUsage.getStoreUsage() != null) {\n                systemUsage.getStoreUsage().start();\n            }\n            systemUsage.getMemoryUsage().addUsageListener(this);\n            messages.start();\n            if (getExpireMessagesPeriod() > 0) {\n                scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());\n            }\n            doPageIn(false);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        LOG.debug(\"message expired: {}\", reference);\n        broker.messageExpired(context, reference, subs);\n        destinationStatistics.getExpired().increment();\n        try {\n            removeMessage(context, subs, (QueueMessageReference) reference);\n            messagesLock.writeLock().lock();\n            try {\n                messages.rollback(reference.getMessageId());\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n        } catch (IOException e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.getActiveMQDestination": "    public ActiveMQDestination getActiveMQDestination() {\n        return destination;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Queue.registerCallbackForNotFullNotification": "    private void registerCallbackForNotFullNotification() {\n        // If the usage manager is not full, then the task will not\n        // get called..\n        if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {\n            // so call it directly here.\n            sendMessagesWaitingForSpaceTask.run();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.send": "    public void send(final ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n\n        if (producerExchange.isMutable() || producerExchange.getRegionDestination() == null) {\n            final Destination regionDestination = lookup(context, messageSend.getDestination(),false);\n            producerExchange.setRegionDestination(regionDestination);\n        }\n\n        producerExchange.getRegionDestination().send(producerExchange, messageSend);\n\n        if (producerExchange.getProducerState() != null && producerExchange.getProducerState().getInfo() != null){\n            producerExchange.getProducerState().getInfo().incrementSentCount();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.AbstractRegion.lookup": "    protected Destination lookup(ConnectionContext context, ActiveMQDestination destination,boolean createTemporary) throws Exception {\n        Destination dest = null;\n\n        destinationsLock.readLock().lock();\n        try {\n            dest = destinations.get(destination);\n        } finally {\n            destinationsLock.readLock().unlock();\n        }\n\n        if (dest == null) {\n            if (isAutoCreateDestinations()) {\n                // Try to auto create the destination... re-invoke broker\n                // from the\n                // top so that the proper security checks are performed.\n                context.getBroker().addDestination(context, destination, createTemporary);\n                dest = addDestination(context, destination, false);\n                // We should now have the dest created.\n                destinationsLock.readLock().lock();\n                try {\n                    dest = destinations.get(destination);\n                } finally {\n                    destinationsLock.readLock().unlock();\n                }\n            }\n\n            if (dest == null) {\n                throw new JMSException(\"The destination \" + destination + \" does not exist.\");\n            }\n        }\n        return dest;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        message.setBrokerInTime(System.currentTimeMillis());\n        if (producerExchange.isMutable() || producerExchange.getRegion() == null\n            || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {\n            // ensure the destination is registered with the RegionBroker\n            producerExchange.getConnectionContext().getBroker()\n                .addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());\n            producerExchange.setRegion(getRegion(destination));\n            producerExchange.setRegionDestination(null);\n        }\n\n        producerExchange.getRegion().send(producerExchange, message);\n\n        // clean up so these references aren't kept (possible leak) in the producer exchange\n        // especially since temps are transitory\n        if (producerExchange.isMutable()) {\n            producerExchange.setRegionDestination(null);\n            producerExchange.setRegion(null);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getRegion": "    protected Region getRegion(ActiveMQDestination destination) throws JMSException {\n        switch (destination.getDestinationType()) {\n            case ActiveMQDestination.QUEUE_TYPE:\n                return queueRegion;\n            case ActiveMQDestination.TOPIC_TYPE:\n                return topicRegion;\n            case ActiveMQDestination.TEMP_QUEUE_TYPE:\n                return tempQueueRegion;\n            case ActiveMQDestination.TEMP_TOPIC_TYPE:\n                return tempTopicRegion;\n            default:\n                throw createUnknownDestinationTypeException(destination);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.addDestination": "    public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {\n\n        Destination answer;\n\n        answer = destinations.get(destination);\n        if (answer != null) {\n            return answer;\n        }\n\n        synchronized (destinationGate) {\n            answer = destinations.get(destination);\n            if (answer != null) {\n                return answer;\n            }\n\n            if (destinationGate.get(destination) != null) {\n                // Guard against spurious wakeup.\n                while (destinationGate.containsKey(destination)) {\n                    destinationGate.wait();\n                }\n                answer = destinations.get(destination);\n                if (answer != null) {\n                    return answer;\n                } else {\n                    // In case of intermediate remove or add failure\n                    destinationGate.put(destination, destination);\n                }\n            }\n        }\n\n        try {\n            boolean create = true;\n            if (destination.isTemporary()) {\n                create = createIfTemp;\n            }\n            answer = getRegion(destination).addDestination(context, destination, create);\n            destinations.put(destination, answer);\n        } finally {\n            synchronized (destinationGate) {\n                destinationGate.remove(destination);\n                destinationGate.notifyAll();\n            }\n        }\n\n        return answer;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.getConnectionContext": "    public ConnectionContext getConnectionContext(String clientId) {\n        return clientIdSet.get(clientId);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.RegionBroker.isAllowTempAutoCreationOnSend": "    public boolean isAllowTempAutoCreationOnSend() {\n        return allowTempAutoCreationOnSend;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.ManagedRegionBroker.send": "    public void send(ProducerBrokerExchange exchange, Message message) throws Exception {\n        if (exchange != null && exchange.getProducerState() != null && exchange.getProducerState().getInfo() != null) {\n            ProducerInfo info = exchange.getProducerState().getInfo();\n            if (info.getDestination() == null && info.getProducerId() != null) {\n                ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, exchange.getConnectionContext().getClientId(), info);\n                ProducerView view = this.dynamicDestinationProducers.get(objectName);\n                if (view != null) {\n                    ActiveMQDestination dest = message.getDestination();\n                    if (dest != null) {\n                        view.setLastUsedDestinationName(dest);\n                    }\n                }\n            }\n         }\n        super.send(exchange, message);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.BrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        next.send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.CompositeDestinationBroker.send": "    public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {\n        ActiveMQDestination destination = message.getDestination();\n        if (destination.isComposite()) {\n            ActiveMQDestination[] destinations = destination.getCompositeDestinations();\n            for (int i = 0; i < destinations.length; i++) {\n                if (i != 0) {\n                    message = message.copy();\n                    message.setMemoryUsage(null);\n                }\n                message.setOriginalDestination(destination);\n                message.setDestination(destinations[i]);\n                next.send(producerExchange, message);\n            }\n        } else {\n            next.send(producerExchange, message);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.send": "    public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {\n        // This method may be invoked recursively.\n        // Track original tx so that it can be restored.\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        Transaction originalTx = context.getTransaction();\n        Transaction transaction = null;\n        Synchronization sync = null;\n        if (message.getTransactionId() != null) {\n            transaction = getTransaction(context, message.getTransactionId(), false);\n            if (transaction != null) {\n                sync = new Synchronization() {\n\n                    public void afterRollback() {\n                        if (audit != null) {\n                            audit.rollback(message);\n                        }\n                    }\n                };\n                transaction.addSynchronization(sync);\n            }\n        }\n        if (audit == null || !audit.isDuplicate(message)) {\n            context.setTransaction(transaction);\n            try {\n                next.send(producerExchange, message);\n            } finally {\n                context.setTransaction(originalTx);\n            }\n        } else {\n            if (sync != null && transaction != null) {\n                transaction.removeSynchronization(sync);\n            }\n            LOG.debug(\"IGNORING duplicate message {}\", message);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = XATransaction.newXAException(\"Transaction '\" + xid + \"' has not been started.\", XAException.XAER_NOTA);\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.send": "    public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {\n        getNext().send(producerExchange, messageSend);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processMessage": "    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getProducerBrokerExchange": "    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.ActiveMQMessage.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        return visitor.processMessage(this);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred: {}\", e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \", e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.isStopping": "    public boolean isStopping() {\n        return stopping.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        this.sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            this.sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-client.src.main.java.org.apache.activemq.advisory.AdvisorySupport.getMessageDeliveredAdvisoryTopic": "    public static ActiveMQTopic getMessageDeliveredAdvisoryTopic(ActiveMQDestination destination) {\n        String name = MESSAGE_DELIVERED_TOPIC_PREFIX + destination.getDestinationTypeAsString() + \".\"\n                + destination.getPhysicalName();\n        return new ActiveMQTopic(name);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getEnqueues": "    public CountStatisticImpl getEnqueues() {\n        return enqueues;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getMessageSize": "    public SizeStatisticImpl getMessageSize(){\n        return this.messageSize;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.destinationStatistics.getExpired": "    public CountStatisticImpl getExpired() {\n        return expired;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.BrokerMBeanSupport.createProducerName": "    public static ObjectName createProducerName(String brokerObjectName, String connectionClientId, ProducerInfo producerInfo) throws MalformedObjectNameException {\n        String objectNameStr = brokerObjectName;\n\n        if (producerInfo.getDestination() == null) {\n            objectNameStr += \",endpoint=dynamicProducer\";\n        } else {\n            objectNameStr += createDestinationProperties(producerInfo.getDestination()) + \",endpoint=Producer\";\n        }\n\n        objectNameStr += \",clientId=\" + JMXSupport.encodeObjectNamePart(connectionClientId);\n        objectNameStr += \",producerId=\" + JMXSupport.encodeObjectNamePart(producerInfo.getProducerId().toString());\n\n        return new ObjectName(objectNameStr);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.jmx.BrokerMBeanSupport.createDestinationProperties": "    private static String createDestinationProperties(String type, String name){\n        return \",destinationType=\"+ JMXSupport.encodeObjectNamePart(type) +\n               \",destinationName=\" + JMXSupport.encodeObjectNamePart(name);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getConnectionContext": "    public ConnectionContext getConnectionContext() {\n        return this.connectionContext;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ConnectionContext.setTransaction": "    public void setTransaction(Transaction transaction) {\n        this.transaction = transaction;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.canDispatch": "    public boolean canDispatch(Message messageSend) {\n        boolean canDispatch = true;\n        if (auditProducerSequenceIds && messageSend.isPersistent()) {\n            final long producerSequenceId = messageSend.getMessageId().getProducerSequenceId();\n            if (isNetworkProducer) {\n                //  messages are multiplexed on this producer so we need to query the persistenceAdapter\n                long lastStoredForMessageProducer = getStoredSequenceIdForMessage(messageSend.getMessageId());\n                if (producerSequenceId <= lastStoredForMessageProducer) {\n                    canDispatch = false;\n                    LOG.warn(\"suppressing duplicate message send [{}] from network producer with producerSequence [{}] less than last stored: {}\", new Object[]{\n                            (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()), producerSequenceId, lastStoredForMessageProducer\n                    });\n                }\n            } else if (producerSequenceId <= lastSendSequenceNumber.get()) {\n                canDispatch = false;\n                if (messageSend.isInTransaction()) {\n                    LOG.warn(\"suppressing duplicated message send [{}] with producerSequenceId [{}] <= last stored: {}\", new Object[]{\n                            (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()), producerSequenceId, lastSendSequenceNumber\n                    });\n                } else {\n                    LOG.debug(\"suppressing duplicated message send [{}] with producerSequenceId [{}] <= last stored: {}\", new Object[]{\n                            (LOG.isTraceEnabled() ? messageSend : messageSend.getMessageId()), producerSequenceId, lastSendSequenceNumber\n                    });\n\n                }\n            } else {\n                // track current so we can suppress duplicates later in the stream\n                lastSendSequenceNumber.set(producerSequenceId);\n            }\n        }\n        return canDispatch;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.ProducerBrokerExchange.getStoredSequenceIdForMessage": "    private long getStoredSequenceIdForMessage(MessageId messageId) {\n        try {\n            return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());\n        } catch (IOException ignored) {\n            LOG.debug(\"Failed to determine last producer sequence id for: {}\", messageId, ignored);\n        }\n        return -1;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "memory store is broken in 5.11.0 for advisories (and probably other issues as well)",
            "Description": "We're running 5.10.2 and don't encounter this issue.  We're running a non-persistent broker in production and testing so that's why we found this issue.\n\nIt looks like 5.11.0 introduced this issue.\n\nEssentially Advisories fail to fire. \n\nIt looks like it\u2019s a bug with MemoryTransactionStore. Switching to persistent brokers fixes the problem.\n\nIt\u2019s because addMessage calls:\n\n        } else {\n            destination.addMessage(null, message);\n        }\n\n.. with an explicit null.\n\nthe message given is:\n\n2015-03-16 12:54:17,538 WARN [ActiveMQ Transport: tcp:///127.0.0.1:56468@16161] org.apache.activemq.advisory.AdvisoryBroker Failed to fire delivered advisory, reason: java.lang.NullPointerException\n\n\u2026 and I saw this when I was running mvn test in the main ActiveMQ test suite (or at least pretty sure I did) so this is happening not just in my code. \n\nThe full exception , which I captured by setting a break point is below. \n\n\njava.lang.NullPointerException\n\tat org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory(AdvisoryBroker.java:626)\n\tat org.apache.activemq.advisory.AdvisoryBroker.messageDelivered(AdvisoryBroker.java:397)\n\tat org.apache.activemq.broker.BrokerFilter.messageDelivered(BrokerFilter.java:349)\n\tat org.apache.activemq.broker.BrokerFilter.messageDelivered(BrokerFilter.java:349)\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageDelivered(MutableBrokerFilter.java:360)\n\tat org.apache.activemq.broker.MutableBrokerFilter.messageDelivered(MutableBrokerFilter.java:360)\n\tat org.apache.activemq.broker.region.BaseDestination.messageDelivered(BaseDestination.java:518)\n\tat org.apache.activemq.broker.region.Queue.messageSent(Queue.java:1806)\n\tat org.apache.activemq.broker.region.Queue.doPendingCursorAdditions(Queue.java:794)\n\tat org.apache.activemq.broker.region.Queue.orderedCursorAdd(Queue.java:875)\n\tat org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:854)\n\tat org.apache.activemq.broker.region.Queue.send(Queue.java:733)\n\tat org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:419)\n\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:468)\n\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:297)\n\tat org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:152)\n\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)\n\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:307)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)\n\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)\n\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:541)\n\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:768)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:334)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:188)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:724)\n\n... the core issue here looks like the message doesn't have a TransactionId and MemoryTransactionStore has an addMessages which has a fall through of addMessage with a null context which then causes the NPE.\n\nDid messages have an implicit transaction Id before?\n"
        }
    },
    {
        "filename": "AMQ-3725.json",
        "creation_time": "2012-02-17T18:57:21.000+0000",
        "stack_trace": "java.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.SyncFailedException: sync failed\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\nERROR | Checkpoint failed\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.SyncFailedException: sync failed\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\nERROR | KahaDB failed to store to Journal\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\nERROR | KahaDB failed to store to Journal\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n WARN | Transport failed: java.io.EOFException\n WARN | Transport failed: java.io.EOFException\n INFO | KahaDB: Recovering checkpoint thread after death\nERROR | Checkpoint failed\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n INFO | Ignoring IO exception, java.io.IOException: Input/output error\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n INFO | KahaDB: Recovering checkpoint thread after death\nERROR | Checkpoint failed\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n INFO | Ignoring IO exception, java.io.IOException: Input/output error\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.kaha.impl.async.DataFileAppender.processQueue": "    protected void processQueue() {\n        DataFile dataFile = null;\n        RandomAccessFile file = null;\n        WriteBatch wb = null;\n        try {\n\n            DataByteArrayOutputStream buff = new DataByteArrayOutputStream(maxWriteBatchSize);\n            while (true) {\n\n                Object o = null;\n\n                // Block till we get a command.\n                synchronized (enqueueMutex) {\n                    while (true) {\n                        if (nextWriteBatch != null) {\n                            o = nextWriteBatch;\n                            nextWriteBatch = null;\n                            break;\n                        }\n                        if (shutdown) {\n                            return;\n                        }\n                        enqueueMutex.wait();\n                    }\n                    enqueueMutex.notify();\n                }\n\n                wb = (WriteBatch)o;\n                if (dataFile != wb.dataFile) {\n                    if (file != null) {\n                        dataFile.closeRandomAccessFile(file);\n                    }\n                    dataFile = wb.dataFile;\n                    file = dataFile.openRandomAccessFile(true);\n                }\n\n                WriteCommand write = wb.first;\n\n                // Write all the data.\n                // Only need to seek to first location.. all others\n                // are in sequence.\n                file.seek(write.location.getOffset());\n\n                \n                boolean forceToDisk=false;\n                \n                // \n                // is it just 1 big write?\n                if (wb.size == write.location.getSize()) {\n                    forceToDisk = write.sync | write.onComplete!=null;\n                    \n                    // Just write it directly..\n                    file.writeInt(write.location.getSize());\n                    file.writeByte(write.location.getType());\n                    file.write(RESERVED_SPACE);\n                    file.write(AsyncDataManager.ITEM_HEAD_SOR);\n                    file.write(write.data.getData(), write.data.getOffset(), write.data.getLength());\n                    file.write(AsyncDataManager.ITEM_HEAD_EOR);\n\n                } else {\n\n                    // Combine the smaller writes into 1 big buffer\n                    while (write != null) {\n                        forceToDisk |= write.sync | write.onComplete!=null;\n\n                        buff.writeInt(write.location.getSize());\n                        buff.writeByte(write.location.getType());\n                        buff.write(RESERVED_SPACE);\n                        buff.write(AsyncDataManager.ITEM_HEAD_SOR);\n                        buff.write(write.data.getData(), write.data.getOffset(), write.data.getLength());\n                        buff.write(AsyncDataManager.ITEM_HEAD_EOR);\n\n                        write = (WriteCommand)write.getNext();\n                    }\n\n                    // Now do the 1 big write.\n                    ByteSequence sequence = buff.toByteSequence();\n                    file.write(sequence.getData(), sequence.getOffset(), sequence.getLength());\n                    buff.reset();\n                }\n\n                if( forceToDisk ) {\n                    file.getFD().sync();\n                }\n                \n                WriteCommand lastWrite = (WriteCommand)wb.first.getTailNode();\n                dataManager.setLastAppendLocation(lastWrite.location);\n\n                // Now that the data is on disk, remove the writes from the in\n                // flight\n                // cache.\n                write = wb.first;\n                while (write != null) {\n                    if (!write.sync) {\n                        inflightWrites.remove(new WriteKey(write.location));\n                    }\n                    if( write.onComplete !=null ) {\n                    \t try {\n\t\t\t\t\t\t\twrite.onComplete.run();\n\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n                    }\n                    write = (WriteCommand)write.getNext();\n                }\n                \n                // Signal any waiting threads that the write is on disk.\n                wb.latch.countDown();\n            }\n        } catch (IOException e) {\n            synchronized (enqueueMutex) {\n                firstAsyncException = e;\n                if (wb != null) {\n                    wb.latch.countDown();\n                    wb.exception.set(e);\n                }\n                if (nextWriteBatch != null) {\n                    nextWriteBatch.latch.countDown();\n                    nextWriteBatch.exception.set(e);\n                }\n            }\n        } catch (InterruptedException e) {\n        } finally {\n            try {\n                if (file != null) {\n                    dataFile.closeRandomAccessFile(file);\n                }\n            } catch (Throwable ignore) {\n            }\n            shutdownDone.countDown();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.kaha.impl.async.DataFileAppender.run": "                    public void run() {\n                        processQueue();\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.kaha.impl.async.DataFile.openRandomAccessFile": "    public synchronized RandomAccessFile openRandomAccessFile(boolean appender) throws IOException {\n        RandomAccessFile rc = new RandomAccessFile(file, \"rw\");\n        // When we start to write files size them up so that the OS has a chance\n        // to allocate the file contiguously.\n        if (appender) {\n            if (length < preferedSize) {\n                try {\n                    // this can throw if we run out of disk space\n                    rc.setLength(preferedSize);\n                } catch (IOException ioe) {            \n                    try {\n                        rc.close();\n                    } catch(Exception ignored) {\n                    }\n                    throw ioe;\n                }\n            }\n        }\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.kaha.impl.async.DataFile.setLength": "    public void setLength(int length) {\n        this.length = length;\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.writeBatch": "    private void writeBatch() throws IOException {\n\n        CountDownLatch checkpointLatch;\n        ArrayList<PageWrite> batch;\n        synchronized (writes) {\n            // If there is not enough to write, wait for a notification...\n\n            batch = new ArrayList<PageWrite>(writes.size());\n            // build a write batch from the current write cache.\n            for (PageWrite write : writes.values()) {\n                batch.add(write);\n                // Move the current write to the diskBound write, this lets folks update the\n                // page again without blocking for this write.\n                write.begin();\n                if (write.diskBound == null && write.diskBoundLocation == -1) {\n                    batch.remove(write);\n                }\n            }\n\n            // Grab on to the existing checkpoint latch cause once we do this write we can\n            // release the folks that were waiting for those writes to hit disk.\n            checkpointLatch = this.checkpointLatch;\n            this.checkpointLatch = null;\n        }\n\n        Checksum checksum = new Adler32();\n        if (enableRecoveryFile) {\n            recoveryFile.seek(RECOVERY_FILE_HEADER_SIZE);\n        }\n        for (PageWrite w : batch) {\n            if (enableRecoveryFile) {\n                try {\n                    checksum.update(w.getDiskBound(), 0, pageSize);\n                } catch (Throwable t) {\n                    throw IOExceptionSupport.create(\"Cannot create recovery file. Reason: \" + t, t);\n                }\n                recoveryFile.writeLong(w.page.getPageId());\n                recoveryFile.write(w.getDiskBound(), 0, pageSize);\n            }\n\n            writeFile.seek(toOffset(w.page.getPageId()));\n            writeFile.write(w.getDiskBound(), 0, pageSize);\n            w.done();\n        }\n\n        try {\n            if (enableRecoveryFile) {\n                // Can we shrink the recovery buffer??\n                if (recoveryPageCount > recoveryFileMaxPageCount) {\n                    int t = Math.max(recoveryFileMinPageCount, batch.size());\n                    recoveryFile.setLength(recoveryFileSizeForPages(t));\n                }\n\n                // Record the page writes in the recovery buffer.\n                recoveryFile.seek(0);\n                // Store the next tx id...\n                recoveryFile.writeLong(nextTxid.get());\n                // Store the checksum for thw write batch so that on recovery we\n                // know if we have a consistent\n                // write batch on disk.\n                recoveryFile.writeLong(checksum.getValue());\n                // Write the # of pages that will follow\n                recoveryFile.writeInt(batch.size());\n            }\n\n            if (enableDiskSyncs) {\n                // Sync to make sure recovery buffer writes land on disk..\n                if (enableRecoveryFile) {\n                    recoveryFile.getFD().sync();\n                }\n                writeFile.getFD().sync();\n            }\n        } finally {\n            synchronized (writes) {\n                for (PageWrite w : batch) {\n                    // If there are no more pending writes, then remove it from\n                    // the write cache.\n                    if (w.isDone()) {\n                        writes.remove(w.page.getPageId());\n                        if (w.tmpFile != null && tmpFilesForRemoval.contains(w.tmpFile)) {\n                            if (!w.tmpFile.delete()) {\n                                throw new IOException(\"Can't delete temporary KahaDB transaction file:\" + w.tmpFile);\n                            }\n                            tmpFilesForRemoval.remove(w.tmpFile);\n                        }\n                    }\n                }\n            }\n\n            if (checkpointLatch != null) {\n                checkpointLatch.countDown();\n            }\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.write": "    void write(Collection<Map.Entry<Long, PageWrite>> updates) throws IOException {\n        synchronized (writes) {\n            if (enabledWriteThread) {\n                while (writes.size() >= writeBatchSize && !stopWriter.get()) {\n                    try {\n                        writes.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        throw new InterruptedIOException();\n                    }\n                }\n            }\n\n            boolean longTx = false;\n\n            for (Map.Entry<Long, PageWrite> entry : updates) {\n                Long key = entry.getKey();\n                PageWrite value = entry.getValue();\n                PageWrite write = writes.get(key);\n                if (write == null) {\n                    writes.put(key, value);\n                } else {\n                    if (value.currentLocation != -1) {\n                        write.setCurrentLocation(value.page, value.currentLocation, value.length);\n                        write.tmpFile = value.tmpFile;\n                        longTx = true;\n                    } else {\n                        write.setCurrent(value.page, value.current);\n                    }\n                }\n            }\n\n            // Once we start approaching capacity, notify the writer to start writing\n            // sync immediately for long txs\n            if (longTx || canStartWriteBatch()) {\n\n                if (enabledWriteThread) {\n                    writes.notify();\n                } else {\n                    writeBatch();\n                }\n            }\n        }\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getDiskBound": "        public byte[] getDiskBound() throws IOException {\n            if (diskBound == null && diskBoundLocation != -1) {\n                diskBound = new byte[length];\n                RandomAccessFile file = new RandomAccessFile(tmpFile, \"r\");\n                file.seek(diskBoundLocation);\n                file.read(diskBound);\n                file.close();\n                diskBoundLocation = -1;\n            }\n            return diskBound;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.toOffset": "    public long toOffset(long pageId) {\n        return PAGE_FILE_HEADER_SIZE + (pageId * pageSize);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.isDone": "        boolean isDone() {\n            return diskBound == null && diskBoundLocation == -1 && current == null && currentLocation == -1;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.recoveryFileSizeForPages": "    private long recoveryFileSizeForPages(int pageCount) {\n        return RECOVERY_FILE_HEADER_SIZE + ((pageSize + 8) * pageCount);\n    }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.getValue": "            public PageWrite getValue() {\n                return write;\n            }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.begin": "        void begin() {\n            if (currentLocation != -1) {\n                diskBoundLocation = currentLocation;\n            } else {\n                diskBound = current;\n            }\n            current = null;\n            currentLocation = -1;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.done": "        boolean done() {\n            diskBoundLocation = -1;\n            diskBound = null;\n            return current == null || currentLocation == -1;\n        }",
            "kahadb.src.main.java.org.apache.kahadb.page.PageFile.flush": "    public void flush() throws IOException {\n\n        if (enabledWriteThread && stopWriter.get()) {\n            throw new IOException(\"Page file already stopped: checkpointing is not allowed\");\n        }\n\n        // Setup a latch that gets notified when all buffered writes hits the disk.\n        CountDownLatch checkpointLatch;\n        synchronized (writes) {\n            if (writes.isEmpty()) {\n                return;\n            }\n            if (enabledWriteThread) {\n                if (this.checkpointLatch == null) {\n                    this.checkpointLatch = new CountDownLatch(1);\n                }\n                checkpointLatch = this.checkpointLatch;\n                writes.notify();\n            } else {\n                writeBatch();\n                return;\n            }\n        }\n        try {\n            checkpointLatch.await();\n        } catch (InterruptedException e) {\n            InterruptedIOException ioe = new InterruptedIOException();\n            ioe.initCause(e);\n            throw ioe;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    void checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {\n        LOG.debug(\"Checkpoint started.\");\n\n        // reflect last update exclusive of current checkpoint\n        Location firstTxLocation = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit();\n        metadata.firstInProgressTransactionLocation = getFirstInProgressTxLocation();\n        tx.store(metadata.page, metadataMarshaller, true);\n        pageFile.flush();\n\n        if( cleanup ) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n            final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Last update: \" + firstTxLocation + \", full gc candidates set: \" + gcCandidateSet);\n            }\n\n            // Don't GC files under replication\n            if( journalFilesBeingReplicated!=null ) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                gcCandidateSet.remove(metadata.producerSequenceIdTrackerLocation.getDataFileId());\n            }\n\n            // Don't GC files after the first in progress tx\n            if( metadata.firstInProgressTransactionLocation!=null ) {\n                if (metadata.firstInProgressTransactionLocation.getDataFileId() < firstTxLocation.getDataFileId()) {\n                    firstTxLocation = metadata.firstInProgressTransactionLocation;\n                }\n            }\n\n            if( firstTxLocation!=null ) {\n                while( !gcCandidateSet.isEmpty() ) {\n                    Integer last = gcCandidateSet.last();\n                    if( last >= firstTxLocation.getDataFileId() ) {\n                        gcCandidateSet.remove(last);\n                    } else {\n                        break;\n                    }\n                }\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after first tx:\" + firstTxLocation + \", \" + gcCandidateSet);\n                }\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if( gcCandidateSet.isEmpty() ) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last=-1;\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if( first==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if( second==null ) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId()+1);\n                            if( !subset.isEmpty() && subset.first() == first.getDataFileId() ) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if( !subset.isEmpty() && subset.last() == second.getDataFileId() ) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n                }\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"gc candidates: \" + gcCandidateSet);\n            }\n            final TreeSet<Integer> gcCandidates = new TreeSet<Integer>(gcCandidateSet);\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidates.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don't delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        ackMessageFileMap.remove(candidate);\n                    } else {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"not removing data file: \" + candidate\n                                    + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                        }\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cleanup removing the data files: \" + gcCandidateSet);\n                }\n                journal.removeDataFiles(gcCandidateSet);\n            }\n        }\n\n        LOG.debug(\"Checkpoint done.\");\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointProducerAudit": "    private Location checkpointProducerAudit() throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oout = new ObjectOutputStream(baos);\n        oout.writeObject(metadata.producerSequenceIdTracker);\n        oout.flush();\n        oout.close();\n        // using completion callback allows a disk sync to be avoided when enableJournalDiskSyncs = false\n        Location location = store(new KahaProducerAuditCommand().setAudit(new Buffer(baos.toByteArray())), nullCompletionCallback);\n        try {\n            location.getLatch().await();\n        } catch (InterruptedException e) {\n            throw new InterruptedIOException(e.toString());\n        }\n        return location;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.remove": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException{\n            return new MessageOrderIterator(tx,m);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.get": "        MessageKeys get(Transaction tx, Long key) throws IOException {\n            MessageKeys result = defaultPriorityIndex.get(tx, key);\n            if (result == null) {\n                result = highPriorityIndex.get(tx, key);\n                if (result == null) {\n                    result = lowPriorityIndex.get(tx, key);\n                    lastGetPriority = LO;\n                } else {\n                    lastGetPriority = HI;\n                }\n            } else {\n                lastGetPriority = DEF;\n            }\n            return result;\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.getFirstInProgressTxLocation": "    public Location getFirstInProgressTxLocation() {\n        Location l = null;\n        synchronized (inflightTransactions) {\n            if (!inflightTransactions.isEmpty()) {\n                for (List<Operation> ops : inflightTransactions.values()) {\n                    if (!ops.isEmpty()) {\n                        l = ops.get(0).getLocation();\n                        break;\n                    }\n                }\n            }\n            if (!preparedTransactions.isEmpty()) {\n                for (List<Operation> ops : preparedTransactions.values()) {\n                    if (!ops.isEmpty()) {\n                        Location t = ops.get(0).getLocation();\n                        if (l==null || t.compareTo(l) <= 0) {\n                            l = t;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return l;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.store": "    public Location store(JournalCommand<?> data, boolean sync, Runnable before,Runnable after, Runnable onJournalStoreComplete) throws IOException {\n        if (before != null) {\n            before.run();\n        }\n        try {\n            ByteSequence sequence = toByteSequence(data);\n            long start = System.currentTimeMillis();\n            Location location = onJournalStoreComplete == null ? journal.write(sequence, sync) :  journal.write(sequence, onJournalStoreComplete) ;\n            long start2 = System.currentTimeMillis();\n            process(data, location, after);\n            long end = System.currentTimeMillis();\n            if( LOG_SLOW_ACCESS_TIME>0 && end-start > LOG_SLOW_ACCESS_TIME) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Slow KahaDB access: Journal append took: \"+(start2-start)+\" ms, Index update took \"+(end-start2)+\" ms\");\n                }\n            }\n\n            if (after != null) {\n                Runnable afterCompletion = null;\n                synchronized (orderedTransactionAfters) {\n                    if (!orderedTransactionAfters.empty()) {\n                        afterCompletion = orderedTransactionAfters.pop();\n                    }\n                }\n                if (afterCompletion != null) {\n                    afterCompletion.run();\n                } else {\n                    // non persistent message case\n                    after.run();\n                }\n            }\n\n            if (checkpointThread != null && !checkpointThread.isAlive()) {\n                startCheckpoint();\n            }\n            return location;\n        } catch (IOException ioe) {\n            LOG.error(\"KahaDB failed to store to Journal\", ioe);\n            brokerService.handleIOException(ioe);\n            throw ioe;\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.hasNext": "            public boolean hasNext() {\n                if (currentIterator == null) {\n                    if (highIterator != null) {\n                        if (highIterator.hasNext()) {\n                            currentIterator = highIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    } else {\n                        currentIterator = defaultIterator;\n                        return currentIterator.hasNext();\n                    }\n                }\n                if (highIterator != null) {\n                    if (currentIterator.hasNext()) {\n                        return true;\n                    }\n                    if (currentIterator == highIterator) {\n                        if (defaultIterator.hasNext()) {\n                            currentIterator = defaultIterator;\n                            return currentIterator.hasNext();\n                        }\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n\n                    if (currentIterator == defaultIterator) {\n                        if (lowIterator.hasNext()) {\n                            currentIterator = lowIterator;\n                            return currentIterator.hasNext();\n                        }\n                        return false;\n                    }\n                }\n                return currentIterator.hasNext();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.visit": "                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if( last != fileId ) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.next": "            public Entry<Long, MessageKeys> next() {\n                Entry<Long, MessageKeys> result = currentIterator.next();\n                if (result != null) {\n                    Long key = result.getKey();\n                    if (highIterator != null) {\n                        if (currentIterator == defaultIterator) {\n                            lastDefaultKey = key;\n                        } else if (currentIterator == highIterator) {\n                            lastHighKey = key;\n                        } else {\n                            lastLowKey = key;\n                        }\n                    } else {\n                        lastDefaultKey = key;\n                    }\n                }\n                return result;\n            }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.execute": "        public void execute(Transaction tx) throws IOException {\n            updateIndex(tx, command, location);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.put": "        MessageKeys put(Transaction tx, int priority, Long key, MessageKeys value) throws IOException {\n            if (priority == javax.jms.Message.DEFAULT_PRIORITY) {\n                return defaultPriorityIndex.put(tx, key, value);\n            } else if (priority > javax.jms.Message.DEFAULT_PRIORITY) {\n                return highPriorityIndex.put(tx, key, value);\n            } else {\n                return lowPriorityIndex.put(tx, key, value);\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex": "    void upadateIndex(Transaction tx, KahaAddMessageCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n\n        // Skip adding the message to the index if this is a topic and there are\n        // no subscriptions.\n        if (sd.subscriptions != null && sd.subscriptions.isEmpty(tx)) {\n            return;\n        }\n\n        // Add the message.\n        int priority = command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY;\n        long id = sd.orderIndex.getNextMessageId(priority);\n        Long previous = sd.locationIndex.put(tx, location, id);\n        if (previous == null) {\n            previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);\n            if (previous == null) {\n                sd.orderIndex.put(tx, priority, id, new MessageKeys(command.getMessageId(), location));\n                if (sd.subscriptions != null && !sd.subscriptions.isEmpty(tx)) {\n                    addAckLocationForNewMessage(tx, sd, id);\n                }\n            } else {\n                // If the message ID as indexed, then the broker asked us to\n                // store a DUP\n                // message. Bad BOY! Don't do it, and log a warning.\n                LOG.warn(\"Duplicate message add attempt rejected. Destination: \" + command.getDestination().getName() + \", Message id: \" + command.getMessageId());\n                sd.messageIdIndex.put(tx, command.getMessageId(), previous);\n                sd.locationIndex.remove(tx, location);\n            }\n        } else {\n            // restore the previous value.. Looks like this was a redo of a\n            // previously\n            // added message. We don't want to assign it a new id as the other\n            // indexes would\n            // be wrong..\n            //\n            sd.locationIndex.put(tx, location, previous);\n        }\n        // record this id in any event, initial send or recovery\n        metadata.producerSequenceIdTracker.isDuplicate(command.getMessageId());\n        metadata.lastUpdate = location;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.load": "        void load(Transaction tx) throws IOException {\n            defaultPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            defaultPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            defaultPriorityIndex.load(tx);\n            lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            lowPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            lowPriorityIndex.load(tx);\n            highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);\n            highPriorityIndex.setValueMarshaller(MessageKeysMarshaller.INSTANCE);\n            highPriorityIndex.load(tx);\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex": "    protected void recoverIndex(Transaction tx) throws IOException {\n        long start = System.currentTimeMillis();\n        // It is possible index updates got applied before the journal updates..\n        // in that case we need to removed references to messages that are not in the journal\n        final Location lastAppendLocation = journal.getLastAppendLocation();\n        long undoCounter=0;\n\n        // Go through all the destinations to see if they have messages past the lastAppendLocation\n        for (StoredDestination sd : storedDestinations.values()) {\n\n            final ArrayList<Long> matches = new ArrayList<Long>();\n            // Find all the Locations that are >= than the last Append Location.\n            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor<Location, Long>(lastAppendLocation) {\n                @Override\n                protected void matched(Location key, Long value) {\n                    matches.add(value);\n                }\n            });\n\n            for (Long sequenceId : matches) {\n                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                sd.locationIndex.remove(tx, keys.location);\n                sd.messageIdIndex.remove(tx, keys.messageId);\n                metadata.producerSequenceIdTracker.rollback(keys.messageId);\n                undoCounter++;\n                // TODO: do we need to modify the ack positions for the pub sub case?\n            }\n        }\n\n        if( undoCounter > 0 ) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting\n            // these the end user should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Rolled back \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n\n        undoCounter = 0;\n        start = System.currentTimeMillis();\n\n        // Lets be extra paranoid here and verify that all the datafiles being referenced\n        // by the indexes still exists.\n\n        final SequenceSet ss = new SequenceSet();\n        for (StoredDestination sd : storedDestinations.values()) {\n            // Use a visitor to cut down the number of pages that we load\n            sd.locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                int last=-1;\n\n                public boolean isInterestedInKeysBetween(Location first, Location second) {\n                    if( first==null ) {\n                        return !ss.contains(0, second.getDataFileId());\n                    } else if( second==null ) {\n                        return true;\n                    } else {\n                        return !ss.contains(first.getDataFileId(), second.getDataFileId());\n                    }\n                }\n\n                public void visit(List<Location> keys, List<Long> values) {\n                    for (Location l : keys) {\n                        int fileId = l.getDataFileId();\n                        if( last != fileId ) {\n                            ss.add(fileId);\n                            last = fileId;\n                        }\n                    }\n                }\n\n            });\n        }\n        HashSet<Integer> missingJournalFiles = new HashSet<Integer>();\n        while (!ss.isEmpty()) {\n            missingJournalFiles.add((int) ss.removeFirst());\n        }\n        missingJournalFiles.removeAll(journal.getFileMap().keySet());\n\n        if (!missingJournalFiles.isEmpty()) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Some journal files are missing: \" + missingJournalFiles);\n            }\n        }\n\n        ArrayList<BTreeVisitor.Predicate<Location>> missingPredicates = new ArrayList<BTreeVisitor.Predicate<Location>>();\n        for (Integer missing : missingJournalFiles) {\n            missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(missing, 0), new Location(missing + 1, 0)));\n        }\n\n        if (checkForCorruptJournalFiles) {\n            Collection<DataFile> dataFiles = journal.getFileMap().values();\n            for (DataFile dataFile : dataFiles) {\n                int id = dataFile.getDataFileId();\n                missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));\n                Sequence seq = dataFile.getCorruptedBlocks().getHead();\n                while (seq != null) {\n                    missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1)));\n                    seq = seq.getNext();\n                }\n            }\n        }\n\n        if (!missingPredicates.isEmpty()) {\n            for (StoredDestination sd : storedDestinations.values()) {\n\n                final ArrayList<Long> matches = new ArrayList<Long>();\n                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor<Location, Long>(missingPredicates) {\n                    @Override\n                    protected void matched(Location key, Long value) {\n                        matches.add(value);\n                    }\n                });\n\n                // If somes message references are affected by the missing data files...\n                if (!matches.isEmpty()) {\n\n                    // We either 'gracefully' recover dropping the missing messages or\n                    // we error out.\n                    if( ignoreMissingJournalfiles ) {\n                        // Update the index to remove the references to the missing data\n                        for (Long sequenceId : matches) {\n                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                            sd.locationIndex.remove(tx, keys.location);\n                            sd.messageIdIndex.remove(tx, keys.messageId);\n                            undoCounter++;\n                            // TODO: do we need to modify the ack positions for the pub sub case?\n                        }\n\n                    } else {\n                        throw new IOException(\"Detected missing/corrupt journal files. \"+matches.size()+\" messages affected.\");\n                    }\n                }\n            }\n        }\n\n        if( undoCounter > 0 ) {\n            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user\n            // should do sync writes to the journal.\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Detected missing/corrupt journal files.  Dropped \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.updateIndex": "    void updateIndex(Transaction tx, KahaSubscriptionCommand command, Location location) throws IOException {\n        StoredDestination sd = getStoredDestination(command.getDestination(), tx);\n        final String subscriptionKey = command.getSubscriptionKey();\n\n        // If set then we are creating it.. otherwise we are destroying the sub\n        if (command.hasSubscriptionInfo()) {\n            sd.subscriptions.put(tx, subscriptionKey, command);\n            long ackLocation=NOT_ACKED;\n            if (!command.getRetroactive()) {\n                ackLocation = sd.orderIndex.nextMessageId-1;\n            } else {\n                addAckLocationForRetroactiveSub(tx, sd, ackLocation, subscriptionKey);\n            }\n            sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(ackLocation));\n            sd.subscriptionCache.add(subscriptionKey);\n        } else {\n            // delete the sub...\n            sd.subscriptions.remove(tx, subscriptionKey);\n            sd.subscriptionAcks.remove(tx, subscriptionKey);\n            sd.subscriptionCache.remove(subscriptionKey);\n            removeAckLocationsForSub(tx, sd, subscriptionKey);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.allocate": "        void allocate(Transaction tx) throws IOException {\n            defaultPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            if (metadata.version >= 2) {\n                lowPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n                highPriorityIndex = new BTreeIndex<Long, MessageKeys>(pageFile, tx.allocate());\n            }\n        }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.loadStoredDestination": "    private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {\n        // Try to load the existing indexes..\n        StoredDestination rc = metadata.destinations.get(tx, key);\n        if (rc == null) {\n            // Brand new destination.. allocate indexes for it.\n            rc = new StoredDestination();\n            rc.orderIndex.allocate(tx);\n            rc.locationIndex = new BTreeIndex<Location, Long>(pageFile, tx.allocate());\n            rc.messageIdIndex = new BTreeIndex<String, Long>(pageFile, tx.allocate());\n\n            if (topic) {\n                rc.subscriptions = new BTreeIndex<String, KahaSubscriptionCommand>(pageFile, tx.allocate());\n                rc.subscriptionAcks = new BTreeIndex<String, LastAck>(pageFile, tx.allocate());\n                rc.ackPositions = new ListIndex<String, SequenceSet>(pageFile, tx.allocate());\n            }\n            metadata.destinations.put(tx, key, rc);\n        }\n\n        // Configure the marshalers and load.\n        rc.orderIndex.load(tx);\n\n        // Figure out the next key using the last entry in the destination.\n        rc.orderIndex.configureLast(tx);\n\n        rc.locationIndex.setKeyMarshaller(org.apache.kahadb.util.LocationMarshaller.INSTANCE);\n        rc.locationIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.locationIndex.load(tx);\n\n        rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);\n        rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);\n        rc.messageIdIndex.load(tx);\n\n        // If it was a topic...\n        if (topic) {\n\n            rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);\n            rc.subscriptions.load(tx);\n\n            rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.subscriptionAcks.setValueMarshaller(new LastAckMarshaller());\n            rc.subscriptionAcks.load(tx);\n\n            rc.ackPositions.setKeyMarshaller(StringMarshaller.INSTANCE);\n            rc.ackPositions.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);\n            rc.ackPositions.load(tx);\n\n            rc.subscriptionCursors = new HashMap<String, MessageOrderCursor>();\n\n            if (metadata.version < 3) {\n\n                // on upgrade need to fill ackLocation with available messages past last ack\n                for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                    Entry<String, LastAck> entry = iterator.next();\n                    for (Iterator<Entry<Long, MessageKeys>> orderIterator =\n                            rc.orderIndex.iterator(tx, new MessageOrderCursor(entry.getValue().lastAckedSequence)); orderIterator.hasNext(); ) {\n                        Long sequence = orderIterator.next().getKey();\n                        addAckLocation(tx, rc, sequence, entry.getKey());\n                    }\n                    // modify so it is upgraded\n                    rc.subscriptionAcks.put(tx, entry.getKey(), entry.getValue());\n                }\n            }\n\n            // Configure the message references index\n            Iterator<Entry<String, SequenceSet>> subscriptions = rc.ackPositions.iterator(tx);\n            while (subscriptions.hasNext()) {\n                Entry<String, SequenceSet> subscription = subscriptions.next();\n                if (subscription.getValue() != null) {\n                    for(Long sequenceId : subscription.getValue()) {\n                        Long current = rc.messageReferences.get(sequenceId);\n                        if (current == null) {\n                            current = new Long(0);\n                        }\n                        rc.messageReferences.put(sequenceId, Long.valueOf(current.longValue() + 1));\n                    }\n                }\n            }\n\n            // Configure the subscription cache\n            for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {\n                Entry<String, LastAck> entry = iterator.next();\n                rc.subscriptionCache.add(entry.getKey());\n            }\n\n            if (rc.orderIndex.nextMessageId == 0) {\n                // check for existing durable sub all acked out - pull next seq from acks as messages are gone\n                if (!rc.subscriptionAcks.isEmpty(tx)) {\n                    for (Iterator<Entry<String, LastAck>> iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {\n                        Entry<String, LastAck> entry = iterator.next();\n                        rc.orderIndex.nextMessageId =\n                                Math.max(rc.orderIndex.nextMessageId, entry.getValue().lastAckedSequence +1);\n                    }\n                }\n            } else {\n                // update based on ackPositions for unmatched, last entry is always the next\n                if (!rc.messageReferences.isEmpty()) {\n                    Long nextMessageId = (Long) rc.messageReferences.keySet().toArray()[rc.messageReferences.size() - 1];\n                    rc.orderIndex.nextMessageId =\n                            Math.max(rc.orderIndex.nextMessageId, nextMessageId);\n                }\n            }\n        }\n\n        if (metadata.version < VERSION) {\n            // store again after upgrade\n            metadata.destinations.put(tx, key, rc);\n        }\n        return rc;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup": "    protected void checkpointCleanup(final boolean cleanup) throws IOException {\n        long start;\n        this.indexLock.writeLock().lock();\n        try {\n            start = System.currentTimeMillis();\n            if( !opened.get() ) {\n                return;\n            }\n            pageFile.tx().execute(new Transaction.Closure<IOException>() {\n                public void execute(Transaction tx) throws IOException {\n                    checkpointUpdate(tx, cleanup);\n                }\n            });\n        } finally {\n            this.indexLock.writeLock().unlock();\n        }\n\n        long end = System.currentTimeMillis();\n        if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Slow KahaDB access: cleanup took \" + (end - start));\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.lock": "    private void lock() throws IOException {\n\n        if (lockFile == null) {\n            File lockFileName = new File(directory, \"lock\");\n            lockFile = new LockFile(lockFileName, true);\n            if (failIfDatabaseIsLocked) {\n                lockFile.lock();\n            } else {\n                boolean locked = false;\n                while ((!isStopped()) && (!isStopping())) {\n                    try {\n                        lockFile.lock();\n                        locked = true;\n                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \"\n                                + lockFileName\n                                + \" is locked... waiting \"\n                                + (getDatabaseLockedWaitDelay() / 1000)\n                                + \" seconds for the database to be unlocked. Reason: \"\n                                + e);\n                        try {\n                            Thread.sleep(getDatabaseLockedWaitDelay());\n                        } catch (InterruptedException e1) {\n                        }\n                    }\n                }\n                if (!locked) {\n                    throw new IOException(\"attempt to obtain lock aborted due to shutdown\");\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.run": "        public void run() {\n        }",
            "kahadb.src.main.java.org.apache.kahadb.journal.DataFile.openRandomAccessFile": "    public synchronized RandomAccessFile openRandomAccessFile() throws IOException {\n        return new RandomAccessFile(file, \"rw\");\n    }",
            "kahadb.src.main.java.org.apache.kahadb.journal.DataFile.closeRandomAccessFile": "    public synchronized void closeRandomAccessFile(RandomAccessFile file) throws IOException {\n        file.close();\n    }"
        },
        "bug_report": {
            "Title": "Kahadb error during SAN failover delayed write - Allow kahaDB to recover in a similar manner as the JDBC store using the IOExceptionHandler",
            "Description": "An issue can arise that causes the broker to terminate when using kahaDB with a SAN, when the SAN fails over.  In this case the failover process is seamless however, on fail back there is a 2-3 sec delay where writes are blocked and the broker terminates.  With the JDBC datastore a similar situation can be handled by using the IOExceptionHandler.  However with kahaDB, when this same IOExceptionHandler is added it prevents the broker from terminating but kahaDB retains an invalid index.\n\n{code}\n INFO | ActiveMQ JMS Message Broker (Broker1, ID:macbookpro-251a.home-56915-1328715089252-0:1) started\n INFO | jetty-7.1.6.v20100715\n INFO | ActiveMQ WebConsole initialized.\n INFO | Initializing Spring FrameworkServlet 'dispatcher'\n INFO | ActiveMQ Console at http://0.0.0.0:8161/admin\n INFO | ActiveMQ Web Demos at http://0.0.0.0:8161/demo\n INFO | RESTful file access application at http://0.0.0.0:8161/fileserver\n INFO | FUSE Web Console at http://0.0.0.0:8161/console\n INFO | Started SelectChannelConnector@0.0.0.0:8161\nERROR | KahaDB failed to store to Journal\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.SyncFailedException: sync failed\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\nERROR | Checkpoint failed\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.SyncFailedException: sync failed\njava.io.SyncFailedException: sync failed\n\tat java.io.FileDescriptor.sync(Native Method)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:382)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\nERROR | KahaDB failed to store to Journal\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\nERROR | KahaDB failed to store to Journal\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n INFO | Ignoring IO exception, java.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\njava.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)\n\tat java.io.RandomAccessFile.open(Native Method)\n\tat java.io.RandomAccessFile.<init>(RandomAccessFile.java:216)\n\tat org.apache.kahadb.journal.DataFile.openRandomAccessFile(DataFile.java:70)\n\tat org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:324)\n\tat org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:203)\n WARN | Transport failed: java.io.EOFException\n WARN | Transport failed: java.io.EOFException\n INFO | KahaDB: Recovering checkpoint thread after death\nERROR | Checkpoint failed\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n INFO | Ignoring IO exception, java.io.IOException: Input/output error\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n INFO | KahaDB: Recovering checkpoint thread after death\nERROR | Checkpoint failed\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n INFO | Ignoring IO exception, java.io.IOException: Input/output error\njava.io.IOException: Input/output error\n\tat java.io.RandomAccessFile.write(Native Method)\n\tat java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)\n\tat org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1006)\n\tat org.apache.kahadb.page.PageFile.flush(PageFile.java:484)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1290)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:768)\n\tat org.apache.kahadb.page.Transaction.execute(Transaction.java:760)\n\tat org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:766)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:315)\n WARN | Transport failed: java.io.EOFException\n{code}"
        }
    },
    {
        "filename": "AMQ-3085.json",
        "creation_time": "2010-12-15T12:18:12.000+0000",
        "stack_trace": "java.io.IOException: Unexpected error occured\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:208) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat java.lang.Thread.run(Thread.java:619) [na:1.6.0_12]\nCaused by: java.lang.IndexOutOfBoundsException: Index: 12, Size: 11\n\tat java.util.concurrent.CopyOnWriteArrayList.add(CopyOnWriteArrayList.java:409) ~[na:1.6.0_12]\n\tat org.apache.activemq.transport.failover.FailoverTransport.add(FailoverTransport.java:613) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport.updateURIs(FailoverTransport.java:1046) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport.processNewTransports(FailoverTransport.java:285) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport.handleConnectionControl(FailoverTransport.java:265) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport$3.onCommand(FailoverTransport.java:177) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:228) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:219) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:201)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        try {\n                            socket.close();\n                        } catch (IOException e) {\n                            LOG.debug(\"Caught exception closing socket\",e);\n                        }finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.add": "    public void add(boolean rebalance, String u) {\n        try {\n            URI newURI = new URI(u);\n            if (contains(newURI)==false) {\n                uris.add(newURI);\n                reconnect(rebalance);\n            }\n       \n        } catch (Exception e) {\n            LOG.error(\"Failed to parse URI: \" + u);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.contains": "    private boolean contains(URI newURI) {\n       \n        boolean result = false;\n        try {\n        for (URI uri:uris) {\n            if (newURI.getPort()==uri.getPort()) {\n                InetAddress newAddr = InetAddress.getByName(newURI.getHost());\n                InetAddress addr = InetAddress.getByName(uri.getHost());\n                if (addr.equals(newAddr)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        }catch(IOException e) {\n            result = true;\n            LOG.error(\"Failed to verify URI \" + newURI + \" already known: \" + e);\n        }\n        return result;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.reconnect": "    public void reconnect(URI uri) throws IOException {\n        add(true, new URI[] { uri });\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.updateURIs": "    public void updateURIs(boolean rebalance, URI[] updatedURIs) throws IOException {\n        if (isUpdateURIsSupported()) {\n            List<URI> copy = new ArrayList<URI>(this.updated);\n            List<URI> add = new ArrayList<URI>();\n            if (updatedURIs != null && updatedURIs.length > 0) {\n                Set<URI> set = new HashSet<URI>();\n                for (int i = 0; i < updatedURIs.length; i++) {\n                    URI uri = updatedURIs[i];\n                    if (uri != null) {\n                        set.add(uri);\n                    }\n                }\n                for (URI uri : set) {\n                    if (copy.remove(uri) == false) {\n                        add.add(uri);\n                    }\n                }\n                synchronized (reconnectMutex) {\n                    this.updated.clear();\n                    this.updated.addAll(add);\n                    for (URI uri : copy) {\n                        this.uris.remove(uri);\n                    }\n                    add(rebalance, add.toArray(new URI[add.size()]));\n                }\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.remove": "    public void remove(boolean rebalance, URI u[]) {\n        for (int i = 0; i < u.length; i++) {\n            uris.remove(u[i]);\n        }\n        reconnect(rebalance);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.isUpdateURIsSupported": "    public boolean isUpdateURIsSupported() {\n        return this.updateURIsSupported;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.processNewTransports": "    private final void processNewTransports(boolean rebalance, String newTransports) {\n        if (newTransports != null) {\n            newTransports = newTransports.trim();\n            if (newTransports.length() > 0 && isUpdateURIsSupported()) {\n                List<URI> list = new ArrayList<URI>();\n                StringTokenizer tokenizer = new StringTokenizer(newTransports, \",\");\n                while (tokenizer.hasMoreTokens()) {\n                    String str = tokenizer.nextToken();\n                    try {\n                        URI uri = new URI(str);\n                        list.add(uri);\n                    } catch (Exception e) {\n                        LOG.error(\"Failed to parse broker address: \" + str, e);\n                    }\n                }\n                if (list.isEmpty() == false) {\n                    try {\n                        updateURIs(rebalance, list.toArray(new URI[list.size()]));\n                    } catch (IOException e) {\n                        LOG.error(\"Failed to update transport URI's from: \" + newTransports, e);\n                    }\n                }\n\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.handleConnectionControl": "    public final void handleConnectionControl(ConnectionControl control) {\n        String reconnectStr = control.getReconnectTo();\n        if (reconnectStr != null) {\n            reconnectStr = reconnectStr.trim();\n            if (reconnectStr.length() > 0) {\n                try {\n                    URI uri = new URI(reconnectStr);\n                    if (isReconnectSupported()) {\n                        reconnect(uri);\n                        LOG.info(\"Reconnected to: \" + uri);\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"Failed to handle ConnectionControl reconnect to \" + reconnectStr, e);\n                }\n            }\n        }\n        processNewTransports(control.isRebalanceConnection(), control.getConnectedBrokers());\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.isReconnectSupported": "    public boolean isReconnectSupported() {\n        return this.reconnectSupported;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.failover.FailoverTransport.onCommand": "            public void onCommand(Object o) {\n                Command command = (Command) o;\n                if (command == null) {\n                    return;\n                }\n                if (command.isResponse()) {\n                    Object object = null;\n                    synchronized (requestMap) {\n                        object = requestMap.remove(Integer.valueOf(((Response) command).getCorrelationId()));\n                    }\n                    if (object != null && object.getClass() == Tracked.class) {\n                        ((Tracked) object).onResponses(command);\n                    }\n                }\n                if (!initialized) {      \n                    initialized = true;\n                }\n                \n                if(command.isConnectionControl()) {\n                    handleConnectionControl((ConnectionControl) command);\n                }\n                if (transportListener != null) {\n                    transportListener.onCommand(command);\n                }\n            }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        IOException error = null;\n                        remoteWireFormatInfo = (WireFormatInfo) command;\n                        try {\n                            startMonitorThreads();\n                        } catch (IOException e) {\n                            error = e;\n                        }\n                        if (error != null) {\n                            onException(error);\n                        }\n                    }\n                }\n                synchronized (readChecker) {\n                    transportListener.onCommand(command);\n                }\n            }\n        } finally {\n\n            inReceive.set(false);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // Disable inactivity monitoring while processing a command.\n        //synchronize this method - its not synchronized\n        //further down the transport stack and gets called by more\n        //than one thread  by this class\n        synchronized(inSend) {\n            inSend.set(true);\n            try {\n\n                if( failed.get() ) {\n                    throw new InactivityIOException(\"Channel was inactive for too long: \"+next.getRemoteAddress());\n                }\n                if (o.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        localWireFormatInfo = (WireFormatInfo)o;\n                        startMonitorThreads();\n                    }\n                }\n                next.oneway(o);\n            } finally {\n                commandSent.set(true);\n                inSend.set(false);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            transportListener.onException(error);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.InactivityMonitor.startMonitorThreads": "    private synchronized void startMonitorThreads() throws IOException {\n        if (monitorStarted.get()) {\n            return;\n        }\n\n        if (!configuredOk()) {\n            return;\n        }\n\n        if (readCheckTime > 0) {\n            monitorStarted.set(true);\n            writeCheckerTask = new SchedulerTimerTask(writeChecker);\n            readCheckerTask = new  SchedulerTimerTask(readChecker);\n            writeCheckTime = readCheckTime>3 ? readCheckTime/3 : readCheckTime;\n            synchronized( InactivityMonitor.class ) {\n                if( CHECKER_COUNTER == 0 ) {\n                    ASYNC_TASKS = createExecutor();\n                    READ_CHECK_TIMER = new Timer(\"InactivityMonitor ReadCheck\",true);\n                    WRITE_CHECK_TIMER = new Timer(\"InactivityMonitor WriteCheck\",true);\n                }\n                CHECKER_COUNTER++;\n                WRITE_CHECK_TIMER.scheduleAtFixedRate(writeCheckerTask, initialDelayTime,writeCheckTime);\n                READ_CHECK_TIMER.scheduleAtFixedRate(readCheckerTask, initialDelayTime,readCheckTime);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "IndexOutOfBoundsException on FailoverTransport.updateURIs after: already known: java.net.UnknownHostException",
            "Description": "broker returned hosts that are not resolvable on the client can throw the update logic in the failover transport off. Disabling update works around this (updateURIsSupported=false on the failover uri). It should be possible to disable the sending on the broker side also.\nsymptom:\n{code}2010-12-10 07:48:16,574 [ActiveMQ Transport: tcp://xx:61616] DEBUG  failover.FailoverTransport:228 - Transport failed with the following exception:\njava.io.IOException: Unexpected error occured\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:208) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat java.lang.Thread.run(Thread.java:619) [na:1.6.0_12]\nCaused by: java.lang.IndexOutOfBoundsException: Index: 12, Size: 11\n\tat java.util.concurrent.CopyOnWriteArrayList.add(CopyOnWriteArrayList.java:409) ~[na:1.6.0_12]\n\tat org.apache.activemq.transport.failover.FailoverTransport.add(FailoverTransport.java:613) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport.updateURIs(FailoverTransport.java:1046) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport.processNewTransports(FailoverTransport.java:285) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport.handleConnectionControl(FailoverTransport.java:265) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.failover.FailoverTransport$3.onCommand(FailoverTransport.java:177) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:228) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:219) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:201) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]\n\t... 1 common frames omitted{code}"
        }
    },
    {
        "filename": "AMQ-3504.json",
        "creation_time": "2011-09-19T14:33:49.000+0000",
        "stack_trace": "java.lang.NullPointerException\n        at org.apache.activemq.transport.ws.StompServlet.doGet(StompServlet.java:51)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:693)\n        at org.eclipse.jetty.websocket.WebSocketServlet.service(WebSocketServlet.java:73)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)\n        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:527)\n        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:423)\n        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)\n        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:930)\n        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:358)\n        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)\n        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:866)\n        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)\n        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:113)\n        at org.eclipse.jetty.server.Server.handle(Server.java:351)\n        at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:594)\n        at org.eclipse.jetty.server.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:1042)\n        at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:549)\n        at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:211)\n        at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:424)\n        at org.eclipse.jetty.server.bio.SocketConnector$ConnectorEndPoint.run(SocketConnector.java:241)\n        at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:436)\n        at java.lang.Thread.run(Thread.java:680)",
        "source_code": {
            "activemq-optional.src.main.java.org.apache.activemq.transport.ws.StompServlet.doGet": "    protected void doGet(HttpServletRequest request, HttpServletResponse response) \n        throws ServletException ,IOException  {\n        getServletContext().getNamedDispatcher(\"default\").forward(request,response);\n    }"
        },
        "bug_report": {
            "Title": "NullPointerException on websocket connection",
            "Description": "When connecting from chrome or firefox 6 over websockets, I get the Null pointer below. It does not happen on firefox 5 or safari . My guess would be that the chrome and ff 6 are implementing a newer version of the websocket spec that is incompatible with the version that the activemq implements.     \n\n2011-09-19 09:18:33,931 | WARN  | /stomp | org.eclipse.jetty.util.log | qtp1545215993-39\njava.lang.NullPointerException\n        at org.apache.activemq.transport.ws.StompServlet.doGet(StompServlet.java:51)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:693)\n        at org.eclipse.jetty.websocket.WebSocketServlet.service(WebSocketServlet.java:73)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)\n        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:527)\n        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:423)\n        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)\n        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:930)\n        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:358)\n        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)\n        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:866)\n        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)\n        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:113)\n        at org.eclipse.jetty.server.Server.handle(Server.java:351)\n        at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:594)\n        at org.eclipse.jetty.server.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:1042)\n        at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:549)\n        at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:211)\n        at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:424)\n        at org.eclipse.jetty.server.bio.SocketConnector$ConnectorEndPoint.run(SocketConnector.java:241)\n        at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:436)\n        at java.lang.Thread.run(Thread.java:680)\n"
        }
    },
    {
        "filename": "AMQ-6707.json",
        "creation_time": "2017-06-19T11:29:47.000+0000",
        "stack_trace": "javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104\n\tat org.apache.activemq.TransactionContext.toXAException(TransactionContext.java:793)\n\tat org.apache.activemq.TransactionContext.commit(TransactionContext.java:622)\n\tat org.apache.geronimo.transaction.manager.WrapperNamedXAResource.commit(WrapperNamedXAResource.java:54)\n\tat org.apache.geronimo.transaction.manager.CommitTask.run(CommitTask.java:64)\n\tat org.apache.geronimo.transaction.manager.TransactionImpl.commitResources(TransactionImpl.java:688)\n\tat org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:327)\n\tat org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:252)\n\tat org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1020)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:761)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:730)\n\tat org.apache.aries.transaction.internal.AriesPlatformTransactionManager.commit(AriesPlatformTransactionManager.java:75)\n\tat sun.reflect.GeneratedMethodAccessor180.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.8.0_131]\n\tat java.lang.reflect.Method.invoke(Method.java:498)[:1.8.0_131]\n\tat com.ectsp.spring.osgi.PlatformTransactionManagerFactoryBean$ProxyTxManagerHandler.invoke(PlatformTransactionManagerFactoryBean.java:115)[169:ectsp-spring-osgi:1.0.0.SNAPSHOT]\n\tat com.sun.proxy.$Proxy68.commit(Unknown Source)[100:org.apache.servicemix.bundles.spring-tx:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:245)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1164)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1156)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1053)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat java.lang.Thread.run(Thread.java:748)[:1.8.0_131]\nCaused by: javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104\n\tat org.apache.activemq.transaction.Transaction.newXAException(Transaction.java:212)\n\tat org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:93)\n\tat org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:76)\n\tat org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:252)\n\tat org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)\n\tat org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)\n\tat org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:547)\n\tat org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:336)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:200)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)[47:org.apache.activemq.activemq-osgi:5.14.5]\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)[47:org.apache.activemq.activemq-osgi:5.14.5]\n\tat java.lang.Thread.run(Thread.java:745)[:1.8.0_131]\nCaused by: java.io.IOException: Could not remove prepared transaction state from message add for sequenceId: 4025171\n\tat org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doCommitAddOp(DefaultJDBCAdapter.java:1031)\n\tat org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.commitAdd(JDBCPersistenceAdapter.java:780)\n\tat org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore$CommitAddOutcome.run(JdbcMemoryTransactionStore.java:146)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:101)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:270)\n\tat org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:86)",
        "source_code": {
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.toXAException": "    private XAException toXAException(JMSException e) {\n        if (e.getCause() != null && e.getCause() instanceof XAException) {\n            XAException original = (XAException)e.getCause();\n            XAException xae = new XAException(original.getMessage());\n            xae.errorCode = original.errorCode;\n            if (xae.errorCode == XA_OK) {\n                // detail not unmarshalled see: org.apache.activemq.openwire.v1.BaseDataStreamMarshaller.createThrowable\n                xae.errorCode = parseFromMessageOr(original.getMessage(), XAException.XAER_RMERR);\n            }\n            xae.initCause(original);\n            return xae;\n        }\n\n        XAException xae = new XAException(e.getMessage());\n        xae.errorCode = XAException.XAER_RMFAIL;\n        xae.initCause(e);\n        return xae;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.parseFromMessageOr": "    private int parseFromMessageOr(String message, int fallbackCode) {\n        final String marker = \"xaErrorCode:\";\n        final int index = message.lastIndexOf(marker);\n        if (index > -1) {\n            try {\n                return Integer.parseInt(message.substring(index + marker.length()));\n            } catch (Exception ignored) {}\n        }\n        return fallbackCode;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.commit": "    public void commit(Xid xid, boolean onePhase) throws XAException {\n\n        LOG.debug(\"Commit: {}, onePhase={}\", xid, onePhase);\n\n        // We allow interleaving multiple transactions, so\n        // we don't limit commit to the associated xid.\n        XATransactionId x;\n        if (xid == null || (equals(associatedXid, xid))) {\n            // should never happen, end(xid,TMSUCCESS) must have been previously\n            // called\n            throw new XAException(XAException.XAER_PROTO);\n        } else {\n            x = new XATransactionId(xid);\n        }\n\n        if (rollbackOnly) {\n             LOG.warn(\"commit of: \" + x + \" failed because it was marked rollback only; typically due to failover with pending acks\");\n             throw new XAException(XAException.XA_RBINTEGRITY);\n         }\n\n        try {\n            this.connection.checkClosedOrFailed();\n            this.connection.ensureConnectionInfoSent();\n\n            // Notify the server that the tx was committed back\n            TransactionInfo info = new TransactionInfo(getConnectionId(), x, onePhase ? TransactionInfo.COMMIT_ONE_PHASE : TransactionInfo.COMMIT_TWO_PHASE);\n\n            this.connection.syncSendPacket(info);\n\n            List<TransactionContext> l;\n            synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {\n                l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);\n            }\n            // After commit may be expensive and can deadlock, do it outside global synch block\n            // No risk for concurrent updates as we own the list now\n            if (l != null) {\n                for (TransactionContext ctx : l) {\n                    try {\n                        ctx.afterCommit();\n                    } catch (Exception ignored) {\n                        LOG.debug(\"ignoring exception from after completion on ended transaction: {}\", ignored, ignored);\n                    }\n                }\n            }\n\n        } catch (JMSException e) {\n            LOG.warn(\"commit of: \" + x + \" failed with: \" + e, e);\n            if (onePhase) {\n                List<TransactionContext> l;\n                synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {\n                    l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);\n                }\n                // After rollback may be expensive and can deadlock, do it outside global synch block\n                // No risk for concurrent updates as we own the list now\n                if (l != null) {\n                    for (TransactionContext ctx : l) {\n                        try {\n                            ctx.afterRollback();\n                        } catch (Throwable ignored) {\n                            LOG.debug(\"failed to firing afterRollback callbacks commit failure, txid: {}, context: {}\", x, ctx, ignored);\n                        }\n                    }\n                }\n            }\n            throw toXAException(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.getConnectionId": "    private ConnectionId getConnectionId() {\n        return connection.getConnectionInfo().getConnectionId();\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.rollback": "    public void rollback(Xid xid) throws XAException {\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Rollback: \" + xid);\n        }\n\n        // We allow interleaving multiple transactions, so\n        // we don't limit rollback to the associated xid.\n        XATransactionId x;\n        if (xid == null) {\n            throw new XAException(XAException.XAER_PROTO);\n        }\n        if (equals(associatedXid, xid)) {\n            // I think this can happen even without an end(xid) call. Need to\n            // check spec.\n            x = (XATransactionId)transactionId;\n        } else {\n            x = new XATransactionId(xid);\n        }\n\n        try {\n            this.connection.checkClosedOrFailed();\n            this.connection.ensureConnectionInfoSent();\n\n            // Let the server know that the tx is rollback.\n            TransactionInfo info = new TransactionInfo(getConnectionId(), x, TransactionInfo.ROLLBACK);\n            this.connection.syncSendPacket(info);\n\n            List<TransactionContext> l;\n            synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {\n                l = ENDED_XA_TRANSACTION_CONTEXTS.remove(x);\n            }\n            // After rollback may be expensive and can deadlock, do it outside global synch block\n            // No risk for concurrent updates as we own the list now\n            if (l != null) {\n                for (TransactionContext ctx : l) {\n                    ctx.afterRollback();\n                }                  \n            }\n        } catch (JMSException e) {\n            throw toXAException(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.afterRollback": "    private void afterRollback() throws JMSException {\n        if (synchronizations == null) {\n            return;\n        }\n\n        Throwable firstException = null;\n        int size = synchronizations.size();\n        for (int i = 0; i < size; i++) {\n            try {\n                synchronizations.get(i).afterRollback();\n            } catch (Throwable t) {\n                LOG.debug(\"Exception from afterRollback on {}\", synchronizations.get(i), t);\n                if (firstException == null) {\n                    firstException = t;\n                }\n            }\n        }\n        synchronizations = null;\n        if (firstException != null) {\n            throw JMSExceptionSupport.create(firstException);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.equals": "    private boolean equals(Xid xid1, Xid xid2) {\n        if (xid1 == xid2) {\n            return true;\n        }\n        if (xid1 == null ^ xid2 == null) {\n            return false;\n        }\n        return xid1.getFormatId() == xid2.getFormatId() && Arrays.equals(xid1.getBranchQualifier(), xid2.getBranchQualifier())\n               && Arrays.equals(xid1.getGlobalTransactionId(), xid2.getGlobalTransactionId());\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.afterCommit": "    private void afterCommit() throws JMSException {\n        if (synchronizations == null) {\n            return;\n        }\n\n        Throwable firstException = null;\n        int size = synchronizations.size();\n        for (int i = 0; i < size; i++) {\n            try {\n                synchronizations.get(i).afterCommit();\n            } catch (Throwable t) {\n                LOG.debug(\"Exception from afterCommit on {}\", synchronizations.get(i), t);\n                if (firstException == null) {\n                    firstException = t;\n                }\n            }\n        }\n        synchronizations = null;\n        if (firstException != null) {\n            throw JMSExceptionSupport.create(firstException);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.getTransactionId": "    public TransactionId getTransactionId() {\n        return transactionId;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.isInXATransaction": "    public boolean isInXATransaction() {\n        if (transactionId != null && transactionId.isXATransaction()) {\n            return true;\n        } else {\n            synchronized(ENDED_XA_TRANSACTION_CONTEXTS) {\n                for(List<TransactionContext> transactions : ENDED_XA_TRANSACTION_CONTEXTS.values()) {\n                      if (transactions.contains(this)) {\n                          return true;\n                      }\n                }\n            }\n        }\n\n        return false;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.beforeEnd": "    private void beforeEnd() throws JMSException {\n        if (synchronizations == null) {\n            return;\n        }\n\n        int size = synchronizations.size();\n        try {\n            for (;beforeEndIndex < size;) {\n                synchronizations.get(beforeEndIndex++).beforeEnd();\n            }\n        } catch (JMSException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw JMSExceptionSupport.create(e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.Transaction.newXAException": "    public static XAException newXAException(String s, int errorCode) {\n        XAException xaException = new XAException(s + \" \" + TransactionContext.xaErrorCodeMarker + errorCode);\n        xaException.errorCode = errorCode;\n        return xaException;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.storeCommit": "    private void storeCommit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit)\n            throws XAException, IOException {\n        try {\n            transactionStore.commit(getTransactionId(), wasPrepared, preCommitTask, postCommitTask);\n            waitPostCommitDone(postCommitTask);\n        } catch (XAException xae) {\n            throw xae;\n        } catch (Throwable t) {\n            LOG.warn(\"Store COMMIT FAILED: \", t);\n            rollback();\n            XAException xae = newXAException(\"STORE COMMIT FAILED: Transaction rolled back\", XAException.XA_RBOTHER);\n            xae.initCause(t);\n            throw xae;\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.commit": "    public void commit(boolean onePhase) throws XAException, IOException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"XA Transaction commit onePhase:\" + onePhase + \", xid: \" + xid);\n        }\n\n        switch (getState()) {\n        case START_STATE:\n            // 1 phase commit, no work done.\n            checkForPreparedState(onePhase);\n            setStateFinished();\n            break;\n        case IN_USE_STATE:\n            // 1 phase commit, work done.\n            checkForPreparedState(onePhase);\n            doPrePrepare();\n            setStateFinished();\n            storeCommit(getTransactionId(), false, preCommitTask, postCommitTask);\n            break;\n        case PREPARED_STATE:\n            // 2 phase commit, work done.\n            // We would record commit here.\n            setStateFinished();\n            storeCommit(getTransactionId(), true, preCommitTask, postCommitTask);\n            break;\n        default:\n            illegalStateTransition(\"commit\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.rollback": "    public void rollback() throws XAException, IOException {\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"XA Transaction rollback: \" + xid);\n        }\n\n        switch (getState()) {\n        case START_STATE:\n            // 1 phase rollback no work done.\n            setStateFinished();\n            break;\n        case IN_USE_STATE:\n            // 1 phase rollback work done.\n            setStateFinished();\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        case PREPARED_STATE:\n            // 2 phase rollback work done.\n            setStateFinished();\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        case FINISHED_STATE:\n            // failure to commit\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        default:\n            throw newXAException(\"Invalid state: \" + getState(), XAException.XA_RBPROTO);\n        }\n\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.getTransactionId": "    public TransactionId getTransactionId() {\n        return xid;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.commitTransaction": "    public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {\n        Transaction transaction = getTransaction(context, xid, true);\n        transaction.commit(onePhase);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Transaction transaction = null;\n        if (xid.isXATransaction()) {\n            synchronized (xaTransactions) {\n                transaction = xaTransactions.get(xid);\n            }\n        } else {\n            transaction = context.getTransactions().get(xid);\n        }\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = XATransaction.newXAException(\"Transaction '\" + xid + \"' has not been started.\", XAException.XAER_NOTA);\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase": "    public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        cs.removeTransactionState(info.getTransactionId());\n        broker.commitTransaction(context, info.getTransactionId(), false);\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.lookupConnectionState": "    public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getConnectionId": "    public String getConnectionId() {\n        List<TransportConnectionState> connectionStates = listConnectionStates();\n        for (TransportConnectionState cs : connectionStates) {\n            if (cs.getInfo().getClientId() != null) {\n                return cs.getInfo().getClientId();\n            }\n            return cs.getInfo().getConnectionId().toString();\n        }\n        return null;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.TransactionInfo.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        switch (type) {\n        case TransactionInfo.BEGIN:\n            return visitor.processBeginTransaction(this);\n        case TransactionInfo.END:\n            return visitor.processEndTransaction(this);\n        case TransactionInfo.PREPARE:\n            return visitor.processPrepareTransaction(this);\n        case TransactionInfo.COMMIT_ONE_PHASE:\n            return visitor.processCommitTransactionOnePhase(this);\n        case TransactionInfo.COMMIT_TWO_PHASE:\n            return visitor.processCommitTransactionTwoPhase(this);\n        case TransactionInfo.ROLLBACK:\n            return visitor.processRollbackTransaction(this);\n        case TransactionInfo.RECOVER:\n            return visitor.processRecoverTransactions(this);\n        case TransactionInfo.FORGET:\n            return visitor.processForgetTransaction(this);\n        default:\n            throw new IOException(\"Transaction info type unknown: \" + type);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop.get()) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(transportException.get());\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred on connection to: {}, {}\",\n                            transport.getRemoteAddress(), e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.forceRollbackOnlyOnFailedAsyncTransactionOp": "    private void forceRollbackOnlyOnFailedAsyncTransactionOp(Throwable e, Command command) {\n        if (brokerService.isRollbackOnlyOnAsyncException() && !(e instanceof IOException) && isInTransaction(command)) {\n            Transaction transaction = getActiveTransaction(command);\n            if (transaction != null && !transaction.isRollbackOnly()) {\n                LOG.debug(\"on async exception, force rollback of transaction for: \" + command, e);\n                transaction.setRollbackOnly(e);\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getRemoteAddress": "    public String getRemoteAddress() {\n        return transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                transportException.set(e);\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                if (SERVICELOG.isDebugEnabled()) {\n                    SERVICELOG.debug(\"Async error occurred: \" + e, e);\n                } else {\n                    SERVICELOG.warn(\"Async error occurred: \" + e);\n                }\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop.get()) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.isStopping": "    public boolean isStopping() {\n        return stopping.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doCommitAddOp": "    public void doCommitAddOp(TransactionContext c, long preparedSequence, long sequence) throws SQLException, IOException {\n        PreparedStatement s = null;\n        try {\n            s = c.getConnection().prepareStatement(this.statements.getClearXidFlagStatement());\n            s.setLong(1, sequence);\n            s.setLong(2, preparedSequence);\n            if (s.executeUpdate() != 1) {\n                throw new IOException(\"Could not remove prepared transaction state from message add for sequenceId: \" + sequence);\n            }\n        } finally {\n            close(s);\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.close": "    protected static void close(ResultSet rs) {\n        try {\n            rs.close();\n        } catch (Throwable e) {\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.commitAdd": "    public void commitAdd(ConnectionContext context, MessageId messageId, long preparedSequenceId) throws IOException {\n        TransactionContext c = getTransactionContext(context);\n        try {\n            long sequence = (Long)messageId.getEntryLocator();\n            getAdapter().doCommitAddOp(c, preparedSequenceId, sequence);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to commit add: \" + messageId + \". Reason: \" + e, e);\n        } finally {\n            c.close();\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.getAdapter": "    public JDBCAdapter getAdapter() throws IOException {\n        if (adapter == null) {\n            setAdapter(createAdapter());\n        }\n        return adapter;\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.log": "    public static void log(String msg, SQLException e) {\n        String s = msg + e.getMessage();\n        while (e.getNextException() != null) {\n            e = e.getNextException();\n            s += \", due to: \" + e.getMessage();\n        }\n        LOG.warn(s, e);\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.getTransactionContext": "    public TransactionContext getTransactionContext() throws IOException {\n        TransactionContext answer = new TransactionContext(this);\n        if (transactionIsolation > 0) {\n            answer.setTransactionIsolation(transactionIsolation);\n        }\n        return answer;\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore.run": "                public void run(ConnectionContext ctx) throws IOException {\n                    topicMessageStore.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore.acknowledge": "    public void acknowledge(final TopicMessageStore topicMessageStore, final String clientId, final String subscriptionName,\n                           final MessageId messageId, final MessageAck ack) throws IOException {\n\n        if (ack.isInTransaction()) {\n            Tx tx = getTx(ack.getTransactionId());\n            tx.add(new LastAckCommand() {\n                public MessageAck getMessageAck() {\n                    return ack;\n                }\n\n                public void run(ConnectionContext ctx) throws IOException {\n                    topicMessageStore.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                }\n\n                @Override\n                public MessageStore getMessageStore() {\n                    return topicMessageStore;\n                }\n\n                @Override\n                public void rollback(ConnectionContext context) throws IOException {\n                    JDBCTopicMessageStore jdbcTopicMessageStore = (JDBCTopicMessageStore)topicMessageStore;\n                    ((JDBCPersistenceAdapter)persistenceAdapter).rollbackLastAck(context,\n                            jdbcTopicMessageStore,\n                            ack,\n                            subscriptionName, clientId);\n                    jdbcTopicMessageStore.complete(clientId, subscriptionName);\n                }\n\n\n                @Override\n                public String getClientId() {\n                    return clientId;\n                }\n\n                @Override\n                public String getSubName() {\n                    return subscriptionName;\n                }\n\n                @Override\n                public long getSequence() {\n                    throw new IllegalStateException(\"Sequence id must be inferred from ack\");\n                }\n\n                @Override\n                public byte getPriority() {\n                    throw new IllegalStateException(\"Priority must be inferred from ack or row\");\n                }\n\n                @Override\n                public void setMessageStore(JDBCTopicMessageStore jdbcTopicMessageStore) {\n                    throw new IllegalStateException(\"message store already known!\");\n                }\n            });\n        } else {\n            topicMessageStore.acknowledge(null, clientId, subscriptionName, messageId, ack);\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore.getPriority": "                public byte getPriority() {\n                    throw new IllegalStateException(\"Priority must be inferred from ack or row\");\n                }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.commit": "    public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit) throws IOException {\n        if (preCommit != null) {\n            preCommit.run();\n        }\n        Tx tx;\n        if (wasPrepared) {\n            tx = preparedTransactions.remove(txid);\n        } else {\n            tx = inflightTransactions.remove(txid);\n        }\n\n        if (tx != null) {\n            tx.commit();\n        }\n        if (postCommit != null) {\n            postCommit.run();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.run": "                public void run(ConnectionContext ctx) throws IOException {\n                    destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                }",
            "activemq-client.src.main.java.org.apache.activemq.localTransactionEventListener.commitEvent": "    void commitEvent();\n\n    void rollbackEvent();\n}",
            "activemq-client.src.main.java.org.apache.activemq.localTransactionEventListener.rollbackEvent": "    void rollbackEvent();\n}",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnectionState.getContext": "    public ConnectionContext getContext() {\n        return context;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.broker.commitTransaction": "    void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception;\n\n    /**\n     * Forgets a transaction.\n     *\n     * @param context\n     * @param transactionId\n     * @throws Exception\n     */\n    void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception;\n\n    /**\n     * Get the BrokerInfo's of any connected Brokers\n     *\n     * @return array of peer BrokerInfos\n     */\n    BrokerInfo[] getPeerBrokerInfos();\n\n    /**\n     * Notify the Broker that a dispatch is going to happen\n     *\n     * @param messageDispatch\n     */\n    void preProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * Notify the Broker that a dispatch has happened\n     *\n     * @param messageDispatch\n     */\n    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     *\n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     *\n     * @param context\n     * @param info\n     *\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     *\n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     *\n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     *\n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     *\n     * @param context\n     * @param messageReference\n     * @param subscription (may be null)\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n\n    /**\n     * A message needs to go the a DLQ\n     *\n     *\n     * @param context\n     * @param messageReference\n     * @param poisonCause reason for dlq submission, may be null\n     * @return true if Message was placed in a DLQ false if discarded.\n     */\n    boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause);\n\n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n\n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub\n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     * @param destination\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo,ActiveMQDestination destination);\n\n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination\n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage<?> usage);\n\n    void virtualDestinationAdded(ConnectionContext context, VirtualDestination virtualDestination);\n\n    void virtualDestinationRemoved(ConnectionContext context, VirtualDestination virtualDestination);\n\n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n\n    Scheduler getScheduler();\n\n    ThreadPoolExecutor getExecutor();\n\n    void networkBridgeStarted(BrokerInfo brokerInfo, boolean createdByDuplex, String remoteIp);\n\n    void networkBridgeStopped(BrokerInfo brokerInfo);\n\n\n}",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.close": "        public void close() throws SQLException {\n            try {\n                delegate.close();\n            } finally {\n                lock.unlock();\n            }\n        }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.commit": "        public void commit() throws SQLException {\n            delegate.commit();\n        }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.getAutoCommit": "        public boolean getAutoCommit() throws SQLException {\n            return delegate.getAutoCommit();\n        }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.executeBatch": "    private void executeBatch(PreparedStatement p, String message) throws SQLException {\n        if (p == null) {\n            return;\n        }\n\n        try {\n            int[] rc = p.executeBatch();\n            for (int i = 0; i < rc.length; i++) {\n                int code = rc[i];\n                if (code < 0 && code != Statement.SUCCESS_NO_INFO) {\n                    throw new SQLException(message + \". Response code: \" + code);\n                }\n            }\n        } finally {\n            try {\n                p.close();\n            } catch (Throwable e) {\n            }\n        }\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.getNextSequenceId": "    public long getNextSequenceId() {\n        return sequenceGenerator.getNextSequenceId();\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.onCompletion": "    public void onCompletion(Runnable runnable) {\n        completions.add(runnable);\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCTopicMessageStore.complete": "    public void complete(String clientId, String subscriptionName) {\n        pendingCompletion.remove(getSubscriptionKey(clientId, subscriptionName));\n        LOG.trace(this + \", completion for: \" + getSubscriptionKey(clientId, subscriptionName));\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCTopicMessageStore.remove": "            public void remove() {\n                throw new RuntimeException(\"not implemented\");\n            }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCTopicMessageStore.getSubscriptionKey": "    protected String getSubscriptionKey(String clientId, String subscriberName) {\n        String result = clientId + \":\";\n        result += subscriberName != null ? subscriberName : \"NOT_SET\";\n        return result;\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.jdbcMessageStore.onAdd": "    protected void onAdd(Message message, long sequenceId, byte priority) {}"
        },
        "bug_report": {
            "Title": "JDBC XA: Could not remove prepared transaction state from message",
            "Description": "When ActiveMQ 5.14.5 is configured with jdbc persistence storage (postgres) from time to time below error occurs:\n{code}\n2017-06-15 01:41:37,418 | ERROR | enerContainer-21 | CommitTask                       | 67 - org.apache.aries.transaction.manager - 1.3.1 | Unexpected exception committing org.apache.geronimo.transaction.manager.WrapperNamedXAResource@34ac9d62; continuing to commit other RMs\njavax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104\n\tat org.apache.activemq.TransactionContext.toXAException(TransactionContext.java:793)\n\tat org.apache.activemq.TransactionContext.commit(TransactionContext.java:622)\n\tat org.apache.geronimo.transaction.manager.WrapperNamedXAResource.commit(WrapperNamedXAResource.java:54)\n\tat org.apache.geronimo.transaction.manager.CommitTask.run(CommitTask.java:64)\n\tat org.apache.geronimo.transaction.manager.TransactionImpl.commitResources(TransactionImpl.java:688)\n\tat org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:327)\n\tat org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:252)\n\tat org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1020)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:761)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:730)\n\tat org.apache.aries.transaction.internal.AriesPlatformTransactionManager.commit(AriesPlatformTransactionManager.java:75)\n\tat sun.reflect.GeneratedMethodAccessor180.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.8.0_131]\n\tat java.lang.reflect.Method.invoke(Method.java:498)[:1.8.0_131]\n\tat com.ectsp.spring.osgi.PlatformTransactionManagerFactoryBean$ProxyTxManagerHandler.invoke(PlatformTransactionManagerFactoryBean.java:115)[169:ectsp-spring-osgi:1.0.0.SNAPSHOT]\n\tat com.sun.proxy.$Proxy68.commit(Unknown Source)[100:org.apache.servicemix.bundles.spring-tx:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:245)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1164)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1156)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1053)[97:org.apache.servicemix.bundles.spring-jms:4.2.8.RELEASE_1]\n\tat java.lang.Thread.run(Thread.java:748)[:1.8.0_131]\nCaused by: javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104\n\tat org.apache.activemq.transaction.Transaction.newXAException(Transaction.java:212)\n\tat org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:93)\n\tat org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:76)\n\tat org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:252)\n\tat org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)\n\tat org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)\n\tat org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:547)\n\tat org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:336)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:200)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)[47:org.apache.activemq.activemq-osgi:5.14.5]\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)[47:org.apache.activemq.activemq-osgi:5.14.5]\n\tat java.lang.Thread.run(Thread.java:745)[:1.8.0_131]\nCaused by: java.io.IOException: Could not remove prepared transaction state from message add for sequenceId: 4025171\n\tat org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doCommitAddOp(DefaultJDBCAdapter.java:1031)\n\tat org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.commitAdd(JDBCPersistenceAdapter.java:780)\n\tat org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore$CommitAddOutcome.run(JdbcMemoryTransactionStore.java:146)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:101)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:270)\n\tat org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:86)\n\t... 15 more\n{code}\nIt seams that it the same issue as in https://issues.apache.org/jira/browse/AMQ-5567."
        }
    },
    {
        "filename": "AMQ-5384.json",
        "creation_time": "2014-10-06T09:26:58.000+0000",
        "stack_trace": "java.lang.Exception: DEBUG STACK TRACE: Overdue resource check-out stack trace.\n        at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:555)\n        at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:756)\n        at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:683)\n        at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)\n        at org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)\n        at org.apache.activemq.store.jdbc.TransactionContext.begin(TransactionContext.java:163)\n        at org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.beginTransaction(JDBCPersistenceAdapter.java:510)\n        at org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:92)\n        at org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:259)\n        at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)\n        at org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:75)\n        at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)\n        at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)\n        at org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:433)\n        at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)\n        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)\n        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n        at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n        at java.lang.Thread.run(Thread.java:662)",
        "source_code": {
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.getConnection": "    public ActiveMQConnection getConnection() {\n        return connection;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.begin": "    public void begin() throws JMSException {\n\n        if (isInXATransaction()) {\n            throw new TransactionInProgressException(\"Cannot start local transaction.  XA transaction is already in progress.\");\n        }\n\n        if (transactionId == null) {\n            synchronizations = null;\n            beforeEndIndex = 0;\n            this.transactionId = new LocalTransactionId(getConnectionId(), localTransactionIdGenerator.getNextSequenceId());\n            TransactionInfo info = new TransactionInfo(getConnectionId(), transactionId, TransactionInfo.BEGIN);\n            this.connection.ensureConnectionInfoSent();\n            this.connection.asyncSendPacket(info);\n\n            // Notify the listener that the tx was started.\n            if (localTransactionEventListener != null) {\n                localTransactionEventListener.beginEvent();\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Begin:\" + transactionId);\n            }\n        }\n\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.isInXATransaction": "    public boolean isInXATransaction() {\n        if (transactionId != null && transactionId.isXATransaction()) {\n        \treturn true;\n        } else {\n    \t\tif (!ENDED_XA_TRANSACTION_CONTEXTS.isEmpty()) {\n\t        \tsynchronized(ENDED_XA_TRANSACTION_CONTEXTS) {\n        \t\t\tfor(List<TransactionContext> transactions : ENDED_XA_TRANSACTION_CONTEXTS.values()) {\n        \t\t\t\tif (transactions.contains(this)) {\n        \t\t\t\t\treturn true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n    \t\t}\n        }\n\n        return false;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.TransactionContext.getConnectionId": "    private ConnectionId getConnectionId() {\n        return connection.getConnectionInfo().getConnectionId();\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.beginTransaction": "    public void beginTransaction(ConnectionContext context) throws IOException {\n        TransactionContext transactionContext = getTransactionContext(context);\n        transactionContext.begin();\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.getTransactionContext": "    public TransactionContext getTransactionContext() throws IOException {\n        TransactionContext answer = new TransactionContext(this);\n        if (transactionIsolation > 0) {\n            answer.setTransactionIsolation(transactionIsolation);\n        }\n        return answer;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.commit": "    public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws IOException {\n        if (preCommit != null) {\n            preCommit.run();\n        }\n        Tx tx;\n        if (wasPrepared) {\n            tx = preparedTransactions.remove(txid);\n        } else {\n            tx = inflightTransactions.remove(txid);\n        }\n\n        if (tx != null) {\n            tx.commit();\n        }\n        if (postCommit != null) {\n            postCommit.run();\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.store.memory.MemoryTransactionStore.run": "                public void run(ConnectionContext ctx) throws IOException {\n                    destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);\n                }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.storeCommit": "    private void storeCommit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit)\n            throws XAException, IOException {\n        try {\n            transactionStore.commit(getTransactionId(), wasPrepared, preCommitTask, postCommitTask);\n            waitPostCommitDone(postCommitTask);\n        } catch (XAException xae) {\n            throw xae;\n        } catch (Throwable t) {\n            LOG.warn(\"Store COMMIT FAILED: \", t);\n            rollback();\n            XAException xae = newXAException(\"STORE COMMIT FAILED: Transaction rolled back\", XAException.XA_RBOTHER);\n            xae.initCause(t);\n            throw xae;\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.commit": "    public void commit(boolean onePhase) throws XAException, IOException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"XA Transaction commit onePhase:\" + onePhase + \", xid: \" + xid);\n        }\n\n        switch (getState()) {\n        case START_STATE:\n            // 1 phase commit, no work done.\n            checkForPreparedState(onePhase);\n            setStateFinished();\n            break;\n        case IN_USE_STATE:\n            // 1 phase commit, work done.\n            checkForPreparedState(onePhase);\n            doPrePrepare();\n            setStateFinished();\n            storeCommit(getTransactionId(), false, preCommitTask, postCommitTask);\n            break;\n        case PREPARED_STATE:\n            // 2 phase commit, work done.\n            // We would record commit here.\n            setStateFinished();\n            storeCommit(getTransactionId(), true, preCommitTask, postCommitTask);\n            break;\n        default:\n            illegalStateTransition(\"commit\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.rollback": "    public void rollback() throws XAException, IOException {\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"XA Transaction rollback: \" + xid);\n        }\n\n        switch (getState()) {\n        case START_STATE:\n            // 1 phase rollback no work done.\n            setStateFinished();\n            break;\n        case IN_USE_STATE:\n            // 1 phase rollback work done.\n            setStateFinished();\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        case PREPARED_STATE:\n            // 2 phase rollback work done.\n            setStateFinished();\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        case FINISHED_STATE:\n            // failure to commit\n            transactionStore.rollback(getTransactionId());\n            doPostRollback();\n            break;\n        default:\n            throw newXAException(\"Invalid state: \" + getState(), XAException.XA_RBPROTO);\n        }\n\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.newXAException": "    public static XAException newXAException(String s, int errorCode) {\n        XAException xaException = new XAException(s + \" \" + TransactionContext.xaErrorCodeMarker + errorCode);\n        xaException.errorCode = errorCode;\n        return xaException;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.transaction.XATransaction.getTransactionId": "    public TransactionId getTransactionId() {\n        return xid;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.commitTransaction": "    public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {\n        Transaction transaction = getTransaction(context, xid, true);\n        transaction.commit(onePhase);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransactionBroker.getTransaction": "    public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {\n        Map transactionMap = null;\n        synchronized (xaTransactions) {\n            transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();\n        }\n        Transaction transaction = (Transaction)transactionMap.get(xid);\n        if (transaction != null) {\n            return transaction;\n        }\n        if (xid.isXATransaction()) {\n            XAException e = XATransaction.newXAException(\"Transaction '\" + xid + \"' has not been started.\", XAException.XAER_NOTA);\n            throw e;\n        } else {\n            throw new JMSException(\"Transaction '\" + xid + \"' has not been started.\");\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.commitTransaction": "    public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {\n        getNext().commitTransaction(context, xid, onePhase);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.MutableBrokerFilter.getNext": "    public Broker getNext() {\n        return next.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase": "    public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        cs.removeTransactionState(info.getTransactionId());\n        broker.commitTransaction(context, info.getTransactionId(), false);\n        return null;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.lookupConnectionState": "    public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.getConnectionId": "    public String getConnectionId() {\n        List<TransportConnectionState> connectionStates = listConnectionStates();\n        for (TransportConnectionState cs : connectionStates) {\n            if (cs.getInfo().getClientId() != null) {\n                return cs.getInfo().getClientId();\n            }\n            return cs.getInfo().getConnectionId().toString();\n        }\n        return null;\n    }",
            "activemq-client.src.main.java.org.apache.activemq.command.TransactionInfo.visit": "    public Response visit(CommandVisitor visitor) throws Exception {\n        switch (type) {\n        case TransactionInfo.BEGIN:\n            return visitor.processBeginTransaction(this);\n        case TransactionInfo.END:\n            return visitor.processEndTransaction(this);\n        case TransactionInfo.PREPARE:\n            return visitor.processPrepareTransaction(this);\n        case TransactionInfo.COMMIT_ONE_PHASE:\n            return visitor.processCommitTransactionOnePhase(this);\n        case TransactionInfo.COMMIT_TWO_PHASE:\n            return visitor.processCommitTransactionTwoPhase(this);\n        case TransactionInfo.ROLLBACK:\n            return visitor.processRollbackTransaction(this);\n        case TransactionInfo.RECOVER:\n            return visitor.processRecoverTransactions(this);\n        case TransactionInfo.FORGET:\n            return visitor.processForgetTransaction(this);\n        default:\n            throw new IOException(\"Transaction info type unknown: \" + type);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.service": "    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred: {}\", e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.serviceException": "    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \", e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.toString": "    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.onCommand": "            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.isStopping": "    public boolean isStopping() {\n        return stopping.get();\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnection.dispatchSync": "    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.MutexTransport.onCommand": "    public void onCommand(Object command) {\n        if (syncOnCommand) {\n            writeLock.lock();\n            try {\n                transportListener.onCommand(command);\n            } finally {\n                writeLock.unlock();\n            }\n        } else {\n            transportListener.onCommand(command);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.onCommand": "    public void onCommand(Object o) {\n        Command command = (Command)o;\n        if (command.isWireFormatInfo()) {\n            WireFormatInfo info = (WireFormatInfo)command;\n            negociate(info);\n        }\n        getTransportListener().onCommand(command);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.WireFormatNegotiator.negociate": "    public void negociate(WireFormatInfo info) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Received WireFormat: \" + info);\n        }\n\n        try {\n            wireInfoSentDownLatch.await();\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" before negotiation: \" + wireFormat);\n            }\n            if (!info.isValid()) {\n                onException(new IOException(\"Remote wire format magic is invalid\"));\n            } else if (info.getVersion() < minimumVersion) {\n                onException(new IOException(\"Remote wire format (\" + info.getVersion() + \") is lower the minimum version required (\" + minimumVersion + \")\"));\n            }\n\n            wireFormat.renegotiateWireFormat(info);\n            Socket socket = next.narrow(Socket.class);\n            if (socket != null) {\n                socket.setTcpNoDelay(wireFormat.isTcpNoDelayEnabled());\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(this + \" after negotiation: \" + wireFormat);\n            }\n\n        } catch (IOException e) {\n            onException(e);\n        } catch (InterruptedException e) {\n            onException((IOException)new InterruptedIOException().initCause(e));\n        } catch (Exception e) {\n            onException(IOExceptionSupport.create(e));\n        }\n        readyCountDownLatch.countDown();\n        onWireFormatNegotiated(info);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onCommand": "    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.oneway": "    public void oneway(Object o) throws IOException {\n        // To prevent the inactivity monitor from sending a message while we\n        // are performing a send we take a read lock. The inactivity monitor\n        // sends its Heart-beat commands under a write lock. This means that\n        // the MutexTransport is still responsible for synchronizing sends\n        this.sendLock.readLock().lock();\n        inSend.set(true);\n        try {\n            doOnewaySend(o);\n        } finally {\n            commandSent.set(true);\n            inSend.set(false);\n            this.sendLock.readLock().unlock();\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.onException": "    public void onException(IOException error) {\n        if (failed.compareAndSet(false, true)) {\n            stopMonitorThreads();\n            if (sendLock.writeLock().isHeldByCurrentThread()) {\n                sendLock.writeLock().unlock();\n            }\n            transportListener.onException(error);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.AbstractInactivityMonitor.processInboundWireFormatInfo": "    protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;\n\n    @Override\n    public void onCommand(Object command) {\n        commandReceived.set(true);\n        inReceive.set(true);\n        try {\n            if (command.getClass() == KeepAliveInfo.class) {\n                KeepAliveInfo info = (KeepAliveInfo) command;\n                if (info.isResponseRequired()) {\n                    sendLock.readLock().lock();\n                    try {\n                        info.setResponseRequired(false);\n                        oneway(info);\n                    } catch (IOException e) {\n                        onException(e);\n                    } finally {\n                        sendLock.readLock().unlock();\n                    }\n                }\n            } else {\n                if (command.getClass() == WireFormatInfo.class) {\n                    synchronized (this) {\n                        try {\n                            processInboundWireFormatInfo((WireFormatInfo) command);\n                        } catch (IOException e) {\n                            onException(e);\n                        }\n                    }\n                }\n\n                transportListener.onCommand(command);\n            }\n        } finally {\n            inReceive.set(false);\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.TransportSupport.doConsume": "    public void doConsume(Object command) {\n        if (command != null) {\n            if (transportListener != null) {\n                transportListener.onCommand(command);\n            } else {\n                LOG.error(\"No transportListener available to process inbound command: \" + command);\n            }\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.doRun": "    protected void doRun() throws IOException {\n        try {\n            Object command = readCommand();\n            doConsume(command);\n        } catch (SocketTimeoutException e) {\n        } catch (InterruptedIOException e) {\n        }\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.readCommand": "    protected Object readCommand() throws IOException {\n        return wireFormat.unmarshal(dataIn);\n    }",
            "activemq-client.src.main.java.org.apache.activemq.transport.tcp.TcpTransport.run": "                    public void run() {\n                        LOG.trace(\"Closing socket {}\", socket);\n                        try {\n                            socket.close();\n                            LOG.debug(\"Closed socket {}\", socket);\n                        } catch (IOException e) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Caught exception closing socket \" + socket + \". This exception will be ignored.\", e);\n                            }\n                        } finally {\n                            latch.countDown();\n                        }\n                    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.begin": "    public void begin() throws IOException {\n        if (inTx) {\n            throw new IOException(\"Already started.\");\n        }\n        inTx = true;\n        connection = getConnection();\n    }",
            "activemq-jdbc-store.src.main.java.org.apache.activemq.store.jdbc.TransactionContext.getConnection": "    public Connection getConnection() throws IOException {\n        if (connection == null) {\n            try {\n                connection = dataSource.getConnection();\n                if (persistenceAdapter.isChangeAutoCommitAllowed()) {\n                    boolean autoCommit = !inTx;\n                    if (connection.getAutoCommit() != autoCommit) {\n                        LOG.trace(\"Setting auto commit to {} on connection {}\", autoCommit, connection);\n                        connection.setAutoCommit(autoCommit);\n                    }\n                }\n            } catch (SQLException e) {\n                JDBCPersistenceAdapter.log(\"Could not get JDBC connection: \", e);\n                inTx = false;\n                close();\n                IOException ioe = IOExceptionSupport.create(e);\n                persistenceAdapter.getBrokerService().handleIOException(ioe);\n                throw ioe;\n            }\n\n            try {\n                connection.setTransactionIsolation(transactionIsolation);\n            } catch (Throwable e) {\n                // ignore\n                LOG.trace(\"Cannot set transaction isolation to \" + transactionIsolation + \" due \" + e.getMessage()\n                        + \". This exception is ignored.\", e);\n            }\n        }\n        return connection;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.TransportConnectionState.getContext": "    public ConnectionContext getContext() {\n        return context;\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.broker.commitTransaction": "    void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception;\n\n    /**\n     * Forgets a transaction.\n     *\n     * @param context\n     * @param transactionId\n     * @throws Exception\n     */\n    void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception;\n\n    /**\n     * Get the BrokerInfo's of any connected Brokers\n     *\n     * @return array of peer BrokerInfos\n     */\n    BrokerInfo[] getPeerBrokerInfos();\n\n    /**\n     * Notify the Broker that a dispatch is going to happen\n     *\n     * @param messageDispatch\n     */\n    void preProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * Notify the Broker that a dispatch has happened\n     *\n     * @param messageDispatch\n     */\n    void postProcessDispatch(MessageDispatch messageDispatch);\n\n    /**\n     * @return true if the broker has stopped\n     */\n    boolean isStopped();\n\n    /**\n     * @return a Set of all durable destinations\n     */\n    Set<ActiveMQDestination> getDurableDestinations();\n\n    /**\n     * Add and process a DestinationInfo object\n     *\n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * Remove and process a DestinationInfo object\n     *\n     * @param context\n     * @param info\n     * @throws Exception\n     */\n    void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception;\n\n    /**\n     * @return true if fault tolerant\n     */\n    boolean isFaultTolerantConfiguration();\n\n    /**\n     * @return the connection context used to make administration operations on\n     *         startup or via JMX MBeans\n     */\n    ConnectionContext getAdminConnectionContext();\n\n    /**\n     * Sets the default administration connection context used when configuring\n     * the broker on startup or via JMX\n     *\n     * @param adminConnectionContext\n     */\n    void setAdminConnectionContext(ConnectionContext adminConnectionContext);\n\n    /**\n     * @return the temp data store\n     */\n    PListStore getTempDataStore();\n\n    /**\n     * @return the URI that can be used to connect to the local Broker\n     */\n    URI getVmConnectorURI();\n\n    /**\n     * called when the brokerService starts\n     */\n    void brokerServiceStarted();\n\n    /**\n     * @return the BrokerService\n     */\n    BrokerService getBrokerService();\n\n    /**\n     * Ensure we get the Broker at the top of the Stack\n     *\n     * @return the broker at the top of the Stack\n     */\n    Broker getRoot();\n\n    /**\n     * Determine if a message has expired -allows default behaviour to be\n     * overriden - as the timestamp set by the producer can be out of sync with\n     * the broker\n     *\n     * @param messageReference\n     * @return true if the message is expired\n     */\n    boolean isExpired(MessageReference messageReference);\n\n    /**\n     * A Message has Expired\n     *\n     * @param context\n     * @param messageReference\n     * @param subscription, may be null\n     */\n    void messageExpired(ConnectionContext context, MessageReference messageReference, Subscription subscription);\n\n    /**\n     * A message needs to go the a DLQ\n     *\n     *\n     * @param context\n     * @param messageReference\n     * @param poisonCause reason for dlq submission, may be null\n     * @return true if Message was placed in a DLQ false if discarded.\n     */\n    boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause);\n\n    /**\n     * @return the broker sequence id\n     */\n    long getBrokerSequenceId();\n\n    /**\n     * called when message is consumed\n     * @param context\n     * @param messageReference\n     */\n    void messageConsumed(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when message is delivered to the broker\n     * @param context\n     * @param messageReference\n     */\n    void messageDelivered(ConnectionContext context, MessageReference messageReference);\n\n    /**\n     * Called when a message is discarded - e.g. running low on memory\n     * This will happen only if the policy is enabled - e.g. non durable topics\n     * @param context\n     * @param sub\n     * @param messageReference\n     */\n    void messageDiscarded(ConnectionContext context, Subscription sub, MessageReference messageReference);\n\n    /**\n     * Called when there is a slow consumer\n     * @param context\n     * @param destination\n     * @param subs\n     */\n    void slowConsumer(ConnectionContext context,Destination destination, Subscription subs);\n\n    /**\n     * Called to notify a producer is too fast\n     * @param context\n     * @param producerInfo\n     * @param destination\n     */\n    void fastProducer(ConnectionContext context,ProducerInfo producerInfo,ActiveMQDestination destination);\n\n    /**\n     * Called when a Usage reaches a limit\n     * @param context\n     * @param destination\n     * @param usage\n     */\n    void isFull(ConnectionContext context,Destination destination,Usage usage);\n\n    /**\n     *  called when the broker becomes the master in a master/slave\n     *  configuration\n     */\n    void nowMasterBroker();\n\n    Scheduler getScheduler();\n\n    ThreadPoolExecutor getExecutor();\n\n    void networkBridgeStarted(BrokerInfo brokerInfo, boolean createdByDuplex, String remoteIp);\n\n    void networkBridgeStopped(BrokerInfo brokerInfo);\n\n\n}",
            "activemq-client.src.main.java.org.apache.activemq.transport.transportListener.onCommand": "    void onCommand(Object command);\n    /**\n     * An unrecoverable exception has occured on the transport\n     * @param error\n     */\n    void onException(IOException error);\n    \n    /**\n     * The transport has suffered an interuption from which it hopes to recover\n     *\n     */\n    void transportInterupted();\n    \n    \n    /**\n     * The transport has resumed after an interuption\n     *\n     */\n    void transportResumed();\n    \n}"
        },
        "bug_report": {
            "Title": "Deadlock on DB connections in JDBCMessageStore.removeMessage",
            "Description": "AMQ 5.9 gets stuck under 30-50 req/second load when using JDBC persistence - this affects our application as it hangs during performance testing (this happens almost every night).\nFollowing stacktraces indicate that there's a deadlock on DB connection:\n\nStack logged by C3P0, showing when first DB connection has been picked from the pool:\n{noformat}\n2014-10-06 08:44:40,646 | INFO  | Logging the stack trace by which the overdue resource was checked-out. | com.mchange.v2.resourcepool.BasicResourcePool | C3P0PooledConnectionPoolManager[identityToken->2x1e6s941raztn6mju110\njava.lang.Exception: DEBUG STACK TRACE: Overdue resource check-out stack trace.\n        at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:555)\n        at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:756)\n        at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:683)\n        at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)\n        at org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)\n        at org.apache.activemq.store.jdbc.TransactionContext.begin(TransactionContext.java:163)\n        at org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.beginTransaction(JDBCPersistenceAdapter.java:510)\n        at org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:92)\n        at org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:259)\n        at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)\n        at org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:75)\n        at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)\n        at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)\n        at org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:433)\n        at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)\n        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)\n        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n        at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n        at java.lang.Thread.run(Thread.java:662)\n{noformat}\n\nFollowing stack shows the same thread pending for second DB connection (without releasing the first one):\n{noformat}\n\"ActiveMQ Transport: tcp:///10.132.7.20:36431@5445\" daemon prio=10 tid=0x000000004119d000 nid=0x61bf in Object.wait() [0x00007f41120d7000]\n   java.lang.Thread.State: WAITING (on object monitor)\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x00000000fabdd2c0> (a com.mchange.v2.resourcepool.BasicResourcePool)\n\tat com.mchange.v2.resourcepool.BasicResourcePool.awaitAvailable(BasicResourcePool.java:1414)\n\tat com.mchange.v2.resourcepool.BasicResourcePool.prelimCheckoutResource(BasicResourcePool.java:606)\n\t- locked <0x00000000fabdd2c0> (a com.mchange.v2.resourcepool.BasicResourcePool)\n\tat com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:526)\n\tat com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:756)\n\tat com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:683)\n\tat com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)\n\tat org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)\n\tat org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.getStoreSequenceId(DefaultJDBCAdapter.java:290)\n\tat org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.getStoreSequenceIdForMessageId(JDBCPersistenceAdapter.java:840)\n\tat org.apache.activemq.store.jdbc.JDBCMessageStore.removeMessage(JDBCMessageStore.java:194)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore$4.run(MemoryTransactionStore.java:348)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:103)\n\tat org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:259)\n\tat org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)\n\tat org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:69)\n\tat org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)\n\tat org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)\n\tat org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:424)\n\tat org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)\n\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)\n\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)\n\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n\tat org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)\n\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)\n\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)\n\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)\n\tat java.lang.Thread.run(Thread.java:662) \n{noformat}\n\nProblem seems to be related with JDBCMessageStore.removeMessage method:\n{code:java}\n    public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n    \tlong seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];\n...\n{code}\n\nCall to {{removeMessage}} already has one DB connection passed in {{context}} method parameter, but calling {{persistenceAdapter.getStoreSequenceIdForMessageId}} creates another DB connection in the same transaction.\n\nDeadlock occurs when all DB connections are used by {{context}}, so that  {{removeMessage}} can't fetch its own connection.\n\nPossible solution would be to pass {{ConnectionContext}} object to {{persistenceAdapter.getStoreSequenceIdForMessageId}} method, so that the method would reuse same connection."
        }
    },
    {
        "filename": "AMQ-5783.json",
        "creation_time": "2015-05-20T08:47:56.000+0000",
        "stack_trace": "java.io.EOFException: Chunk stream does not exist, page: 39 is marked free\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction$2.readPage(Transaction.java:470)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction$2.<init>(Transaction.java:447)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.openInputStream(Transaction.java:444)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.load(Transaction.java:420)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.load(Transaction.java:377)\n\tat org.apache.activemq.store.kahadb.disk.index.BTreeIndex.loadNode(BTreeIndex.java:266)\n\tat org.apache.activemq.store.kahadb.disk.index.BTreeIndex.getRoot(BTreeIndex.java:174)\n\tat org.apache.activemq.store.kahadb.disk.index.BTreeIndex.iterator(BTreeIndex.java:236)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex$MessageOrderIterator.<init>(MessageDatabase.java:3033)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.iterator(MessageDatabase.java:2985)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore$4.execute(KahaDBStore.java:564)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.recover(KahaDBStore.java:558)\n\tat org.apache.activemq.store.ProxyTopicMessageStore.recover(ProxyTopicMessageStore.java:62)\n\tat org.apache.activemq.broker.region.Topic.doBrowse(Topic.java:589)\n\tat org.apache.activemq.broker.region.Topic.access$100(Topic.java:65)\n\tat org.apache.activemq.broker.region.Topic$6.run(Topic.java:722)\n\tat org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)\n\tat java.util.TimerThread.mainLoop(Timer.java:555)\n\tat java.util.TimerThread.run(Timer.java:505)",
        "source_code": {
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.loadNode": "    BTreeNode<Key,Value> loadNode(Transaction tx, long pageId, BTreeNode<Key,Value> parent) throws IOException {\n        Page<BTreeNode<Key,Value>> page = tx.load(pageId, marshaller);\n        BTreeNode<Key, Value> node = page.get();\n        node.setPage(page);\n        node.setParent(parent);\n        return node;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.get": "    synchronized public Value get(Transaction tx, Key key) throws IOException {\n        assertLoaded();\n        return getRoot(tx).get(tx, key);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.load": "    synchronized public void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            LOG.debug(\"loading\");\n            if( keyMarshaller == null ) {\n                throw new IllegalArgumentException(\"The key marshaller must be set before loading the BTreeIndex\");\n            }\n            if( valueMarshaller == null ) {\n                throw new IllegalArgumentException(\"The value marshaller must be set before loading the BTreeIndex\");\n            }\n            \n            final Page<BTreeNode<Key,Value>> p = tx.load(pageId, null);\n            if( p.getType() == Page.PAGE_FREE_TYPE ) {\n                 // Need to initialize it..\n                BTreeNode<Key, Value> root = createNode(p, null);\n                storeNode(tx, root, true);\n            }\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.getRoot": "    private BTreeNode<Key,Value> getRoot(Transaction tx) throws IOException {\n        return loadNode(tx, pageId, null);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeIndex.iterator": "    synchronized public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, Key initialKey, Key maxKey) throws IOException {\n        return getRoot(tx).iterator(tx, initialKey, maxKey);\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.iterator": "        Iterator<Entry<Long, MessageKeys>> iterator(Transaction tx, MessageOrderCursor m) throws IOException{\n            return new MessageOrderIterator(tx,m,this);\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.execute": "                    public void execute(Transaction tx) throws IOException {\n                        for (Iterator<Entry<String, StoredDestination>> iterator = metadata.destinations.iterator(tx); iterator\n                                .hasNext();) {\n                            Entry<String, StoredDestination> entry = iterator.next();\n                            if (!isEmptyTopic(entry, tx)) {\n                                rc.add(convert(entry.getKey()));\n                            }\n                        }\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.convert": "    private ActiveMQDestination convert(int type, String name) {\n        switch (KahaDestination.DestinationType.valueOf(type)) {\n        case QUEUE:\n            return new ActiveMQQueue(name);\n        case TOPIC:\n            return new ActiveMQTopic(name);\n        case TEMP_QUEUE:\n            return new ActiveMQTempQueue(name);\n        case TEMP_TOPIC:\n            return new ActiveMQTempTopic(name);\n        default:\n            throw new IllegalArgumentException(\"Not in the valid destination format\");\n        }\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.isEmptyTopic": "                    private boolean isEmptyTopic(Entry<String, StoredDestination> entry, Transaction tx)\n                            throws IOException {\n                        boolean isEmptyTopic = false;\n                        ActiveMQDestination dest = convert(entry.getKey());\n                        if (dest.isTopic()) {\n                            StoredDestination loadedStore = getStoredDestination(convert(dest), tx);\n                            if (loadedStore.subscriptionAcks.isEmpty(tx)) {\n                                isEmptyTopic = true;\n                            }\n                        }\n                        return isEmptyTopic;\n                    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.recoverRolledBackAcks": "        protected int recoverRolledBackAcks(StoredDestination sd, Transaction tx, int maxReturned, MessageRecoveryListener listener) throws Exception {\n            int counter = 0;\n            String id;\n            for (Iterator<String> iterator = rolledBackAcks.iterator(); iterator.hasNext(); ) {\n                id = iterator.next();\n                iterator.remove();\n                Long sequence = sd.messageIdIndex.get(tx, id);\n                if (sequence != null) {\n                    if (sd.orderIndex.alreadyDispatched(sequence)) {\n                        listener.recoverMessage(loadMessage(sd.orderIndex.get(tx, sequence).location));\n                        counter++;\n                        if (counter >= maxReturned) {\n                            break;\n                        }\n                    } else {\n                        LOG.info(\"rolledback ack message {} with seq {} will be picked up in future batch {}\", id, sequence, sd.orderIndex.cursor);\n                    }\n                } else {\n                    LOG.warn(\"Failed to locate rolled back ack message {} in {}\", id, sd);\n                }\n            }\n            return counter;\n        }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.loadMessage": "    Message loadMessage(Location location) throws IOException {\n        JournalCommand<?> command = load(location);\n        KahaAddMessageCommand addMessage = null;\n        switch (command.type()) {\n            case KAHA_UPDATE_MESSAGE_COMMAND:\n                addMessage = ((KahaUpdateMessageCommand)command).getMessage();\n                break;\n            default:\n                addMessage = (KahaAddMessageCommand) command;\n        }\n        Message msg = (Message) wireFormat.unmarshal(new DataInputStream(addMessage.getMessage().newInput()));\n        return msg;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.KahaDBStore.recover": "        public void recover(final MessageRecoveryListener listener) throws Exception {\n            // recovery may involve expiry which will modify\n            indexLock.writeLock().lock();\n            try {\n                pageFile.tx().execute(new Transaction.Closure<Exception>() {\n                    @Override\n                    public void execute(Transaction tx) throws Exception {\n                        StoredDestination sd = getStoredDestination(dest, tx);\n                        recoverRolledBackAcks(sd, tx, Integer.MAX_VALUE, listener);\n                        sd.orderIndex.resetCursorPosition();\n                        for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); listener.hasSpace() && iterator\n                                .hasNext(); ) {\n                            Entry<Long, MessageKeys> entry = iterator.next();\n                            if (ackedAndPrepared.contains(entry.getValue().messageId)) {\n                                continue;\n                            }\n                            Message msg = loadMessage(entry.getValue().location);\n                            listener.recoverMessage(msg);\n                        }\n                    }\n                });\n            } finally {\n                indexLock.writeLock().unlock();\n            }\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.store.ProxyTopicMessageStore.recover": "    public void recover(MessageRecoveryListener listener) throws Exception {\n        delegate.recover(listener);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.doBrowse": "    private void doBrowse(final List<Message> browseList, final int max) {\n        try {\n            if (topicStore != null) {\n                final List<Message> toExpire = new ArrayList<Message>();\n                topicStore.recover(new MessageRecoveryListener() {\n                    @Override\n                    public boolean recoverMessage(Message message) throws Exception {\n                        if (message.isExpired()) {\n                            toExpire.add(message);\n                        }\n                        browseList.add(message);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean recoverMessageReference(MessageId messageReference) throws Exception {\n                        return true;\n                    }\n\n                    @Override\n                    public boolean hasSpace() {\n                        return browseList.size() < max;\n                    }\n\n                    @Override\n                    public boolean isDuplicate(MessageId id) {\n                        return false;\n                    }\n                });\n                final ConnectionContext connectionContext = createConnectionContext();\n                for (Message message : toExpire) {\n                    for (DurableTopicSubscription sub : durableSubscribers.values()) {\n                        if (!sub.isActive()) {\n                            messageExpired(connectionContext, sub, message);\n                        }\n                    }\n                }\n                Message[] msgs = subscriptionRecoveryPolicy.browse(getActiveMQDestination());\n                if (msgs != null) {\n                    for (int i = 0; i < msgs.length && browseList.size() < max; i++) {\n                        browseList.add(msgs[i]);\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            LOG.warn(\"Failed to browse Topic: {}\", getActiveMQDestination().getPhysicalName(), e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.browse": "    public Message[] browse() {\n        final List<Message> result = new ArrayList<Message>();\n        doBrowse(result, getMaxBrowsePageSize());\n        return result.toArray(new Message[result.size()]);\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.messageExpired": "    public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {\n        broker.messageExpired(context, reference, subs);\n        // AMQ-2586: Better to leave this stat at zero than to give the user\n        // misleading metrics.\n        // destinationStatistics.getMessages().decrement();\n        destinationStatistics.getExpired().increment();\n        MessageAck ack = new MessageAck();\n        ack.setAckType(MessageAck.STANDARD_ACK_TYPE);\n        ack.setDestination(destination);\n        ack.setMessageID(reference.getMessageId());\n        try {\n            if (subs instanceof DurableTopicSubscription) {\n                ((DurableTopicSubscription)subs).removePending(reference);\n            }\n            acknowledge(context, subs, ack, reference);\n        } catch (Exception e) {\n            LOG.error(\"Failed to remove expired Message from the store \", e);\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.run": "        public void run() {\n            List<Message> browsedMessages = new InsertionCountList<Message>();\n            doBrowse(browsedMessages, getMaxExpirePageSize());\n        }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.doMessageSend": "    synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message)\n            throws IOException, Exception {\n        final ConnectionContext context = producerExchange.getConnectionContext();\n        message.setRegionDestination(this);\n        message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());\n        Future<Object> result = null;\n\n        if (topicStore != null && message.isPersistent() && !canOptimizeOutPersistence()) {\n            if (systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {\n                final String logMessage = \"Persistent store is Full, \" + getStoreUsageHighWaterMark() + \"% of \"\n                        + systemUsage.getStoreUsage().getLimit() + \". Stopping producer (\" + message.getProducerId()\n                        + \") to prevent flooding \" + getActiveMQDestination().getQualifiedName() + \".\"\n                        + \" See http://activemq.apache.org/producer-flow-control.html for more info\";\n                if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {\n                    throw new javax.jms.ResourceAllocationException(logMessage);\n                }\n\n                waitForSpace(context,producerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);\n            }\n            result = topicStore.asyncAddTopicMessage(context, message,isOptimizeStorage());\n        }\n\n        message.incrementReferenceCount();\n\n        if (context.isInTransaction()) {\n            context.getTransaction().addSynchronization(new Synchronization() {\n                @Override\n                public void afterCommit() throws Exception {\n                    // It could take while before we receive the commit\n                    // operation.. by that time the message could have\n                    // expired..\n                    if (broker.isExpired(message)) {\n                        getDestinationStatistics().getExpired().increment();\n                        broker.messageExpired(context, message, null);\n                        message.decrementReferenceCount();\n                        return;\n                    }\n                    try {\n                        dispatch(context, message);\n                    } finally {\n                        message.decrementReferenceCount();\n                    }\n                }\n\n                @Override\n                public void afterRollback() throws Exception {\n                    message.decrementReferenceCount();\n                }\n            });\n\n        } else {\n            try {\n                dispatch(context, message);\n            } finally {\n                message.decrementReferenceCount();\n            }\n        }\n\n        if (result != null && !result.isCancelled()) {\n            try {\n                result.get();\n            } catch (CancellationException e) {\n                // ignore - the task has been cancelled if the message\n                // has already been deleted\n            }\n        }\n    }",
            "activemq-broker.src.main.java.org.apache.activemq.broker.region.Topic.wakeup": "    public final void wakeup() {\n    }",
            "activemq-client.src.main.java.org.apache.activemq.thread.SchedulerTimerTask.run": "    public void run() {\n        this.task.run();                         \n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeNode.setPage": "    public void setPage(Page<BTreeNode<Key, Value>> page) {\n        this.page = page;\n    }",
            "activemq-kahadb-store.src.main.java.org.apache.activemq.store.kahadb.disk.index.BTreeNode.setParent": "    public void setParent(BTreeNode<Key, Value> parent) {\n        this.parent = parent;\n    }"
        },
        "bug_report": {
            "Title": "Failed to browse Topic: XXXXX java.io.EOFException: Chunk stream does not exist, page: y is marked free",
            "Description": "When an offline durable subscriber is timed out (offlineDurableSubscriberTimeout configured) periodically see the following WARNING message.   \n\n{code}\n\n2015-05-13 13:45:08,472 [sage] Scheduler] - WARN  Topic                          - Failed to browse Topic: XXXXX\njava.io.EOFException: Chunk stream does not exist, page: 39 is marked free\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction$2.readPage(Transaction.java:470)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction$2.<init>(Transaction.java:447)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.openInputStream(Transaction.java:444)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.load(Transaction.java:420)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.load(Transaction.java:377)\n\tat org.apache.activemq.store.kahadb.disk.index.BTreeIndex.loadNode(BTreeIndex.java:266)\n\tat org.apache.activemq.store.kahadb.disk.index.BTreeIndex.getRoot(BTreeIndex.java:174)\n\tat org.apache.activemq.store.kahadb.disk.index.BTreeIndex.iterator(BTreeIndex.java:236)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex$MessageOrderIterator.<init>(MessageDatabase.java:3033)\n\tat org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.iterator(MessageDatabase.java:2985)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore$4.execute(KahaDBStore.java:564)\n\tat org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)\n\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.recover(KahaDBStore.java:558)\n\tat org.apache.activemq.store.ProxyTopicMessageStore.recover(ProxyTopicMessageStore.java:62)\n\tat org.apache.activemq.broker.region.Topic.doBrowse(Topic.java:589)\n\tat org.apache.activemq.broker.region.Topic.access$100(Topic.java:65)\n\tat org.apache.activemq.broker.region.Topic$6.run(Topic.java:722)\n\tat org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)\n\tat java.util.TimerThread.mainLoop(Timer.java:555)\n\tat java.util.TimerThread.run(Timer.java:505)\n\n{code}"
        }
    },
    {
        "filename": "AMQ-2965.json",
        "creation_time": "2010-10-07T20:18:59.000+0000",
        "stack_trace": "java.net.UnknownHostException: Q01M0003: Q01M0003 \n        at java.net.InetAddress.getLocalHost(Unknown Source) \n        at org.apache.activemq.util.IdGenerator.&amp;lt;clinit&amp;gt;(IdGenerator.java:52) \n        at org.apache.activemq.broker.region.RegionBroker.&amp;lt;clinit&amp;gt;(RegionBroker.java:75) \n        at org.apache.activemq.broker.BrokerService.createRegionBroker(BrokerService.java:1734) \n        at org.apache.activemq.broker.BrokerService.createRegionBroker(BrokerService.java:1728) \n        at org.apache.activemq.broker.BrokerService.createBroker(BrokerService.java:1688) \n        at org.apache.activemq.broker.BrokerService.getBroker(BrokerService.java:706) \n        at org.apache.activemq.broker.BrokerService.start(BrokerService.java:469) \n        at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:85) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1414) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1375) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1335) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:473) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409) \n        at java.security.AccessController.doPrivileged(Native Method) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380) \n        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264) \n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164) \n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429) \n        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728) \n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:380) \n        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&amp;lt;init&amp;gt;(ResourceXmlApplicationContext.java:64) \n        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&amp;lt;init&amp;gt;(ResourceXmlApplicationContext.java:52) \n        at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:96) \n        at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:52) \n        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71) \n        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54) \n        at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:115) \n        at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:74) \n        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57) \n        at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:136) \n        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57) \n        at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:82) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.apache.activemq.console.Main.runTaskClass(Main.java:251) \n        at org.apache.activemq.console.Main.main(Main.java:107) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240) \n        at java.lang.Thread.run(Unknown Source)",
        "source_code": {
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.createRegionBroker": "    protected Broker createRegionBroker(DestinationInterceptor destinationInterceptor) throws IOException {\n        RegionBroker regionBroker;\n        if (isUseJmx()) {\n            regionBroker = new ManagedRegionBroker(this, getManagementContext(), getBrokerObjectName(),\n                    getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory, destinationInterceptor,getScheduler(),getExecutor());\n        } else {\n            regionBroker = new RegionBroker(this, getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory,\n                    destinationInterceptor,getScheduler(),getExecutor());\n        }\n        destinationFactory.setRegionBroker(regionBroker);\n        regionBroker.setKeepDurableSubsActive(keepDurableSubsActive);\n        regionBroker.setBrokerName(getBrokerName());\n        regionBroker.getDestinationStatistics().setEnabled(enableStatistics);\n        if (brokerId != null) {\n            regionBroker.setBrokerId(brokerId);\n        }\n        return regionBroker;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getTaskRunnerFactory": "    public TaskRunnerFactory getTaskRunnerFactory() {\n        if (this.taskRunnerFactory == null) {\n            this.taskRunnerFactory = new TaskRunnerFactory(\"BrokerService[\"+getBrokerName()+\"] Task\", getTaskRunnerPriority(), true, 1000,\n                    isDedicatedTaskRunner());\n        }\n        return this.taskRunnerFactory;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getExecutor": "    protected synchronized ThreadPoolExecutor getExecutor() {\n        if (this.executor == null) {\n        this.executor = new ThreadPoolExecutor(1, 10, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {\n            public Thread newThread(Runnable runnable) {\n                Thread thread = new Thread(runnable, \"Usage Async Task\");\n                thread.setDaemon(true);\n                return thread;\n            }\n        });\n        }\n        return this.executor;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.createDefaultDestinationInterceptor": "    protected DestinationInterceptor[] createDefaultDestinationInterceptor() {\n        List<DestinationInterceptor> answer = new ArrayList<DestinationInterceptor>();\n        if (isUseVirtualTopics()) {\n            VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();\n            VirtualTopic virtualTopic = new VirtualTopic();\n            virtualTopic.setName(\"VirtualTopic.>\");\n            VirtualDestination[] virtualDestinations = { virtualTopic };\n            interceptor.setVirtualDestinations(virtualDestinations);\n            answer.add(interceptor);\n        }\n        if (isUseMirroredQueues()) {\n            MirroredQueue interceptor = new MirroredQueue();\n            answer.add(interceptor);\n        }\n        DestinationInterceptor[] array = new DestinationInterceptor[answer.size()];\n        answer.toArray(array);\n        return array;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getConsumerSystemUsage": "    public SystemUsage getConsumerSystemUsage() throws IOException {\n        if (this.consumerSystemUsaage == null) {\n            if (splitSystemUsageForProducersConsumers) {\n                this.consumerSystemUsaage = new SystemUsage(getSystemUsage(), \"Consumer\");\n                float portion = consumerSystemUsagePortion / 100f;\n                this.consumerSystemUsaage.getMemoryUsage().setUsagePortion(portion);\n                addService(this.consumerSystemUsaage);\n            } else {\n                consumerSystemUsaage = getSystemUsage();\n            }\n        }\n        return this.consumerSystemUsaage;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getScheduler": "    protected synchronized Scheduler getScheduler() {\n        if (this.scheduler==null) {\n            this.scheduler = new Scheduler(\"ActiveMQ Broker[\"+getBrokerName()+\"] Scheduler\");\n            try {\n                this.scheduler.start();\n            } catch (Exception e) {\n               LOG.error(\"Failed to start Scheduler \",e);\n            }\n        }\n        return this.scheduler;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.setBrokerName": "    public void setBrokerName(String brokerName) {\n        if (brokerName == null) {\n            throw new NullPointerException(\"The broker name cannot be null\");\n        }\n        String str = brokerName.replaceAll(\"[^a-zA-Z0-9\\\\.\\\\_\\\\-\\\\:]\", \"_\");\n        if (!str.equals(brokerName)) {\n            LOG.error(\"Broker Name: \" + brokerName + \" contained illegal characters - replaced with \" + str);\n        }\n        this.brokerName = str.trim();\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getPersistenceAdapter": "    public PersistenceAdapter getPersistenceAdapter() throws IOException {\n        if (persistenceAdapter == null) {\n            persistenceAdapter = createPersistenceAdapter();\n            configureService(persistenceAdapter);\n            this.persistenceAdapter = registerPersistenceAdapterMBean(persistenceAdapter);\n        }\n        return persistenceAdapter;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.setBrokerId": "    public void setBrokerId(String brokerId) {\n        this.brokerId = new BrokerId(brokerId);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.setRegionBroker": "    public void setRegionBroker(Broker regionBroker) {\n        this.regionBroker = regionBroker;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.setKeepDurableSubsActive": "    public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {\n        this.keepDurableSubsActive = keepDurableSubsActive;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.isUseJmx": "    public boolean isUseJmx() {\n        return useJmx;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getManagementContext": "    public ManagementContext getManagementContext() {\n        if (managementContext == null) {\n            managementContext = new ManagementContext();\n        }\n        return managementContext;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getBrokerObjectName": "    public ObjectName getBrokerObjectName() throws IOException {\n        if (brokerObjectName == null) {\n            brokerObjectName = createBrokerObjectName();\n        }\n        return brokerObjectName;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.configureServices": "    protected void configureServices(Object[] services) {\n        for (Object service : services) {\n            configureService(service);\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getBrokerName": "    public String getBrokerName() {\n        return brokerName;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.createBroker": "    protected Broker createBroker() throws Exception {\n        regionBroker = createRegionBroker();\n        Broker broker = addInterceptors(regionBroker);\n        // Add a filter that will stop access to the broker once stopped\n        broker = new MutableBrokerFilter(broker) {\n            Broker old;\n\n            @Override\n            public void stop() throws Exception {\n                old = this.next.getAndSet(new ErrorBroker(\"Broker has been stopped: \" + this) {\n                    // Just ignore additional stop actions.\n                    @Override\n                    public void stop() throws Exception {\n                    }\n                });\n                old.stop();\n            }\n\n            @Override\n            public void start() throws Exception {\n                if (forceStart && old != null) {\n                    this.next.set(old);\n                }\n                getNext().start();\n            }\n        };\n        return broker;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.start": "            public void start() throws Exception {\n                if (forceStart && old != null) {\n                    this.next.set(old);\n                }\n                getNext().start();\n            }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.addInterceptors": "    protected Broker addInterceptors(Broker broker) throws Exception {\n        if (isSchedulerSupport()) {\n            SchedulerBroker sb = new SchedulerBroker(broker, getSchedulerDirectoryFile());\n            if (isUseJmx()) {\n                JobSchedulerViewMBean view = new JobSchedulerView(sb.getJobScheduler());\n                try {\n                    ObjectName objectName = new ObjectName(getManagementContext().getJmxDomainName() + \":\"\n                            + \"BrokerName=\" + JMXSupport.encodeObjectNamePart(getBrokerName()) + \",\"\n                            + \"Type=jobScheduler,\" + \"jobSchedulerName=JMS\");\n\n                    AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);\n                    this.adminView.setJMSJobScheduler(objectName);\n                } catch (Throwable e) {\n                    throw IOExceptionSupport.create(\"JobScheduler could not be registered in JMX: \"\n                            + e.getMessage(), e);\n                }\n\n            }\n            broker = sb;\n        }\n        if (isAdvisorySupport()) {\n            broker = new AdvisoryBroker(broker);\n        }\n        broker = new CompositeDestinationBroker(broker);\n        broker = new TransactionBroker(broker, getPersistenceAdapter().createTransactionStore());\n        if (isPopulateJMSXUserID()) {\n            broker = new UserIDBroker(broker);\n        }\n        if (isMonitorConnectionSplits()) {\n            broker = new ConnectionSplitBroker(broker);\n        }\n        if (plugins != null) {\n            for (int i = 0; i < plugins.length; i++) {\n                BrokerPlugin plugin = plugins[i];\n                broker = plugin.installPlugin(broker);\n            }\n        }\n        return broker;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.stop": "                    public void stop() throws Exception {\n                    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerService.getBroker": "    public Broker getBroker() throws Exception {\n        if (broker == null) {\n            LOG.info(\"ActiveMQ \" + ActiveMQConnectionMetaData.PROVIDER_VERSION + \" JMS Message Broker (\"\n                    + getBrokerName() + \") is starting\");\n            LOG.info(\"For help or more information please see: http://activemq.apache.org/\");\n            broker = createBroker();\n        }\n        return broker;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet": "    public void afterPropertiesSet() throws Exception {\n        ensureSystemUsageHasStore();\n        if (shouldAutostart()) {\n            start();\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.xbean.XBeanBrokerService.shouldAutostart": "    protected boolean shouldAutostart() {\n        return start;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.xbean.XBeanBrokerService.ensureSystemUsageHasStore": "    private void ensureSystemUsageHasStore() throws IOException {\n        SystemUsage usage = getSystemUsage();\n        if (usage.getStoreUsage().getStore() == null) {\n            usage.getStoreUsage().setStore(getPersistenceAdapter());\n        }\n        if (usage.getTempUsage().getStore() == null) {\n            usage.getTempUsage().setStore(getTempDataStore());\n        }\n    }",
            "activemq-core.src.main.java.org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext": "    protected ApplicationContext createApplicationContext(String uri) throws MalformedURLException {\n        LOG.debug(\"Now attempting to figure out the type of resource: \" + uri);\n\n        Resource resource;\n        File file = new File(uri);\n        if (file.exists()) {\n            resource = new FileSystemResource(uri);\n        } else if (ResourceUtils.isUrl(uri)) {\n            resource = new UrlResource(uri);\n        } else {\n            resource = new ClassPathResource(uri);\n        }\n        return new ResourceXmlApplicationContext(resource);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.xbean.XBeanBrokerFactory.createBroker": "    public BrokerService createBroker(URI config) throws Exception {\n\n        String uri = config.getSchemeSpecificPart();\n        ApplicationContext context = createApplicationContext(uri);\n\n        BrokerService broker = null;\n        try {\n            broker = (BrokerService)context.getBean(\"broker\");\n        } catch (BeansException e) {\n        }\n\n        if (broker == null) {\n            // lets try find by type\n            String[] names = context.getBeanNamesForType(BrokerService.class);\n            for (int i = 0; i < names.length; i++) {\n                String name = names[i];\n                broker = (BrokerService)context.getBean(name);\n                if (broker != null) {\n                    break;\n                }\n            }\n        }\n        if (broker == null) {\n            throw new IllegalArgumentException(\"The configuration has no BrokerService instance for resource: \" + config);\n        }\n        \n        if (broker instanceof ApplicationContextAware) {\n        \t((ApplicationContextAware)broker).setApplicationContext(context);\n        }\n        \n        // TODO warning resources from the context may not be closed down!\n\n        return broker;\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFactory.createBroker": "    public static BrokerService createBroker(String brokerURI, boolean startBroker) throws Exception {\n        return createBroker(new URI(brokerURI), startBroker);\n    }",
            "activemq-core.src.main.java.org.apache.activemq.broker.BrokerFactory.createBrokerFactoryHandler": "    public static BrokerFactoryHandler createBrokerFactoryHandler(String type) throws IOException {\n        try {\n            return (BrokerFactoryHandler)BROKER_FACTORY_HANDLER_FINDER.newInstance(type);\n        } catch (Throwable e) {\n            throw IOExceptionSupport.create(\"Could not load \" + type + \" factory:\" + e, e);\n        }\n    }"
        },
        "bug_report": {
            "Title": "ActiveMQ fails to start if no DNS resolution for hostname is available",
            "Description": "ActiveMQ is installed on a physical server with two ethernet interfaces -- the first is a 10.x.x.x network and used only for external traffic , the second interface is a 172.x.x.x network and is used only for internal (intra-cluster node) communication. ActiveMQ is configured to listen only on the 172.x.x.x interface. External DNS resolution exists but internal DNS resolution does not. While each host has a unique name, none of these names are resolvable. Under these circumstances, ActiveMQ fails to start up successfully. Below are the exceptions and stack trace: \n\n{panel}\n2010-06-09 16:48:45,714 | ERROR | Failed to resolve localhost | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \n2010-06-09 16:48:46,092 | INFO | Using Persistence Adapter: org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter@47c297a3 | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \n2010-06-09 16:48:46,928 | INFO | JMX consoles can connect to service:jmx:rmi://localhost:11616/jndi/rmi://localhost:1616/jmxrmi | org.apache.activemq.broker.jmx.ManagementContext | JMX connector \n2010-06-09 16:48:47,036 | INFO | ActiveMQ 5.3.2 JMS Message Broker (Q01M0003) is starting | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \n2010-06-09 16:48:47,036 | INFO | For help or more information please see: http://activemq.apache.org/ | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \n2010-06-09 16:48:47,280 | WARN | could not generate unique stub | org.apache.activemq.util.IdGenerator | WrapperSimpleAppMain \njava.net.UnknownHostException: Q01M0003: Q01M0003 \n        at java.net.InetAddress.getLocalHost(Unknown Source) \n        at org.apache.activemq.util.IdGenerator.&amp;lt;clinit&amp;gt;(IdGenerator.java:52) \n        at org.apache.activemq.broker.region.RegionBroker.&amp;lt;clinit&amp;gt;(RegionBroker.java:75) \n        at org.apache.activemq.broker.BrokerService.createRegionBroker(BrokerService.java:1734) \n        at org.apache.activemq.broker.BrokerService.createRegionBroker(BrokerService.java:1728) \n        at org.apache.activemq.broker.BrokerService.createBroker(BrokerService.java:1688) \n        at org.apache.activemq.broker.BrokerService.getBroker(BrokerService.java:706) \n        at org.apache.activemq.broker.BrokerService.start(BrokerService.java:469) \n        at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:85) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1414) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1375) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1335) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:473) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409) \n        at java.security.AccessController.doPrivileged(Native Method) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380) \n        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264) \n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164) \n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429) \n        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728) \n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:380) \n        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&amp;lt;init&amp;gt;(ResourceXmlApplicationContext.java:64) \n        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&amp;lt;init&amp;gt;(ResourceXmlApplicationContext.java:52) \n        at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:96) \n        at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:52) \n        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71) \n        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54) \n        at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:115) \n        at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:74) \n        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57) \n        at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:136) \n        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57) \n        at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:82) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.apache.activemq.console.Main.runTaskClass(Main.java:251) \n        at org.apache.activemq.console.Main.main(Main.java:107) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240) \n        at java.lang.Thread.run(Unknown Source) \n2010-06-09 16:48:47,407 | ERROR | Failed to start ActiveMQ JMS Message Broker. Reason: java.io.IOException: Transport Connector could not be registered in JMX: Q01M0003: Q01M0003 | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \njava.io.IOException: Transport Connector could not be registered in JMX: Q01M0003: Q01M0003 \n        at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:27) \n        at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:1585) \n        at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2006) \n        at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:1959) \n        at org.apache.activemq.broker.BrokerService.start(BrokerService.java:491) \n        at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:85) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1414) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1375) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1335) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:473) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409) \n        at java.security.AccessController.doPrivileged(Native Method) \n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380) \n        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264) \n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185) \n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164) \n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429) \n        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728) \n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:380) \n        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&amp;lt;init&amp;gt;(ResourceXmlApplicationContext.java:64) \n        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&amp;lt;init&amp;gt;(ResourceXmlApplicationContext.java:52) \n        at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:96) \n        at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:52) \n        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71) \n        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54) \n        at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:115) \n        at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:74) \n        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57) \n        at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:136) \n        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57) \n        at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:82) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.apache.activemq.console.Main.runTaskClass(Main.java:251) \n        at org.apache.activemq.console.Main.main(Main.java:107) \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) \n        at java.lang.reflect.Method.invoke(Unknown Source) \n        at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240) \n        at java.lang.Thread.run(Unknown Source) \nCaused by: java.net.UnknownHostException: Q01M0003: Q01M0003 \n        at java.net.InetAddress.getLocalHost(Unknown Source) \n        at org.apache.activemq.transport.tcp.TcpTransportServer.resolveHostName(TcpTransportServer.java:336) \n        at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:142) \n        at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:60) \n        at org.apache.activemq.transport.TransportFactory.bind(TransportFactory.java:131) \n        at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:305) \n        at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:137) \n        at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:100) \n        at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:1580) \n        ... 47 more \n2010-06-09 16:48:47,409 | INFO | ActiveMQ Message Broker (Q01M0003, null) is shutting down | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \n2010-06-09 16:48:47,410 | INFO | Connector openwire Stopped | org.apache.activemq.broker.TransportConnector | WrapperSimpleAppMain \n2010-06-09 16:48:47,535 | INFO | ActiveMQ JMS Message Broker (Q01M0003, null) stopped | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain \n{panel}\n\nThis problem can be worked around by adding an entry to the /etc/hosts file for each machine. Unfortunately this presents quite a maintenance nightmare in a very large environment. "
        }
    }
]