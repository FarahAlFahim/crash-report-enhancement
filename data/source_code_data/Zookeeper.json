[
    {
        "filename": "ZOOKEEPER-1864.json",
        "creation_time": "2014-01-20T06:09:53.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.zookeeper.server.quorum.QuorumPeer.setQuorumVerifier(QuorumPeer.java:1320)\n\tat org.apache.zookeeper.server.quorum.QuorumPeerMain.runFromConfig(QuorumPeerMain.java:156)\n\tat org.apache.curator.test.TestingZooKeeperServer$1.run(TestingZooKeeperServer.java:134)\n\tat java.lang.Thread.run(Thread.java:722)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setQuorumVerifier": "    public synchronized QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){\n        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n            // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n           // and then got the same config in UPTODATE message so its already known\n           LOG.debug(getId() + \" setQuorumVerifier called with known or old config \" + qv.getVersion() + \n                   \". Current version: \" + quorumVerifier.getVersion());\n           return quorumVerifier;  \n        }\n        QuorumVerifier prevQV = quorumVerifier;\n       quorumVerifier = qv;\n       if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion()))\n           lastSeenQuorumVerifier = qv;\n        if (writeToDisk) {\n                // we need to write the dynamic config file. Either it already exists\n                // or we have the old-style config file and we're in the backward compatibility mode,\n                // so we'll create the dynamic config file for the first time now\n                if (dynamicConfigFilename !=null || (configFilename !=null && configBackwardCompatibility)) { \n                try {\n                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, configFilename, configBackwardCompatibility, qv);\n                    if (configBackwardCompatibility) {\n                        dynamicConfigFilename = configFilename + \".dynamic\";\n                        configBackwardCompatibility = false;\n                    }\n                } catch(IOException e){\n                    LOG.error(\"Error closing file: \", e.getMessage());     \n                }\n            } else {\n                LOG.error(\"writeToDisk == true but dynamicConfigFilename == null, configFilename \"\n                          + (configFilename == null ? \"== null\": \"!=null\")\n                          + \" and configBackwardCompatibility == \" + configBackwardCompatibility);\n            }\n        }\n\n        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()){\n           QuorumPeerConfig.deleteFile(dynamicConfigFilename + \".next\");\n       }\n       QuorumServer qs = qv.getAllMembers().get(getId());\n       if (qs!=null){\n           setQuorumAddress(qs.addr);\n           setElectionAddress(qs.electionAddr);\n           setClientAddress(qs.clientAddr);\n       }\n       return prevQV;\n    }   ",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setElectionAddress": "    public void setElectionAddress(InetSocketAddress addr){\n        myElectionAddr = addr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setClientAddress": "    public void setClientAddress(InetSocketAddress addr){\n        myClientAddr = addr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setQuorumAddress": "    public synchronized void setQuorumAddress(InetSocketAddress addr){\n        myQuorumAddr = addr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.getId": "    public long getId() {\n        return myid;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.runFromConfig": "    public void runFromConfig(QuorumPeerConfig config) throws IOException {\n      try {\n          ManagedUtil.registerLog4jMBeans();\n      } catch (JMException e) {\n          LOG.warn(\"Unable to register log4j JMX control\", e);\n      }\n\n      LOG.info(\"Starting quorum peer\");\n      try {\n          ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();\n          cnxnFactory.configure(config.getClientPortAddress(),\n                                config.getMaxClientCnxns());\n\n          quorumPeer = new QuorumPeer();\n          quorumPeer.setTxnFactory(new FileTxnSnapLog(\n                      config.getDataLogDir(),\n                      config.getDataDir()));\n          quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n          quorumPeer.enableLocalSessionsUpgrading(\n              config.isLocalSessionsUpgradingEnabled());\n          //quorumPeer.setQuorumPeers(config.getAllMembers());\n          quorumPeer.setElectionType(config.getElectionAlg());\n          quorumPeer.setMyid(config.getServerId());\n          quorumPeer.setTickTime(config.getTickTime());\n          quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n          quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n          quorumPeer.setInitLimit(config.getInitLimit());\n          quorumPeer.setSyncLimit(config.getSyncLimit());\n          quorumPeer.setDynamicConfigFilename(config.getDynamicConfigFilename());\n          quorumPeer.setConfigFileName(config.getConfigFilename());\n          quorumPeer.setConfigBackwardCompatibility(config.getConfigBackwardCompatibility());\n          quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n          quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n          if (config.getLastSeenQuorumVerifier()!=null) {\n              quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n          }\n          quorumPeer.initConfigInZKDatabase();\n          quorumPeer.setCnxnFactory(cnxnFactory);\n          quorumPeer.setLearnerType(config.getPeerType());\n          quorumPeer.setSyncEnabled(config.getSyncEnabled());\n          quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n          \n          quorumPeer.start();\n          quorumPeer.join();\n      } catch (InterruptedException e) {\n          // warn, but generally this is ok\n          LOG.warn(\"Quorum Peer interrupted\", e);\n      }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.deleteFile": "    public static void deleteFile(String filename){        \n       File f = new File(filename);\n       if (f.exists()) {\n           try{ \n               f.delete();\n           } catch (Exception e) {\n               LOG.warn(\"deleting \" + filename + \" failed\");\n           }\n       }                   \n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.writeDynamicConfig": "    public static void writeDynamicConfig(String dynamicConfigFilename, String configFileStr, \n            boolean configBackwardCompatibilityMode, QuorumVerifier qv) throws IOException {                             \n        FileOutputStream outConfig = null;\n       try {\n           byte b[] = qv.toString().getBytes();                                            \n           if (configBackwardCompatibilityMode) {\n               dynamicConfigFilename = configFileStr + \".dynamic\";\n           }\n           String tmpFilename = dynamicConfigFilename + \".tmp\";\n           outConfig = new FileOutputStream(tmpFilename);\n           \n           outConfig.write(b);\n           outConfig.close();\n           File curFile = new File(dynamicConfigFilename);\n           File tmpFile = new File(tmpFilename);\n           if (!tmpFile.renameTo(curFile)) {\n               throw new IOException(\"renaming \" + tmpFile.toString() + \" to \" + curFile.toString() + \" failed!\");\n           }\n       } finally{\n           if (outConfig!=null) { \n               outConfig.close();\n           }\n       }\n       // the following is for users who run without a dynamic config file (old config file)\n       // if the configuration changes (reconfiguration executes), we create a dynamic config\n       // file, remove all the dynamic definitions from the config file and add a pointer\n       // to the config file. The dynamic config file's name will be the same as the config file's\n       // with \".dynamic\" appended to it\n       \n        if (configBackwardCompatibilityMode) {\n           BufferedWriter out = null;\n               try {\n                   File configFile = (new VerifyingFileFactory.Builder(LOG)\n                       .warnForRelativePath()\n                       .failForNonExistingPath()\n                       .build()).create(configFileStr);\n                       \n                   Properties cfg = new Properties();\n                   FileInputStream in = new FileInputStream(configFile);\n                   try {\n                       cfg.load(in);\n                   } finally {\n                       in.close();\n                   }\n                   String tmpFilename = configFileStr + \".tmp\";                    \n                   FileWriter fstream = new FileWriter(tmpFilename);\n                   out = new BufferedWriter(fstream);                 \n                   \n                   for (Entry<Object, Object> entry : cfg.entrySet()) {\n                       String key = entry.getKey().toString().trim();\n                       String value = entry.getValue().toString().trim();    \n                       if (!key.startsWith(\"server.\") && !key.startsWith(\"group\") \n                               && !key.startsWith(\"weight\") && !key.equals(\"clientPort\") && !key.equals(\"clientPortAddress\")){\n                           out.write(key.concat(\"=\").concat(value).concat(\"\\n\"));\n                       }\n                   }                      \n                   out.write(\"dynamicConfigFile=\".concat(dynamicConfigFilename).concat(\"\\n\"));\n                   out.close();\n                   File tmpFile = new File(tmpFilename);\n                   if (!tmpFile.renameTo(configFile)) {\n                       throw new IOException(\"renaming \" + tmpFile.toString() + \" to \" + configFile.toString() + \" failed!\");\n                   }\n               } finally{\n                   if (out!=null) {\n                           out.close();\n                   }\n               }\n           }\n   } ",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getQuorumListenOnAllIPs": "    public Boolean getQuorumListenOnAllIPs() {\n        return quorumListenOnAllIPs;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getPeerType": "    public LearnerType getPeerType() {\n        return peerType;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getSyncEnabled": "    public boolean getSyncEnabled() {\n        return syncEnabled;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getDataLogDir": "    public File getDataLogDir() { return dataLogDir; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setInitLimit": "    public void setInitLimit(int initLimit) {\n        LOG.info(\"initLimit set to \" + initLimit);\n        this.initLimit = initLimit;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setQuorumListenOnAllIPs": "    public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs) {\n        this.quorumListenOnAllIPs = quorumListenOnAllIPs;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setTickTime": "    public void setTickTime(int tickTime) {\n        LOG.info(\"tickTime set to \" + tickTime);\n        this.tickTime = tickTime;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.getTxnFactory": "    public FileTxnSnapLog getTxnFactory() {\n        return this.logFactory;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.enableLocalSessions": "    public void enableLocalSessions(boolean flag) {\n        LOG.info(\"Local sessions \" + (flag ? \"enabled\" : \"disabled\"));\n        localSessionsEnabled = flag;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getQuorumVerifier": "    public QuorumVerifier getQuorumVerifier() {\n        return quorumVerifier;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setLastSeenQuorumVerifier": "    public synchronized void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){\n        if (lastSeenQuorumVerifier!=null && lastSeenQuorumVerifier.getVersion() >= qv.getVersion()) {\n           LOG.warn(\"setLastSeenQuorumVerifier called with stale config \" + qv.getVersion() + \n                   \". Current version: \" + quorumVerifier.getVersion());\n          \n        }\n        lastSeenQuorumVerifier = qv;\n        connectNewPeers();\n        if (writeToDisk) {\n            try {\n               QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename + \".next\", null, false, qv);\n           } catch(IOException e){\n                LOG.error(\"Error closing file: \", e.getMessage());\n            }\n        } \n\n     }       ",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.connectNewPeers": "    public synchronized void connectNewPeers(){\n       if (qcm!=null && getQuorumVerifier()!=null && getLastSeenQuorumVerifier()!=null) {\n           Map<Long, QuorumServer> committedView = getQuorumVerifier().getAllMembers();\n           for (Entry<Long, QuorumServer> e: getLastSeenQuorumVerifier().getAllMembers().entrySet()){\n               if (!committedView.containsKey(e.getKey())) \n                   qcm.connectOne(e.getKey(), e.getValue().electionAddr);\n           }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setConfigFileName": "    protected synchronized void setConfigFileName(String s) {\n        configFilename = s;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit": "    public int getInitLimit() { return initLimit; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.start": "    public synchronized void start() {\n        if (!getView().containsKey(myid)) {\n            throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n         }\n        loadDataBase();\n        cnxnFactory.start();\n        startLeaderElection();\n        super.start();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.getView": "    public Map<Long,QuorumPeer.QuorumServer> getView() {\n        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.startLeaderElection": "    synchronized public void startLeaderElection() {\n       try {\n           if (getPeerState() == ServerState.LOOKING) {\n               currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n           }\n       } catch(IOException e) {\n           RuntimeException re = new RuntimeException(e.getMessage());\n           re.setStackTrace(e.getStackTrace());\n           throw re;\n       }\n\n       // if (!getView().containsKey(myid)) {\n      //      throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n        //}\n        if (electionType == 0) {\n            try {\n                udpSocket = new DatagramSocket(myQuorumAddr.getPort());\n                responder = new ResponderThread();\n                responder.start();\n            } catch (SocketException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        this.electionAlg = createElectionAlgorithm(electionType);\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.loadDataBase": "    private void loadDataBase() {\n        try {\n            zkDb.loadDataBase();\n\n            // load the epochs\n            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n            long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n            try {\n                currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n            } catch(FileNotFoundException e) {\n            \t// pick a reasonable epoch number\n            \t// this should only happen once when moving to a\n            \t// new code version\n            \tcurrentEpoch = epochOfZxid;\n            \tLOG.info(CURRENT_EPOCH_FILENAME\n            \t        + \" not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation\",\n            \t        currentEpoch);\n            \twriteLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n            }\n            if (epochOfZxid > currentEpoch) {\n                throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \", is older than the last zxid, \" + lastProcessedZxid);\n            }\n            try {\n                acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n            } catch(FileNotFoundException e) {\n            \t// pick a reasonable epoch number\n            \t// this should only happen once when moving to a\n            \t// new code version\n            \tacceptedEpoch = epochOfZxid;\n            \tLOG.info(ACCEPTED_EPOCH_FILENAME\n            \t        + \" not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation\",\n            \t        acceptedEpoch);\n            \twriteLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n            }\n            if (acceptedEpoch < currentEpoch) {\n                throw new IOException(\"The current epoch, \" + ZxidUtils.zxidToString(currentEpoch) + \" is less than the accepted epoch, \" + ZxidUtils.zxidToString(acceptedEpoch));\n            }\n        } catch(IOException ie) {\n            LOG.error(\"Unable to load database on disk\", ie);\n            throw new RuntimeException(\"Unable to run quorum server \", ie);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.enableLocalSessionsUpgrading": "    public void enableLocalSessionsUpgrading(boolean flag) {\n        LOG.info(\"Local session upgrading \" + (flag ? \"enabled\" : \"disabled\"));\n        localSessionsUpgradingEnabled = flag;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setLearnerType": "    public void setLearnerType(LearnerType p) {\n        learnerType = p;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getMaxClientCnxns": "    public int getMaxClientCnxns() { return maxClientCnxns; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getMaxSessionTimeout": "    public int getMaxSessionTimeout() { return maxSessionTimeout; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit": "    public int getSyncLimit() { return syncLimit; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getConfigBackwardCompatibility": "    public boolean getConfigBackwardCompatibility(){\n        return configBackwardCompatibilityMode;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getClientPortAddress": "    public InetSocketAddress getClientPortAddress() { return clientPortAddress; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setMinSessionTimeout": "    public void setMinSessionTimeout(int min) {\n        LOG.info(\"minSessionTimeout set to \" + min);\n        this.minSessionTimeout = min;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getServerId": "    public long getServerId() { return serverId; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setCnxnFactory": "    public void setCnxnFactory(ServerCnxnFactory cnxnFactory) {\n        this.cnxnFactory = cnxnFactory;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setMaxSessionTimeout": "    public void setMaxSessionTimeout(int max) {\n        LOG.info(\"maxSessionTimeout set to \" + max);\n        this.maxSessionTimeout = max;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setQuorumVerifier": "    public synchronized QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){\n        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n            // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n           // and then got the same config in UPTODATE message so its already known\n           LOG.debug(getId() + \" setQuorumVerifier called with known or old config \" + qv.getVersion() + \n                   \". Current version: \" + quorumVerifier.getVersion());\n           return quorumVerifier;  \n        }\n        QuorumVerifier prevQV = quorumVerifier;\n       quorumVerifier = qv;\n       if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion()))\n           lastSeenQuorumVerifier = qv;\n        if (writeToDisk) {\n                // we need to write the dynamic config file. Either it already exists\n                // or we have the old-style config file and we're in the backward compatibility mode,\n                // so we'll create the dynamic config file for the first time now\n                if (dynamicConfigFilename !=null || (configFilename !=null && configBackwardCompatibility)) { \n                try {\n                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, configFilename, configBackwardCompatibility, qv);\n                    if (configBackwardCompatibility) {\n                        dynamicConfigFilename = configFilename + \".dynamic\";\n                        configBackwardCompatibility = false;\n                    }\n                } catch(IOException e){\n                    LOG.error(\"Error closing file: \", e.getMessage());     \n                }\n            } else {\n                LOG.error(\"writeToDisk == true but dynamicConfigFilename == null, configFilename \"\n                          + (configFilename == null ? \"== null\": \"!=null\")\n                          + \" and configBackwardCompatibility == \" + configBackwardCompatibility);\n            }\n        }\n\n        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()){\n           QuorumPeerConfig.deleteFile(dynamicConfigFilename + \".next\");\n       }\n       QuorumServer qs = qv.getAllMembers().get(getId());\n       if (qs!=null){\n           setQuorumAddress(qs.addr);\n           setElectionAddress(qs.electionAddr);\n           setClientAddress(qs.clientAddr);\n       }\n       return prevQV;\n    }   ",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setElectionAddress": "    public void setElectionAddress(InetSocketAddress addr){\n        myElectionAddr = addr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setClientAddress": "    public void setClientAddress(InetSocketAddress addr){\n        myClientAddr = addr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setQuorumAddress": "    public synchronized void setQuorumAddress(InetSocketAddress addr){\n        myQuorumAddr = addr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.getId": "    public long getId() {\n        return myid;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getDataDir": "    public File getDataDir() { return dataDir; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setElectionType": "    public void setElectionType(int electionType) {\n        this.electionType = electionType;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setDynamicConfigFilename": "    protected synchronized void setDynamicConfigFilename(String s) {\n        dynamicConfigFilename = s;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getTickTime": "    public int getTickTime() { return tickTime; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.isLocalSessionsUpgradingEnabled": "    public boolean isLocalSessionsUpgradingEnabled() {\n        return localSessionsUpgradingEnabled;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setSyncEnabled": "    public void setSyncEnabled(boolean syncEnabled) {\n        this.syncEnabled = syncEnabled;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setTxnFactory": "    public void setTxnFactory(FileTxnSnapLog factory) {\n        this.logFactory = factory;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setSyncLimit": "    public void setSyncLimit(int syncLimit) {\n        this.syncLimit = syncLimit;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getDynamicConfigFilename": "    public String getDynamicConfigFilename() {\n       return dynamicConfigFileStr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setZKDatabase": "    public void setZKDatabase(ZKDatabase database) {\n        this.zkDb = database;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.areLocalSessionsEnabled": "    public boolean areLocalSessionsEnabled() { return localSessionsEnabled; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.initConfigInZKDatabase": "    public synchronized void initConfigInZKDatabase() {   \n        if (zkDb != null) zkDb.initConfigInZKDatabase(getQuorumVerifier());\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.getQuorumVerifier": "    public synchronized QuorumVerifier getQuorumVerifier(){\n        return quorumVerifier;\n\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getMinSessionTimeout": "    public int getMinSessionTimeout() { return minSessionTimeout; }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setConfigBackwardCompatibility": "    protected synchronized void setConfigBackwardCompatibility(boolean bc) {\n        configBackwardCompatibility = bc;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.quorumPeer.setMyid": "    public void setMyid(long myid) {\n        this.myid = myid;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg": "    public int getElectionAlg() { return electionAlg; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getConfigFilename": "    public String getConfigFilename(){\n        return configFileStr;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getLastSeenQuorumVerifier": "    public QuorumVerifier getLastSeenQuorumVerifier() {   \n        return lastSeenQuorumVerifier;\n    }"
        },
        "bug_report": {
            "Title": "quorumVerifier is null when creating a QuorumPeerConfig from parsing a Properties object",
            "Description": "This bug was found when using ZK 3.5.0 with curator-test 2.3.0.\ncurator-test is building a QuorumPeerConfig from a Properties object and then when we try to run the quorum peer using that configuration, we get an NPE:\n{noformat}\n2014-01-19 21:58:39,768 [myid:] - ERROR [Thread-3:TestingZooKeeperServer$1@138] - From testing server (random state: false)\njava.lang.NullPointerException\n\tat org.apache.zookeeper.server.quorum.QuorumPeer.setQuorumVerifier(QuorumPeer.java:1320)\n\tat org.apache.zookeeper.server.quorum.QuorumPeerMain.runFromConfig(QuorumPeerMain.java:156)\n\tat org.apache.curator.test.TestingZooKeeperServer$1.run(TestingZooKeeperServer.java:134)\n\tat java.lang.Thread.run(Thread.java:722)\n{noformat}\nThe reason that this happens is because QuorumPeerConfig:parseProperties only peforms a subset of what 'QuorumPeerConfig:parse(String path)' does. The exact additional task performed that we need in parseProperties is the dynamic config backwards compatibility check:\n{noformat}\n            // backward compatibility - dynamic configuration in the same file as static configuration params\n            // see writeDynamicConfig() - we change the config file to new format if reconfig happens\n            if (dynamicConfigFileStr == null) {\n                configBackwardCompatibilityMode = true;\n                configFileStr = path;................\n                parseDynamicConfig(cfg, electionAlg, true);\n                checkValidity();................\n            }\n{noformat}\n"
        }
    },
    {
        "filename": "ZOOKEEPER-2213.json",
        "creation_time": "2015-06-10T15:29:23.000+0000",
        "stack_trace": "java.lang.IllegalArgumentException: Invalid path\n        at org.apache.zookeeper.common.PathTrie.findMaxPrefix(PathTrie.java:259)\n        at org.apache.zookeeper.server.DataTree.getMaxPrefixWithQuota(DataTree.java:634)\n        at org.apache.zookeeper.server.DataTree.setData(DataTree.java:616)\n        at org.apache.zookeeper.server.DataTree.processTxn(DataTree.java:807)\n        at org.apache.zookeeper.server.persistence.FileTxnSnapLog.processTransaction(FileTxnSnapLog.java:198)\n        at org.apache.zookeeper.server.persistence.FileTxnSnapLog.restore(FileTxnSnapLog.java:151)\n        at org.apache.zookeeper.server.ZKDatabase.loadDataBase(ZKDatabase.java:223)\n        at org.apache.zookeeper.server.ZooKeeperServer.loadData(ZooKeeperServer.java:250)\n        at org.apache.zookeeper.server.ZooKeeperServer.startdata(ZooKeeperServer.java:377)\n        at org.apache.zookeeper.server.NIOServerCnxnFactory.startup(NIOServerCnxnFactory.java:122)\n        at org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ZooKeeperServerMain.java:112)\n        at org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun(ZooKeeperServerMain.java:86)\n        at org.apache.zookeeper.server.ZooKeeperServerMain.main(ZooKeeperServerMain.java:52)\n        at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(QuorumPeerMain.java:116)\n        at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain.java:78)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.common.PathTrie.findMaxPrefix": "    public String findMaxPrefix(String path) {\n        if (path == null) {\n            return null;\n        }\n        if (\"/\".equals(path)) {\n            return path;\n        }\n        String[] pathComponents = path.split(\"/\");\n        TrieNode parent = rootNode;\n        List<String> components = new ArrayList<String>();\n        if (pathComponents.length <= 1) {\n            throw new IllegalArgumentException(\"Invalid path \" + path);\n        }\n        int i = 1;\n        String part = null;\n        StringBuilder sb = new StringBuilder();\n        int lastindex = -1;\n        while((i < pathComponents.length)) {\n            if (parent.getChild(pathComponents[i]) != null) {\n                part = pathComponents[i];\n                parent = parent.getChild(part);\n                components.add(part);\n                if (parent.getProperty()) {\n                    lastindex = i-1;\n                }\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        for (int j=0; j< (lastindex+1); j++) {\n            sb.append(\"/\" + components.get(j));\n        }\n        return sb.toString();\n    }",
            "src.java.main.org.apache.zookeeper.common.PathTrie.getProperty": "        boolean getProperty() {\n            return this.property;\n        }",
            "src.java.main.org.apache.zookeeper.common.PathTrie.getChild": "        TrieNode getChild(String childName) {\n            synchronized(children) {\n               if (!children.containsKey(childName)) {\n                   return null;\n               }\n               else {\n                   return children.get(childName);\n               }\n            }\n        }",
            "src.java.main.org.apache.zookeeper.common.PathTrie.toString": "        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"Children of trienode: \");\n            synchronized(children) {\n                for (String str: children.keySet()) {\n                    sb.append(\" \" + str);\n                }\n            }\n            return sb.toString();\n        }",
            "src.java.main.org.apache.zookeeper.server.DataTree.getMaxPrefixWithQuota": "    public String getMaxPrefixWithQuota(String path) {\n        // do nothing for the root.\n        // we are not keeping a quota on the zookeeper\n        // root node for now.\n        String lastPrefix = pTrie.findMaxPrefix(path);\n\n        if (rootZookeeper.equals(lastPrefix) || \"\".equals(lastPrefix)) {\n            return null;\n        }\n        else {\n            return lastPrefix;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.equals": "        public boolean equals(Object o) {\n            if (o instanceof ProcessTxnResult) {\n                ProcessTxnResult other = (ProcessTxnResult) o;\n                return other.clientId == clientId && other.cxid == cxid;\n            }\n            return false;\n        }",
            "src.java.main.org.apache.zookeeper.server.DataTree.setData": "    public Stat setData(String path, byte data[], int version, long zxid,\n            long time) throws KeeperException.NoNodeException {\n        Stat s = new Stat();\n        DataNode n = nodes.get(path);\n        if (n == null) {\n            throw new KeeperException.NoNodeException();\n        }\n        byte lastdata[] = null;\n        synchronized (n) {\n            lastdata = n.data;\n            n.data = data;\n            n.stat.setMtime(time);\n            n.stat.setMzxid(zxid);\n            n.stat.setVersion(version);\n            n.copyStat(s);\n        }\n        // now update if the path is in a quota subtree.\n        String lastPrefix = getMaxPrefixWithQuota(path);\n        if(lastPrefix != null) {\n          this.updateBytes(lastPrefix, (data == null ? 0 : data.length)\n              - (lastdata == null ? 0 : lastdata.length));\n        }\n        dataWatches.triggerWatch(path, EventType.NodeDataChanged);\n        return s;\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.updateBytes": "    public void updateBytes(String lastPrefix, long diff) {\n        String statNode = Quotas.statPath(lastPrefix);\n        DataNode node = nodes.get(statNode);\n        if (node == null) {\n            // should never be null but just to make\n            // findbugs happy\n            LOG.error(\"Missing stat node for bytes \" + statNode);\n            return;\n        }\n        StatsTrack updatedStat = null;\n        synchronized (node) {\n            updatedStat = new StatsTrack(new String(node.data));\n            updatedStat.setBytes(updatedStat.getBytes() + diff);\n            node.data = updatedStat.toString().getBytes();\n        }\n        // now check if the bytes match the quota\n        String quotaNode = Quotas.quotaPath(lastPrefix);\n        node = nodes.get(quotaNode);\n        if (node == null) {\n            // should never be null but just to make\n            // findbugs happy\n            LOG.error(\"Missing quota node for bytes \" + quotaNode);\n            return;\n        }\n        StatsTrack thisStats = null;\n        synchronized (node) {\n            thisStats = new StatsTrack(new String(node.data));\n        }\n        if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {\n            LOG\n            .warn(\"Quota exceeded: \" + lastPrefix + \" bytes=\"\n                    + updatedStat.getBytes() + \" limit=\"\n                    + thisStats.getBytes());\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.copyStat": "    static public void copyStat(Stat from, Stat to) {\n        to.setAversion(from.getAversion());\n        to.setCtime(from.getCtime());\n        to.setCversion(from.getCversion());\n        to.setCzxid(from.getCzxid());\n        to.setMtime(from.getMtime());\n        to.setMzxid(from.getMzxid());\n        to.setPzxid(from.getPzxid());\n        to.setVersion(from.getVersion());\n        to.setEphemeralOwner(from.getEphemeralOwner());\n        to.setDataLength(from.getDataLength());\n        to.setNumChildren(from.getNumChildren());\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.processTxn": "    public ProcessTxnResult processTxn(TxnHeader header, Record txn)\n    {\n        ProcessTxnResult rc = new ProcessTxnResult();\n\n        try {\n            rc.clientId = header.getClientId();\n            rc.cxid = header.getCxid();\n            rc.zxid = header.getZxid();\n            rc.type = header.getType();\n            rc.err = 0;\n            rc.multiResult = null;\n            switch (header.getType()) {\n                case OpCode.create:\n                    CreateTxn createTxn = (CreateTxn) txn;\n                    rc.path = createTxn.getPath();\n                    createNode(\n                            createTxn.getPath(),\n                            createTxn.getData(),\n                            createTxn.getAcl(),\n                            createTxn.getEphemeral() ? header.getClientId() : 0,\n                            createTxn.getParentCVersion(),\n                            header.getZxid(), header.getTime(), null);\n                    break;\n                case OpCode.create2:\n                    CreateTxn create2Txn = (CreateTxn) txn;\n                    rc.path = create2Txn.getPath();\n                    Stat stat = new Stat();\n                    createNode(\n                            create2Txn.getPath(),\n                            create2Txn.getData(),\n                            create2Txn.getAcl(),\n                            create2Txn.getEphemeral() ? header.getClientId() : 0,\n                            create2Txn.getParentCVersion(),\n                            header.getZxid(), header.getTime(), stat);\n                    rc.stat = stat;\n                    break;\n                case OpCode.createContainer:\n                    CreateContainerTxn createContainerTxn = (CreateContainerTxn) txn;\n                    rc.path = createContainerTxn.getPath();\n                    stat = new Stat();\n                    createNode(\n                            createContainerTxn.getPath(),\n                            createContainerTxn.getData(),\n                            createContainerTxn.getAcl(),\n                            CONTAINER_EPHEMERAL_OWNER,\n                            createContainerTxn.getParentCVersion(),\n                            header.getZxid(), header.getTime(), stat);\n                    rc.stat = stat;\n                    break;\n                case OpCode.delete:\n                case OpCode.deleteContainer:\n                    DeleteTxn deleteTxn = (DeleteTxn) txn;\n                    rc.path = deleteTxn.getPath();\n                    deleteNode(deleteTxn.getPath(), header.getZxid());\n                    break;\n                case OpCode.reconfig:\n                case OpCode.setData:\n                    SetDataTxn setDataTxn = (SetDataTxn) txn;\n                    rc.path = setDataTxn.getPath();\n                    rc.stat = setData(setDataTxn.getPath(), setDataTxn\n                            .getData(), setDataTxn.getVersion(), header\n                            .getZxid(), header.getTime());\n                    break;\n                case OpCode.setACL:\n                    SetACLTxn setACLTxn = (SetACLTxn) txn;\n                    rc.path = setACLTxn.getPath();\n                    rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(),\n                            setACLTxn.getVersion());\n                    break;\n                case OpCode.closeSession:\n                    killSession(header.getClientId(), header.getZxid());\n                    break;\n                case OpCode.error:\n                    ErrorTxn errTxn = (ErrorTxn) txn;\n                    rc.err = errTxn.getErr();\n                    break;\n                case OpCode.check:\n                    CheckVersionTxn checkTxn = (CheckVersionTxn) txn;\n                    rc.path = checkTxn.getPath();\n                    break;\n                case OpCode.multi:\n                    MultiTxn multiTxn = (MultiTxn) txn ;\n                    List<Txn> txns = multiTxn.getTxns();\n                    rc.multiResult = new ArrayList<ProcessTxnResult>();\n                    boolean failed = false;\n                    for (Txn subtxn : txns) {\n                        if (subtxn.getType() == OpCode.error) {\n                            failed = true;\n                            break;\n                        }\n                    }\n\n                    boolean post_failed = false;\n                    for (Txn subtxn : txns) {\n                        ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());\n                        Record record = null;\n                        switch (subtxn.getType()) {\n                            case OpCode.create:\n                                record = new CreateTxn();\n                                break;\n                            case OpCode.createContainer:\n                                record = new CreateContainerTxn();\n                                break;\n                            case OpCode.delete:\n                            case OpCode.deleteContainer:\n                                record = new DeleteTxn();\n                                break;\n                            case OpCode.setData:\n                                record = new SetDataTxn();\n                                break;\n                            case OpCode.error:\n                                record = new ErrorTxn();\n                                post_failed = true;\n                                break;\n                            case OpCode.check:\n                                record = new CheckVersionTxn();\n                                break;\n                            default:\n                                throw new IOException(\"Invalid type of op: \" + subtxn.getType());\n                        }\n                        assert(record != null);\n\n                        ByteBufferInputStream.byteBuffer2Record(bb, record);\n\n                        if (failed && subtxn.getType() != OpCode.error){\n                            int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue()\n                                                 : Code.OK.intValue();\n\n                            subtxn.setType(OpCode.error);\n                            record = new ErrorTxn(ec);\n                        }\n\n                        if (failed) {\n                            assert(subtxn.getType() == OpCode.error) ;\n                        }\n\n                        TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(),\n                                                         header.getZxid(), header.getTime(),\n                                                         subtxn.getType());\n                        ProcessTxnResult subRc = processTxn(subHdr, record);\n                        rc.multiResult.add(subRc);\n                        if (subRc.err != 0 && rc.err == 0) {\n                            rc.err = subRc.err ;\n                        }\n                    }\n                    break;\n            }\n        } catch (KeeperException e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Failed: \" + header + \":\" + txn, e);\n            }\n            rc.err = e.code().intValue();\n        } catch (IOException e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Failed: \" + header + \":\" + txn, e);\n            }\n        }\n        /*\n         * A snapshot might be in progress while we are modifying the data\n         * tree. If we set lastProcessedZxid prior to making corresponding\n         * change to the tree, then the zxid associated with the snapshot\n         * file will be ahead of its contents. Thus, while restoring from\n         * the snapshot, the restore method will not apply the transaction\n         * for zxid associated with the snapshot file, since the restore\n         * method assumes that transaction to be present in the snapshot.\n         *\n         * To avoid this, we first apply the transaction and then modify\n         * lastProcessedZxid.  During restore, we correctly handle the\n         * case where the snapshot contains data ahead of the zxid associated\n         * with the file.\n         */\n        if (rc.zxid > lastProcessedZxid) {\n            lastProcessedZxid = rc.zxid;\n        }\n\n        /*\n         * Snapshots are taken lazily. It can happen that the child\n         * znodes of a parent are created after the parent\n         * is serialized. Therefore, while replaying logs during restore, a\n         * create might fail because the node was already\n         * created.\n         *\n         * After seeing this failure, we should increment\n         * the cversion of the parent znode since the parent was serialized\n         * before its children.\n         *\n         * Note, such failures on DT should be seen only during\n         * restore.\n         */\n        if (header.getType() == OpCode.create &&\n                rc.err == Code.NODEEXISTS.intValue()) {\n            LOG.debug(\"Adjusting parent cversion for Txn: \" + header.getType() +\n                    \" path:\" + rc.path + \" err: \" + rc.err);\n            int lastSlash = rc.path.lastIndexOf('/');\n            String parentName = rc.path.substring(0, lastSlash);\n            CreateTxn cTxn = (CreateTxn)txn;\n            try {\n                setCversionPzxid(parentName, cTxn.getParentCVersion(),\n                        header.getZxid());\n            } catch (KeeperException.NoNodeException e) {\n                LOG.error(\"Failed to set parent cversion for: \" +\n                      parentName, e);\n                rc.err = e.code().intValue();\n            }\n        } else if (rc.err != Code.OK.intValue()) {\n            LOG.debug(\"Ignoring processTxn failure hdr: \" + header.getType() +\n                  \" : error: \" + rc.err);\n        }\n        return rc;\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.setACL": "    public Stat setACL(String path, List<ACL> acl, int version)\n            throws KeeperException.NoNodeException {\n        Stat stat = new Stat();\n        DataNode n = nodes.get(path);\n        if (n == null) {\n            throw new KeeperException.NoNodeException();\n        }\n        synchronized (n) {\n            n.stat.setAversion(version);\n            n.acl = convertAcls(acl);\n            n.copyStat(stat);\n            return stat;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.getData": "    public byte[] getData(String path, Stat stat, Watcher watcher)\n            throws KeeperException.NoNodeException {\n        DataNode n = nodes.get(path);\n        if (n == null) {\n            throw new KeeperException.NoNodeException();\n        }\n        synchronized (n) {\n            n.copyStat(stat);\n            if (watcher != null) {\n                dataWatches.addWatch(path, watcher);\n            }\n            return n.data;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.killSession": "    void killSession(long session, long zxid) {\n        // the list is already removed from the ephemerals\n        // so we do not have to worry about synchronizing on\n        // the list. This is only called from FinalRequestProcessor\n        // so there is no need for synchronization. The list is not\n        // changed here. Only create and delete change the list which\n        // are again called from FinalRequestProcessor in sequence.\n        HashSet<String> list = ephemerals.remove(session);\n        if (list != null) {\n            for (String path : list) {\n                try {\n                    deleteNode(path, zxid);\n                    if (LOG.isDebugEnabled()) {\n                        LOG\n                                .debug(\"Deleting ephemeral node \" + path\n                                        + \" for session 0x\"\n                                        + Long.toHexString(session));\n                    }\n                } catch (NoNodeException e) {\n                    LOG.warn(\"Ignoring NoNodeException for path \" + path\n                            + \" while removing ephemeral for dead session 0x\"\n                            + Long.toHexString(session));\n                }\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.createNode": "    public void createNode(final String path, byte data[], List<ACL> acl,\n            long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat)\n            throws KeeperException.NoNodeException,\n            KeeperException.NodeExistsException {\n        int lastSlash = path.lastIndexOf('/');\n        String parentName = path.substring(0, lastSlash);\n        String childName = path.substring(lastSlash + 1);\n        StatPersisted stat = new StatPersisted();\n        stat.setCtime(time);\n        stat.setMtime(time);\n        stat.setCzxid(zxid);\n        stat.setMzxid(zxid);\n        stat.setPzxid(zxid);\n        stat.setVersion(0);\n        stat.setAversion(0);\n        stat.setEphemeralOwner(ephemeralOwner);\n        DataNode parent = nodes.get(parentName);\n        if (parent == null) {\n            throw new KeeperException.NoNodeException();\n        }\n        synchronized (parent) {\n            Set<String> children = parent.getChildren();\n            if (children != null && children.contains(childName)) {\n                throw new KeeperException.NodeExistsException();\n            }\n\n            if (parentCVersion == -1) {\n                parentCVersion = parent.stat.getCversion();\n                parentCVersion++;\n            }\n            parent.stat.setCversion(parentCVersion);\n            parent.stat.setPzxid(zxid);\n            Long longval = convertAcls(acl);\n            DataNode child = new DataNode(data, longval, stat);\n            parent.addChild(childName);\n            nodes.put(path, child);\n            if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {\n                containers.add(path);\n            } else if (ephemeralOwner != 0) {\n                HashSet<String> list = ephemerals.get(ephemeralOwner);\n                if (list == null) {\n                    list = new HashSet<String>();\n                    ephemerals.put(ephemeralOwner, list);\n                }\n                synchronized (list) {\n                    list.add(path);\n                }\n            }\n            if (outputStat != null) {\n            \tchild.copyStat(outputStat);\n            }\n        }\n        // now check if its one of the zookeeper node child\n        if (parentName.startsWith(quotaZookeeper)) {\n            // now check if its the limit node\n            if (Quotas.limitNode.equals(childName)) {\n                // this is the limit node\n                // get the parent and add it to the trie\n                pTrie.addPath(parentName.substring(quotaZookeeper.length()));\n            }\n            if (Quotas.statNode.equals(childName)) {\n                updateQuotaForPath(parentName\n                        .substring(quotaZookeeper.length()));\n            }\n        }\n        // also check to update the quotas for this node\n        String lastPrefix = getMaxPrefixWithQuota(path);\n        if(lastPrefix != null) {\n            // ok we have some match and need to update\n            updateCount(lastPrefix, 1);\n            updateBytes(lastPrefix, data == null ? 0 : data.length);\n        }\n        dataWatches.triggerWatch(path, Event.EventType.NodeCreated);\n        childWatches.triggerWatch(parentName.equals(\"\") ? \"/\" : parentName,\n                Event.EventType.NodeChildrenChanged);\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.setCversionPzxid": "    public void setCversionPzxid(String path, int newCversion, long zxid)\n        throws KeeperException.NoNodeException {\n        if (path.endsWith(\"/\")) {\n           path = path.substring(0, path.length() - 1);\n        }\n        DataNode node = nodes.get(path);\n        if (node == null) {\n            throw new KeeperException.NoNodeException(path);\n        }\n        synchronized (node) {\n            if(newCversion == -1) {\n                newCversion = node.stat.getCversion() + 1;\n            }\n            if (newCversion > node.stat.getCversion()) {\n                node.stat.setCversion(newCversion);\n                node.stat.setPzxid(zxid);\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.deleteNode": "    public void deleteNode(String path, long zxid)\n            throws KeeperException.NoNodeException {\n        int lastSlash = path.lastIndexOf('/');\n        String parentName = path.substring(0, lastSlash);\n        String childName = path.substring(lastSlash + 1);\n        DataNode node = nodes.get(path);\n        if (node == null) {\n            throw new KeeperException.NoNodeException();\n        }\n        nodes.remove(path);\n        DataNode parent = nodes.get(parentName);\n        if (parent == null) {\n            throw new KeeperException.NoNodeException();\n        }\n        synchronized (parent) {\n            parent.removeChild(childName);\n            parent.stat.setPzxid(zxid);\n            long eowner = node.stat.getEphemeralOwner();\n            if (eowner == CONTAINER_EPHEMERAL_OWNER) {\n                containers.remove(path);\n            } else if (eowner != 0) {\n                HashSet<String> nodes = ephemerals.get(eowner);\n                if (nodes != null) {\n                    synchronized (nodes) {\n                        nodes.remove(path);\n                    }\n                }\n            }\n        }\n        if (parentName.startsWith(procZookeeper) && Quotas.limitNode.equals(childName)) {\n            // delete the node in the trie.\n            // we need to update the trie as well\n            pTrie.deletePath(parentName.substring(quotaZookeeper.length()));\n        }\n\n        // also check to update the quotas for this node\n        String lastPrefix = getMaxPrefixWithQuota(path);\n        if(lastPrefix != null) {\n            // ok we have some match and need to update\n            updateCount(lastPrefix, -1);\n            int bytes = 0;\n            synchronized (node) {\n                bytes = (node.data == null ? 0 : -(node.data.length));\n            }\n            updateBytes(lastPrefix, bytes);\n        }\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                    \"dataWatches.triggerWatch \" + path);\n            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                    \"childWatches.triggerWatch \" + parentName);\n        }\n        Set<Watcher> processed = dataWatches.triggerWatch(path,\n                EventType.NodeDeleted);\n        childWatches.triggerWatch(path, EventType.NodeDeleted, processed);\n        childWatches.triggerWatch(\"\".equals(parentName) ? \"/\" : parentName,\n                EventType.NodeChildrenChanged);\n    }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.processTransaction": "    public void processTransaction(TxnHeader hdr,DataTree dt,\n            Map<Long, Integer> sessions, Record txn)\n        throws KeeperException.NoNodeException {\n        ProcessTxnResult rc;\n        switch (hdr.getType()) {\n        case OpCode.createSession:\n            sessions.put(hdr.getClientId(),\n                    ((CreateSessionTxn) txn).getTimeOut());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\n                        \"playLog --- create session in log: 0x\"\n                                + Long.toHexString(hdr.getClientId())\n                                + \" with timeout: \"\n                                + ((CreateSessionTxn) txn).getTimeOut());\n            }\n            // give dataTree a chance to sync its lastProcessedZxid\n            rc = dt.processTxn(hdr, txn);\n            break;\n        case OpCode.closeSession:\n            sessions.remove(hdr.getClientId());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\n                        \"playLog --- close session in log: 0x\"\n                                + Long.toHexString(hdr.getClientId()));\n            }\n            rc = dt.processTxn(hdr, txn);\n            break;\n        default:\n            rc = dt.processTxn(hdr, txn);\n        }\n\n        /**\n         * Snapshots are lazily created. So when a snapshot is in progress,\n         * there is a chance for later transactions to make into the\n         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n         * errors could occur. It should be safe to ignore these.\n         */\n        if (rc.err != Code.OK.intValue()) {\n            LOG.debug(\n                    \"Ignoring processTxn failure hdr: {}, error: {}, path: {}\",\n                    hdr.getType(), rc.err, rc.path);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.restore": "    public long restore(DataTree dt, Map<Long, Integer> sessions,\n            PlayBackListener listener) throws IOException {\n        snapLog.deserialize(dt, sessions);\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);\n        long highestZxid = dt.lastProcessedZxid;\n        TxnHeader hdr;\n        try {\n            while (true) {\n                // iterator points to\n                // the first valid txn when initialized\n                hdr = itr.getHeader();\n                if (hdr == null) {\n                    //empty logs\n                    return dt.lastProcessedZxid;\n                }\n                if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n                    LOG.error(\"{}(higestZxid) > {}(next log) for type {}\",\n                            new Object[] { highestZxid, hdr.getZxid(),\n                                    hdr.getType() });\n                } else {\n                    highestZxid = hdr.getZxid();\n                }\n                try {\n                    processTransaction(hdr,dt,sessions, itr.getTxn());\n                } catch(KeeperException.NoNodeException e) {\n                   throw new IOException(\"Failed to process transaction type: \" +\n                         hdr.getType() + \" error: \" + e.getMessage(), e);\n                }\n                listener.onTxnLoaded(hdr, itr.getTxn());\n                if (!itr.next())\n                    break;\n            }\n        } finally {\n            if (itr != null) {\n                itr.close();\n            }\n        }\n        return highestZxid;\n    }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.close": "    public void close() throws IOException {\n        txnLog.close();\n        snapLog.close();\n    }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.onTxnLoaded": "        void onTxnLoaded(TxnHeader hdr, Record rec);\n    }\n\n    /**\n     * the constructor which takes the datadir and\n     * snapdir.\n     * @param dataDir the trasaction directory\n     * @param snapDir the snapshot directory\n     */\n    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {",
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.loadDataBase": "    public long loadDataBase() throws IOException {\n        PlayBackListener listener=new PlayBackListener(){\n            public void onTxnLoaded(TxnHeader hdr,Record txn){\n                Request r = new Request(0, hdr.getCxid(),hdr.getType(), hdr, txn, hdr.getZxid());\n                addCommittedProposal(r);\n            }\n        };\n\n        long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);\n        initialized = true;\n        return zxid;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.addCommittedProposal": "    public void addCommittedProposal(Request request) {\n        WriteLock wl = logLock.writeLock();\n        try {\n            wl.lock();\n            if (committedLog.size() > commitLogCount) {\n                committedLog.removeFirst();\n                minCommittedLog = committedLog.getFirst().packet.getZxid();\n            }\n            if (committedLog.isEmpty()) {\n                minCommittedLog = request.zxid;\n                maxCommittedLog = request.zxid;\n            }\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n            try {\n                request.getHdr().serialize(boa, \"hdr\");\n                if (request.getTxn() != null) {\n                    request.getTxn().serialize(boa, \"txn\");\n                }\n                baos.close();\n            } catch (IOException e) {\n                LOG.error(\"This really should be impossible\", e);\n            }\n            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,\n                    baos.toByteArray(), null);\n            Proposal p = new Proposal();\n            p.packet = pp;\n            p.request = request;\n            committedLog.add(p);\n            maxCommittedLog = p.packet.getZxid();\n        } finally {\n            wl.unlock();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.loadData": "    public void loadData() throws IOException, InterruptedException {\n        /*\n         * When a new leader starts executing Leader#lead, it \n         * invokes this method. The database, however, has been\n         * initialized before running leader election so that\n         * the server could pick its zxid for its initial vote.\n         * It does it by invoking QuorumPeer#getLastLoggedZxid.\n         * Consequently, we don't need to initialize it once more\n         * and avoid the penalty of loading it a second time. Not \n         * reloading it is particularly important for applications\n         * that host a large database.\n         * \n         * The following if block checks whether the database has\n         * been initialized or not. Note that this method is\n         * invoked by at least one other method: \n         * ZooKeeperServer#startdata.\n         *  \n         * See ZOOKEEPER-1642 for more detail.\n         */\n        if(zkDb.isInitialized()){\n            setZxid(zkDb.getDataTreeLastProcessedZxid());\n        }\n        else {\n            setZxid(zkDb.loadDataBase());\n        }\n        \n        // Clean up dead sessions\n        LinkedList<Long> deadSessions = new LinkedList<Long>();\n        for (Long session : zkDb.getSessions()) {\n            if (zkDb.getSessionWithTimeOuts().get(session) == null) {\n                deadSessions.add(session);\n            }\n        }\n\n        for (long session : deadSessions) {\n            // XXX: Is lastProcessedZxid really the best thing to use?\n            killSession(session, zkDb.getDataTreeLastProcessedZxid());\n        }\n\n        // Make a clean snapshot\n        takeSnapshot();\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.setZxid": "    public void setZxid(long zxid) {\n        hzxid.set(zxid);\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.killSession": "    protected void killSession(long sessionId, long zxid) {\n        zkDb.killSession(sessionId, zxid);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,\n                                         \"ZooKeeperServer --- killSession: 0x\"\n                    + Long.toHexString(sessionId));\n        }\n        if (sessionTracker != null) {\n            sessionTracker.removeSession(sessionId);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.takeSnapshot": "    public void takeSnapshot(){\n        try {\n            txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts());\n        } catch (IOException e) {\n            LOG.error(\"Severe unrecoverable error, exiting\", e);\n            // This is a severe error that we cannot recover from,\n            // so we need to exit\n            System.exit(10);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.startdata": "    public void startdata()\n    throws IOException, InterruptedException {\n        //check to see if zkDb is not null\n        if (zkDb == null) {\n            zkDb = new ZKDatabase(this.txnLogFactory);\n        }\n        if (!zkDb.isInitialized()) {\n            loadData();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.NIOServerCnxnFactory.startup": "    public void startup(ZooKeeperServer zks, boolean startServer)\n            throws IOException, InterruptedException {\n        start();\n        setZooKeeperServer(zks);\n        if (startServer) {\n            zks.startdata();\n            zks.startup();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.NIOServerCnxnFactory.start": "    public void start() {\n        stopped = false;\n        if (workerPool == null) {\n            workerPool = new WorkerService(\n                \"NIOWorker\", numWorkerThreads, false);\n        }\n        for(SelectorThread thread : selectorThreads) {\n            if (thread.getState() == Thread.State.NEW) {\n                thread.start();\n            }\n        }\n        // ensure thread is started once and only once\n        if (acceptThread.getState() == Thread.State.NEW) {\n            acceptThread.start();\n        }\n        if (expirerThread.getState() == Thread.State.NEW) {\n            expirerThread.start();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig": "    public void runFromConfig(ServerConfig config) throws IOException, AdminServerException {\n        LOG.info(\"Starting server\");\n        FileTxnSnapLog txnLog = null;\n        try {\n            // Note that this thread isn't going to be doing anything else,\n            // so rather than spawning another thread, we will just call\n            // run() in this thread.\n            // create a file logger url from the command line args\n            txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);\n            ZooKeeperServer zkServer = new ZooKeeperServer( txnLog,\n                    config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, null);\n\n            // Start Admin server\n            adminServer = AdminServerFactory.createAdminServer();\n            adminServer.setZooKeeperServer(zkServer);\n            adminServer.start();\n\n            boolean needStartZKServer = true;\n            if (config.getClientPortAddress() != null) {\n                cnxnFactory = ServerCnxnFactory.createFactory();\n                cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), false);\n                cnxnFactory.startup(zkServer);\n                // zkServer has been started. So we don't need to start it again in secureCnxnFactory.\n                needStartZKServer = false;\n            }\n            if (config.getSecureClientPortAddress() != null) {\n                secureCnxnFactory = ServerCnxnFactory.createFactory();\n                secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), true);\n                secureCnxnFactory.startup(zkServer, needStartZKServer);\n            }\n\n            containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor,\n                    Integer.getInteger(\"znode.container.checkIntervalMs\", (int) TimeUnit.MINUTES.toMillis(1)),\n                    Integer.getInteger(\"znode.container.maxPerMinute\", 10000)\n            );\n            containerManager.start();\n\n            if (cnxnFactory != null) {\n                cnxnFactory.join();\n            }\n            if (secureCnxnFactory != null) {\n                secureCnxnFactory.join();\n            }\n\n            if (zkServer.isRunning()) {\n                zkServer.shutdown();\n            }\n        } catch (InterruptedException e) {\n            // warn, but generally this is ok\n            LOG.warn(\"Server interrupted\", e);\n        } finally {\n            if (txnLog != null) {\n                txnLog.close();\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServerMain.shutdown": "    protected void shutdown() {\n        if (containerManager != null) {\n            containerManager.stop();\n        }\n        if (cnxnFactory != null) {\n            cnxnFactory.shutdown();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.shutdown();\n        }\n        try {\n            adminServer.shutdown();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem stopping AdminServer\", e);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun": "    protected void initializeAndRun(String[] args)\n        throws ConfigException, IOException, AdminServerException\n    {\n        try {\n            ManagedUtil.registerLog4jMBeans();\n        } catch (JMException e) {\n            LOG.warn(\"Unable to register log4j JMX control\", e);\n        }\n\n        ServerConfig config = new ServerConfig();\n        if (args.length == 1) {\n            config.parse(args[0]);\n        } else {\n            config.parse(args);\n        }\n\n        runFromConfig(config);\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServerMain.main": "    public static void main(String[] args) {\n        ZooKeeperServerMain main = new ZooKeeperServerMain();\n        try {\n            main.initializeAndRun(args);\n        } catch (IllegalArgumentException e) {\n            LOG.error(\"Invalid arguments, exiting abnormally\", e);\n            LOG.info(USAGE);\n            System.err.println(USAGE);\n            System.exit(2);\n        } catch (ConfigException e) {\n            LOG.error(\"Invalid config, exiting abnormally\", e);\n            System.err.println(\"Invalid config, exiting abnormally\");\n            System.exit(2);\n        } catch (DatadirException e) {\n            LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n            System.err.println(\"Unable to access datadir, exiting abnormally\");\n            System.exit(3);\n        } catch (AdminServerException e) {\n            LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n            System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n            System.exit(4);\n        } catch (Exception e) {\n            LOG.error(\"Unexpected exception, exiting abnormally\", e);\n            System.exit(1);\n        }\n        LOG.info(\"Exiting normally\");\n        System.exit(0);\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun": "    protected void initializeAndRun(String[] args)\n        throws ConfigException, IOException, AdminServerException\n    {\n        QuorumPeerConfig config = new QuorumPeerConfig();\n        if (args.length == 1) {\n            config.parse(args[0]);\n        }\n\n        // Start and schedule the the purge task\n        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config\n                .getDataDir(), config.getDataLogDir(), config\n                .getSnapRetainCount(), config.getPurgeInterval());\n        purgeMgr.start();\n\n        if (args.length == 1 && config.isDistributed()) {\n            runFromConfig(config);\n        } else {\n            LOG.warn(\"Either no config or no quorum defined in config, running \"\n                    + \" in standalone mode\");\n            // there is only server in the quorum -- run as standalone\n            ZooKeeperServerMain.main(args);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.runFromConfig": "    public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException {\n      try {\n          ManagedUtil.registerLog4jMBeans();\n      } catch (JMException e) {\n          LOG.warn(\"Unable to register log4j JMX control\", e);\n      }\n\n      LOG.info(\"Starting quorum peer\");\n      try {\n          ServerCnxnFactory cnxnFactory = null;\n          ServerCnxnFactory secureCnxnFactory = null;\n\n          if (config.getClientPortAddress() != null) {\n              cnxnFactory = ServerCnxnFactory.createFactory();\n              cnxnFactory.configure(config.getClientPortAddress(),\n                      config.getMaxClientCnxns(),\n                      false);\n          }\n\n          if (config.getSecureClientPortAddress() != null) {\n              secureCnxnFactory = ServerCnxnFactory.createFactory();\n              secureCnxnFactory.configure(config.getSecureClientPortAddress(),\n                      config.getMaxClientCnxns(),\n                      true);\n          }\n\n          quorumPeer = new QuorumPeer();\n          quorumPeer.setTxnFactory(new FileTxnSnapLog(\n                      config.getDataLogDir(),\n                      config.getDataDir()));\n          quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n          quorumPeer.enableLocalSessionsUpgrading(\n              config.isLocalSessionsUpgradingEnabled());\n          //quorumPeer.setQuorumPeers(config.getAllMembers());\n          quorumPeer.setElectionType(config.getElectionAlg());\n          quorumPeer.setMyid(config.getServerId());\n          quorumPeer.setTickTime(config.getTickTime());\n          quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n          quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n          quorumPeer.setInitLimit(config.getInitLimit());\n          quorumPeer.setSyncLimit(config.getSyncLimit());\n          quorumPeer.setConfigFileName(config.getConfigFilename());\n          quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n          quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n          if (config.getLastSeenQuorumVerifier()!=null) {\n              quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n          }\n          quorumPeer.initConfigInZKDatabase();\n          quorumPeer.setCnxnFactory(cnxnFactory);\n          quorumPeer.setSecureCnxnFactory(secureCnxnFactory);\n          quorumPeer.setLearnerType(config.getPeerType());\n          quorumPeer.setSyncEnabled(config.getSyncEnabled());\n          quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n          \n          quorumPeer.start();\n          quorumPeer.join();\n      } catch (InterruptedException e) {\n          // warn, but generally this is ok\n          LOG.warn(\"Quorum Peer interrupted\", e);\n      }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.main": "    public static void main(String[] args) {\n        QuorumPeerMain main = new QuorumPeerMain();\n        try {\n            main.initializeAndRun(args);\n        } catch (IllegalArgumentException e) {\n            LOG.error(\"Invalid arguments, exiting abnormally\", e);\n            LOG.info(USAGE);\n            System.err.println(USAGE);\n            System.exit(2);\n        } catch (ConfigException e) {\n            LOG.error(\"Invalid config, exiting abnormally\", e);\n            System.err.println(\"Invalid config, exiting abnormally\");\n            System.exit(2);\n        } catch (DatadirException e) {\n            LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n            System.err.println(\"Unable to access datadir, exiting abnormally\");\n            System.exit(3);\n        } catch (AdminServerException e) {\n            LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n            System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n            System.exit(4);\n        } catch (Exception e) {\n            LOG.error(\"Unexpected exception, exiting abnormally\", e);\n            System.exit(1);\n        }\n        LOG.info(\"Exiting normally\");\n        System.exit(0);\n    }",
            "src.java.main.org.apache.zookeeper.server.ByteBufferInputStream.byteBuffer2Record": "    static public void byteBuffer2Record(ByteBuffer bb, Record record)\n            throws IOException {\n        BinaryInputArchive ia;\n        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n        record.deserialize(ia, \"request\");\n    }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.read": "        public int read(byte[] b, int off, int len) throws IOException {\n            int rc = super.read(b, off, len);\n            if (rc > 0) {\n                position += rc;\n            }\n            return rc;\n        }",
            "src.java.main.org.apache.zookeeper.server.ServerConfig.getMaxClientCnxns": "    public int getMaxClientCnxns() { return maxClientCnxns; }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getZKDatabase": "    public ZKDatabase getZKDatabase() {\n        return this.zkDb;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxnFactory.createFactory": "    static public ServerCnxnFactory createFactory(InetSocketAddress addr,\n            int maxClientCnxns) throws IOException\n    {\n        ServerCnxnFactory factory = createFactory();\n        factory.configure(addr, maxClientCnxns);\n        return factory;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxnFactory.configure": "    public abstract void configure(InetSocketAddress addr, int maxcc, boolean secure)\n            throws IOException;\n\n    public abstract void reconfigure(InetSocketAddress addr);\n\n    protected SaslServerCallbackHandler saslServerCallbackHandler;\n    public Login login;\n\n    /** Maximum number of connections allowed from particular host (ip) */\n    public abstract int getMaxClientCnxnsPerHost();\n\n    /** Maximum number of connections allowed from particular host (ip) */\n    public abstract void setMaxClientCnxnsPerHost(int max);\n\n    public boolean isSecure() {\n        return secure;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerConfig.getClientPortAddress": "    public InetSocketAddress getClientPortAddress() {\n        return clientPortAddress;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.isRunning": "    public boolean isRunning() {\n        return state == State.RUNNING;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerConfig.getSecureClientPortAddress": "    public InetSocketAddress getSecureClientPortAddress() {\n        return secureClientPortAddress;\n    }",
            "src.java.main.org.apache.zookeeper.server.containerManager.start": "    public void start() {\n        if (task.get() == null) {\n            TimerTask timerTask = new TimerTask() {\n                @Override\n                public void run() {\n                    try {\n                        checkContainers();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        LOG.info(\"interrupted\");\n                        cancel();\n                    } catch ( Throwable e ) {\n                        LOG.error(\"Error checking containers\", e);\n                    }\n                }\n            };\n            if (task.compareAndSet(null, timerTask)) {\n                timer.scheduleAtFixedRate(timerTask, checkIntervalMs,\n                        checkIntervalMs);\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.containerManager.checkContainers": "    public void checkContainers()\n            throws InterruptedException {\n        long minIntervalMs = getMinIntervalMs();\n        for (String containerPath : getCandidates()) {\n            long startMs = Time.currentElapsedTime();\n\n            ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes());\n            Request request = new Request(null, 0, 0,\n                    ZooDefs.OpCode.deleteContainer, path, null);\n            try {\n                LOG.info(\"Attempting to delete candidate container: %s\",\n                        containerPath);\n                requestProcessor.processRequest(request);\n            } catch (Exception e) {\n                LOG.error(String.format(\"Could not delete container: %s\" ,\n                        containerPath), e);\n            }\n\n            long elapsedMs = Time.currentElapsedTime() - startMs;\n            long waitMs = minIntervalMs - elapsedMs;\n            if (waitMs > 0) {\n                Thread.sleep(waitMs);\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerConfig.parse": "    public void parse(String path) throws ConfigException {\n        QuorumPeerConfig config = new QuorumPeerConfig();\n        config.parse(path);\n\n        // let qpconfig parse the file and then pull the stuff we are\n        // interested in\n        readFrom(config);\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerConfig.readFrom": "    public void readFrom(QuorumPeerConfig config) {\n        clientPortAddress = config.getClientPortAddress();\n        secureClientPortAddress = config.getSecureClientPortAddress();\n        dataDir = config.getDataDir();\n        dataLogDir = config.getDataLogDir();\n        tickTime = config.getTickTime();\n        maxClientCnxns = config.getMaxClientCnxns();\n        minSessionTimeout = config.getMinSessionTimeout();\n        maxSessionTimeout = config.getMaxSessionTimeout();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.isDistributed": "    public boolean isDistributed() {\n        return quorumVerifier!=null && (!standaloneEnabled || quorumVerifier.getVotingMembers().size() > 1);\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getDataDir": "    public File getDataDir() { return dataDir; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getDataLogDir": "    public File getDataLogDir() { return dataLogDir; }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getSnapRetainCount": "    public int getSnapRetainCount() {\n        return snapRetainCount;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.parse": "    public void parse(String path) throws ConfigException {\n        LOG.info(\"Reading configuration from: \" + path);\n       \n        try {\n            File configFile = (new VerifyingFileFactory.Builder(LOG)\n                .warnForRelativePath()\n                .failForNonExistingPath()\n                .build()).create(path);\n                \n            Properties cfg = new Properties();\n            FileInputStream in = new FileInputStream(configFile);\n            try {\n                cfg.load(in);\n                configFileStr = path;\n            } finally {\n                in.close();\n            }\n            \n            parseProperties(cfg);\n        } catch (IOException e) {\n            throw new ConfigException(\"Error processing \" + path, e);\n        } catch (IllegalArgumentException e) {\n            throw new ConfigException(\"Error processing \" + path, e);\n        }   \n        \n        if (dynamicConfigFileStr!=null) {\n           try {           \n               Properties dynamicCfg = new Properties();\n               FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);\n               try {\n                   dynamicCfg.load(inConfig);\n                   if (dynamicCfg.getProperty(\"version\") != null) {\n                       throw new ConfigException(\"dynamic file shouldn't have version inside\");\n                   }\n\n                   String version = getVersionFromFilename(dynamicConfigFileStr);\n                   // If there isn't any version associated with the filename,\n                   // the default version is 0.\n                   if (version != null) {\n                       dynamicCfg.setProperty(\"version\", version);\n                   }\n               } finally {\n                   inConfig.close();\n               }\n               setupQuorumPeerConfig(dynamicCfg, false);\n\n           } catch (IOException e) {\n               throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n           } catch (IllegalArgumentException e) {\n               throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n           }        \n           File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);\n           if (nextDynamicConfigFile.exists()) {\n               try {           \n                   Properties dynamicConfigNextCfg = new Properties();\n                   FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);       \n                   try {\n                       dynamicConfigNextCfg.load(inConfigNext);\n                   } finally {\n                       inConfigNext.close();\n                   }\n                   boolean isHierarchical = false;\n                   for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {\n                       String key = entry.getKey().toString().trim();  \n                       if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n                           isHierarchical = true;\n                           break;\n                       }\n                   }\n                   lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);\n               } catch (IOException e) {\n                   LOG.warn(\"NextQuorumVerifier is initiated to null\");\n               }\n           }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.setupQuorumPeerConfig": "    void setupQuorumPeerConfig(Properties prop, boolean configBackwardCompatibilityMode)\n            throws IOException, ConfigException {\n        quorumVerifier = parseDynamicConfig(prop, electionAlg, true, configBackwardCompatibilityMode);\n        setupMyId();\n        setupClientPort();\n        setupPeerType();\n        checkValidity();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.createQuorumVerifier": "    private static QuorumVerifier createQuorumVerifier(Properties dynamicConfigProp, boolean isHierarchical) throws ConfigException{\n       if(isHierarchical){\n            return new QuorumHierarchical(dynamicConfigProp);\n        } else {\n           /*\n             * The default QuorumVerifier is QuorumMaj\n             */        \n            //LOG.info(\"Defaulting to majority quorums\");\n            return new QuorumMaj(dynamicConfigProp);            \n        }          \n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getVersionFromFilename": "    public static String getVersionFromFilename(String filename) {\n        int i = filename.lastIndexOf('.');\n        if(i < 0 || i >= filename.length())\n            return null;\n\n        String hexVersion = filename.substring(i + 1);\n        try {\n            long version = Long.parseLong(hexVersion, 16);\n            return Long.toHexString(version);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties": "    public void parseProperties(Properties zkProp)\n    throws IOException, ConfigException {\n        int clientPort = 0;\n        int secureClientPort = 0;\n        String clientPortAddress = null;\n        String secureClientPortAddress = null;\n        VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n        for (Entry<Object, Object> entry : zkProp.entrySet()) {\n            String key = entry.getKey().toString().trim();\n            String value = entry.getValue().toString().trim();\n            if (key.equals(\"dataDir\")) {\n                dataDir = vff.create(value);\n            } else if (key.equals(\"dataLogDir\")) {\n                dataLogDir = vff.create(value);\n            } else if (key.equals(\"clientPort\")) {\n                clientPort = Integer.parseInt(value);\n            } else if (key.equals(\"localSessionsEnabled\")) {\n                localSessionsEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n                localSessionsUpgradingEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"clientPortAddress\")) {\n                clientPortAddress = value.trim();\n            } else if (key.equals(\"secureClientPort\")) {\n                secureClientPort = Integer.parseInt(value);\n            } else if (key.equals(\"secureClientPortAddress\")){\n                secureClientPortAddress = value.trim();\n            } else if (key.equals(\"tickTime\")) {\n                tickTime = Integer.parseInt(value);\n            } else if (key.equals(\"maxClientCnxns\")) {\n                maxClientCnxns = Integer.parseInt(value);\n            } else if (key.equals(\"minSessionTimeout\")) {\n                minSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"maxSessionTimeout\")) {\n                maxSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"initLimit\")) {\n                initLimit = Integer.parseInt(value);\n            } else if (key.equals(\"syncLimit\")) {\n                syncLimit = Integer.parseInt(value);\n            } else if (key.equals(\"electionAlg\")) {\n                electionAlg = Integer.parseInt(value);\n            } else if (key.equals(\"quorumListenOnAllIPs\")) {\n                quorumListenOnAllIPs = Boolean.parseBoolean(value);\n            } else if (key.equals(\"peerType\")) {\n                if (value.toLowerCase().equals(\"observer\")) {\n                    peerType = LearnerType.OBSERVER;\n                } else if (value.toLowerCase().equals(\"participant\")) {\n                    peerType = LearnerType.PARTICIPANT;\n                } else\n                {\n                    throw new ConfigException(\"Unrecognised peertype: \" + value);\n                }\n            } else if (key.equals( \"syncEnabled\" )) {\n                syncEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"dynamicConfigFile\")){\n                dynamicConfigFileStr = value;\n            } else if (key.equals(\"autopurge.snapRetainCount\")) {\n                snapRetainCount = Integer.parseInt(value);\n            } else if (key.equals(\"autopurge.purgeInterval\")) {\n                purgeInterval = Integer.parseInt(value);\n            } else if (key.equals(\"standaloneEnabled\")) {\n                if (value.toLowerCase().equals(\"true\")) {\n                    setStandaloneEnabled(true);\n                } else if (value.toLowerCase().equals(\"false\")) {\n                    setStandaloneEnabled(false);\n                } else {\n                    throw new ConfigException(\"Invalid option for standalone mode. Choose 'true' or 'false.'\");\n                }\n            } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n                throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n            } else {\n                System.setProperty(\"zookeeper.\" + key, value);\n            }\n        }\n\n        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n            LOG.warn(\"Invalid autopurge.snapRetainCount: \" + snapRetainCount\n                    + \". Defaulting to \" + MIN_SNAP_RETAIN_COUNT);\n            snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n        }\n\n        if (dataDir == null) {\n            throw new IllegalArgumentException(\"dataDir is not set\");\n        }\n        if (dataLogDir == null) {\n            dataLogDir = dataDir;\n        }\n\n        if (clientPort == 0) {\n            LOG.info(\"clientPort is not set\");\n            if (this.clientPortAddress != null) {\n                throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n            }\n        } else if (clientPortAddress != null) {\n            this.clientPortAddress = new InetSocketAddress(\n                    InetAddress.getByName(clientPortAddress), clientPort);\n            LOG.info(\"clientPortAddress is {}\", this.clientPortAddress.toString());\n        } else {\n            this.clientPortAddress = new InetSocketAddress(clientPort);\n            LOG.info(\"clientPortAddress is {}\", this.clientPortAddress.toString());\n        }\n\n        if (secureClientPort == 0) {\n            LOG.info(\"secureClientPort is not set\");\n            if (this.secureClientPortAddress != null) {\n                throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n            }\n        } else if (secureClientPortAddress != null) {\n            this.secureClientPortAddress = new InetSocketAddress(\n                    InetAddress.getByName(secureClientPortAddress), secureClientPort);\n            LOG.info(\"secureClientPortAddress is {}\", this.secureClientPortAddress.toString());\n        } else {\n            this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n            LOG.info(\"secureClientPortAddress is {}\", this.secureClientPortAddress.toString());\n        }\n\n        if (tickTime == 0) {\n            throw new IllegalArgumentException(\"tickTime is not set\");\n        }\n\n        minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n        maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n\n        if (minSessionTimeout > maxSessionTimeout) {\n            throw new IllegalArgumentException(\n                    \"minSessionTimeout must not be larger than maxSessionTimeout\");\n        }          \n\n        // backward compatibility - dynamic configuration in the same file as\n        // static configuration params see writeDynamicConfig()\n        if (dynamicConfigFileStr == null) {\n            setupQuorumPeerConfig(zkProp, true);\n            if (isDistributed()) {\n                // we don't backup static config for standalone mode.\n                backupOldConfig();\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.getPurgeInterval": "    public int getPurgeInterval() {\n        return purgeInterval;\n    }"
        },
        "bug_report": {
            "Title": "Empty path in Set crashes server and prevents restart",
            "Description": "See https://github.com/samuel/go-zookeeper/issues/62\n\nI've reproduced this on 3.4.5 with the code:\n        c, _, _ := zk.Connect([]string{\"127.0.0.1\"}, time.Second)\n        c.Set(\"\", []byte{}, 0)\n\nThis crashes a local zookeeper 3.4.5 server:\n2015-06-10 16:21:10,862 [myid:] - ERROR [SyncThread:0:SyncRequestProcessor@151] - Severe unrecoverable error, exiting  \njava.lang.IllegalArgumentException: Invalid path\n        at org.apache.zookeeper.common.PathTrie.findMaxPrefix(PathTrie.java:259)\n        at org.apache.zookeeper.server.DataTree.getMaxPrefixWithQuota(DataTree.java:634)\n        at org.apache.zookeeper.server.DataTree.setData(DataTree.java:616)\n        at org.apache.zookeeper.server.DataTree.processTxn(DataTree.java:807)\n        at org.apache.zookeeper.server.ZKDatabase.processTxn(ZKDatabase.java:329)\n        at org.apache.zookeeper.server.ZooKeeperServer.processTxn(ZooKeeperServer.java:965)\n        at org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:116)\n        at org.apache.zookeeper.server.SyncRequestProcessor.flush(SyncRequestProcessor.java:167)\n        at org.apache.zookeeper.server.SyncRequestProcessor.run(SyncRequestProcessor.java:101)\n\nOn restart the zookeeper server crashes out:\n2015-06-10 16:22:21,352 [myid:] - ERROR [main:ZooKeeperServerMain@54] - Invalid arguments, exiting abnormally\njava.lang.IllegalArgumentException: Invalid path\n        at org.apache.zookeeper.common.PathTrie.findMaxPrefix(PathTrie.java:259)\n        at org.apache.zookeeper.server.DataTree.getMaxPrefixWithQuota(DataTree.java:634)\n        at org.apache.zookeeper.server.DataTree.setData(DataTree.java:616)\n        at org.apache.zookeeper.server.DataTree.processTxn(DataTree.java:807)\n        at org.apache.zookeeper.server.persistence.FileTxnSnapLog.processTransaction(FileTxnSnapLog.java:198)\n        at org.apache.zookeeper.server.persistence.FileTxnSnapLog.restore(FileTxnSnapLog.java:151)\n        at org.apache.zookeeper.server.ZKDatabase.loadDataBase(ZKDatabase.java:223)\n        at org.apache.zookeeper.server.ZooKeeperServer.loadData(ZooKeeperServer.java:250)\n        at org.apache.zookeeper.server.ZooKeeperServer.startdata(ZooKeeperServer.java:377)\n        at org.apache.zookeeper.server.NIOServerCnxnFactory.startup(NIOServerCnxnFactory.java:122)\n        at org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ZooKeeperServerMain.java:112)\n        at org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun(ZooKeeperServerMain.java:86)\n        at org.apache.zookeeper.server.ZooKeeperServerMain.main(ZooKeeperServerMain.java:52)\n        at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(QuorumPeerMain.java:116)\n        at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain.java:78)"
        }
    },
    {
        "filename": "ZOOKEEPER-2297.json",
        "creation_time": "2015-10-19T11:38:58.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\nat org.apache.zookeeper.common.X509Util.createKeyManager(X509Util.java:129)\n\nat org.apache.zookeeper.server.auth.X509AuthenticationProvider.<init>(X509AuthenticationProvider.java:75)\n\nat org.apache.zookeeper.server.auth.ProviderRegistry.initialize(ProviderRegistry.java:42)\n\nat org.apache.zookeeper.server.auth.ProviderRegistry.getProvider(ProviderRegistry.java:68)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.fixupACL(PrepRequestProcessor.java:952)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.pRequest2Txn(PrepRequestProcessor.java:379)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.pRequest(PrepRequestProcessor.java:716)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.run(PrepRequestProcessor.java:144)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.common.X509Util.createKeyManager": "    public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword)\n            throws KeyManagerException {\n        FileInputStream inputStream = null;\n        try {\n            char[] keyStorePasswordChars = keyStorePassword.toCharArray();\n            File keyStoreFile = new File(keyStoreLocation);\n            KeyStore ks = KeyStore.getInstance(\"JKS\");\n            inputStream = new FileInputStream(keyStoreFile);\n            ks.load(inputStream, keyStorePasswordChars);\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n            kmf.init(ks, keyStorePasswordChars);\n\n            for (KeyManager km : kmf.getKeyManagers()) {\n                if (km instanceof X509KeyManager) {\n                    return (X509KeyManager) km;\n                }\n            }\n            throw new KeyManagerException(\"Couldn't find X509KeyManager\");\n\n        } catch (Exception e) {\n            throw new KeyManagerException(e);\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (IOException e) {}\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.ProviderRegistry.initialize": "    public static void initialize() {\n        synchronized (ProviderRegistry.class) {\n            if (initialized)\n                return;\n            IPAuthenticationProvider ipp = new IPAuthenticationProvider();\n            DigestAuthenticationProvider digp = new DigestAuthenticationProvider();\n            X509AuthenticationProvider x509p = new X509AuthenticationProvider();\n            authenticationProviders.put(ipp.getScheme(), ipp);\n            authenticationProviders.put(digp.getScheme(), digp);\n            authenticationProviders.put(x509p.getScheme(), x509p);\n            Enumeration<Object> en = System.getProperties().keys();\n            while (en.hasMoreElements()) {\n                String k = (String) en.nextElement();\n                if (k.startsWith(\"zookeeper.authProvider.\")) {\n                    String className = System.getProperty(k);\n                    try {\n                        Class<?> c = ZooKeeperServer.class.getClassLoader()\n                                .loadClass(className);\n                        AuthenticationProvider ap = (AuthenticationProvider) c\n                                .newInstance();\n                        authenticationProviders.put(ap.getScheme(), ap);\n                    } catch (Exception e) {\n                        LOG.warn(\"Problems loading \" + className,e);\n                    }\n                }\n            }\n            initialized = true;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.ProviderRegistry.getProvider": "    public static AuthenticationProvider getProvider(String scheme) {\n        if(!initialized)\n            initialize();\n        return authenticationProviders.get(scheme);\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.fixupACL": "    private List<ACL> fixupACL(String path, List<Id> authInfo, List<ACL> acls)\n        throws KeeperException.InvalidACLException {\n        // check for well formed ACLs\n        // This resolves https://issues.apache.org/jira/browse/ZOOKEEPER-1877\n        List<ACL> uniqacls = removeDuplicates(acls);\n        LinkedList<ACL> rv = new LinkedList<ACL>();\n        if (uniqacls == null || uniqacls.size() == 0) {\n            throw new KeeperException.InvalidACLException(path);\n        }\n        for (ACL a: uniqacls) {\n            LOG.debug(\"Processing ACL: {}\", a);\n            if (a == null) {\n                throw new KeeperException.InvalidACLException(path);\n            }\n            Id id = a.getId();\n            if (id == null || id.getScheme() == null) {\n                throw new KeeperException.InvalidACLException(path);\n            }\n            if (id.getScheme().equals(\"world\") && id.getId().equals(\"anyone\")) {\n                rv.add(a);\n            } else if (id.getScheme().equals(\"auth\")) {\n                // This is the \"auth\" id, so we have to expand it to the\n                // authenticated ids of the requestor\n                boolean authIdValid = false;\n                for (Id cid : authInfo) {\n                    AuthenticationProvider ap =\n                        ProviderRegistry.getProvider(cid.getScheme());\n                    if (ap == null) {\n                        LOG.error(\"Missing AuthenticationProvider for \"\n                            + cid.getScheme());\n                    } else if (ap.isAuthenticated()) {\n                        authIdValid = true;\n                        rv.add(new ACL(a.getPerms(), cid));\n                    }\n                }\n                if (!authIdValid) {\n                    throw new KeeperException.InvalidACLException(path);\n                }\n            } else {\n                AuthenticationProvider ap = ProviderRegistry.getProvider(id.getScheme());\n                if (ap == null || !ap.isValid(id.getId())) {\n                    throw new KeeperException.InvalidACLException(path);\n                }\n                rv.add(a);\n            }\n        }\n        return rv;\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.removeDuplicates": "    private List<ACL> removeDuplicates(List<ACL> acl) {\n\n        ArrayList<ACL> retval = new ArrayList<ACL>();\n        Iterator<ACL> it = acl.iterator();\n        while (it.hasNext()) {\n            ACL a = it.next();\n            if (retval.contains(a) == false) {\n                retval.add(a);\n            }\n        }\n        return retval;\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.pRequest2Txn": "    protected void pRequest2Txn(int type, long zxid, Request request,\n                                Record record, boolean deserialize)\n        throws KeeperException, IOException, RequestProcessorException\n    {\n        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,\n                Time.currentWallTime(), type));\n\n        switch (type) {\n            case OpCode.create:\n            case OpCode.create2:\n            case OpCode.createContainer: {\n                CreateRequest createRequest = (CreateRequest)record;\n                if (deserialize) {\n                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);\n                }\n                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n                validateCreateRequest(createMode, request);\n                String path = createRequest.getPath();\n                String parentPath = validatePathForCreate(path, request.sessionId);\n\n                List<ACL> listACL = fixupACL(path, request.authInfo, createRequest.getAcl());\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n\n                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);\n                int parentCVersion = parentRecord.stat.getCversion();\n                if (createMode.isSequential()) {\n                    path = path + String.format(Locale.ENGLISH, \"%010d\", parentCVersion);\n                }\n                validatePath(path, request.sessionId);\n                try {\n                    if (getRecordForPath(path) != null) {\n                        throw new KeeperException.NodeExistsException(path);\n                    }\n                } catch (KeeperException.NoNodeException e) {\n                    // ignore this one\n                }\n                boolean ephemeralParent = (parentRecord.stat.getEphemeralOwner() != 0) &&\n                        (parentRecord.stat.getEphemeralOwner() != DataTree.CONTAINER_EPHEMERAL_OWNER);\n                if (ephemeralParent) {\n                    throw new KeeperException.NoChildrenForEphemeralsException(path);\n                }\n                int newCversion = parentRecord.stat.getCversion()+1;\n                if (type == OpCode.createContainer) {\n                    request.setTxn(new CreateContainerTxn(path, createRequest.getData(), listACL, newCversion));\n                } else {\n                    request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),\n                            newCversion));\n                }\n                StatPersisted s = new StatPersisted();\n                if (createMode.isEphemeral()) {\n                    s.setEphemeralOwner(request.sessionId);\n                }\n                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n                parentRecord.childCount++;\n                parentRecord.stat.setCversion(newCversion);\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));\n                break;\n            }\n            case OpCode.deleteContainer: {\n                String path = new String(request.request.array());\n                String parentPath = getParentPathAndValidate(path);\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n                ChangeRecord nodeRecord = getRecordForPath(path);\n                if (nodeRecord.childCount > 0) {\n                    throw new KeeperException.NotEmptyException(path);\n                }\n                if (nodeRecord.stat.getEphemeralOwner() != DataTree.CONTAINER_EPHEMERAL_OWNER) {\n                    throw new KeeperException.BadVersionException(path);\n                }\n                request.setTxn(new DeleteTxn(path));\n                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n                parentRecord.childCount--;\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));\n                break;\n            }\n            case OpCode.delete:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                DeleteRequest deleteRequest = (DeleteRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);\n                String path = deleteRequest.getPath();\n                String parentPath = getParentPathAndValidate(path);\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n                ChangeRecord nodeRecord = getRecordForPath(path);\n                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo);\n                checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);\n                if (nodeRecord.childCount > 0) {\n                    throw new KeeperException.NotEmptyException(path);\n                }\n                request.setTxn(new DeleteTxn(path));\n                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n                parentRecord.childCount--;\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));\n                break;\n            case OpCode.setData:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                SetDataRequest setDataRequest = (SetDataRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);\n                path = setDataRequest.getPath();\n                validatePath(path, request.sessionId);\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);\n                int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);\n                request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));\n                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n                nodeRecord.stat.setVersion(newVersion);\n                addChangeRecord(nodeRecord);\n                break;\n            case OpCode.reconfig:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                ReconfigRequest reconfigRequest = (ReconfigRequest)record; \n                LeaderZooKeeperServer lzks;\n                try {\n                    lzks = (LeaderZooKeeperServer)zks;\n                } catch (ClassCastException e) {\n                    // standalone mode - reconfiguration currently not supported\n                    throw new KeeperException.UnimplementedException();\n                }\n                QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                                                                                 \n                // check that there's no reconfig in progress\n                if (lastSeenQV.getVersion()!=lzks.self.getQuorumVerifier().getVersion()) {\n                       throw new KeeperException.ReconfigInProgress(); \n                }\n                long configId = reconfigRequest.getCurConfigId();\n  \n                if (configId != -1 && configId!=lzks.self.getLastSeenQuorumVerifier().getVersion()){\n                   String msg = \"Reconfiguration from version \" + configId + \" failed -- last seen version is \" + lzks.self.getLastSeenQuorumVerifier().getVersion();\n                   throw new KeeperException.BadVersionException(msg);\n                }\n\n                String newMembers = reconfigRequest.getNewMembers();\n                \n                if (newMembers != null) { //non-incremental membership change                  \n                   LOG.info(\"Non-incremental reconfig\");\n                \n                   // Input may be delimited by either commas or newlines so convert to common newline separated format\n                   newMembers = newMembers.replaceAll(\",\", \"\\n\");\n                   \n                   try{\n                       Properties props = new Properties();                        \n                       props.load(new StringReader(newMembers));\n                       request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);\n                       request.qv.setVersion(request.getHdr().getZxid());\n                   } catch (IOException e) {\n                       throw new KeeperException.BadArgumentsException(e.getMessage());\n                   } catch (ConfigException e) {\n                       throw new KeeperException.BadArgumentsException(e.getMessage());\n                   }                   \n                } else { //incremental change - must be a majority quorum system   \n                   LOG.info(\"Incremental reconfig\");\n                   \n                   List<String> joiningServers = null; \n                   String joiningServersString = reconfigRequest.getJoiningServers();\n                   if (joiningServersString != null)\n                   {\n                       joiningServers = StringUtils.split(joiningServersString,\",\");\n                   }\n                   \n                   List<String> leavingServers = null;\n                   String leavingServersString = reconfigRequest.getLeavingServers();\n                   if (leavingServersString != null)\n                   {\n                       leavingServers = StringUtils.split(leavingServersString, \",\");\n                   }\n                   \n                   if (!(lastSeenQV instanceof QuorumMaj)) {\n                           String msg = \"Incremental reconfiguration requested but last configuration seen has a non-majority quorum system\";\n                           LOG.warn(msg);\n                           throw new KeeperException.BadArgumentsException(msg);               \n                   }\n                   Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());\n                   try {                           \n                       if (leavingServers != null) {\n                           for (String leaving: leavingServers){\n                               long sid = Long.parseLong(leaving);\n                               nextServers.remove(sid);\n                           } \n                       }\n                       if (joiningServers != null) {\n                           for (String joiner: joiningServers){\n                        \t   // joiner should have the following format: server.x = server_spec;client_spec               \n                        \t   String[] parts = StringUtils.split(joiner, \"=\").toArray(new String[0]);\n                               if (parts.length != 2) {\n                                   throw new KeeperException.BadArgumentsException(\"Wrong format of server string\");\n                               }\n                               // extract server id x from first part of joiner: server.x\n                               Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));\n                               QuorumServer qs = new QuorumServer(sid, parts[1]);\n                               if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {\n                                   throw new KeeperException.BadArgumentsException(\"Wrong format of server string - each server should have 3 ports specified\"); \t   \n                               }\n\n                               // check duplication of addresses and ports\n                               for (QuorumServer nqs: nextServers.values()) {\n                                   if (qs.id == nqs.id) {\n                                       continue;\n                                   }\n                                   qs.checkAddressDuplicate(nqs);\n                               }\n\n                               nextServers.remove(qs.id);\n                               nextServers.put(Long.valueOf(qs.id), qs);\n                           }  \n                       }\n                   } catch (ConfigException e){\n                       throw new KeeperException.BadArgumentsException(\"Reconfiguration failed\");\n                   }\n                   request.qv = new QuorumMaj(nextServers);\n                   request.qv.setVersion(request.getHdr().getZxid());\n                }\n                if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {\n                   String msg = \"Reconfig failed - new configuration must include at least 2 followers\";\n                   LOG.warn(msg);\n                   throw new KeeperException.BadArgumentsException(msg);\n                } else if (request.qv.getVotingMembers().size() < 1) {\n                   String msg = \"Reconfig failed - new configuration must include at least 1 follower\";\n                   LOG.warn(msg);\n                   throw new KeeperException.BadArgumentsException(msg);\n                }                           \n                   \n                if (!lzks.getLeader().isQuorumSynced(request.qv)) {\n                   String msg2 = \"Reconfig failed - there must be a connected and synced quorum in new configuration\";\n                   LOG.warn(msg2);             \n                   throw new KeeperException.NewConfigNoQuorum();\n                }\n                \n                nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);               \n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);                  \n                request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));    \n                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n                nodeRecord.stat.setVersion(-1);                \n                addChangeRecord(nodeRecord);\n                break;                         \n            case OpCode.setACL:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                SetACLRequest setAclRequest = (SetACLRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);\n                path = setAclRequest.getPath();\n                validatePath(path, request.sessionId);\n                List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);\n                newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);\n                request.setTxn(new SetACLTxn(path, listACL, newVersion));\n                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n                nodeRecord.stat.setAversion(newVersion);\n                addChangeRecord(nodeRecord);\n                break;\n            case OpCode.createSession:\n                request.request.rewind();\n                int to = request.request.getInt();\n                request.setTxn(new CreateSessionTxn(to));\n                request.request.rewind();\n                if (request.isLocalSession()) {\n                    // This will add to local session tracker if it is enabled\n                    zks.sessionTracker.addSession(request.sessionId, to);\n                } else {\n                    // Explicitly add to global session if the flag is not set\n                    zks.sessionTracker.addGlobalSession(request.sessionId, to);\n                }\n                zks.setOwner(request.sessionId, request.getOwner());\n                break;\n            case OpCode.closeSession:\n                // We don't want to do this check since the session expiration thread\n                // queues up this operation without being the session owner.\n                // this request is the last of the session so it should be ok\n                //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                Set<String> es = zks.getZKDatabase()\n                        .getEphemerals(request.sessionId);\n                synchronized (zks.outstandingChanges) {\n                    for (ChangeRecord c : zks.outstandingChanges) {\n                        if (c.stat == null) {\n                            // Doing a delete\n                            es.remove(c.path);\n                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {\n                            es.add(c.path);\n                        }\n                    }\n                    for (String path2Delete : es) {\n                        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));\n                    }\n\n                    zks.sessionTracker.setSessionClosing(request.sessionId);\n                }\n\n                LOG.info(\"Processed session termination for sessionid: 0x\"\n                        + Long.toHexString(request.sessionId));\n                break;\n            case OpCode.check:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                CheckVersionRequest checkVersionRequest = (CheckVersionRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);\n                path = checkVersionRequest.getPath();\n                validatePath(path, request.sessionId);\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo);\n                request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(),\n                        checkVersionRequest.getVersion(), path)));\n                break;\n            default:\n                LOG.warn(\"unknown type \" + type);\n                break;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.checkAndIncVersion": "    private static int checkAndIncVersion(int currentVersion, int expectedVersion, String path)\n            throws KeeperException.BadVersionException {\n        if (expectedVersion != -1 && expectedVersion != currentVersion) {\n            throw new KeeperException.BadVersionException(path);\n        }\n        return currentVersion + 1;\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.validateCreateRequest": "    private void validateCreateRequest(CreateMode createMode, Request request)\n            throws KeeperException {\n        if (createMode.isEphemeral()) {\n            // Exception is set when local session failed to upgrade\n            // so we just need to report the error\n            if (request.getException() != null) {\n                throw request.getException();\n            }\n            zks.sessionTracker.checkGlobalSession(request.sessionId,\n                    request.getOwner());\n        } else {\n            zks.sessionTracker.checkSession(request.sessionId,\n                    request.getOwner());\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.getParentPathAndValidate": "    private String getParentPathAndValidate(String path)\n            throws BadArgumentsException {\n        int lastSlash = path.lastIndexOf('/');\n        if (lastSlash == -1 || path.indexOf('\\0') != -1\n                || zks.getZKDatabase().isSpecialPath(path)) {\n            throw new BadArgumentsException(path);\n        }\n        return path.substring(0, lastSlash);\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.getRecordForPath": "    private ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException {\n        ChangeRecord lastChange = null;\n        synchronized (zks.outstandingChanges) {\n            lastChange = zks.outstandingChangesForPath.get(path);\n            if (lastChange == null) {\n                DataNode n = zks.getZKDatabase().getNode(path);\n                if (n != null) {\n                    Long acl;\n                    Set<String> children;\n                    synchronized(n) {\n                        acl = n.acl;\n                        children = n.getChildren();\n                    }\n                    lastChange = new ChangeRecord(-1, path, n.stat,\n                        children != null ? children.size() : 0,\n                            zks.getZKDatabase().convertLong(acl));\n                }\n            }\n        }\n        if (lastChange == null || lastChange.stat == null) {\n            throw new KeeperException.NoNodeException(path);\n        }\n        return lastChange;\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.checkACL": "    static void checkACL(ZooKeeperServer zks, List<ACL> acl, int perm,\n            List<Id> ids) throws KeeperException.NoAuthException {\n        if (skipACL) {\n            return;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Permission requested: {} \", perm);\n            LOG.debug(\"ACLs for node: {}\", acl);\n            LOG.debug(\"Client credentials: {}\", ids);\n        }\n        if (acl == null || acl.size() == 0) {\n            return;\n        }\n        for (Id authId : ids) {\n            if (authId.getScheme().equals(\"super\")) {\n                return;\n            }\n        }\n        for (ACL a : acl) {\n            Id id = a.getId();\n            if ((a.getPerms() & perm) != 0) {\n                if (id.getScheme().equals(\"world\")\n                        && id.getId().equals(\"anyone\")) {\n                    return;\n                }\n                AuthenticationProvider ap = ProviderRegistry.getProvider(id\n                        .getScheme());\n                if (ap != null) {\n                    for (Id authId : ids) {\n                        if (authId.getScheme().equals(id.getScheme())\n                                && ap.matches(authId.getId(), id.getId())) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        throw new KeeperException.NoAuthException();\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.validatePath": "    private void validatePath(String path, long sessionId) throws BadArgumentsException {\n        try {\n            PathUtils.validatePath(path);\n        } catch(IllegalArgumentException ie) {\n            LOG.info(\"Invalid path {} with session 0x{}, reason: {}\",\n                    path, Long.toHexString(sessionId), ie.getMessage());\n            throw new BadArgumentsException(path);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.addChangeRecord": "    private void addChangeRecord(ChangeRecord c) {\n        synchronized (zks.outstandingChanges) {\n            zks.outstandingChanges.add(c);\n            zks.outstandingChangesForPath.put(c.path, c);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.validatePathForCreate": "    private String validatePathForCreate(String path, long sessionId)\n            throws BadArgumentsException {\n        int lastSlash = path.lastIndexOf('/');\n        if (lastSlash == -1 || path.indexOf('\\0') != -1 || failCreate) {\n            LOG.info(\"Invalid path %s with session 0x%s\",\n                    path, Long.toHexString(sessionId));\n            throw new KeeperException.BadArgumentsException(path);\n        }\n        return path.substring(0, lastSlash);\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.pRequest": "    protected void pRequest(Request request) throws RequestProcessorException {\n        // LOG.info(\"Prep>>> cxid = \" + request.cxid + \" type = \" +\n        // request.type + \" id = 0x\" + Long.toHexString(request.sessionId));\n        request.setHdr(null);\n        request.setTxn(null);\n\n        try {\n            switch (request.type) {\n            case OpCode.createContainer:\n            case OpCode.create:\n            case OpCode.create2:\n                CreateRequest create2Request = new CreateRequest();\n                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);\n                break;\n            case OpCode.deleteContainer:\n            case OpCode.delete:\n                DeleteRequest deleteRequest = new DeleteRequest();\n                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);\n                break;\n            case OpCode.setData:\n                SetDataRequest setDataRequest = new SetDataRequest();                \n                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);\n                break;\n            case OpCode.reconfig:\n                ReconfigRequest reconfigRequest = new ReconfigRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);\n                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);\n                break;\n            case OpCode.setACL:\n                SetACLRequest setAclRequest = new SetACLRequest();                \n                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);\n                break;\n            case OpCode.check:\n                CheckVersionRequest checkRequest = new CheckVersionRequest();              \n                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);\n                break;\n            case OpCode.multi:\n                MultiTransactionRecord multiRequest = new MultiTransactionRecord();\n                try {\n                    ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);\n                } catch(IOException e) {\n                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(),\n                            Time.currentWallTime(), OpCode.multi));\n                    throw e;\n                }\n                List<Txn> txns = new ArrayList<Txn>();\n                //Each op in a multi-op must have the same zxid!\n                long zxid = zks.getNextZxid();\n                KeeperException ke = null;\n\n                //Store off current pending change records in case we need to rollback\n                Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);\n\n                for(Op op: multiRequest) {\n                    Record subrequest = op.toRequestRecord();\n                    int type;\n                    Record txn;\n\n                    /* If we've already failed one of the ops, don't bother\n                     * trying the rest as we know it's going to fail and it\n                     * would be confusing in the logfiles.\n                     */\n                    if (ke != null) {\n                        type = OpCode.error;\n                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());\n                    }\n\n                    /* Prep the request and convert to a Txn */\n                    else {\n                        try {\n                            pRequest2Txn(op.getType(), zxid, request, subrequest, false);\n                            type = request.getHdr().getType();\n                            txn = request.getTxn();\n                        } catch (KeeperException e) {\n                            ke = e;\n                            type = OpCode.error;\n                            txn = new ErrorTxn(e.code().intValue());\n\n                            LOG.info(\"Got user-level KeeperException when processing \"\n                                    + request.toString() + \" aborting remaining multi ops.\"\n                                    + \" Error Path:\" + e.getPath()\n                                    + \" Error:\" + e.getMessage());\n\n                            request.setException(e);\n\n                            /* Rollback change records from failed multi-op */\n                            rollbackPendingChanges(zxid, pendingChanges);\n                        }\n                    }\n\n                    //FIXME: I don't want to have to serialize it here and then\n                    //       immediately deserialize in next processor. But I'm\n                    //       not sure how else to get the txn stored into our list.\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n                    txn.serialize(boa, \"request\") ;\n                    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n\n                    txns.add(new Txn(type, bb.array()));\n                }\n\n                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,\n                        Time.currentWallTime(), request.type));\n                request.setTxn(new MultiTxn(txns));\n\n                break;\n\n            //create/close session don't require request record\n            case OpCode.createSession:\n            case OpCode.closeSession:\n                if (!request.isLocalSession()) {\n                    pRequest2Txn(request.type, zks.getNextZxid(), request,\n                                 null, true);\n                }\n                break;\n\n            //All the rest don't need to create a Txn - just verify session\n            case OpCode.sync:\n            case OpCode.exists:\n            case OpCode.getData:\n            case OpCode.getACL:\n            case OpCode.getChildren:\n            case OpCode.getChildren2:\n            case OpCode.ping:\n            case OpCode.setWatches:\n            case OpCode.checkWatches:\n            case OpCode.removeWatches:\n                zks.sessionTracker.checkSession(request.sessionId,\n                        request.getOwner());\n                break;\n            default:\n                LOG.warn(\"unknown type \" + request.type);\n                break;\n            }\n        } catch (KeeperException e) {\n            if (request.getHdr() != null) {\n                request.getHdr().setType(OpCode.error);\n                request.setTxn(new ErrorTxn(e.code().intValue()));\n            }\n            LOG.info(\"Got user-level KeeperException when processing \"\n                    + request.toString()\n                    + \" Error Path:\" + e.getPath()\n                    + \" Error:\" + e.getMessage());\n            request.setException(e);\n        } catch (Exception e) {\n            // log at error level as we are returning a marshalling\n            // error to the user\n            LOG.error(\"Failed to process \" + request, e);\n\n            StringBuilder sb = new StringBuilder();\n            ByteBuffer bb = request.request;\n            if(bb != null){\n                bb.rewind();\n                while (bb.hasRemaining()) {\n                    sb.append(Integer.toHexString(bb.get() & 0xff));\n                }\n            } else {\n                sb.append(\"request buffer is null\");\n            }\n\n            LOG.error(\"Dumping request buffer: 0x\" + sb.toString());\n            if (request.getHdr() != null) {\n                request.getHdr().setType(OpCode.error);\n                request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));\n            }\n        }\n        request.zxid = zks.getZxid();\n        nextProcessor.processRequest(request);\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.rollbackPendingChanges": "    void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRecords) {\n        synchronized (zks.outstandingChanges) {\n            // Grab a list iterator starting at the END of the list so we can iterate in reverse\n            ListIterator<ChangeRecord> iter = zks.outstandingChanges.listIterator(zks.outstandingChanges.size());\n            while (iter.hasPrevious()) {\n                ChangeRecord c = iter.previous();\n                if (c.zxid == zxid) {\n                    iter.remove();\n                    // Remove all outstanding changes for paths of this multi.\n                    // Previous records will be added back later.\n                    zks.outstandingChangesForPath.remove(c.path);\n                } else {\n                    break;\n                }\n            }\n\n            // we don't need to roll back any records because there is nothing left.\n            if (zks.outstandingChanges.isEmpty()) {\n                return;\n            }\n\n            long firstZxid = zks.outstandingChanges.get(0).zxid;\n\n            for (ChangeRecord c : pendingChangeRecords.values()) {\n                // Don't apply any prior change records less than firstZxid.\n                // Note that previous outstanding requests might have been removed\n                // once they are completed.\n                if (c.zxid < firstZxid) {\n                    continue;\n                }\n\n                // add previously existing records back.\n                zks.outstandingChangesForPath.put(c.path, c);\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.getPendingChanges": "    private Map<String, ChangeRecord> getPendingChanges(MultiTransactionRecord multiRequest) {\n        HashMap<String, ChangeRecord> pendingChangeRecords = new HashMap<String, ChangeRecord>();\n\n        for (Op op : multiRequest) {\n            String path = op.getPath();\n            ChangeRecord cr = getOutstandingChange(path);\n            // only previously existing records need to be rolled back.\n            if (cr != null) {\n                pendingChangeRecords.put(path, cr);\n            }\n\n            /*\n             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord\n             * of the parent node of a request. So that if this is a\n             * sequential node creation request, rollbackPendingChanges()\n             * can restore previous parent's ChangeRecord correctly.\n             *\n             * Otherwise, sequential node name generation will be incorrect\n             * for a subsequent request.\n             */\n            int lastSlash = path.lastIndexOf('/');\n            if (lastSlash == -1 || path.indexOf('\\0') != -1) {\n                continue;\n            }\n            String parentPath = path.substring(0, lastSlash);\n            ChangeRecord parentCr = getOutstandingChange(parentPath);\n            if (parentCr != null) {\n                pendingChangeRecords.put(parentPath, parentCr);\n            }\n        }\n\n        return pendingChangeRecords;\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.processRequest": "    public void processRequest(Request request) {\n        submittedRequests.add(request);\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.run": "    public void run() {\n        try {\n            while (true) {\n                Request request = submittedRequests.take();\n                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n                if (request.type == OpCode.ping) {\n                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;\n                }\n                if (LOG.isTraceEnabled()) {\n                    ZooTrace.logRequest(LOG, traceMask, 'P', request, \"\");\n                }\n                if (Request.requestOfDeath == request) {\n                    break;\n                }\n                pRequest(request);\n            }\n        } catch (RequestProcessorException e) {\n            if (e.getCause() instanceof XidRolloverException) {\n                LOG.info(e.getCause().getMessage());\n            }\n            handleException(this.getName(), e);\n        } catch (Exception e) {\n            handleException(this.getName(), e);\n        }\n        LOG.info(\"PrepRequestProcessor exited loop!\");\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.X509AuthenticationProvider.getScheme": "    public String getScheme() {\n        return \"x509\";\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.DigestAuthenticationProvider.getScheme": "    public String getScheme() {\n        return \"digest\";\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.AuthenticationProvider.getScheme": "    String getScheme();\n\n    /**\n     * This method is called when a client passes authentication data for this\n     * scheme. The authData is directly from the authentication packet. The\n     * implementor may attach new ids to the authInfo field of cnxn or may use\n     * cnxn to send packets back to the client.\n     * \n     * @param cnxn\n     *                the cnxn that received the authentication information.\n     * @param authData\n     *                the authentication data received.\n     * @return TODO\n     */\n    KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte authData[]);\n\n    /**\n     * This method is called to see if the given id matches the given id\n     * expression in the ACL. This allows schemes to use application specific\n     * wild cards.\n     * \n     * @param id\n     *                the id to check.\n     * @param aclExpr\n     *                the expression to match ids against.\n     * @return true if the id can be matched by the expression.\n     */\n    boolean matches(String id, String aclExpr);\n\n    /**\n     * This method is used to check if the authentication done by this provider\n     * should be used to identify the creator of a node. Some ids such as hosts\n     * and ip addresses are rather transient and in general don't really\n     * identify a client even though sometimes they do.\n     * \n     * @return true if this provider identifies creators.\n     */\n    boolean isAuthenticated();\n\n    /**\n     * Validates the syntax of an id.\n     * \n     * @param id\n     *                the id to validate.\n     * @return true if id is well formed.\n     */\n    boolean isValid(String id);\n}",
            "src.java.main.org.apache.zookeeper.server.auth.IPAuthenticationProvider.getScheme": "    public String getScheme() {\n        return \"ip\";\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.setTxn": "    public void setTxn(Record txn) {\n        this.txn = txn;\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.getHdr": "    public TxnHeader getHdr() {\n        return hdr;\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.getOwner": "    public Object getOwner() {\n        return owner;\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.setHdr": "    public void setHdr(TxnHeader hdr) {\n        this.hdr = hdr;\n    }",
            "src.java.main.org.apache.zookeeper.server.ByteBufferInputStream.byteBuffer2Record": "    static public void byteBuffer2Record(ByteBuffer bb, Record record)\n            throws IOException {\n        BinaryInputArchive ia;\n        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n        record.deserialize(ia, \"request\");\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.isLocalSession": "    public boolean isLocalSession() {\n        return isLocalSession;\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.setException": "    public void setException(KeeperException e) {\n        this.e = e;\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.toString": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"sessionid:0x\").append(Long.toHexString(sessionId))\n            .append(\" type:\").append(op2String(type))\n            .append(\" cxid:0x\").append(Long.toHexString(cxid))\n            .append(\" zxid:0x\").append(Long.toHexString(hdr == null ?\n                    -2 : hdr.getZxid()))\n            .append(\" txntype:\").append(hdr == null ?\n                    \"unknown\" : \"\" + hdr.getType());\n\n        // best effort to print the path assoc with this request\n        String path = \"n/a\";\n        if (type != OpCode.createSession\n                && type != OpCode.setWatches\n                && type != OpCode.closeSession\n                && request != null\n                && request.remaining() >= 4)\n        {\n            try {\n                // make sure we don't mess with request itself\n                ByteBuffer rbuf = request.asReadOnlyBuffer();\n                rbuf.clear();\n                int pathLen = rbuf.getInt();\n                // sanity check\n                if (pathLen >= 0\n                        && pathLen < 4096\n                        && rbuf.remaining() >= pathLen)\n                {\n                    byte b[] = new byte[pathLen];\n                    rbuf.get(b);\n                    path = new String(b);\n                }\n            } catch (Exception e) {\n                // ignore - can't find the path, will output \"n/a\" instead\n            }\n        }\n        sb.append(\" reqpath:\").append(path);\n\n        return sb.toString();\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.op2String": "    static String op2String(int op) {\n        switch (op) {\n        case OpCode.notification:\n            return \"notification\";\n        case OpCode.create:\n            return \"create\";\n        case OpCode.create2:\n            return \"create2\";\n        case OpCode.createContainer:\n            return \"createContainer\";\n        case OpCode.setWatches:\n            return \"setWatches\";\n        case OpCode.delete:\n            return \"delete\";\n        case OpCode.deleteContainer:\n            return \"deleteContainer\";\n        case OpCode.exists:\n            return \"exists\";\n        case OpCode.getData:\n            return \"getData\";\n        case OpCode.check:\n            return \"check\";\n        case OpCode.multi:\n            return \"multi\";\n        case OpCode.setData:\n            return \"setData\";\n        case OpCode.sync:\n              return \"sync:\";\n        case OpCode.getACL:\n            return \"getACL\";\n        case OpCode.setACL:\n            return \"setACL\";\n        case OpCode.getChildren:\n            return \"getChildren\";\n        case OpCode.getChildren2:\n            return \"getChildren2\";\n        case OpCode.ping:\n            return \"ping\";\n        case OpCode.createSession:\n            return \"createSession\";\n        case OpCode.closeSession:\n            return \"closeSession\";\n        case OpCode.error:\n            return \"error\";\n        case OpCode.reconfig:\n           return \"reconfig\";\n        case OpCode.checkWatches:\n            return \"checkWatches\";\n        case OpCode.removeWatches:\n            return \"removeWatches\";\n        default:\n            return \"unknown \" + op;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.Request.getTxn": "    public Record getTxn() {\n        return txn;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.logRequest": "    static public void logRequest(Logger log, long mask,\n            char rp, Request request, String header)\n    {\n        if (isTraceEnabled(log, mask)) {\n            log.trace(header + \":\" + rp + request.toString());\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.isTraceEnabled": "    public static synchronized boolean isTraceEnabled(Logger log, long mask) {\n        return log.isTraceEnabled() && (mask & traceMask) != 0;\n    }"
        },
        "bug_report": {
            "Title": "NPE is thrown while creating \"key manager\" and \"trust manager\" ",
            "Description": "NPE is thrown while creating \"key manager\" and \"trust manager\" , even though the zk setup is in non-secure mode\n\nbq. 2015-10-19 12:54:12,278 [myid:2] - ERROR [ProcessThread(sid:2 cport:-1)::X509AuthenticationProvider@78] - Failed to create key manager\n\nbq. org.apache.zookeeper.common.X509Exception$KeyManagerException: java.lang.NullPointerException\n\nat org.apache.zookeeper.common.X509Util.createKeyManager(X509Util.java:129)\n\nat org.apache.zookeeper.server.auth.X509AuthenticationProvider.<init>(X509AuthenticationProvider.java:75)\n\nat org.apache.zookeeper.server.auth.ProviderRegistry.initialize(ProviderRegistry.java:42)\n\nat org.apache.zookeeper.server.auth.ProviderRegistry.getProvider(ProviderRegistry.java:68)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.fixupACL(PrepRequestProcessor.java:952)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.pRequest2Txn(PrepRequestProcessor.java:379)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.pRequest(PrepRequestProcessor.java:716)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.run(PrepRequestProcessor.java:144)\n\nCaused by: java.lang.NullPointerException\n\nat org.apache.zookeeper.common.X509Util.createKeyManager(X509Util.java:113)\n\n... 7 more\n\nbq. 2015-10-19 12:54:12,279 [myid:2] - ERROR [ProcessThread(sid:2 cport:-1)::X509AuthenticationProvider@90] - Failed to create trust manager\n\nbq.  org.apache.zookeeper.common.X509Exception$TrustManagerException: java.lang.NullPointerException\n\nat org.apache.zookeeper.common.X509Util.createTrustManager(X509Util.java:158)\n\nat org.apache.zookeeper.server.auth.X509AuthenticationProvider.<init>(X509AuthenticationProvider.java:87)\n\nat org.apache.zookeeper.server.auth.ProviderRegistry.initialize(ProviderRegistry.java:42)\n\nat org.apache.zookeeper.server.auth.ProviderRegistry.getProvider(ProviderRegistry.java:68)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.fixupACL(PrepRequestProcessor.java:952)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.pRequest2Txn(PrepRequestProcessor.java:379)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.pRequest(PrepRequestProcessor.java:716)\n\nat org.apache.zookeeper.server.PrepRequestProcessor.run(PrepRequestProcessor.java:144)\n\nCaused by: java.lang.NullPointerException\n\nat org.apache.zookeeper.common.X509Util.createTrustManager(X509Util.java:143)\n\n... 7 more\n\n"
        }
    },
    {
        "filename": "ZOOKEEPER-1264.json",
        "creation_time": "2011-10-28T04:23:28.000+0000",
        "stack_trace": "junit.framework.AssertionFailedError: Should have same number of\nephemerals in both followers expected:<11741> but was:<14001>\n       at org.apache.zookeeper.test.FollowerResyncConcurrencyTest.verifyState(FollowerResyncConcurrencyTest.java:400)\n       at org.apache.zookeeper.test.FollowerResyncConcurrencyTest.testResyncBySnapThenDiffAfterFollowerCrashes(FollowerResyncConcurrencyTest.java:196)\n       at org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52)",
        "source_code": {},
        "bug_report": {
            "Title": "FollowerResyncConcurrencyTest failing intermittently",
            "Description": "The FollowerResyncConcurrencyTest test is failing intermittently. \n\nsaw the following on 3.4:\n{noformat}\njunit.framework.AssertionFailedError: Should have same number of\nephemerals in both followers expected:<11741> but was:<14001>\n       at org.apache.zookeeper.test.FollowerResyncConcurrencyTest.verifyState(FollowerResyncConcurrencyTest.java:400)\n       at org.apache.zookeeper.test.FollowerResyncConcurrencyTest.testResyncBySnapThenDiffAfterFollowerCrashes(FollowerResyncConcurrencyTest.java:196)\n       at org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52)\n{noformat}\n"
        }
    },
    {
        "filename": "ZOOKEEPER-2808.json",
        "creation_time": "2017-06-15T17:46:22.000+0000",
        "stack_trace": "java.lang.RuntimeException: Failed to fetch acls for 1\n        at org.apache.zookeeper.server.DataTree.convertLong(DataTree.java:250)\n        at org.apache.zookeeper.server.DataTree.getACL(DataTree.java:799)\n        at org.apache.zookeeper.server.ZKDatabase.getACL(ZKDatabase.java:574)\n        at org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:463)\n        at org.apache.zookeeper.server.quorum.CommitProcessor$CommitWorkRequest.doWork(CommitProcessor.java:439)\n        at org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:151)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.server.DataTree.getACL": "    public List<ACL> getACL(DataNode node) {\n        synchronized (node) {\n            return aclCache.convertLong(node.acl);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.DataTree.copyStat": "    static public void copyStat(Stat from, Stat to) {\n        to.setAversion(from.getAversion());\n        to.setCtime(from.getCtime());\n        to.setCversion(from.getCversion());\n        to.setCzxid(from.getCzxid());\n        to.setMtime(from.getMtime());\n        to.setMzxid(from.getMzxid());\n        to.setPzxid(from.getPzxid());\n        to.setVersion(from.getVersion());\n        to.setEphemeralOwner(from.getEphemeralOwner());\n        to.setDataLength(from.getDataLength());\n        to.setNumChildren(from.getNumChildren());\n    }",
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.getACL": "    public List<ACL> getACL(String path, Stat stat) throws NoNodeException {\n        return dataTree.getACL(path, stat);\n    }",
            "src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.processRequest": "    public void processRequest(Request request) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request:: \" + request);\n        }\n        // request.addRQRec(\">final\");\n        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n        if (request.type == OpCode.ping) {\n            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n        }\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logRequest(LOG, traceMask, 'E', request, \"\");\n        }\n        ProcessTxnResult rc = null;\n        synchronized (zks.outstandingChanges) {\n            // Need to process local session requests\n            rc = zks.processTxn(request);\n\n            // request.hdr is set for write requests, which are the only ones\n            // that add to outstandingChanges.\n            if (request.getHdr() != null) {\n                TxnHeader hdr = request.getHdr();\n                Record txn = request.getTxn();\n                long zxid = hdr.getZxid();\n                while (!zks.outstandingChanges.isEmpty()\n                       && zks.outstandingChanges.get(0).zxid <= zxid) {\n                    ChangeRecord cr = zks.outstandingChanges.remove(0);\n                    if (cr.zxid < zxid) {\n                        LOG.warn(\"Zxid outstanding \" + cr.zxid\n                                 + \" is less than current \" + zxid);\n                    }\n                    if (zks.outstandingChangesForPath.get(cr.path) == cr) {\n                        zks.outstandingChangesForPath.remove(cr.path);\n                    }\n                }\n            }\n\n            // do not add non quorum packets to the queue.\n            if (request.isQuorum()) {\n                zks.getZKDatabase().addCommittedProposal(request);\n            }\n        }\n\n        // ZOOKEEPER-558:\n        // In some cases the server does not close the connection (e.g., closeconn buffer\n        // was not being queued \u2014 ZOOKEEPER-558) properly. This happens, for example,\n        // when the client closes the connection. The server should still close the session, though.\n        // Calling closeSession() after losing the cnxn, results in the client close session response being dropped.\n        if (request.type == OpCode.closeSession && connClosedByClient(request)) {\n            // We need to check if we can close the session id.\n            // Sometimes the corresponding ServerCnxnFactory could be null because\n            // we are just playing diffs from the leader.\n            if (closeSession(zks.serverCnxnFactory, request.sessionId) ||\n                    closeSession(zks.secureServerCnxnFactory, request.sessionId)) {\n                return;\n            }\n        }\n\n        if (request.cnxn == null) {\n            return;\n        }\n        ServerCnxn cnxn = request.cnxn;\n\n        String lastOp = \"NA\";\n        zks.decInProcess();\n        Code err = Code.OK;\n        Record rsp = null;\n        try {\n            if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n                /*\n                 * When local session upgrading is disabled, leader will\n                 * reject the ephemeral node creation due to session expire.\n                 * However, if this is the follower that issue the request,\n                 * it will have the correct error code, so we should use that\n                 * and report to user\n                 */\n                if (request.getException() != null) {\n                    throw request.getException();\n                } else {\n                    throw KeeperException.create(KeeperException.Code\n                            .get(((ErrorTxn) request.getTxn()).getErr()));\n                }\n            }\n\n            KeeperException ke = request.getException();\n            if (ke != null && request.type != OpCode.multi) {\n                throw ke;\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}\",request);\n            }\n            switch (request.type) {\n            case OpCode.ping: {\n                zks.serverStats().updateLatency(request.createTime);\n\n                lastOp = \"PING\";\n                cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,\n                        request.createTime, Time.currentElapsedTime());\n\n                cnxn.sendResponse(new ReplyHeader(-2,\n                        zks.getZKDatabase().getDataTreeLastProcessedZxid(), 0), null, \"response\");\n                return;\n            }\n            case OpCode.createSession: {\n                zks.serverStats().updateLatency(request.createTime);\n\n                lastOp = \"SESS\";\n                cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,\n                        request.createTime, Time.currentElapsedTime());\n\n                zks.finishSessionInit(request.cnxn, true);\n                return;\n            }\n            case OpCode.multi: {\n                lastOp = \"MULT\";\n                rsp = new MultiResponse() ;\n\n                for (ProcessTxnResult subTxnResult : rc.multiResult) {\n\n                    OpResult subResult ;\n\n                    switch (subTxnResult.type) {\n                        case OpCode.check:\n                            subResult = new CheckResult();\n                            break;\n                        case OpCode.create:\n                            subResult = new CreateResult(subTxnResult.path);\n                            break;\n                        case OpCode.create2:\n                        case OpCode.createTTL:\n                        case OpCode.createContainer:\n                            subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n                            break;\n                        case OpCode.delete:\n                        case OpCode.deleteContainer:\n                            subResult = new DeleteResult();\n                            break;\n                        case OpCode.setData:\n                            subResult = new SetDataResult(subTxnResult.stat);\n                            break;\n                        case OpCode.error:\n                            subResult = new ErrorResult(subTxnResult.err) ;\n                            break;\n                        default:\n                            throw new IOException(\"Invalid type of op\");\n                    }\n\n                    ((MultiResponse)rsp).add(subResult);\n                }\n\n                break;\n            }\n            case OpCode.create: {\n                lastOp = \"CREA\";\n                rsp = new CreateResponse(rc.path);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.create2:\n            case OpCode.createTTL:\n            case OpCode.createContainer: {\n                lastOp = \"CREA\";\n                rsp = new Create2Response(rc.path, rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.delete:\n            case OpCode.deleteContainer: {\n                lastOp = \"DELE\";\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.setData: {\n                lastOp = \"SETD\";\n                rsp = new SetDataResponse(rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.reconfig: {\n                lastOp = \"RECO\";\n                rsp = new GetDataResponse(((QuorumZooKeeperServer)zks).self.getQuorumVerifier().toString().getBytes(), rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.setACL: {\n                lastOp = \"SETA\";\n                rsp = new SetACLResponse(rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.closeSession: {\n                lastOp = \"CLOS\";\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.sync: {\n                lastOp = \"SYNC\";\n                SyncRequest syncRequest = new SyncRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        syncRequest);\n                rsp = new SyncResponse(syncRequest.getPath());\n                break;\n            }\n            case OpCode.check: {\n                lastOp = \"CHEC\";\n                rsp = new SetDataResponse(rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.exists: {\n                lastOp = \"EXIS\";\n                // TODO we need to figure out the security requirement for this!\n                ExistsRequest existsRequest = new ExistsRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        existsRequest);\n                String path = existsRequest.getPath();\n                if (path.indexOf('\\0') != -1) {\n                    throw new KeeperException.BadArgumentsException();\n                }\n                Stat stat = zks.getZKDatabase().statNode(path, existsRequest\n                        .getWatch() ? cnxn : null);\n                rsp = new ExistsResponse(stat);\n                break;\n            }\n            case OpCode.getData: {\n                lastOp = \"GETD\";\n                GetDataRequest getDataRequest = new GetDataRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getDataRequest);\n                DataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());\n                if (n == null) {\n                    throw new KeeperException.NoNodeException();\n                }\n                PrepRequestProcessor.checkACL(zks, request.cnxn, zks.getZKDatabase().aclForNode(n),\n                        ZooDefs.Perms.READ,\n                        request.authInfo, getDataRequest.getPath(), null);\n                Stat stat = new Stat();\n                byte b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,\n                        getDataRequest.getWatch() ? cnxn : null);\n                rsp = new GetDataResponse(b, stat);\n                break;\n            }\n            case OpCode.setWatches: {\n                lastOp = \"SETW\";\n                SetWatches setWatches = new SetWatches();\n                // XXX We really should NOT need this!!!!\n                request.request.rewind();\n                ByteBufferInputStream.byteBuffer2Record(request.request, setWatches);\n                long relativeZxid = setWatches.getRelativeZxid();\n                zks.getZKDatabase().setWatches(relativeZxid,\n                        setWatches.getDataWatches(),\n                        setWatches.getExistWatches(),\n                        setWatches.getChildWatches(), cnxn);\n                break;\n            }\n            case OpCode.getACL: {\n                lastOp = \"GETA\";\n                GetACLRequest getACLRequest = new GetACLRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getACLRequest);\n                Stat stat = new Stat();\n                List<ACL> acl =\n                    zks.getZKDatabase().getACL(getACLRequest.getPath(), stat);\n                rsp = new GetACLResponse(acl, stat);\n                break;\n            }\n            case OpCode.getChildren: {\n                lastOp = \"GETC\";\n                GetChildrenRequest getChildrenRequest = new GetChildrenRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getChildrenRequest);\n                DataNode n = zks.getZKDatabase().getNode(getChildrenRequest.getPath());\n                if (n == null) {\n                    throw new KeeperException.NoNodeException();\n                }\n                PrepRequestProcessor.checkACL(zks, request.cnxn, zks.getZKDatabase().aclForNode(n),\n                        ZooDefs.Perms.READ,\n                        request.authInfo, getChildrenRequest.getPath(), null);\n                List<String> children = zks.getZKDatabase().getChildren(\n                        getChildrenRequest.getPath(), null, getChildrenRequest\n                                .getWatch() ? cnxn : null);\n                rsp = new GetChildrenResponse(children);\n                break;\n            }\n            case OpCode.getChildren2: {\n                lastOp = \"GETC\";\n                GetChildren2Request getChildren2Request = new GetChildren2Request();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getChildren2Request);\n                Stat stat = new Stat();\n                DataNode n = zks.getZKDatabase().getNode(getChildren2Request.getPath());\n                if (n == null) {\n                    throw new KeeperException.NoNodeException();\n                }\n                PrepRequestProcessor.checkACL(zks, request.cnxn, zks.getZKDatabase().aclForNode(n),\n                        ZooDefs.Perms.READ,\n                        request.authInfo, getChildren2Request.getPath(), null);\n                List<String> children = zks.getZKDatabase().getChildren(\n                        getChildren2Request.getPath(), stat, getChildren2Request\n                                .getWatch() ? cnxn : null);\n                rsp = new GetChildren2Response(children, stat);\n                break;\n            }\n            case OpCode.checkWatches: {\n                lastOp = \"CHKW\";\n                CheckWatchesRequest checkWatches = new CheckWatchesRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        checkWatches);\n                WatcherType type = WatcherType.fromInt(checkWatches.getType());\n                boolean containsWatcher = zks.getZKDatabase().containsWatcher(\n                        checkWatches.getPath(), type, cnxn);\n                if (!containsWatcher) {\n                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\",\n                            new Object[] { checkWatches.getPath(), type });\n                    throw new KeeperException.NoWatcherException(msg);\n                }\n                break;\n            }\n            case OpCode.removeWatches: {\n                lastOp = \"REMW\";\n                RemoveWatchesRequest removeWatches = new RemoveWatchesRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        removeWatches);\n                WatcherType type = WatcherType.fromInt(removeWatches.getType());\n                boolean removed = zks.getZKDatabase().removeWatch(\n                        removeWatches.getPath(), type, cnxn);\n                if (!removed) {\n                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\",\n                            new Object[] { removeWatches.getPath(), type });\n                    throw new KeeperException.NoWatcherException(msg);\n                }\n                break;\n            }\n            }\n        } catch (SessionMovedException e) {\n            // session moved is a connection level error, we need to tear\n            // down the connection otw ZOOKEEPER-710 might happen\n            // ie client on slow follower starts to renew session, fails\n            // before this completes, then tries the fast follower (leader)\n            // and is successful, however the initial renew is then\n            // successfully fwd/processed by the leader and as a result\n            // the client and leader disagree on where the client is most\n            // recently attached (and therefore invalid SESSION MOVED generated)\n            cnxn.sendCloseSession();\n            return;\n        } catch (KeeperException e) {\n            err = e.code();\n        } catch (Exception e) {\n            // log at error level as we are returning a marshalling\n            // error to the user\n            LOG.error(\"Failed to process \" + request, e);\n            StringBuilder sb = new StringBuilder();\n            ByteBuffer bb = request.request;\n            bb.rewind();\n            while (bb.hasRemaining()) {\n                sb.append(Integer.toHexString(bb.get() & 0xff));\n            }\n            LOG.error(\"Dumping request buffer: 0x\" + sb.toString());\n            err = Code.MARSHALLINGERROR;\n        }\n\n        long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n        ReplyHeader hdr =\n            new ReplyHeader(request.cxid, lastZxid, err.intValue());\n\n        zks.serverStats().updateLatency(request.createTime);\n        cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,\n                    request.createTime, Time.currentElapsedTime());\n\n        try {\n            cnxn.sendResponse(hdr, rsp, \"response\");\n            if (request.type == OpCode.closeSession) {\n                cnxn.sendCloseSession();\n            }\n        } catch (IOException e) {\n            LOG.error(\"FIXMSG\",e);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.closeSession": "    private boolean closeSession(ServerCnxnFactory serverCnxnFactory, long sessionId) {\n        if (serverCnxnFactory == null) {\n            return false;\n        }\n        return serverCnxnFactory.closeSession(sessionId);\n    }",
            "src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.connClosedByClient": "    private boolean connClosedByClient(Request request) {\n        return request.cnxn == null;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.doWork": "        public void doWork() throws RequestProcessorException {\n            try {\n                nextProcessor.processRequest(request);\n            } finally {\n                if (numRequestsProcessing.decrementAndGet() == 0){\n                    wakeupOnEmpty();\n                }\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.processRequest": "    public void processRequest(Request request) {\n        if (stopped) {\n            return;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request:: \" + request);\n        }\n        queuedRequests.add(request);\n        wakeup();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.wakeupOnEmpty": "    private void wakeupOnEmpty() {\n        synchronized(emptyPoolSync){\n            emptyPoolSync.notifyAll();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.WorkerService.run": "        public void run() {\n            try {\n                // Check if stopped while request was on queue\n                if (stopped) {\n                    workRequest.cleanup();\n                    return;\n                }\n                workRequest.doWork();\n            } catch (Exception e) {\n                LOG.warn(\"Unexpected exception\", e);\n                workRequest.cleanup();\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.WorkerService.cleanup": "        public void cleanup() {\n        }",
            "src.java.main.org.apache.zookeeper.server.WorkerService.doWork": "        public abstract void doWork() throws Exception;\n\n        /**\n         * (Optional) If implemented, is called if the service is stopped\n         * or unable to schedule the request.\n         */\n        public void cleanup() {\n        }",
            "src.java.main.org.apache.zookeeper.server.request.getTxn": "    public Record getTxn() {\n        return txn;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.logRequest": "    static public void logRequest(Logger log, long mask,\n            char rp, Request request, String header)\n    {\n        if (isTraceEnabled(log, mask)) {\n            log.trace(header + \":\" + rp + request.toString());\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.isTraceEnabled": "    public static synchronized boolean isTraceEnabled(Logger log, long mask) {\n        return log.isTraceEnabled() && (mask & traceMask) != 0;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxn.sendCloseSession": "    abstract void sendCloseSession();\n\n    public abstract void process(WatchedEvent event);\n\n    public abstract long getSessionId();\n\n    abstract void setSessionId(long sessionId);\n\n    /** auth info for the cnxn, returns an unmodifyable list */\n    public List<Id> getAuthInfo() {\n        return Collections.unmodifiableList(new ArrayList<>(authInfo));\n    }",
            "src.java.main.org.apache.zookeeper.server.ByteBufferInputStream.byteBuffer2Record": "    static public void byteBuffer2Record(ByteBuffer bb, Record record)\n            throws IOException {\n        BinaryInputArchive ia;\n        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n        record.deserialize(ia, \"request\");\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.checkACL": "    static void checkACL(ZooKeeperServer zks, ServerCnxn cnxn, List<ACL> acl, int perm, List<Id> ids,\n                         String path, List<ACL> setAcls) throws KeeperException.NoAuthException {\n        if (skipACL) {\n            return;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Permission requested: {} \", perm);\n            LOG.debug(\"ACLs for node: {}\", acl);\n            LOG.debug(\"Client credentials: {}\", ids);\n        }\n        if (acl == null || acl.size() == 0) {\n            return;\n        }\n        for (Id authId : ids) {\n            if (authId.getScheme().equals(\"super\")) {\n                return;\n            }\n        }\n        for (ACL a : acl) {\n            Id id = a.getId();\n            if ((a.getPerms() & perm) != 0) {\n                if (id.getScheme().equals(\"world\")\n                        && id.getId().equals(\"anyone\")) {\n                    return;\n                }\n                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id\n                        .getScheme());\n                if (ap != null) {\n                    for (Id authId : ids) {\n                        if (authId.getScheme().equals(id.getScheme())\n                                && ap.matches(new ServerAuthenticationProvider.ServerObjs(zks, cnxn),\n                                new ServerAuthenticationProvider.MatchValues(path, authId.getId(), id.getId(), perm, setAcls))) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        throw new KeeperException.NoAuthException();\n    }",
            "src.java.main.org.apache.zookeeper.server.request.getHdr": "    public TxnHeader getHdr() {\n        return hdr;\n    }",
            "src.java.main.org.apache.zookeeper.server.request.isQuorum": "    public boolean isQuorum() {\n        switch (this.type) {\n        case OpCode.exists:\n        case OpCode.getACL:\n        case OpCode.getChildren:\n        case OpCode.getChildren2:\n        case OpCode.getData:\n            return false;\n        case OpCode.create:\n        case OpCode.create2:\n        case OpCode.createTTL:\n        case OpCode.createContainer:\n        case OpCode.error:\n        case OpCode.delete:\n        case OpCode.deleteContainer:\n        case OpCode.setACL:\n        case OpCode.setData:\n        case OpCode.check:\n        case OpCode.multi:\n        case OpCode.reconfig:\n            return true;\n        case OpCode.closeSession:\n        case OpCode.createSession:\n            return !this.isLocalSession;\n        default:\n            return false;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxn.updateStatsForResponse": "    protected synchronized void updateStatsForResponse(long cxid, long zxid,\n            String op, long start, long end)\n    {\n        // don't overwrite with \"special\" xids - we're interested\n        // in the clients last real operation\n        if (cxid >= 0) {\n            lastCxid = cxid;\n        }\n        lastZxid = zxid;\n        lastOp = op;\n        lastResponseTime = end;\n        long elapsed = end - start;\n        lastLatency = elapsed;\n        if (elapsed < minLatency) {\n            minLatency = elapsed;\n        }\n        if (elapsed > maxLatency) {\n            maxLatency = elapsed;\n        }\n        count++;\n        totalLatency += elapsed;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxn.sendResponse": "    public abstract void sendResponse(ReplyHeader h, Record r, String tag)\n        throws IOException;\n\n    /* notify the client the session is closing and close/cleanup socket */\n    abstract void sendCloseSession();\n\n    public abstract void process(WatchedEvent event);\n\n    public abstract long getSessionId();\n\n    abstract void setSessionId(long sessionId);\n\n    /** auth info for the cnxn, returns an unmodifyable list */\n    public List<Id> getAuthInfo() {\n        return Collections.unmodifiableList(new ArrayList<>(authInfo));\n    }",
            "src.java.main.org.apache.zookeeper.server.request.getException": "    public KeeperException getException() {\n        return e;\n    }"
        },
        "bug_report": {
            "Title": "ACL with index 1 might be removed if it's only being used once",
            "Description": "When Zeus start up, it will create DataTree instance, in which the empty config znode is created with READ_UNSAFE acl, the acl will be stored in a map with index 1. Then it's going to load the snapshot from disk, the nodes and acl map will be cleared, but the reconfig znode is still reference to acl index 1. The reconfig znode will be reused, so actually it may reference to a different ACL stored in the snasphot. After leader-follower syncing, the reconfig znode will be added back again (if it doesn't exist), which will remove the previous reference to ACL index 1, if the index 1 has 0 reference it will be removed from the ACL map, which could cause that ACL un-usable, and that znode will not be readable.\n\nError logs related:\n-----------------------------\n2017-06-12 12:02:21,443 [myid:2] - ERROR [CommitProcWorkThread-14:DataTree@249] - ERROR: ACL not available for long 1\n2017-06-12 12:02:21,444 [myid:2] - ERROR [CommitProcWorkThread-14:FinalRequestProcessor@567] - Failed to process sessionid:0x201035cc882002d type:getChildren cxid:0x1 zxid:0xfffffffffffffffe txntype:unknown reqpath:n/a\njava.lang.RuntimeException: Failed to fetch acls for 1\n        at org.apache.zookeeper.server.DataTree.convertLong(DataTree.java:250)\n        at org.apache.zookeeper.server.DataTree.getACL(DataTree.java:799)\n        at org.apache.zookeeper.server.ZKDatabase.getACL(ZKDatabase.java:574)\n        at org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:463)\n        at org.apache.zookeeper.server.quorum.CommitProcessor$CommitWorkRequest.doWork(CommitProcessor.java:439)\n        at org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:151)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)"
        }
    },
    {
        "filename": "ZOOKEEPER-2982.json",
        "creation_time": "2018-02-19T19:28:06.000+0000",
        "stack_trace": "java.net.UnknownHostException: zk-2.zk.default.svc.cluster.local\r\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:184)\r\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\r\n        at java.net.Socket.connect(Socket.java:589)\r\n        at org.apache.zookeeper.server.quorum.Learner.sockConnect(Learner.java:227)\r\n        at org.apache.zookeeper.server.quorum.Learner.connectToLeader(Learner.java:256)\r\n        at org.apache.zookeeper.server.quorum.Follower.followLeader(Follower.java:76)\r\n        at org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:1133)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.server.quorum.Learner.sockConnect": "    protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) \n    throws IOException {\n        sock.connect(addr, timeout);\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.Learner.connectToLeader": "    protected void connectToLeader(InetSocketAddress addr, String hostname)\n    throws IOException, ConnectException, InterruptedException {\n        sock = new Socket();        \n        sock.setSoTimeout(self.tickTime * self.initLimit);\n\n        int initLimitTime = self.tickTime * self.initLimit;\n        int remainingInitLimitTime = initLimitTime;\n        long startNanoTime = nanoTime();\n\n        for (int tries = 0; tries < 5; tries++) {\n            try {\n                // recalculate the init limit time because retries sleep for 1000 milliseconds\n                remainingInitLimitTime = initLimitTime - (int)((nanoTime() - startNanoTime) / 1000000);\n                if (remainingInitLimitTime <= 0) {\n                    LOG.error(\"initLimit exceeded on retries.\");\n                    throw new IOException(\"initLimit exceeded on retries.\");\n                }\n\n                sockConnect(sock, addr, Math.min(self.tickTime * self.syncLimit, remainingInitLimitTime));\n                sock.setTcpNoDelay(nodelay);\n                break;\n            } catch (IOException e) {\n                remainingInitLimitTime = initLimitTime - (int)((nanoTime() - startNanoTime) / 1000000);\n\n                if (remainingInitLimitTime <= 1000) {\n                    LOG.error(\"Unexpected exception, initLimit exceeded. tries=\" + tries +\n                             \", remaining init limit=\" + remainingInitLimitTime +\n                             \", connecting to \" + addr,e);\n                    throw e;\n                } else if (tries >= 4) {\n                    LOG.error(\"Unexpected exception, retries exceeded. tries=\" + tries +\n                             \", remaining init limit=\" + remainingInitLimitTime +\n                             \", connecting to \" + addr,e);\n                    throw e;\n                } else {\n                    LOG.warn(\"Unexpected exception, tries=\" + tries +\n                            \", remaining init limit=\" + remainingInitLimitTime +\n                            \", connecting to \" + addr,e);\n                    sock = new Socket();\n                    sock.setSoTimeout(self.tickTime * self.initLimit);\n                }\n            }\n            Thread.sleep(1000);\n        }\n\n        self.authLearner.authenticate(sock, hostname);\n\n        leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n                sock.getInputStream()));\n        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n        leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n    }   ",
            "src.java.main.org.apache.zookeeper.server.quorum.Learner.nanoTime": "    protected long nanoTime() {\n        return System.nanoTime();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.Follower.followLeader": "    void followLeader() throws InterruptedException {\n        self.end_fle = Time.currentElapsedTime();\n        long electionTimeTaken = self.end_fle - self.start_fle;\n        self.setElectionTimeTaken(electionTimeTaken);\n        LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken,\n                QuorumPeer.FLE_TIME_UNIT);\n        self.start_fle = 0;\n        self.end_fle = 0;\n        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n        try {\n            QuorumServer leaderServer = findLeader();\n            try {\n                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n                if (self.isReconfigStateChange())\n                   throw new Exception(\"learned about role change\");\n                //check to see if the leader zxid is lower than ours\n                //this should never happen but is just a safety check\n                long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n                if (newEpoch < self.getAcceptedEpoch()) {\n                    LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid)\n                            + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n                    throw new IOException(\"Error: Epoch of leader is lower\");\n                }\n                syncWithLeader(newEpochZxid);                \n                QuorumPacket qp = new QuorumPacket();\n                while (this.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when following the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n    \n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX((Learner)this);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.Follower.processPacket": "    protected void processPacket(QuorumPacket qp) throws Exception{\n        switch (qp.getType()) {\n        case Leader.PING:            \n            ping(qp);            \n            break;\n        case Leader.PROPOSAL:           \n            TxnHeader hdr = new TxnHeader();\n            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);\n            if (hdr.getZxid() != lastQueued + 1) {\n                LOG.warn(\"Got zxid 0x\"\n                        + Long.toHexString(hdr.getZxid())\n                        + \" expected 0x\"\n                        + Long.toHexString(lastQueued + 1));\n            }\n            lastQueued = hdr.getZxid();\n            \n            if (hdr.getType() == OpCode.reconfig){\n               SetDataTxn setDataTxn = (SetDataTxn) txn;       \n               QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));\n               self.setLastSeenQuorumVerifier(qv, true);                               \n            }\n            \n            fzk.logRequest(hdr, txn);\n            break;\n        case Leader.COMMIT:\n            fzk.commit(qp.getZxid());\n            break;\n            \n        case Leader.COMMITANDACTIVATE:\n           // get the new configuration from the request\n           Request request = fzk.pendingTxns.element();\n           SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();                                                                                                      \n           QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                                \n \n           // get new designated leader from (current) leader's message\n           ByteBuffer buffer = ByteBuffer.wrap(qp.getData());    \n           long suggestedLeaderId = buffer.getLong();\n            boolean majorChange = \n                   self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n           // commit (writes the new config to ZK tree (/zookeeper/config)                     \n           fzk.commit(qp.getZxid());\n            if (majorChange) {\n               throw new Exception(\"changes proposed in reconfig\");\n           }\n           break;\n        case Leader.UPTODATE:\n            LOG.error(\"Received an UPTODATE message after Follower started\");\n            break;\n        case Leader.REVALIDATE:\n            revalidate(qp);\n            break;\n        case Leader.SYNC:\n            fzk.sync();\n            break;\n        default:\n            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n            break;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.run": "                            public void run() {\n                                try {\n                                    // lower-bound grace period to 2 secs\n                                    sleep(Math.max(2000, tickTime));\n                                    if (ServerState.LOOKING.equals(getPeerState())) {\n                                        roZk.startup();\n                                    }\n                                } catch (InterruptedException e) {\n                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n                                } catch (Exception e) {\n                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n                                }\n                            }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setPeerState": "    public synchronized void setPeerState(ServerState newState){\n        state=newState;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.getCurrentVote": "    public synchronized Vote getCurrentVote(){\n        return currentVote;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.shutdown": "    public void shutdown() {\n        running = false;\n        if (leader != null) {\n            leader.shutdown(\"quorum Peer shutdown\");\n        }\n        if (follower != null) {\n            follower.shutdown();\n        }\n        shutdownServerCnxnFactory();\n        if(udpSocket != null) {\n            udpSocket.close();\n        }\n\n        try {\n            adminServer.shutdown();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem stopping AdminServer\", e);\n        }\n\n        if(getElectionAlg() != null){\n            this.interrupt();\n            getElectionAlg().shutdown();\n        }\n        try {\n            zkDb.close();\n        } catch (IOException ie) {\n            LOG.warn(\"Error closing logs \", ie);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.makeFollower": "    protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {\n        return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setFollower": "    synchronized protected void setFollower(Follower newFollower){\n        follower=newFollower;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.getId": "    public long getId() {\n        return myid;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.getPeerState": "    public synchronized ServerState getPeerState(){\n        return state;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setLeader": "    synchronized protected void setLeader(Leader newLeader){\n        leader=newLeader;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.updateThreadName": "    private void updateThreadName() {\n        String plain = cnxnFactory != null ?\n                cnxnFactory.getLocalAddress() != null ?\n                        cnxnFactory.getLocalAddress().toString() : \"disabled\" : \"disabled\";\n        String secure = secureCnxnFactory != null ? secureCnxnFactory.getLocalAddress().toString() : \"disabled\";\n        setName(String.format(\"QuorumPeer[myid=%d](plain=%s)(secure=%s)\", getId(), plain, secure));\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.startLeaderElection": "    synchronized public void startLeaderElection() {\n        try {\n            if (getPeerState() == ServerState.LOOKING) {\n                currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n            }\n        } catch(IOException e) {\n            RuntimeException re = new RuntimeException(e.getMessage());\n            re.setStackTrace(e.getStackTrace());\n            throw re;\n        }\n\n        this.electionAlg = createElectionAlgorithm(electionType);\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.reconfigFlagClear": "    public synchronized void reconfigFlagClear(){\n       reconfigFlag = false;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setObserver": "    synchronized protected void setObserver(Observer newObserver){\n        observer=newObserver;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.updateServerState": "    private synchronized void updateServerState(){\n       if (!reconfigFlag) {\n           setPeerState(ServerState.LOOKING);\n           LOG.warn(\"PeerState set to LOOKING\");\n           return;\n       }\n       \n       if (getId() == getCurrentVote().getId()) {\n           setPeerState(ServerState.LEADING);\n           LOG.debug(\"PeerState set to LEADING\");\n       } else if (getLearnerType() == LearnerType.PARTICIPANT) {\n           setPeerState(ServerState.FOLLOWING);\n           LOG.debug(\"PeerState set to FOLLOWING\");\n       } else if (getLearnerType() == LearnerType.OBSERVER) {\n           setPeerState(ServerState.OBSERVING);\n           LOG.debug(\"PeerState set to OBSERVER\");\n       } else { // currently shouldn't happen since there are only 2 learner types\n           setPeerState(ServerState.LOOKING);\n           LOG.debug(\"Shouldn't be here\");\n       }       \n       reconfigFlag = false;   \n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.makeObserver": "    protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {\n        return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.makeLeader": "    protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException {\n        return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.getView": "    public Map<Long,QuorumPeer.QuorumServer> getView() {\n        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.start": "    public synchronized void start() {\n        if (!getView().containsKey(myid)) {\n            throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n         }\n        loadDataBase();\n        startServerCnxnFactory();\n        try {\n            adminServer.start();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem starting AdminServer\", e);\n            System.out.println(e);\n        }\n        startLeaderElection();\n        super.start();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.makeLEStrategy": "    protected Election makeLEStrategy(){\n        LOG.debug(\"Initializing leader election protocol...\");\n        return electionAlg;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.setCurrentVote": "    public synchronized void setCurrentVote(Vote v){\n        currentVote = v;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.follower.getZxid": "    public long getZxid() {\n        try {\n            synchronized (fzk) {\n                return fzk.getZxid();\n            }\n        } catch (NullPointerException e) {\n            LOG.warn(\"error getting zxid\", e);\n        }\n        return -1;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.lead": "    void lead() throws IOException, InterruptedException {\n        self.end_fle = Time.currentElapsedTime();\n        long electionTimeTaken = self.end_fle - self.start_fle;\n        self.setElectionTimeTaken(electionTimeTaken);\n        LOG.info(\"LEADING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken,\n                QuorumPeer.FLE_TIME_UNIT);\n        self.start_fle = 0;\n        self.end_fle = 0;\n\n        zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n\n        try {\n            self.tick.set(0);\n            zk.loadData();\n\n            leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n\n            // Start thread that waits for connection requests from\n            // new followers.\n            cnxAcceptor = new LearnerCnxAcceptor();\n            cnxAcceptor.start();\n\n            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());\n\n            zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n\n            synchronized(this){\n                lastProposed = zk.getZxid();\n            }\n\n            newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),\n                   null, null);\n\n\n            if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n                LOG.info(\"NEWLEADER proposal has Zxid of \"\n                        + Long.toHexString(newLeaderProposal.packet.getZxid()));\n            }\n\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            QuorumVerifier curQV = self.getQuorumVerifier();\n            if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n                // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n                // specified by the user; the lack of version in a config file is interpreted as version=0). \n                // As soon as a config is established we would like to increase its version so that it\n                // takes presedence over other initial configs that were not established (such as a config\n                // of a server trying to join the ensemble, which may be a partial view of the system, not the full config). \n                // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n                // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n                // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier, \n                // and there's still no agreement on the new version that we'd like to use. Instead, we use \n                // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n                // so its a good way to let followers know about the new version. (The original reason for sending \n                // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n                // that it finds before starting to propose operations. Here we're reusing the same code path for \n                // reaching consensus on the new version number.)\n                \n                // It is important that this is done before the leader executes waitForEpochAck,\n                // so before LearnerHandlers return from their waitForEpochAck\n                // hence before they construct the NEWLEADER message containing\n                // the last-seen-quorumverifier of the leader, which we change below\n               try {\n                   QuorumVerifier newQV = self.configFromString(curQV.toString());\n                   newQV.setVersion(zk.getZxid());\n                   self.setLastSeenQuorumVerifier(newQV, true);    \n               } catch (Exception e) {\n                   throw new IOException(e);\n               }\n            }\n            \n            newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n            if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()){\n               newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n            }\n            \n            // We have to get at least a majority of servers in sync with\n            // us. We do this by waiting for the NEWLEADER packet to get\n            // acknowledged\n                       \n             waitForEpochAck(self.getId(), leaderStateSummary);\n             self.setCurrentEpoch(epoch);    \n            \n             try {\n                 waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);\n             } catch (InterruptedException e) {\n                 shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \"\n                         + newLeaderProposal.ackSetsToString() + \" ]\");\n                 HashSet<Long> followerSet = new HashSet<Long>();\n\n                 for(LearnerHandler f : getLearners()) {\n                     if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())){\n                         followerSet.add(f.getSid());\n                     }\n                 }    \n                 boolean initTicksShouldBeIncreased = true;\n                 for (Proposal.QuorumVerifierAcksetPair qvAckset:newLeaderProposal.qvAcksetPairs) {\n                     if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n                         initTicksShouldBeIncreased = false;\n                         break;\n                     }\n                 }                  \n                 if (initTicksShouldBeIncreased) {\n                     LOG.warn(\"Enough followers present. \"+\n                             \"Perhaps the initTicks need to be increased.\");\n                 }\n                 return;\n             }\n\n             startZkServer();\n             \n            /**\n             * WARNING: do not use this for anything other than QA testing\n             * on a real cluster. Specifically to enable verification that quorum\n             * can handle the lower 32bit roll-over issue identified in\n             * ZOOKEEPER-1277. Without this option it would take a very long\n             * time (on order of a month say) to see the 4 billion writes\n             * necessary to cause the roll-over to occur.\n             *\n             * This field allows you to override the zxid of the server. Typically\n             * you'll want to set it to something like 0xfffffff0 and then\n             * start the quorum, run some operations and see the re-election.\n             */\n            String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n            if (initialZxid != null) {\n                long zxid = Long.parseLong(initialZxid);\n                zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n            }\n\n            if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n                self.setZooKeeperServer(zk);\n            }\n\n            self.adminServer.setZooKeeperServer(zk);\n\n            // Everything is a go, simply start counting the ticks\n            // WARNING: I couldn't find any wait statement on a synchronized\n            // block that would be notified by this notifyAll() call, so\n            // I commented it out\n            //synchronized (this) {\n            //    notifyAll();\n            //}\n            // We ping twice a tick, so we only update the tick every other\n            // iteration\n            boolean tickSkip = true;\n            // If not null then shutdown this leader\n            String shutdownMessage = null;\n\n            while (true) {\n                synchronized (this) {\n                    long start = Time.currentElapsedTime();\n                    long cur = start;\n                    long end = start + self.tickTime / 2;\n                    while (cur < end) {\n                        wait(end - cur);\n                        cur = Time.currentElapsedTime();\n                    }\n\n                    if (!tickSkip) {\n                        self.tick.incrementAndGet();\n                    }\n\n                    // We use an instance of SyncedLearnerTracker to\n                    // track synced learners to make sure we still have a\n                    // quorum of current (and potentially next pending) view.\n                    SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n                    syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n                    if (self.getLastSeenQuorumVerifier() != null\n                            && self.getLastSeenQuorumVerifier().getVersion() > self\n                                    .getQuorumVerifier().getVersion()) {\n                        syncedAckSet.addQuorumVerifier(self\n                                .getLastSeenQuorumVerifier());\n                    }\n\n                    syncedAckSet.addAck(self.getId());\n\n                    for (LearnerHandler f : getLearners()) {\n                        if (f.synced()) {\n                            syncedAckSet.addAck(f.getSid());\n                        }\n                    }\n\n                    // check leader running status\n                    if (!this.isRunning()) {\n                        // set shutdown flag\n                        shutdownMessage = \"Unexpected internal error\";\n                        break;\n                    }\n\n                    if (!tickSkip && !syncedAckSet.hasAllQuorums()) {\n                        // Lost quorum of last committed and/or last proposed\n                        // config, set shutdown flag\n                        shutdownMessage = \"Not sufficient followers synced, only synced with sids: [ \"\n                                + syncedAckSet.ackSetsToString() + \" ]\";\n                        break;\n                    }\n                    tickSkip = !tickSkip;\n                }\n                for (LearnerHandler f : getLearners()) {\n                    f.ping();\n                }\n            }\n            if (shutdownMessage != null) {\n                shutdown(shutdownMessage);\n                // leader goes in looking state\n            }\n        } finally {\n            zk.unregisterJMX(this);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.waitForNewLeaderAck": "    public void waitForNewLeaderAck(long sid, long zxid, LearnerType learnerType)\n            throws InterruptedException {\n\n        synchronized (newLeaderProposal.qvAcksetPairs) {\n\n            if (quorumFormed) {\n                return;\n            }\n\n            long currentZxid = newLeaderProposal.packet.getZxid();\n            if (zxid != currentZxid) {\n                LOG.error(\"NEWLEADER ACK from sid: \" + sid\n                        + \" is from a different epoch - current 0x\"\n                        + Long.toHexString(currentZxid) + \" receieved 0x\"\n                        + Long.toHexString(zxid));\n                return;\n            }\n\n            /*\n             * Note that addAck already checks that the learner\n             * is a PARTICIPANT.\n             */\n            newLeaderProposal.addAck(sid);\n\n            if (newLeaderProposal.hasAllQuorums()) {\n                quorumFormed = true;\n                newLeaderProposal.qvAcksetPairs.notifyAll();\n            } else {\n                long start = Time.currentElapsedTime();\n                long cur = start;\n                long end = start + self.getInitLimit() * self.getTickTime();\n                while (!quorumFormed && cur < end) {\n                    newLeaderProposal.qvAcksetPairs.wait(end - cur);\n                    cur = Time.currentElapsedTime();\n                }\n                if (!quorumFormed) {\n                    throw new InterruptedException(\n                            \"Timeout while waiting for NEWLEADER to be acked by quorum\");\n                }\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.waitForEpochAck": "    public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException {\n        synchronized(electingFollowers) {\n            if (electionFinished) {\n                return;\n            }\n            if (ss.getCurrentEpoch() != -1) {\n                if (ss.isMoreRecentThan(leaderStateSummary)) {\n                    throw new IOException(\"Follower is ahead of the leader, leader summary: \" \n                                                    + leaderStateSummary.getCurrentEpoch()\n                                                    + \" (current epoch), \"\n                                                    + leaderStateSummary.getLastZxid()\n                                                    + \" (last zxid)\");\n                }\n                if (ss.getLastZxid() != -1) {\n                    electingFollowers.add(id);\n                }\n            }\n            QuorumVerifier verifier = self.getQuorumVerifier();\n            if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {\n                electionFinished = true;\n                electingFollowers.notifyAll();\n            } else {\n                long start = Time.currentElapsedTime();\n                long cur = start;\n                long end = start + self.getInitLimit()*self.getTickTime();\n                while(!electionFinished && cur < end) {\n                    electingFollowers.wait(end - cur);\n                    cur = Time.currentElapsedTime();\n                }\n                if (!electionFinished) {\n                    throw new InterruptedException(\"Timeout while waiting for epoch to be acked by quorum\");\n                }\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.getEpochToPropose": "    public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {\n        synchronized(connectingFollowers) {\n            if (!waitingForNewEpoch) {\n                return epoch;\n            }\n            if (lastAcceptedEpoch >= epoch) {\n                epoch = lastAcceptedEpoch+1;\n            }\n            connectingFollowers.add(sid);\n            QuorumVerifier verifier = self.getQuorumVerifier();\n            if (connectingFollowers.contains(self.getId()) &&\n                                            verifier.containsQuorum(connectingFollowers)) {\n                waitingForNewEpoch = false;\n                self.setAcceptedEpoch(epoch);\n                connectingFollowers.notifyAll();\n            } else {\n                long start = Time.currentElapsedTime();\n                long cur = start;\n                long end = start + self.getInitLimit()*self.getTickTime();\n                while(waitingForNewEpoch && cur < end) {\n                    connectingFollowers.wait(end - cur);\n                    cur = Time.currentElapsedTime();\n                }\n                if (waitingForNewEpoch) {\n                    throw new InterruptedException(\"Timeout while waiting for epoch from quorum\");\n                }\n            }\n            return epoch;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.shutdown": "        public void shutdown() {\n            LOG.info(\"Shutting down\");\n            next.shutdown();\n        }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.getLearners": "    public List<LearnerHandler> getLearners() {\n        synchronized (learners) {\n            return new ArrayList<LearnerHandler>(learners);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.startZkServer": "    private synchronized void startZkServer() {\n        // Update lastCommitted and Db's zxid to a value representing the new epoch\n        lastCommitted = zk.getZxid();\n        LOG.info(\"Have quorum of supporters, sids: [ \"\n                + newLeaderProposal.ackSetsToString()\n                + \" ]; starting up and setting last processed zxid: 0x{}\",\n                Long.toHexString(zk.getZxid()));\n        \n        /*\n         * ZOOKEEPER-1324. the leader sends the new config it must complete\n         *  to others inside a NEWLEADER message (see LearnerHandler where\n         *  the NEWLEADER message is constructed), and once it has enough\n         *  acks we must execute the following code so that it applies the\n         *  config to itself.\n         */\n        QuorumVerifier newQV = self.getLastSeenQuorumVerifier();\n        \n        Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());                                         \n\n        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);\n        if (designatedLeader != self.getId()) {\n            allowedToCommit = false;\n        }\n        \n        zk.startup();\n        /*\n         * Update the election vote here to ensure that all members of the\n         * ensemble report the same vote to new servers that start up and\n         * send leader election notifications to the ensemble.\n         * \n         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n         */\n        self.updateElectionVote(getEpoch());\n\n        zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.toString": "        public String toString() {\n            return packet.getType() + \", \" + packet.getZxid() + \", \" + request;\n        }",
            "src.java.main.org.apache.zookeeper.server.quorum.leader.isRunning": "    private boolean isRunning() {\n        return self.isRunning() && zk.isRunning();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.Vote.getZxid": "    public long getZxid() {\n        return zxid;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.startup": "    public synchronized void startup() {\n        // check to avoid startup follows shutdown\n        if (shutdown) {\n            LOG.warn(\"Not starting Read-only server as startup follows shutdown!\");\n            return;\n        }\n        registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);\n        super.startup();\n        self.setZooKeeperServer(this);\n        self.adminServer.setZooKeeperServer(this);\n        LOG.info(\"Read-only server started\");\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX": "    public void registerJMX(ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean) {\n        // register with JMX\n        try {\n            jmxServerBean = serverBean;\n            MBeanRegistry.getInstance().register(serverBean, localPeerBean);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to register with JMX\", e);\n            jmxServerBean = null;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.follower.followLeader": "    void followLeader() throws InterruptedException {\n        self.end_fle = Time.currentElapsedTime();\n        long electionTimeTaken = self.end_fle - self.start_fle;\n        self.setElectionTimeTaken(electionTimeTaken);\n        LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - {} {}\", electionTimeTaken,\n                QuorumPeer.FLE_TIME_UNIT);\n        self.start_fle = 0;\n        self.end_fle = 0;\n        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n        try {\n            QuorumServer leaderServer = findLeader();\n            try {\n                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n                if (self.isReconfigStateChange())\n                   throw new Exception(\"learned about role change\");\n                //check to see if the leader zxid is lower than ours\n                //this should never happen but is just a safety check\n                long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n                if (newEpoch < self.getAcceptedEpoch()) {\n                    LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid)\n                            + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n                    throw new IOException(\"Error: Epoch of leader is lower\");\n                }\n                syncWithLeader(newEpochZxid);                \n                QuorumPacket qp = new QuorumPacket();\n                while (this.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when following the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n    \n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX((Learner)this);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.follower.processPacket": "    protected void processPacket(QuorumPacket qp) throws Exception{\n        switch (qp.getType()) {\n        case Leader.PING:            \n            ping(qp);            \n            break;\n        case Leader.PROPOSAL:           \n            TxnHeader hdr = new TxnHeader();\n            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);\n            if (hdr.getZxid() != lastQueued + 1) {\n                LOG.warn(\"Got zxid 0x\"\n                        + Long.toHexString(hdr.getZxid())\n                        + \" expected 0x\"\n                        + Long.toHexString(lastQueued + 1));\n            }\n            lastQueued = hdr.getZxid();\n            \n            if (hdr.getType() == OpCode.reconfig){\n               SetDataTxn setDataTxn = (SetDataTxn) txn;       \n               QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));\n               self.setLastSeenQuorumVerifier(qv, true);                               \n            }\n            \n            fzk.logRequest(hdr, txn);\n            break;\n        case Leader.COMMIT:\n            fzk.commit(qp.getZxid());\n            break;\n            \n        case Leader.COMMITANDACTIVATE:\n           // get the new configuration from the request\n           Request request = fzk.pendingTxns.element();\n           SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();                                                                                                      \n           QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                                \n \n           // get new designated leader from (current) leader's message\n           ByteBuffer buffer = ByteBuffer.wrap(qp.getData());    \n           long suggestedLeaderId = buffer.getLong();\n            boolean majorChange = \n                   self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n           // commit (writes the new config to ZK tree (/zookeeper/config)                     \n           fzk.commit(qp.getZxid());\n            if (majorChange) {\n               throw new Exception(\"changes proposed in reconfig\");\n           }\n           break;\n        case Leader.UPTODATE:\n            LOG.error(\"Received an UPTODATE message after Follower started\");\n            break;\n        case Leader.REVALIDATE:\n            revalidate(qp);\n            break;\n        case Leader.SYNC:\n            fzk.sync();\n            break;\n        default:\n            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n            break;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.observer.observeLeader": "    void observeLeader() throws Exception {\n        zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n\n        try {\n            QuorumServer leaderServer = findLeader();\n            LOG.info(\"Observing \" + leaderServer.addr);\n            try {\n                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n                if (self.isReconfigStateChange())\n                   throw new Exception(\"learned about role change\");\n \n                syncWithLeader(newLeaderZxid);\n                QuorumPacket qp = new QuorumPacket();\n                while (this.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when observing the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n\n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX(this);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.observer.processPacket": "    protected void processPacket(QuorumPacket qp) throws Exception{\n        switch (qp.getType()) {\n        case Leader.PING:\n            ping(qp);\n            break;\n        case Leader.PROPOSAL:\n            LOG.warn(\"Ignoring proposal\");\n            break;\n        case Leader.COMMIT:\n            LOG.warn(\"Ignoring commit\");\n            break;\n        case Leader.UPTODATE:\n            LOG.error(\"Received an UPTODATE message after Observer started\");\n            break;\n        case Leader.REVALIDATE:\n            revalidate(qp);\n            break;\n        case Leader.SYNC:\n            ((ObserverZooKeeperServer)zk).sync();\n            break;\n        case Leader.INFORM:\n            TxnHeader hdr = new TxnHeader();\n            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);\n            Request request = new Request (hdr.getClientId(),  hdr.getCxid(), hdr.getType(), hdr, txn, 0);\n            ObserverZooKeeperServer obs = (ObserverZooKeeperServer)zk;\n            obs.commitRequest(request);\n            break;\n        case Leader.INFORMANDACTIVATE:            \n            hdr = new TxnHeader();\n            \n           // get new designated leader from (current) leader's message\n            ByteBuffer buffer = ByteBuffer.wrap(qp.getData());    \n           long suggestedLeaderId = buffer.getLong();\n           \n            byte[] remainingdata = new byte[buffer.remaining()];\n            buffer.get(remainingdata);\n            txn = SerializeUtils.deserializeTxn(remainingdata, hdr);\n            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn)txn).getData()));\n            \n            request = new Request (hdr.getClientId(),  hdr.getCxid(), hdr.getType(), hdr, txn, 0);\n            obs = (ObserverZooKeeperServer)zk;\n                        \n            boolean majorChange = \n                self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);\n           \n            obs.commitRequest(request);                                 \n\n            if (majorChange) {\n               throw new Exception(\"changes proposed in reconfig\");\n           }            \n            break;\n        default:\n            LOG.warn(\"Unknown packet type: {}\", LearnerHandler.packetToString(qp));\n            break;\n        }\n    }"
        },
        "bug_report": {
            "Title": "Re-try DNS hostname -> IP resolution",
            "Description": "ZOOKEEPER-1506 fixed a DNS resolution issue in 3.4.  Some portions of the fix haven't yet been ported to 3.5.\r\n\r\nTo recap the outstanding problem in 3.5, if a given ZK server is started before all peer addresses are resolvable, that server may cache a negative lookup result and forever fail to resolve the address.    For example, deploying ZK 3.5 to Kubernetes using a StatefulSet plus a Service (headless) may fail because the DNS records are created lazily.\r\n\r\n{code}\r\n2018-02-18 09:11:22,583 [myid:0] - WARN  [QuorumPeer[myid=0](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled):Follower@95] - Exception when following the leader\r\njava.net.UnknownHostException: zk-2.zk.default.svc.cluster.local\r\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:184)\r\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\r\n        at java.net.Socket.connect(Socket.java:589)\r\n        at org.apache.zookeeper.server.quorum.Learner.sockConnect(Learner.java:227)\r\n        at org.apache.zookeeper.server.quorum.Learner.connectToLeader(Learner.java:256)\r\n        at org.apache.zookeeper.server.quorum.Follower.followLeader(Follower.java:76)\r\n        at org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:1133)\r\n{code}\r\n\r\nIn the above example, the address `zk-2.zk.default.svc.cluster.local` was not resolvable when the server started, but became resolvable shortly thereafter.    The server should eventually succeed but doesn't."
        }
    },
    {
        "filename": "ZOOKEEPER-1179.json",
        "creation_time": "2011-09-13T16:20:56.000+0000",
        "stack_trace": "java.io.IOException: A non-blocking socket operation could not be completed immediately\n\tat sun.nio.ch.SocketDispatcher.close0(Native Method)\n\tat sun.nio.ch.SocketDispatcher.preClose(SocketDispatcher.java:44)\n\tat sun.nio.ch.SocketChannelImpl.implCloseSelectableChannel(SocketChannelImpl.java:684)\n\tat java.nio.channels.spi.AbstractSelectableChannel.implCloseChannel(AbstractSelectableChannel.java:201)\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:97)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.close(NioWorker.java:593)\n\tat org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:119)\n\tat org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:76)\n\tat org.jboss.netty.channel.Channels.close(Channels.java:720)\n\tat org.jboss.netty.channel.AbstractChannel.close(AbstractChannel.java:208)\n\tat org.apache.zookeeper.server.NettyServerCnxn.close(NettyServerCnxn.java:116)\n\tat org.apache.zookeeper.server.NettyServerCnxn.cleanupWriterSocket(NettyServerCnxn.java:241)\n\tat org.apache.zookeeper.server.NettyServerCnxn.access$0(NettyServerCnxn.java:231)\n\tat org.apache.zookeeper.server.NettyServerCnxn$CommandThread.run(NettyServerCnxn.java:314)\n\tat org.apache.zookeeper.server.NettyServerCnxn$CommandThread.start(NettyServerCnxn.java:305)\n\tat org.apache.zookeeper.server.NettyServerCnxn.checkFourLetterWord(NettyServerCnxn.java:674)\n\tat org.apache.zookeeper.server.NettyServerCnxn.receiveMessage(NettyServerCnxn.java:791)\n\tat org.apache.zookeeper.server.NettyServerCnxnFactory$CnxnChannelHandler.processMessage(NettyServerCnxnFactory.java:217)\n\tat org.apache.zookeeper.server.NettyServerCnxnFactory$CnxnChannelHandler.messageReceived(NettyServerCnxnFactory.java:141)\n\tat org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:274)\n\tat org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:261)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:350)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.processSelectedKeys(NioWorker.java:281)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:201)\n\tat org.jboss.netty.util.internal.IoWorkerRunnable.run(IoWorkerRunnable.java:46)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:619)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.close": "        public void close() throws IOException {\n            if (sb == null) return;\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.getRemoteAddress": "        public SocketAddress getRemoteAddress() {return null;}",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.checkFlush": "        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.cleanupWriterSocket": "    private void cleanupWriterSocket(PrintWriter pwriter) {\n        try {\n            if (pwriter != null) {\n                pwriter.flush();\n                pwriter.close();\n            }\n        } catch (Exception e) {\n            LOG.info(\"Error closing PrintWriter \", e);\n        } finally {\n            try {\n                close();\n            } catch (Exception e) {\n                LOG.error(\"Error closing a command socket \", e);\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.flush": "        public void flush() throws IOException {\n            checkFlush(true);\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.run": "        public void run() {\n            try {\n                commandRun();\n            } catch (IOException ie) {\n                LOG.error(\"Error in running command \", ie);\n            } finally {\n                cleanupWriterSocket(pw);\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.commandRun": "        public void commandRun() {\n            if (zkServer == null) {\n                pw.print(\"null\");\n            } else if (zkServer instanceof ReadOnlyZooKeeperServer) {\n                pw.print(\"ro\");\n            } else {\n                pw.print(\"rw\");\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.start": "        public void start() {\n            run();\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.checkFourLetterWord": "    private boolean checkFourLetterWord(final Channel channel,\n            ChannelBuffer message, final int len) throws IOException\n    {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        String cmd = cmd2String.get(len);\n        if (cmd == null) {\n            return false;\n        }\n        channel.setInterestOps(0).awaitUninterruptibly();\n        LOG.info(\"Processing \" + cmd + \" command from \"\n                + channel.getRemoteAddress());\n        packetReceived();\n\n        final PrintWriter pwriter = new PrintWriter(\n                new BufferedWriter(new SendBufferWriter()));\n        if (len == ruokCmd) {\n            RuokCommand ruok = new RuokCommand(pwriter);\n            ruok.start();\n            return true;\n        } else if (len == getTraceMaskCmd) {\n            TraceMaskCommand tmask = new TraceMaskCommand(pwriter);\n            tmask.start();\n            return true;\n        } else if (len == setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(4);\n            message.readBytes(mask);\n\n            bb.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, traceMask);\n            setMask.start();\n            return true;\n        } else if (len == enviCmd) {\n            EnvCommand env = new EnvCommand(pwriter);\n            env.start();\n            return true;\n        } else if (len == confCmd) {\n            ConfCommand ccmd = new ConfCommand(pwriter);\n            ccmd.start();\n            return true;\n        } else if (len == srstCmd) {\n            StatResetCommand strst = new StatResetCommand(pwriter);\n            strst.start();\n            return true;\n        } else if (len == crstCmd) {\n            CnxnStatResetCommand crst = new CnxnStatResetCommand(pwriter);\n            crst.start();\n            return true;\n        } else if (len == dumpCmd) {\n            DumpCommand dump = new DumpCommand(pwriter);\n            dump.start();\n            return true;\n        } else if (len == statCmd || len == srvrCmd) {\n            StatCommand stat = new StatCommand(pwriter, len);\n            stat.start();\n            return true;\n        } else if (len == consCmd) {\n            ConsCommand cons = new ConsCommand(pwriter);\n            cons.start();\n            return true;\n        } else if (len == wchpCmd || len == wchcCmd || len == wchsCmd) {\n            WatchCommand wcmd = new WatchCommand(pwriter, len);\n            wcmd.start();\n            return true;\n        } else if (len == mntrCmd) {\n            MonitorCommand mntr = new MonitorCommand(pwriter);\n            mntr.start();\n            return true;\n        } else if (len == isroCmd) {\n            IsroCommand isro = new IsroCommand(pwriter);\n            isro.start();\n            return true;\n        }\n        return false;\n    }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.receiveMessage": "    public void receiveMessage(ChannelBuffer message) {\n        try {\n            while(message.readable() && !throttled) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable \" + message.readableBytes()\n                                + \" bb len \" + bb.remaining() + \" \" + bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(Long.toHexString(sessionId)\n                                + \" bb 0x\"\n                                + ChannelBuffers.hexDump(\n                                        ChannelBuffers.copiedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable \"\n                                + message.readableBytes()\n                                + \" bb len \" + bb.remaining() + \" \" + bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes \"\n                                + Long.toHexString(sessionId)\n                                + \" bb 0x\"\n                                + ChannelBuffers.hexDump(\n                                        ChannelBuffers.copiedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        packetReceived();\n                        bb.flip();\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            zks.processPacket(this, bb);\n\n                            if (zks.shouldThrottle(outstandingCount.incrementAndGet())) {\n                                disableRecv();\n                            }\n                        } else {\n                            LOG.debug(\"got conn req request from \"\n                                    + getRemoteSocketAddress());\n                            zks.processConnectRequest(this, bb);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable \"\n                                + message.readableBytes()\n                                + \" bblenrem \" + bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(Long.toHexString(sessionId)\n                                + \" bbLen 0x\"\n                                + ChannelBuffers.hexDump(\n                                        ChannelBuffers.copiedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(Long.toHexString(sessionId)\n                                    + \" bbLen 0x\"\n                                    + ChannelBuffers.hexDump(\n                                            ChannelBuffers.copiedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(Long.toHexString(sessionId)\n                                    + \" bbLen len is \" + len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch(IOException e) {\n            LOG.warn(\"Closing connection to \" + getRemoteSocketAddress(), e);\n            close();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.getRemoteSocketAddress": "    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress)channel.getRemoteAddress();\n    }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.disableRecv": "    public void disableRecv() {\n        throttled = true;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Throttling - disabling recv \" + this);\n        }\n        channel.setReadable(false).awaitUninterruptibly();\n    }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxnFactory.processMessage": "        private void processMessage(MessageEvent e, NettyServerCnxn cnxn) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(Long.toHexString(cnxn.sessionId) + \" queuedBuffer: \"\n                        + cnxn.queuedBuffer);\n            }\n\n            if (e instanceof NettyServerCnxn.ResumeMessageEvent) {\n                LOG.debug(\"Received ResumeMessageEvent\");\n                if (cnxn.queuedBuffer != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"processing queue \"\n                                + Long.toHexString(cnxn.sessionId)\n                                + \" queuedBuffer 0x\"\n                                + ChannelBuffers.hexDump(cnxn.queuedBuffer));\n                    }\n                    cnxn.receiveMessage(cnxn.queuedBuffer);\n                    if (!cnxn.queuedBuffer.readable()) {\n                        LOG.debug(\"Processed queue - no bytes remaining\");\n                        cnxn.queuedBuffer = null;\n                    } else {\n                        LOG.debug(\"Processed queue - bytes remaining\");\n                    }\n                } else {\n                    LOG.debug(\"queue empty\");\n                }\n                cnxn.channel.setReadable(true);\n            } else {\n                ChannelBuffer buf = (ChannelBuffer)e.getMessage();\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(Long.toHexString(cnxn.sessionId)\n                            + \" buf 0x\"\n                            + ChannelBuffers.hexDump(buf));\n                }\n                \n                if (cnxn.throttled) {\n                    LOG.debug(\"Received message while throttled\");\n                    // we are throttled, so we need to queue\n                    if (cnxn.queuedBuffer == null) {\n                        LOG.debug(\"allocating queue\");\n                        cnxn.queuedBuffer = dynamicBuffer(buf.readableBytes());\n                    }\n                    cnxn.queuedBuffer.writeBytes(buf);\n                    LOG.debug(Long.toHexString(cnxn.sessionId)\n                            + \" queuedBuffer 0x\"\n                            + ChannelBuffers.hexDump(cnxn.queuedBuffer));\n                } else {\n                    LOG.debug(\"not throttled\");\n                    if (cnxn.queuedBuffer != null) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(Long.toHexString(cnxn.sessionId)\n                                    + \" queuedBuffer 0x\"\n                                    + ChannelBuffers.hexDump(cnxn.queuedBuffer));\n                        }\n                        cnxn.queuedBuffer.writeBytes(buf);\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(Long.toHexString(cnxn.sessionId)\n                                    + \" queuedBuffer 0x\"\n                                    + ChannelBuffers.hexDump(cnxn.queuedBuffer));\n                        }\n\n                        cnxn.receiveMessage(cnxn.queuedBuffer);\n                        if (!cnxn.queuedBuffer.readable()) {\n                            LOG.debug(\"Processed queue - no bytes remaining\");\n                            cnxn.queuedBuffer = null;\n                        } else {\n                            LOG.debug(\"Processed queue - bytes remaining\");\n                        }\n                    } else {\n                        cnxn.receiveMessage(buf);\n                        if (buf.readable()) {\n                            if (LOG.isTraceEnabled()) {\n                                LOG.trace(\"Before copy \" + buf);\n                            }\n                            cnxn.queuedBuffer = dynamicBuffer(buf.readableBytes()); \n                            cnxn.queuedBuffer.writeBytes(buf);\n                            if (LOG.isTraceEnabled()) {\n                                LOG.trace(\"Copy is \" + cnxn.queuedBuffer);\n                                LOG.trace(Long.toHexString(cnxn.sessionId)\n                                        + \" queuedBuffer 0x\"\n                                        + ChannelBuffers.hexDump(cnxn.queuedBuffer));\n                            }\n                        }\n                    }\n                }\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxnFactory.messageReceived": "        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n            throws Exception\n        {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"message received called \" + e.getMessage());\n            }\n            try {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"New message \" + e.toString()\n                            + \" from \" + ctx.getChannel());\n                }\n                NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();\n                synchronized(cnxn) {\n                    processMessage(e, cnxn);\n                }\n            } catch(Exception ex) {\n                LOG.error(\"Unexpected exception in receive\", ex);\n                throw ex;\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.setTextTraceLevel": "    public static void setTextTraceLevel(long mask) {\n        traceMask = mask;\n        Logger LOG = LoggerFactory.getLogger(ZooTrace.class);\n        LOG.info(\"Set text trace mask to 0x\" + Long.toHexString(mask));\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.shouldThrottle": "    public boolean shouldThrottle(long outStandingCount) {\n        if (getGlobalOutstandingLimit() < getInProcess()) {\n            return outStandingCount > 0;\n        }\n        return false; \n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getInProcess": "    public int getInProcess() {\n        return requestsInProcess;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getGlobalOutstandingLimit": "    public int getGlobalOutstandingLimit() {\n        String sc = System.getProperty(\"zookeeper.globalOutstandingLimit\");\n        int limit;\n        try {\n            limit = Integer.parseInt(sc);\n        } catch (Exception e) {\n            limit = 1000;\n        }\n        return limit;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.processConnectRequest": "    public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException {\n        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));\n        ConnectRequest connReq = new ConnectRequest();\n        connReq.deserialize(bia, \"connect\");\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Session establishment request from client \"\n                    + cnxn.getRemoteSocketAddress()\n                    + \" client's lastZxid is 0x\"\n                    + Long.toHexString(connReq.getLastZxidSeen()));\n        }\n        boolean readOnly = false;\n        try {\n            readOnly = bia.readBool(\"readOnly\");\n            cnxn.isOldClient = false;\n        } catch (IOException e) {\n            // this is ok -- just a packet from an old client which\n            // doesn't contain readOnly field\n            LOG.warn(\"Connection request from old client \"\n                    + cnxn.getRemoteSocketAddress()\n                    + \"; will be dropped if server is in r-o mode\");\n        }\n        if (readOnly == false && this instanceof ReadOnlyZooKeeperServer) {\n            String msg = \"Refusing session request for not-read-only client \"\n                + cnxn.getRemoteSocketAddress();\n            LOG.info(msg);\n            throw new CloseRequestException(msg);\n        }\n        if (connReq.getLastZxidSeen() > zkDb.dataTree.lastProcessedZxid) {\n            String msg = \"Refusing session request for client \"\n                + cnxn.getRemoteSocketAddress()\n                + \" as it has seen zxid 0x\"\n                + Long.toHexString(connReq.getLastZxidSeen())\n                + \" our last zxid is 0x\"\n                + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid())\n                + \" client must try another server\";\n\n            LOG.info(msg);\n            throw new CloseRequestException(msg);\n        }\n        int sessionTimeout = connReq.getTimeOut();\n        byte passwd[] = connReq.getPasswd();\n        int minSessionTimeout = getMinSessionTimeout();\n        if (sessionTimeout < minSessionTimeout) {\n            sessionTimeout = minSessionTimeout;\n        }\n        int maxSessionTimeout = getMaxSessionTimeout();\n        if (sessionTimeout > maxSessionTimeout) {\n            sessionTimeout = maxSessionTimeout;\n        }\n        cnxn.setSessionTimeout(sessionTimeout);\n        // We don't want to receive any packets until we are sure that the\n        // session is setup\n        cnxn.disableRecv();\n        long sessionId = connReq.getSessionId();\n        if (sessionId != 0) {\n            long clientSessionId = connReq.getSessionId();\n            LOG.info(\"Client attempting to renew session 0x\"\n                    + Long.toHexString(clientSessionId)\n                    + \" at \" + cnxn.getRemoteSocketAddress());\n            serverCnxnFactory.closeSession(sessionId);\n            cnxn.setSessionId(sessionId);\n            reopenSession(cnxn, sessionId, passwd, sessionTimeout);\n        } else {\n            LOG.info(\"Client attempting to establish new session at \"\n                    + cnxn.getRemoteSocketAddress());\n            createSession(cnxn, passwd, sessionTimeout);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getMaxSessionTimeout": "    public int getMaxSessionTimeout() {\n        return maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.closeSession": "    public void closeSession(ServerCnxn cnxn, RequestHeader requestHeader) {\n        closeSession(cnxn.getSessionId());\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.createSession": "    long createSession(ServerCnxn cnxn, byte passwd[], int timeout) {\n        long sessionId = sessionTracker.createSession(timeout);\n        Random r = new Random(sessionId ^ superSecret);\n        r.nextBytes(passwd);\n        ByteBuffer to = ByteBuffer.allocate(4);\n        to.putInt(timeout);\n        cnxn.setSessionId(sessionId);\n        submitRequest(cnxn, sessionId, OpCode.createSession, 0, to, null);\n        return sessionId;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.reopenSession": "    public void reopenSession(ServerCnxn cnxn, long sessionId, byte[] passwd,\n            int sessionTimeout) throws IOException {\n        if (!checkPasswd(sessionId, passwd)) {\n            finishSessionInit(cnxn, false);\n        } else {\n            revalidateSession(cnxn, sessionId, sessionTimeout);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getMinSessionTimeout": "    public int getMinSessionTimeout() {\n        return minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getZKDatabase": "    public ZKDatabase getZKDatabase() {\n        return this.zkDb;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.processPacket": "    public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException {\n        // We have the request, now process and setup for next\n        InputStream bais = new ByteBufferInputStream(incomingBuffer);\n        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);\n        RequestHeader h = new RequestHeader();\n        h.deserialize(bia, \"header\");\n        // Through the magic of byte buffers, txn will not be\n        // pointing\n        // to the start of the txn\n        incomingBuffer = incomingBuffer.slice();\n        if (h.getType() == OpCode.auth) {\n            LOG.info(\"got auth packet \" + cnxn.getRemoteSocketAddress());\n            AuthPacket authPacket = new AuthPacket();\n            ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);\n            String scheme = authPacket.getScheme();\n            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);\n            Code authReturn = KeeperException.Code.AUTHFAILED;\n            if(ap != null) {\n                try {\n                    authReturn = ap.handleAuthentication(cnxn, authPacket.getAuth());\n                } catch(RuntimeException e) {\n                    LOG.warn(\"Caught runtime exception from AuthenticationProvider: \" + scheme + \" due to \" + e);\n                    authReturn = KeeperException.Code.AUTHFAILED;                   \n                }\n            }\n            if (authReturn!= KeeperException.Code.OK) {\n                if (ap == null) {\n                    LOG.warn(\"No authentication provider for scheme: \"\n                            + scheme + \" has \"\n                            + ProviderRegistry.listProviders());\n                } else {\n                    LOG.warn(\"Authentication failed for scheme: \" + scheme);\n                }\n                // send a response...\n                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,\n                        KeeperException.Code.AUTHFAILED.intValue());\n                cnxn.sendResponse(rh, null, null);\n                // ... and close connection\n                cnxn.sendBuffer(ServerCnxnFactory.closeConn);\n                cnxn.disableRecv();\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Authentication succeeded for scheme: \"\n                              + scheme);\n                }\n                LOG.info(\"auth success \" + cnxn.getRemoteSocketAddress());\n                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,\n                        KeeperException.Code.OK.intValue());\n                cnxn.sendResponse(rh, null, null);\n            }\n            return;\n        } else {\n            if (h.getType() == OpCode.sasl) {\n                Record rsp = processSasl(incomingBuffer,cnxn);\n                ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n                cnxn.sendResponse(rh,rsp, \"response\"); // not sure about 3rd arg..what is it?\n            }\n            else {\n                Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),\n                  h.getType(), incomingBuffer, cnxn.getAuthInfo());\n                si.setOwner(ServerCnxn.me);\n                submitRequest(si);\n            }\n        }\n        cnxn.incrOutstandingRequests(h);\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.setOwner": "    public void setOwner(long id, Object owner) throws SessionExpiredException {\n        sessionTracker.setOwner(id, owner);\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.byteBuffer2Record": "    static public void byteBuffer2Record(ByteBuffer bb, Record record)\n            throws IOException {\n        BinaryInputArchive ia;\n        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n        record.deserialize(ia, \"request\");\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.processSasl": "    private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {\n        LOG.debug(\"Responding to client SASL token.\");\n        GetSASLRequest clientTokenRecord = new GetSASLRequest();\n        byteBuffer2Record(incomingBuffer,clientTokenRecord);\n        byte[] clientToken = clientTokenRecord.getToken();\n        LOG.debug(\"Size of client SASL token: \" + clientToken.length);\n        byte[] responseToken = null;\n        try {\n            ZooKeeperSaslServer saslServer  = cnxn.zooKeeperSaslServer;\n            try {\n                // note that clientToken might be empty (clientToken.length == 0):\n                // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the\n                // SASL negotiation process.\n                responseToken = saslServer.evaluateResponse(clientToken);\n                if (saslServer.isComplete() == true) {\n                    String authorizationID = saslServer.getAuthorizationID();\n                    LOG.info(\"adding SASL authorization for authorizationID: \" + authorizationID);\n                    cnxn.addAuthInfo(new Id(\"sasl\",authorizationID));\n                }\n            }\n            catch (SaslException e) {\n                LOG.warn(\"Client failed to SASL authenticate: \" + e);\n                if ((System.getProperty(\"zookeeper.allowSaslFailedClients\") != null)\n                  &&\n                  (System.getProperty(\"zookeeper.allowSaslFailedClients\").equals(\"true\"))) {\n                    LOG.warn(\"Maintaining client connection despite SASL authentication failure.\");\n                } else {\n                    LOG.warn(\"Closing client connection due to SASL authentication failure.\");\n                    cnxn.close();\n                }\n            }\n        }\n        catch (NullPointerException e) {\n            LOG.error(\"cnxn.saslServer is null: cnxn object did not initialize its saslServer properly.\");\n        }\n        if (responseToken != null) {\n            LOG.debug(\"Size of server SASL response: \" + responseToken.length);\n        }\n        // wrap SASL response token to client inside a Response object.\n        return new SetSASLResponse(responseToken);\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.submitRequest": "    public void submitRequest(Request si) {\n        if (firstProcessor == null) {\n            synchronized (this) {\n                try {\n                    while (!running) {\n                        wait(1000);\n                    }\n                } catch (InterruptedException e) {\n                    LOG.warn(\"Unexpected interruption\", e);\n                }\n                if (firstProcessor == null) {\n                    throw new RuntimeException(\"Not started\");\n                }\n            }\n        }\n        try {\n            touch(si.cnxn);\n            boolean validpacket = Request.isValid(si.type);\n            if (validpacket) {\n                firstProcessor.processRequest(si);\n                if (si.cnxn != null) {\n                    incInProcess();\n                }\n            } else {\n                LOG.warn(\"Dropping packet at server of type \" + si.type);\n                // if invalid packet drop the packet.\n            }\n        } catch (MissingSessionException e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Dropping request: \" + e.getMessage());\n            }\n        }\n    }"
        },
        "bug_report": {
            "Title": "NettyServerCnxn does not properly close socket on 4 letter word requests",
            "Description": "When calling a 4-letter-word to a server configured to use NettyServerCnxnFactory, the factory will not properly cancel all the keys and close the socket after sending the response for the 4lw. The close request will throw this exception, and the thread will not shut down:\n2011-09-13 12:14:17,546 - WARN  [New I/O server worker #1-1:NettyServerCnxnFactory$CnxnChannelHandler@117] - Exception caught [id: 0x009300cc, /1.1.1.1:38542 => /139.172.114.138:2181] EXCEPTION: java.io.IOException: A non-blocking socket operation could not be completed immediately\njava.io.IOException: A non-blocking socket operation could not be completed immediately\n\tat sun.nio.ch.SocketDispatcher.close0(Native Method)\n\tat sun.nio.ch.SocketDispatcher.preClose(SocketDispatcher.java:44)\n\tat sun.nio.ch.SocketChannelImpl.implCloseSelectableChannel(SocketChannelImpl.java:684)\n\tat java.nio.channels.spi.AbstractSelectableChannel.implCloseChannel(AbstractSelectableChannel.java:201)\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:97)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.close(NioWorker.java:593)\n\tat org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:119)\n\tat org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:76)\n\tat org.jboss.netty.channel.Channels.close(Channels.java:720)\n\tat org.jboss.netty.channel.AbstractChannel.close(AbstractChannel.java:208)\n\tat org.apache.zookeeper.server.NettyServerCnxn.close(NettyServerCnxn.java:116)\n\tat org.apache.zookeeper.server.NettyServerCnxn.cleanupWriterSocket(NettyServerCnxn.java:241)\n\tat org.apache.zookeeper.server.NettyServerCnxn.access$0(NettyServerCnxn.java:231)\n\tat org.apache.zookeeper.server.NettyServerCnxn$CommandThread.run(NettyServerCnxn.java:314)\n\tat org.apache.zookeeper.server.NettyServerCnxn$CommandThread.start(NettyServerCnxn.java:305)\n\tat org.apache.zookeeper.server.NettyServerCnxn.checkFourLetterWord(NettyServerCnxn.java:674)\n\tat org.apache.zookeeper.server.NettyServerCnxn.receiveMessage(NettyServerCnxn.java:791)\n\tat org.apache.zookeeper.server.NettyServerCnxnFactory$CnxnChannelHandler.processMessage(NettyServerCnxnFactory.java:217)\n\tat org.apache.zookeeper.server.NettyServerCnxnFactory$CnxnChannelHandler.messageReceived(NettyServerCnxnFactory.java:141)\n\tat org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:274)\n\tat org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:261)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:350)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.processSelectedKeys(NioWorker.java:281)\n\tat org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:201)\n\tat org.jboss.netty.util.internal.IoWorkerRunnable.run(IoWorkerRunnable.java:46)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:619)"
        }
    },
    {
        "filename": "ZOOKEEPER-2581.json",
        "creation_time": "2016-09-14T07:12:58.000+0000",
        "stack_trace": "java.lang.NullPointerException\n\tat org.apache.zookeeper.common.X509Util.createKeyManager(X509Util.java:129)\n\tat org.apache.zookeeper.server.auth.X509AuthenticationProvider.<init>(X509AuthenticationProvider.java:75)\n\tat org.apache.zookeeper.server.auth.ProviderRegistry.initialize(ProviderRegistry.java:42)\n\tat org.apache.zookeeper.server.auth.ProviderRegistry.getProvider(ProviderRegistry.java:68)\n\tat org.apache.zookeeper.server.PrepRequestProcessor.checkACL(PrepRequestProcessor.java:319)\n\tat org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:324)\n\tat org.apache.zookeeper.server.quorum.CommitProcessor$CommitWorkRequest.doWork(CommitProcessor.java:296)\n\tat org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:162)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.common.X509Util.createKeyManager": "    public static X509KeyManager createKeyManager(String keyStoreLocation, String keyStorePassword)\n            throws KeyManagerException {\n        FileInputStream inputStream = null;\n        try {\n            char[] keyStorePasswordChars = keyStorePassword.toCharArray();\n            File keyStoreFile = new File(keyStoreLocation);\n            KeyStore ks = KeyStore.getInstance(\"JKS\");\n            inputStream = new FileInputStream(keyStoreFile);\n            ks.load(inputStream, keyStorePasswordChars);\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n            kmf.init(ks, keyStorePasswordChars);\n\n            for (KeyManager km : kmf.getKeyManagers()) {\n                if (km instanceof X509KeyManager) {\n                    return (X509KeyManager) km;\n                }\n            }\n            throw new KeyManagerException(\"Couldn't find X509KeyManager\");\n\n        } catch (Exception e) {\n            throw new KeyManagerException(e);\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (IOException e) {}\n            }\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.ProviderRegistry.initialize": "    public static void initialize() {\n        synchronized (ProviderRegistry.class) {\n            if (initialized)\n                return;\n            IPAuthenticationProvider ipp = new IPAuthenticationProvider();\n            DigestAuthenticationProvider digp = new DigestAuthenticationProvider();\n            authenticationProviders.put(ipp.getScheme(), ipp);\n            authenticationProviders.put(digp.getScheme(), digp);\n            Enumeration<Object> en = System.getProperties().keys();\n            while (en.hasMoreElements()) {\n                String k = (String) en.nextElement();\n                if (k.startsWith(\"zookeeper.authProvider.\")) {\n                    String className = System.getProperty(k);\n                    try {\n                        Class<?> c = ZooKeeperServer.class.getClassLoader()\n                                .loadClass(className);\n                        AuthenticationProvider ap = (AuthenticationProvider) c\n                                .newInstance();\n                        authenticationProviders.put(ap.getScheme(), ap);\n                    } catch (Exception e) {\n                        LOG.warn(\"Problems loading \" + className,e);\n                    }\n                }\n            }\n            initialized = true;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.ProviderRegistry.getProvider": "    public static AuthenticationProvider getProvider(String scheme) {\n        if(!initialized)\n            initialize();\n        return authenticationProviders.get(scheme);\n    }",
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.checkACL": "    static void checkACL(ZooKeeperServer zks, List<ACL> acl, int perm,\n            List<Id> ids) throws KeeperException.NoAuthException {\n        if (skipACL) {\n            return;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Permission requested: {} \", perm);\n            LOG.debug(\"ACLs for node: {}\", acl);\n            LOG.debug(\"Client credentials: {}\", ids);\n        }\n        if (acl == null || acl.size() == 0) {\n            return;\n        }\n        for (Id authId : ids) {\n            if (authId.getScheme().equals(\"super\")) {\n                return;\n            }\n        }\n        for (ACL a : acl) {\n            Id id = a.getId();\n            if ((a.getPerms() & perm) != 0) {\n                if (id.getScheme().equals(\"world\")\n                        && id.getId().equals(\"anyone\")) {\n                    return;\n                }\n                AuthenticationProvider ap = ProviderRegistry.getProvider(id\n                        .getScheme());\n                if (ap != null) {\n                    for (Id authId : ids) {\n                        if (authId.getScheme().equals(id.getScheme())\n                                && ap.matches(authId.getId(), id.getId())) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        throw new KeeperException.NoAuthException();\n    }",
            "src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.processRequest": "    public void processRequest(Request request) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request:: \" + request);\n        }\n        // request.addRQRec(\">final\");\n        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n        if (request.type == OpCode.ping) {\n            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n        }\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logRequest(LOG, traceMask, 'E', request, \"\");\n        }\n        ProcessTxnResult rc = null;\n        synchronized (zks.outstandingChanges) {\n            // Need to process local session requests\n            rc = zks.processTxn(request);\n\n            // request.hdr is set for write requests, which are the only ones\n            // that add to outstandingChanges.\n            if (request.getHdr() != null) {\n                TxnHeader hdr = request.getHdr();\n                Record txn = request.getTxn();\n                long zxid = hdr.getZxid();\n                while (!zks.outstandingChanges.isEmpty()\n                       && zks.outstandingChanges.get(0).zxid <= zxid) {\n                    ChangeRecord cr = zks.outstandingChanges.remove(0);\n                    if (cr.zxid < zxid) {\n                        LOG.warn(\"Zxid outstanding \" + cr.zxid\n                                 + \" is less than current \" + zxid);\n                    }\n                    if (zks.outstandingChangesForPath.get(cr.path) == cr) {\n                        zks.outstandingChangesForPath.remove(cr.path);\n                    }\n                }\n            }\n\n            // do not add non quorum packets to the queue.\n            if (request.isQuorum()) {\n                zks.getZKDatabase().addCommittedProposal(request);\n            }\n        }\n\n        // ZOOKEEPER-558:\n        // In some cases the server does not close the connection (e.g., closeconn buffer\n        // was not being queued \u2014 ZOOKEEPER-558) properly. This happens, for example,\n        // when the client closes the connection. The server should still close the session, though.\n        // Calling closeSession() after losing the cnxn, results in the client close session response being dropped.\n        if (request.type == OpCode.closeSession && connClosedByClient(request)) {\n            // We need to check if we can close the session id.\n            // Sometimes the corresponding ServerCnxnFactory could be null because\n            // we are just playing diffs from the leader.\n            if (closeSession(zks.serverCnxnFactory, request.sessionId) ||\n                    closeSession(zks.secureServerCnxnFactory, request.sessionId)) {\n                return;\n            }\n        }\n\n        if (request.cnxn == null) {\n            return;\n        }\n        ServerCnxn cnxn = request.cnxn;\n\n        String lastOp = \"NA\";\n        zks.decInProcess();\n        Code err = Code.OK;\n        Record rsp = null;\n        try {\n            if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {\n                /*\n                 * When local session upgrading is disabled, leader will\n                 * reject the ephemeral node creation due to session expire.\n                 * However, if this is the follower that issue the request,\n                 * it will have the correct error code, so we should use that\n                 * and report to user\n                 */\n                if (request.getException() != null) {\n                    throw request.getException();\n                } else {\n                    throw KeeperException.create(KeeperException.Code\n                            .get(((ErrorTxn) request.getTxn()).getErr()));\n                }\n            }\n\n            KeeperException ke = request.getException();\n            if (ke != null && request.type != OpCode.multi) {\n                throw ke;\n            }\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"{}\",request);\n            }\n            switch (request.type) {\n            case OpCode.ping: {\n                zks.serverStats().updateLatency(request.createTime);\n\n                lastOp = \"PING\";\n                cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,\n                        request.createTime, Time.currentElapsedTime());\n\n                cnxn.sendResponse(new ReplyHeader(-2,\n                        zks.getZKDatabase().getDataTreeLastProcessedZxid(), 0), null, \"response\");\n                return;\n            }\n            case OpCode.createSession: {\n                zks.serverStats().updateLatency(request.createTime);\n\n                lastOp = \"SESS\";\n                cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,\n                        request.createTime, Time.currentElapsedTime());\n\n                zks.finishSessionInit(request.cnxn, true);\n                return;\n            }\n            case OpCode.multi: {\n                lastOp = \"MULT\";\n                rsp = new MultiResponse() ;\n\n                for (ProcessTxnResult subTxnResult : rc.multiResult) {\n\n                    OpResult subResult ;\n\n                    switch (subTxnResult.type) {\n                        case OpCode.check:\n                            subResult = new CheckResult();\n                            break;\n                        case OpCode.create:\n                            subResult = new CreateResult(subTxnResult.path);\n                            break;\n                        case OpCode.create2:\n                        case OpCode.createContainer:\n                            subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);\n                            break;\n                        case OpCode.delete:\n                        case OpCode.deleteContainer:\n                            subResult = new DeleteResult();\n                            break;\n                        case OpCode.setData:\n                            subResult = new SetDataResult(subTxnResult.stat);\n                            break;\n                        case OpCode.error:\n                            subResult = new ErrorResult(subTxnResult.err) ;\n                            break;\n                        default:\n                            throw new IOException(\"Invalid type of op\");\n                    }\n\n                    ((MultiResponse)rsp).add(subResult);\n                }\n\n                break;\n            }\n            case OpCode.create: {\n                lastOp = \"CREA\";\n                rsp = new CreateResponse(rc.path);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.create2:\n            case OpCode.createContainer: {\n                lastOp = \"CREA\";\n                rsp = new Create2Response(rc.path, rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.delete:\n            case OpCode.deleteContainer: {\n                lastOp = \"DELE\";\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.setData: {\n                lastOp = \"SETD\";\n                rsp = new SetDataResponse(rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.reconfig: {\n                lastOp = \"RECO\";\n                rsp = new GetDataResponse(((QuorumZooKeeperServer)zks).self.getQuorumVerifier().toString().getBytes(), rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.setACL: {\n                lastOp = \"SETA\";\n                rsp = new SetACLResponse(rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.closeSession: {\n                lastOp = \"CLOS\";\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.sync: {\n                lastOp = \"SYNC\";\n                SyncRequest syncRequest = new SyncRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        syncRequest);\n                rsp = new SyncResponse(syncRequest.getPath());\n                break;\n            }\n            case OpCode.check: {\n                lastOp = \"CHEC\";\n                rsp = new SetDataResponse(rc.stat);\n                err = Code.get(rc.err);\n                break;\n            }\n            case OpCode.exists: {\n                lastOp = \"EXIS\";\n                // TODO we need to figure out the security requirement for this!\n                ExistsRequest existsRequest = new ExistsRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        existsRequest);\n                String path = existsRequest.getPath();\n                if (path.indexOf('\\0') != -1) {\n                    throw new KeeperException.BadArgumentsException();\n                }\n                Stat stat = zks.getZKDatabase().statNode(path, existsRequest\n                        .getWatch() ? cnxn : null);\n                rsp = new ExistsResponse(stat);\n                break;\n            }\n            case OpCode.getData: {\n                lastOp = \"GETD\";\n                GetDataRequest getDataRequest = new GetDataRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getDataRequest);\n                DataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());\n                if (n == null) {\n                    throw new KeeperException.NoNodeException();\n                }\n                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),\n                        ZooDefs.Perms.READ,\n                        request.authInfo);\n                Stat stat = new Stat();\n                byte b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,\n                        getDataRequest.getWatch() ? cnxn : null);\n                rsp = new GetDataResponse(b, stat);\n                break;\n            }\n            case OpCode.setWatches: {\n                lastOp = \"SETW\";\n                SetWatches setWatches = new SetWatches();\n                // XXX We really should NOT need this!!!!\n                request.request.rewind();\n                ByteBufferInputStream.byteBuffer2Record(request.request, setWatches);\n                long relativeZxid = setWatches.getRelativeZxid();\n                zks.getZKDatabase().setWatches(relativeZxid,\n                        setWatches.getDataWatches(),\n                        setWatches.getExistWatches(),\n                        setWatches.getChildWatches(), cnxn);\n                break;\n            }\n            case OpCode.getACL: {\n                lastOp = \"GETA\";\n                GetACLRequest getACLRequest = new GetACLRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getACLRequest);\n                Stat stat = new Stat();\n                List<ACL> acl =\n                    zks.getZKDatabase().getACL(getACLRequest.getPath(), stat);\n                rsp = new GetACLResponse(acl, stat);\n                break;\n            }\n            case OpCode.getChildren: {\n                lastOp = \"GETC\";\n                GetChildrenRequest getChildrenRequest = new GetChildrenRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getChildrenRequest);\n                DataNode n = zks.getZKDatabase().getNode(getChildrenRequest.getPath());\n                if (n == null) {\n                    throw new KeeperException.NoNodeException();\n                }\n                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),\n                        ZooDefs.Perms.READ,\n                        request.authInfo);\n                List<String> children = zks.getZKDatabase().getChildren(\n                        getChildrenRequest.getPath(), null, getChildrenRequest\n                                .getWatch() ? cnxn : null);\n                rsp = new GetChildrenResponse(children);\n                break;\n            }\n            case OpCode.getChildren2: {\n                lastOp = \"GETC\";\n                GetChildren2Request getChildren2Request = new GetChildren2Request();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        getChildren2Request);\n                Stat stat = new Stat();\n                DataNode n = zks.getZKDatabase().getNode(getChildren2Request.getPath());\n                if (n == null) {\n                    throw new KeeperException.NoNodeException();\n                }\n                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),\n                        ZooDefs.Perms.READ,\n                        request.authInfo);\n                List<String> children = zks.getZKDatabase().getChildren(\n                        getChildren2Request.getPath(), stat, getChildren2Request\n                                .getWatch() ? cnxn : null);\n                rsp = new GetChildren2Response(children, stat);\n                break;\n            }\n            case OpCode.checkWatches: {\n                lastOp = \"CHKW\";\n                CheckWatchesRequest checkWatches = new CheckWatchesRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        checkWatches);\n                WatcherType type = WatcherType.fromInt(checkWatches.getType());\n                boolean containsWatcher = zks.getZKDatabase().containsWatcher(\n                        checkWatches.getPath(), type, cnxn);\n                if (!containsWatcher) {\n                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\",\n                            new Object[] { checkWatches.getPath(), type });\n                    throw new KeeperException.NoWatcherException(msg);\n                }\n                break;\n            }\n            case OpCode.removeWatches: {\n                lastOp = \"REMW\";\n                RemoveWatchesRequest removeWatches = new RemoveWatchesRequest();\n                ByteBufferInputStream.byteBuffer2Record(request.request,\n                        removeWatches);\n                WatcherType type = WatcherType.fromInt(removeWatches.getType());\n                boolean removed = zks.getZKDatabase().removeWatch(\n                        removeWatches.getPath(), type, cnxn);\n                if (!removed) {\n                    String msg = String.format(Locale.ENGLISH, \"%s (type: %s)\",\n                            new Object[] { removeWatches.getPath(), type });\n                    throw new KeeperException.NoWatcherException(msg);\n                }\n                break;\n            }\n            }\n        } catch (SessionMovedException e) {\n            // session moved is a connection level error, we need to tear\n            // down the connection otw ZOOKEEPER-710 might happen\n            // ie client on slow follower starts to renew session, fails\n            // before this completes, then tries the fast follower (leader)\n            // and is successful, however the initial renew is then\n            // successfully fwd/processed by the leader and as a result\n            // the client and leader disagree on where the client is most\n            // recently attached (and therefore invalid SESSION MOVED generated)\n            cnxn.sendCloseSession();\n            return;\n        } catch (KeeperException e) {\n            err = e.code();\n        } catch (Exception e) {\n            // log at error level as we are returning a marshalling\n            // error to the user\n            LOG.error(\"Failed to process \" + request, e);\n            StringBuilder sb = new StringBuilder();\n            ByteBuffer bb = request.request;\n            bb.rewind();\n            while (bb.hasRemaining()) {\n                sb.append(Integer.toHexString(bb.get() & 0xff));\n            }\n            LOG.error(\"Dumping request buffer: 0x\" + sb.toString());\n            err = Code.MARSHALLINGERROR;\n        }\n\n        long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();\n        ReplyHeader hdr =\n            new ReplyHeader(request.cxid, lastZxid, err.intValue());\n\n        zks.serverStats().updateLatency(request.createTime);\n        cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,\n                    request.createTime, Time.currentElapsedTime());\n\n        try {\n            cnxn.sendResponse(hdr, rsp, \"response\");\n            if (request.type == OpCode.closeSession) {\n                cnxn.sendCloseSession();\n            }\n        } catch (IOException e) {\n            LOG.error(\"FIXMSG\",e);\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.closeSession": "    private boolean closeSession(ServerCnxnFactory serverCnxnFactory, long sessionId) {\n        if (serverCnxnFactory == null) {\n            return false;\n        }\n        return serverCnxnFactory.closeSession(sessionId);\n    }",
            "src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.connClosedByClient": "    private boolean connClosedByClient(Request request) {\n        return request.cnxn == null;\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.doWork": "        public void doWork() throws RequestProcessorException {\n            try {\n                nextProcessor.processRequest(request);\n            } finally {\n                if (numRequestsProcessing.decrementAndGet() == 0){\n                    wakeupOnEmpty();\n                }\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.processRequest": "    public void processRequest(Request request) {\n        if (stopped) {\n            return;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request:: \" + request);\n        }\n        queuedRequests.add(request);\n        wakeup();\n    }",
            "src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.wakeupOnEmpty": "    private void wakeupOnEmpty() {\n        synchronized(emptyPoolSync){\n            emptyPoolSync.notifyAll();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.WorkerService.run": "        public void run() {\n            try {\n                // Check if stopped while request was on queue\n                if (stopped) {\n                    workRequest.cleanup();\n                    return;\n                }\n                workRequest.doWork();\n            } catch (Exception e) {\n                LOG.warn(\"Unexpected exception\", e);\n                workRequest.cleanup();\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.WorkerService.cleanup": "        public void cleanup() {\n        }",
            "src.java.main.org.apache.zookeeper.server.WorkerService.doWork": "        public abstract void doWork() throws Exception;\n\n        /**\n         * (Optional) If implemented, is called if the service is stopped\n         * or unable to schedule the request.\n         */\n        public void cleanup() {\n        }",
            "src.java.main.org.apache.zookeeper.server.auth.DigestAuthenticationProvider.getScheme": "    public String getScheme() {\n        return \"digest\";\n    }",
            "src.java.main.org.apache.zookeeper.server.auth.AuthenticationProvider.getScheme": "    String getScheme();\n\n    /**\n     * This method is called when a client passes authentication data for this\n     * scheme. The authData is directly from the authentication packet. The\n     * implementor may attach new ids to the authInfo field of cnxn or may use\n     * cnxn to send packets back to the client.\n     * \n     * @param cnxn\n     *                the cnxn that received the authentication information.\n     * @param authData\n     *                the authentication data received.\n     * @return TODO\n     */\n    KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte authData[]);\n\n    /**\n     * This method is called to see if the given id matches the given id\n     * expression in the ACL. This allows schemes to use application specific\n     * wild cards.\n     * \n     * @param id\n     *                the id to check.\n     * @param aclExpr\n     *                the expression to match ids against.\n     * @return true if the id can be matched by the expression.\n     */\n    boolean matches(String id, String aclExpr);\n\n    /**\n     * This method is used to check if the authentication done by this provider\n     * should be used to identify the creator of a node. Some ids such as hosts\n     * and ip addresses are rather transient and in general don't really\n     * identify a client even though sometimes they do.\n     * \n     * @return true if this provider identifies creators.\n     */\n    boolean isAuthenticated();\n\n    /**\n     * Validates the syntax of an id.\n     * \n     * @param id\n     *                the id to validate.\n     * @return true if id is well formed.\n     */\n    boolean isValid(String id);\n}",
            "src.java.main.org.apache.zookeeper.server.auth.IPAuthenticationProvider.getScheme": "    public String getScheme() {\n        return \"ip\";\n    }",
            "src.java.main.org.apache.zookeeper.server.request.getTxn": "    public Record getTxn() {\n        return txn;\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.logRequest": "    static public void logRequest(Logger log, long mask,\n            char rp, Request request, String header)\n    {\n        if (isTraceEnabled(log, mask)) {\n            log.trace(header + \":\" + rp + request.toString());\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ZooTrace.isTraceEnabled": "    public static synchronized boolean isTraceEnabled(Logger log, long mask) {\n        return log.isTraceEnabled() && (mask & traceMask) != 0;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxn.sendCloseSession": "    abstract void sendCloseSession();\n\n    public abstract void process(WatchedEvent event);\n\n    public abstract long getSessionId();\n\n    abstract void setSessionId(long sessionId);\n\n    /** auth info for the cnxn, returns an unmodifyable list */\n    public List<Id> getAuthInfo() {\n        return Collections.unmodifiableList(authInfo);\n    }",
            "src.java.main.org.apache.zookeeper.server.ByteBufferInputStream.byteBuffer2Record": "    static public void byteBuffer2Record(ByteBuffer bb, Record record)\n            throws IOException {\n        BinaryInputArchive ia;\n        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n        record.deserialize(ia, \"request\");\n    }",
            "src.java.main.org.apache.zookeeper.server.request.getHdr": "    public TxnHeader getHdr() {\n        return hdr;\n    }",
            "src.java.main.org.apache.zookeeper.server.request.isQuorum": "    public boolean isQuorum() {\n        switch (this.type) {\n        case OpCode.exists:\n        case OpCode.getACL:\n        case OpCode.getChildren:\n        case OpCode.getChildren2:\n        case OpCode.getData:\n            return false;\n        case OpCode.create:\n        case OpCode.create2:\n        case OpCode.createContainer:\n        case OpCode.error:\n        case OpCode.delete:\n        case OpCode.deleteContainer:\n        case OpCode.setACL:\n        case OpCode.setData:\n        case OpCode.check:\n        case OpCode.multi:\n        case OpCode.reconfig:\n            return true;\n        case OpCode.closeSession:\n        case OpCode.createSession:\n            return !this.isLocalSession;\n        default:\n            return false;\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxn.updateStatsForResponse": "    protected synchronized void updateStatsForResponse(long cxid, long zxid,\n            String op, long start, long end)\n    {\n        // don't overwrite with \"special\" xids - we're interested\n        // in the clients last real operation\n        if (cxid >= 0) {\n            lastCxid = cxid;\n        }\n        lastZxid = zxid;\n        lastOp = op;\n        lastResponseTime = end;\n        long elapsed = end - start;\n        lastLatency = elapsed;\n        if (elapsed < minLatency) {\n            minLatency = elapsed;\n        }\n        if (elapsed > maxLatency) {\n            maxLatency = elapsed;\n        }\n        count++;\n        totalLatency += elapsed;\n    }",
            "src.java.main.org.apache.zookeeper.server.ServerCnxn.sendResponse": "    public abstract void sendResponse(ReplyHeader h, Record r, String tag)\n        throws IOException;\n\n    /* notify the client the session is closing and close/cleanup socket */\n    abstract void sendCloseSession();\n\n    public abstract void process(WatchedEvent event);\n\n    public abstract long getSessionId();\n\n    abstract void setSessionId(long sessionId);\n\n    /** auth info for the cnxn, returns an unmodifyable list */\n    public List<Id> getAuthInfo() {\n        return Collections.unmodifiableList(authInfo);\n    }",
            "src.java.main.org.apache.zookeeper.server.request.getException": "    public KeeperException getException() {\n        return e;\n    }"
        },
        "bug_report": {
            "Title": "Not handled NullPointerException while creating key manager and trustManager",
            "Description": "Not handled NullPointerException while creating key manager and trustManager:-\n\n\n2016-09-14 13:35:23,488 [myid:1] - ERROR [CommitProcWorkThread-1:X509AuthenticationProvider@78] - Failed to create key manager\norg.apache.zookeeper.common.X509Exception$KeyManagerException: java.lang.NullPointerException\n\tat org.apache.zookeeper.common.X509Util.createKeyManager(X509Util.java:129)\n\tat org.apache.zookeeper.server.auth.X509AuthenticationProvider.<init>(X509AuthenticationProvider.java:75)\n\tat org.apache.zookeeper.server.auth.ProviderRegistry.initialize(ProviderRegistry.java:42)\n\tat org.apache.zookeeper.server.auth.ProviderRegistry.getProvider(ProviderRegistry.java:68)\n\tat org.apache.zookeeper.server.PrepRequestProcessor.checkACL(PrepRequestProcessor.java:319)\n\tat org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:324)\n\tat org.apache.zookeeper.server.quorum.CommitProcessor$CommitWorkRequest.doWork(CommitProcessor.java:296)\n\tat org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:162)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.NullPointerException\n\tat org.apache.zookeeper.common.X509Util.createKeyManager(X509Util.java:113)\n\t... 10 more\n2016-09-14 13:35:23,489 [myid:1] - ERROR [CommitProcWorkThread-1:X509AuthenticationProvider@90] - Failed to create trust manager\norg.apache.zookeeper.common.X509Exception$TrustManagerException: java.lang.NullPointerException\n\tat org.apache.zookeeper.common.X509Util.createTrustManager(X509Util.java:158)\n\tat org.apache.zookeeper.server.auth.X509AuthenticationProvider.<init>(X509AuthenticationProvider.java:87)\n\tat org.apache.zookeeper.server.auth.ProviderRegistry.initialize(ProviderRegistry.java:42)\n\tat org.apache.zookeeper.server.auth.ProviderRegistry.getProvider(ProviderRegistry.java:68)\n\tat org.apache.zookeeper.server.PrepRequestProcessor.checkACL(PrepRequestProcessor.java:319)\n\tat org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:324)\n\tat org.apache.zookeeper.server.quorum.CommitProcessor$CommitWorkRequest.doWork(CommitProcessor.java:296)\n\tat org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:162)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.NullPointerException\n\tat org.apache.zookeeper.common.X509Util.createTrustManager(X509Util.java:143)\n\t... 10 more"
        }
    },
    {
        "filename": "ZOOKEEPER-1870.json",
        "creation_time": "2014-01-28T18:45:43.000+0000",
        "stack_trace": "junit.framework.AssertionFailedError: client could not connect to reestablished quorum: giving up after 30+ seconds.\n\tat org.apache.zookeeper.test.ReconfigTest.testNormalOperation(ReconfigTest.java:143)\n\tat org.apache.zookeeper.server.quorum.StandaloneDisabledTest.startSingleServerTest(StandaloneDisabledTest.java:75)\n\tat org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52)",
        "source_code": {},
        "bug_report": {
            "Title": "flakey test in StandaloneDisabledTest.startSingleServerTest",
            "Description": "I'm seeing lots of the following failure. Seems like a flakey test (passes every so often).\n\n{noformat}\njunit.framework.AssertionFailedError: client could not connect to reestablished quorum: giving up after 30+ seconds.\n\tat org.apache.zookeeper.test.ReconfigTest.testNormalOperation(ReconfigTest.java:143)\n\tat org.apache.zookeeper.server.quorum.StandaloneDisabledTest.startSingleServerTest(StandaloneDisabledTest.java:75)\n\tat org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52)\n{noformat}\n\nI've found 3 problems:\n\n1. QuorumCnxManager.Listener.run() leaks the socket depending on when the shutdown flag gets set.\n2. QuorumCnxManager.halt() doesn't wait for the listener to terminate.\n3. QuorumPeer.shuttingDownLE flag doesn't get reset when restarting the leader election.\n"
        }
    },
    {
        "filename": "ZOOKEEPER-2247.json",
        "creation_time": "2015-08-14T13:13:18.000+0000",
        "stack_trace": "java.io.IOException: Input/output error\n\tat sun.nio.ch.FileDispatcherImpl.force0(Native Method)\n\tat sun.nio.ch.FileDispatcherImpl.force(FileDispatcherImpl.java:76)\n\tat sun.nio.ch.FileChannelImpl.force(FileChannelImpl.java:376)\n\tat org.apache.zookeeper.server.persistence.FileTxnLog.commit(FileTxnLog.java:331)\n\tat org.apache.zookeeper.server.persistence.FileTxnSnapLog.commit(FileTxnSnapLog.java:380)\n\tat org.apache.zookeeper.server.ZKDatabase.commit(ZKDatabase.java:563)\n\tat org.apache.zookeeper.server.SyncRequestProcessor.flush(SyncRequestProcessor.java:178)\n\tat org.apache.zookeeper.server.SyncRequestProcessor.run(SyncRequestProcessor.java:113)",
        "source_code": {
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.commit": "    public synchronized void commit() throws IOException {\n        if (logStream != null) {\n            logStream.flush();\n        }\n        for (FileOutputStream log : streamsToFlush) {\n            log.flush();\n            if (forceSync) {\n                long startSyncNS = System.nanoTime();\n\n                log.getChannel().force(false);\n\n                long syncElapsedMS =\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);\n                if (syncElapsedMS > fsyncWarningThresholdMS) {\n                    LOG.warn(\"fsync-ing the write ahead log in \"\n                            + Thread.currentThread().getName()\n                            + \" took \" + syncElapsedMS\n                            + \"ms which will adversely effect operation latency. \"\n                            + \"See the ZooKeeper troubleshooting guide\");\n                }\n            }\n        }\n        while (streamsToFlush.size() > 1) {\n            streamsToFlush.removeFirst().close();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.close": "        public void close() throws IOException {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }",
            "src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.commit": "    public void commit() throws IOException {\n        txnLog.commit();\n    }",
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.commit": "    public void commit() throws IOException {\n        this.snapLog.commit();\n    }",
            "src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.flush": "    private void flush(LinkedList<Request> toFlush)\n        throws IOException, RequestProcessorException\n    {\n        if (toFlush.isEmpty())\n            return;\n\n        zks.getZKDatabase().commit();\n        while (!toFlush.isEmpty()) {\n            Request i = toFlush.remove();\n            if (nextProcessor != null) {\n                nextProcessor.processRequest(i);\n            }\n        }\n        if (nextProcessor != null && nextProcessor instanceof Flushable) {\n            ((Flushable)nextProcessor).flush();\n        }\n    }",
            "src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.processRequest": "    public void processRequest(Request request) {\n        // request.addRQRec(\">sync\");\n        queuedRequests.add(request);\n    }",
            "src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.run": "                                        public void run() {\n                                            try {\n                                                zks.takeSnapshot();\n                                            } catch(Exception e) {\n                                                LOG.warn(\"Unexpected exception\", e);\n                                            }\n                                        }"
        },
        "bug_report": {
            "Title": "Zookeeper service becomes unavailable when leader fails to write transaction log",
            "Description": "Zookeeper service becomes unavailable when leader fails to write transaction log. Bellow are the exceptions\n{code}\n2015-08-14 15:41:18,556 [myid:100] - ERROR [SyncThread:100:ZooKeeperCriticalThread@48] - Severe unrecoverable error, from thread : SyncThread:100\njava.io.IOException: Input/output error\n\tat sun.nio.ch.FileDispatcherImpl.force0(Native Method)\n\tat sun.nio.ch.FileDispatcherImpl.force(FileDispatcherImpl.java:76)\n\tat sun.nio.ch.FileChannelImpl.force(FileChannelImpl.java:376)\n\tat org.apache.zookeeper.server.persistence.FileTxnLog.commit(FileTxnLog.java:331)\n\tat org.apache.zookeeper.server.persistence.FileTxnSnapLog.commit(FileTxnSnapLog.java:380)\n\tat org.apache.zookeeper.server.ZKDatabase.commit(ZKDatabase.java:563)\n\tat org.apache.zookeeper.server.SyncRequestProcessor.flush(SyncRequestProcessor.java:178)\n\tat org.apache.zookeeper.server.SyncRequestProcessor.run(SyncRequestProcessor.java:113)\n2015-08-14 15:41:18,559 [myid:100] - INFO  [SyncThread:100:ZooKeeperServer$ZooKeeperServerListenerImpl@500] - Thread SyncThread:100 exits, error code 1\n2015-08-14 15:41:18,559 [myid:100] - INFO  [SyncThread:100:ZooKeeperServer@523] - shutting down\n2015-08-14 15:41:18,560 [myid:100] - INFO  [SyncThread:100:SessionTrackerImpl@232] - Shutting down\n2015-08-14 15:41:18,560 [myid:100] - INFO  [SyncThread:100:LeaderRequestProcessor@77] - Shutting down\n2015-08-14 15:41:18,560 [myid:100] - INFO  [SyncThread:100:PrepRequestProcessor@1035] - Shutting down\n2015-08-14 15:41:18,560 [myid:100] - INFO  [SyncThread:100:ProposalRequestProcessor@88] - Shutting down\n2015-08-14 15:41:18,561 [myid:100] - INFO  [SyncThread:100:CommitProcessor@356] - Shutting down\n2015-08-14 15:41:18,561 [myid:100] - INFO  [CommitProcessor:100:CommitProcessor@191] - CommitProcessor exited loop!\n2015-08-14 15:41:18,562 [myid:100] - INFO  [SyncThread:100:Leader$ToBeAppliedRequestProcessor@915] - Shutting down\n2015-08-14 15:41:18,562 [myid:100] - INFO  [SyncThread:100:FinalRequestProcessor@646] - shutdown of request processor complete\n2015-08-14 15:41:18,562 [myid:100] - INFO  [SyncThread:100:SyncRequestProcessor@191] - Shutting down\n2015-08-14 15:41:18,563 [myid:100] - INFO  [ProcessThread(sid:100 cport:-1)::PrepRequestProcessor@159] - PrepRequestProcessor exited loop!\n{code}\nAfter this exception Leader server still remains leader. After this non recoverable exception the leader should go down and let other followers become leader.\n"
        }
    }
]