[
    {
        "filename": "AMQ-6548.json",
        "creation_time": "2016-12-21T12:04:12.000+0000",
        "bug_report": {
            "Title": "Commit messages on exception",
            "Description": "The application encounters an error when attempting to process messages in a message-driven bean (MDB) due to the EJB component being unavailable as it is shutting down. This issue arises during the lifecycle management of the EJB, specifically when the component is expected to handle incoming messages but is not in an active state. The stack trace indicates that the error occurs within the EJB invocation process, highlighting the need for proper lifecycle management and error handling in the context of message processing.",
            "StackTrace": [
                "2016-12-15 16:12:58,831 ERROR [org.jboss.as.ejb3.invocation.processInvocation] (default-threads - 23) WFLYEJB0034: EJB Invocation failed on component test.test.mdb for method public void test.test.onMessage(javax.jms.Message): org.jboss.as.ejb3.component.EJBComponentUnavailableException: WFLYEJB0421: Invocation cannot proceed as component is shutting down",
                "at org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory$1.processInvocation(ShutDownInterceptorFactory.java:59)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.as.ejb3.deployment.processors.EjbSuspendInterceptor.processInvocation(EjbSuspendInterceptor.java:53)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.as.ejb3.component.interceptors.LoggingInterceptor.processInvocation(LoggingInterceptor.java:66)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.as.ee.component.NamespaceContextInterceptor.processInvocation(NamespaceContextInterceptor.java:50)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor.processInvocation(AdditionalSetupInterceptor.java:54)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription$5$1.processInvocation(MessageDrivenComponentDescription.java:213)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.invocation.ContextClassLoaderInterceptor.processInvocation(ContextClassLoaderInterceptor.java:64)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)",
                "at org.wildfly.security.manager.WildFlySecurityManager.doChecked(WildFlySecurityManager.java:634)",
                "at org.jboss.invocation.AccessCheckingInterceptor.processInvocation(AccessCheckingInterceptor.java:61)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.invocation.InterceptorContext.run(InterceptorContext.java:356)",
                "at org.jboss.invocation.PrivilegedWithCombinerInterceptor.processInvocation(PrivilegedWithCombinerInterceptor.java:80)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)",
                "at org.jboss.as.ee.component.ViewService$View.invoke(ViewService.java:195)",
                "at org.jboss.as.ee.component.ViewDescription$1.processInvocation(ViewDescription.java:185)",
                "at org.jboss.invocation.InterceptorContext.proceed(InterceptorContext.java:340)",
                "at org.jboss.invocation.ChainedInterceptor.processInvocation(ChainedInterceptor.java:61)",
                "at org.jboss.as.ee.component.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:73)",
                "at test.test$$$view19.onMessage(Unknown Source)",
                "at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
                "at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)",
                "at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)",
                "at java.lang.reflect.Method.invoke(Method.java:498)",
                "at org.jboss.as.ejb3.inflow.MessageEndpointInvocationHandler.doInvoke(MessageEndpointInvocationHandler.java:139)",
                "at org.jboss.as.ejb3.inflow.AbstractInvocationHandler.invoke(AbstractInvocationHandler.java:73)",
                "at test.test$$$endpoint12.onMessage(Unknown Source)",
                "at org.apache.activemq.ra.MessageEndpointProxy$MessageEndpointAlive.onMessage(MessageEndpointProxy.java:123)",
                "at org.apache.activemq.ra.MessageEndpointProxy.onMessage(MessageEndpointProxy.java:64)",
                "at org.apache.activemq.ActiveMQSession.run(ActiveMQSession.java:1041)",
                "at org.apache.activemq.ra.ServerSessionImpl.run(ServerSessionImpl.java:169)",
                "at org.jboss.jca.core.workmanager.WorkWrapper.run(WorkWrapper.java:226)",
                "at org.jboss.threads.SimpleDirectExecutor.execute(SimpleDirectExecutor.java:33)",
                "at org.jboss.threads.QueueExecutor.runTask(QueueExecutor.java:808)",
                "at org.jboss.threads.QueueExecutor.access$100(QueueExecutor.java:45)",
                "at org.jboss.threads.QueueExecutor$Worker.run(QueueExecutor.java:828)",
                "at java.lang.Thread.run(Thread.java:745)",
                "at org.jboss.threads.JBossThread.run(JBossThread.java:320)"
            ],
            "RootCause": "The root cause of the issue is that the EJB component is shutting down, which prevents it from processing incoming messages. This is indicated by the EJBComponentUnavailableException in the stack trace.",
            "StepsToReproduce": [
                "Deploy the application with the MDB configured.",
                "Trigger the shutdown of the EJB component while it is expected to process messages.",
                "Send a message to the MDB queue."
            ],
            "ExpectedBehavior": "The MDB should process incoming messages without errors, even during component lifecycle transitions.",
            "ObservedBehavior": "The application throws an EJBComponentUnavailableException when attempting to process messages, indicating that the component is shutting down.",
            "Suggestions": "Review the EJB lifecycle management to ensure that the component is not shutting down while messages are still being processed. Implement error handling to manage message processing during component shutdown.",
            "problem_location": {
                "files": [
                    "EJBComponentLifecycleManager.java",
                    "MessageDrivenComponentDescription.java"
                ],
                "classes": [
                    "org.jboss.as.ejb3.component.EJBComponentLifecycleManager",
                    "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"
                ],
                "methods": [
                    "EJBComponentLifecycleManager.start",
                    "MessageDrivenComponentDescription.processInvocation"
                ]
            },
            "possible_fix": "Consider implementing a mechanism to delay the shutdown of the EJB component until all messages have been processed. This may involve checking the message queue state before allowing the component to shut down."
        },
        "possible_fix_code": {
            "EJBComponentLifecycleManager.start": "public void start() {\n    // Check if the component is shutting down before starting\n    if (isShuttingDown()) {\n        // Log a warning and return to prevent starting\n        logger.warn(\"EJB component is shutting down, cannot start.\");\n        return;\n    }\n    // Proceed with the normal start process\n    // Initialize resources and set the component to active state\n    this.active = true;\n    // Additional startup logic here\n}"
        }
    },
    {
        "filename": "AMQ-3434.json",
        "creation_time": "2011-08-03T09:15:05.000+0000",
        "bug_report": {
            "Title": "Contention in PLIist creation results in NPE on load - FilePendingMessageCursor",
            "Description": "The issue arises intermittently during the loading of the DiskList in the FilePendingMessageCursor, leading to a NullPointerException (NPE). The stack trace indicates that the NPE occurs in the ListIndex class, specifically in the loadNode method when attempting to access a page that has not been properly initialized. This is likely due to an uninitialized or invalid headPageId, which is crucial for loading the initial page in the ListIndex.",
            "StackTrace": [
                "java.lang.NullPointerException",
                "at org.apache.kahadb.index.ListIndex.loadNode(ListIndex.java:203)",
                "at org.apache.kahadb.index.ListIndex.load(ListIndex.java:75)",
                "at org.apache.activemq.store.kahadb.plist.PListStore$1.execute(PListStore.java:219)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:729)",
                "at org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:216)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:454)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:432)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.tryAddMessageLast(FilePendingMessageCursor.java:217)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.addMessageLast(FilePendingMessageCursor.java:193)",
                "at org.apache.activemq.broker.region.Queue.sendMessage(Queue.java:1629)",
                "at org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:720)",
                "at org.apache.activemq.broker.region.Queue.send(Queue.java:652)",
                "at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:379)",
                "at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:523)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)",
                "at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)",
                "at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:304)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)",
                "at org.apache.activemq.broker.UserIDBroker.send(UserIDBroker.java:56)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)",
                "at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:468)",
                "at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:316)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:180)",
                "at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)",
                "at org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:81)",
                "at org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:140)",
                "at org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.onStompSend:257)",
                "at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.onStompCommand:178)",
                "at org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:70)",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:221)",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:203)",
                "at java.lang.Thread.run(Thread.java:662)"
            ],
            "RootCause": "The NullPointerException is likely caused by an uninitialized or invalid headPageId in the ListIndex class, which is essential for loading the initial page. If headPageId is not properly set before the load method is called, the transaction will fail to load the corresponding page, resulting in a null reference.",
            "StepsToReproduce": [
                "Start the ActiveMQ broker.",
                "Send messages to the queue associated with the FilePendingMessageCursor.",
                "Trigger the loading of the DiskList in the FilePendingMessageCursor.",
                "Observe the logs for the occurrence of the NullPointerException."
            ],
            "ExpectedBehavior": "The system should successfully load the DiskList without throwing a NullPointerException, allowing messages to be processed correctly.",
            "ObservedBehavior": "The system throws a NullPointerException during the loading of the DiskList, preventing messages from being processed and causing potential message loss.",
            "Suggestions": "Ensure that headPageId is properly initialized before the load method is called. Verify that the Transaction object is correctly set up and can load pages as expected. Investigate any configuration or setup processes that might influence the state of headPageId and the transaction.",
            "problem_location": {
                "files": [
                    "kahadb/src/main/java/org/apache/kahadb/index/ListIndex.java",
                    "activemq-core/src/main/java/org/apache/activemq/broker/region/cursors/FilePendingMessageCursor.java"
                ],
                "classes": [
                    "org.apache.kahadb.index.ListIndex",
                    "org.apache.activemq.broker.region.cursors.FilePendingMessageCursor"
                ],
                "methods": [
                    "ListIndex.load",
                    "ListIndex.loadNode",
                    "FilePendingMessageCursor.getDiskList"
                ]
            },
            "possible_fix": "Check the initialization of headPageId in the ListIndex class constructor and ensure it is set correctly before invoking the load method. Additionally, review the Transaction management to ensure it is properly configured to handle page loading."
        },
        "possible_fix_code": {
            "org.apache.kahadb.index.ListIndex.load": "    synchronized public void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            LOG.debug(\"loading\");\n            if( keyMarshaller == null ) {\n                throw new IllegalArgumentException(\"The key marshaller must be set before loading the ListIndex\");\n            }\n            if( valueMarshaller == null ) {\n                throw new IllegalArgumentException(\"The value marshaller must be set before loading the ListIndex\");\n            }\n            \n            // Check if headPageId is valid before loading\n            if (headPageId <= 0) {\n                throw new IllegalStateException(\"headPageId is not properly initialized.\");\n            }\n            \n            final Page<ListNode<Key,Value>> p = tx.load(headPageId, null);\n            if( p.getType() == Page.PAGE_FREE_TYPE ) {\n                 // Need to initialize it..\n                ListNode<Key, Value> root = createNode(p);\n                storeNode(tx, root, true);\n                tailPageId = headPageId = p.getPageId();\n            } else {\n                ListNode<Key, Value> node = loadNode(tx, headPageId);\n                size.addAndGet(node.size(tx));\n                while (node.getNext() != -1) {\n                    node = loadNode(tx, node.getNext());\n                    size.addAndGet(node.size(tx));\n                    tailPageId = node.getPageId();\n                }\n            }\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3443.json",
        "creation_time": "2011-08-09T17:46:14.000+0000",
        "bug_report": {
            "Title": "Checkpoint contention with large transaction write using temp file",
            "Description": "Intermittent unit test failure observed in the `AMQ2149KahaDBTest` class, specifically in the `testQueueTransactionalOrderWithRestart` method. The failure is caused by a `FileNotFoundException` indicating that a temporary recovery file could not be created due to its absence in the specified directory. This issue is likely related to the KahaDB storage mechanism used by ActiveMQ, which is responsible for managing message persistence. The error suggests potential problems with directory creation, file deletion, or permission settings.",
            "StackTrace": [
                "2011-08-09 05:25:21,468 [eckpoint Worker] - ERROR MessageDatabase - Checkpoint failed",
                "java.io.IOException: Cannot create recovery file. Reason: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)",
                "at org.apache.kahadb.util.IOExceptionSupport.create(IOExceptionSupport.java:27)",
                "at org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1002)",
                "at org.apache.kahadb.page.PageFile.flush(PageFile.java:482)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1167)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$10.execute(MessageDatabase.java:728)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:762)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:726)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:714)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:279)",
                "Caused by: java.io.FileNotFoundException: target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB/tx-7648-1312867516460.tmp (No such file or directory)",
                "at java.io.RandomAccessFile.open(Native Method)",
                "at java.io.RandomAccessFile.<init>(RandomAccessFile.java:212)",
                "at org.apache.kahadb.page.PageFile$PageWrite.getDiskBound(PageFile.java:185)",
                "at org.apache.kahadb.page.PageFile.writeBatch(PageFile.java:1000)"
            ],
            "RootCause": "The root cause of the issue is a `FileNotFoundException` triggered when the system attempts to create a temporary recovery file for KahaDB, which indicates that the specified directory does not exist or is inaccessible due to permission issues.",
            "StepsToReproduce": [
                "Run the unit test `AMQ2149KahaDBTest`.",
                "Ensure that the KahaDB directory structure is correctly set up at `target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB`.",
                "Verify that the application has the necessary permissions to create files in the specified directory."
            ],
            "ExpectedBehavior": "The system should successfully create the temporary recovery file in the specified KahaDB directory without encountering any `FileNotFoundException` errors.",
            "ObservedBehavior": "The system fails to create the temporary recovery file, resulting in a `FileNotFoundException` and causing the unit test to fail intermittently.",
            "Suggestions": "Check the KahaDB configuration in ActiveMQ to ensure that the directory exists and that the application has the necessary permissions to access and write to it. Additionally, verify that the directory structure is correctly set up before running the tests.",
            "problem_location": {
                "files": [
                    "MessageDatabase.java",
                    "PageFile.java"
                ],
                "classes": [
                    "org.apache.activemq.store.kahadb.MessageDatabase",
                    "org.apache.kahadb.page.PageFile"
                ],
                "methods": [
                    "MessageDatabase.checkpointUpdate",
                    "PageFile.writeBatch"
                ]
            },
            "possible_fix": "Ensure that the directory `target/testQueueTransactionalOrderWithRestart/testQueueTransactionalOrderWithRestart/KahaDB` is created before running the tests. Additionally, check and adjust the file system permissions to allow the application to create and write files in this directory."
        },
        "possible_fix_code": {
            "activemq-core.src.main.java.org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate": "    void checkpointUpdate(Transaction tx, Journal journal, boolean cleanup) throws IOException {\n        LOG.debug(\"Checkpoint started.\");\n\n        // Ensure the KahaDB directory exists\n        File dbDirectory = new File(directory, \"KahaDB\");\n        if (!dbDirectory.exists()) {\n            if (!dbDirectory.mkdirs()) {\n                throw new IOException(\"Failed to create KahaDB directory: \" + dbDirectory.getAbsolutePath());\n            }\n        }\n\n        // reflect last update exclusive of current checkpoint\n        Location firstTxLocation = metadata.lastUpdate;\n\n        metadata.state = OPEN_STATE;\n        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit(journal);\n        metadata.firstInProgressTransactionLocation = getFirstInProgressTxLocation();\n        tx.store(metadata.page, metadataMarshaller, true);\n        pageFile.flush();\n\n        if (cleanup) {\n\n            final TreeSet<Integer> completeFileSet = new TreeSet<Integer>(journal.getFileMap().keySet());\n            final TreeSet<Integer> gcCandidateSet = new TreeSet<Integer>(completeFileSet);\n\n            LOG.trace(\"Last update: \" + firstTxLocation + \", full gc candidates set: \" + gcCandidateSet);\n\n            // Don\u2019t GC files under replication\n            if (journalFilesBeingReplicated != null) {\n                gcCandidateSet.removeAll(journalFilesBeingReplicated);\n            }\n\n            if (metadata.producerSequenceIdTrackerLocation != null) {\n                gcCandidateSet.remove(metadata.producerSequenceIdTrackerLocation.getDataFileId());\n            }\n\n            // Don\u2019t GC files after the first in progress tx\n            if (metadata.firstInProgressTransactionLocation != null) {\n                if (metadata.firstInProgressTransactionLocation.getDataFileId() < firstTxLocation.getDataFileId()) {\n                    firstTxLocation = metadata.firstInProgressTransactionLocation;\n                }\n            }\n\n            if (firstTxLocation != null) {\n                while (!gcCandidateSet.isEmpty()) {\n                    Integer last = gcCandidateSet.last();\n                    if (last >= firstTxLocation.getDataFileId()) {\n                        gcCandidateSet.remove(last);\n                    } else {\n                        break;\n                    }\n                }\n                LOG.trace(\"gc candidates after first tx:\" + firstTxLocation + \", \" + gcCandidateSet);\n            }\n\n            // Go through all the destinations to see if any of them can remove GC candidates.\n            for (Entry<String, StoredDestination> entry : storedDestinations.entrySet()) {\n                if (gcCandidateSet.isEmpty()) {\n                    break;\n                }\n\n                // Use a visitor to cut down the number of pages that we load\n                entry.getValue().locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                    int last = -1;\n\n                    public boolean isInterestedInKeysBetween(Location first, Location second) {\n                        if (first == null) {\n                            SortedSet<Integer> subset = gcCandidateSet.headSet(second.getDataFileId() + 1);\n                            if (!subset.isEmpty() && subset.last() == second.getDataFileId()) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else if (second == null) {\n                            SortedSet<Integer> subset = gcCandidateSet.tailSet(first.getDataFileId());\n                            if (!subset.isEmpty() && subset.first() == first.getDataFileId()) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        } else {\n                            SortedSet<Integer> subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId() + 1);\n                            if (!subset.isEmpty() && subset.first() == first.getDataFileId()) {\n                                subset.remove(first.getDataFileId());\n                            }\n                            if (!subset.isEmpty() && subset.last() == second.getDataFileId()) {\n                                subset.remove(second.getDataFileId());\n                            }\n                            return !subset.isEmpty();\n                        }\n                    }\n\n                    public void visit(List<Location> keys, List<Long> values) {\n                        for (Location l : keys) {\n                            int fileId = l.getDataFileId();\n                            if (last != fileId) {\n                                gcCandidateSet.remove(fileId);\n                                last = fileId;\n                            }\n                        }\n                    }\n                });\n                LOG.trace(\"gc candidates after dest:\" + entry.getKey() + \", \" + gcCandidateSet);\n            }\n\n            // check we are not deleting file with ack for in-use journal files\n            LOG.trace(\"gc candidates: \" + gcCandidateSet);\n            final TreeSet<Integer> gcCandidates = new TreeSet<Integer>(gcCandidateSet);\n            Iterator<Integer> candidates = gcCandidateSet.iterator();\n            while (candidates.hasNext()) {\n                Integer candidate = candidates.next();\n                Set<Integer> referencedFileIds = ackMessageFileMap.get(candidate);\n                if (referencedFileIds != null) {\n                    for (Integer referencedFileId : referencedFileIds) {\n                        if (completeFileSet.contains(referencedFileId) && !gcCandidates.contains(referencedFileId)) {\n                            // active file that is not targeted for deletion is referenced so don\u2019t delete\n                            candidates.remove();\n                            break;\n                        }\n                    }\n                    if (gcCandidateSet.contains(candidate)) {\n                        ackMessageFileMap.remove(candidate);\n                    } else {\n                        LOG.trace(\"not removing data file: \" + candidate\n                                + \" as contained ack(s) refer to referenced file: \" + referencedFileIds);\n                    }\n                }\n            }\n\n            if (!gcCandidateSet.isEmpty()) {\n                LOG.debug(\"Cleanup removing the data files: \" + gcCandidateSet);\n                journal.removeDataFiles(gcCandidateSet);\n            }\n        }\n\n        LOG.debug(\"Checkpoint done.\");\n    }"
        }
    },
    {
        "filename": "AMQ-4369.json",
        "creation_time": "2013-03-13T13:51:31.000+0000",
        "bug_report": {
            "Title": "Default IOException handler needs to be set before Persistence adapter and network connectors are started",
            "Description": "An IOException is encountered during input/output operations, specifically when reading from a RandomAccessFile. This occurs because the default IOExceptionHandler is not registered before the persistence adapter and network connectors are initialized, leading to unhandled IO exceptions. The stack trace indicates that the IOException is thrown during the execution of the readPage method in the PageFile class, which is invoked by the Transaction class during its load process.",
            "StackTrace": [
                "java.io.IOException: Input/output error",
                "at java.io.RandomAccessFile.readBytes(Native Method)",
                "at java.io.RandomAccessFile.read(RandomAccessFile.java:355)",
                "at java.io.RandomAccessFile.readFully(RandomAccessFile.java:414)",
                "at java.io.RandomAccessFile.readFully(RandomAccessFile.java:394)",
                "at org.apache.kahadb.page.PageFile.readPage(PageFile.java:833)",
                "at org.apache.kahadb.page.Transaction.load(Transaction.java:411)",
                "at org.apache.kahadb.page.Transaction.load(Transaction.java:368)",
                "at org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)",
                "at org.apache.kahadb.index.BTreeIndex.getRoot(BTreeIndex.java:174)",
                "at org.apache.kahadb.index.BTreeIndex.remove(BTreeIndex.java:194)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.updateIndex(MessageDatabase.java:1212)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1026)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:865)",
                "at org.apache.activemq.broker.region.Queue.acknowledge(Queue.java:830)"
            ],
            "RootCause": "The IOException is likely caused by the absence of a registered IOExceptionHandler before the persistence adapter and network connectors are started, leading to unhandled IO exceptions during file operations.",
            "StepsToReproduce": [
                "Start the application without setting a default IOExceptionHandler.",
                "Attempt to perform operations that involve file reading/writing, such as starting the persistence adapter or network connectors."
            ],
            "ExpectedBehavior": "The system should handle IO exceptions gracefully by invoking the registered IOExceptionHandler, allowing for proper error management and recovery.",
            "ObservedBehavior": "The system logs an unhandled IOException, indicating that no IOExceptionHandler is registered, which leads to potential data loss or corruption.",
            "Suggestions": "Ensure that the default IOExceptionHandler is set before initializing the persistence adapter and network connectors. This can be done by modifying the initialization sequence in the application startup code.",
            "problem_location": {
                "files": [
                    "activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/PageFile.java",
                    "activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/Transaction.java"
                ],
                "classes": [
                    "org.apache.kahadb.page.PageFile",
                    "org.apache.kahadb.page.Transaction"
                ],
                "methods": [
                    "PageFile.readPage",
                    "Transaction.load"
                ]
            },
            "possible_fix": "Modify the application startup sequence to ensure that the default IOExceptionHandler is registered before any file operations are performed. This may involve adding a configuration step in the initialization code."
        },
        "possible_fix_code": {
            "PageFile.load": "    public void load() throws IOException, IllegalStateException {\n        if (loaded.compareAndSet(false, true)) {\n\n            // Ensure the default IOExceptionHandler is set before any file operations\n            setDefaultIOExceptionHandler();\n\n            if (enablePageCaching) {\n                if (isUseLFRUEviction()) {\n                    pageCache = Collections.synchronizedMap(new LFUCache<Long, Page>(pageCacheSize, getLFUEvictionFactor()));\n                } else {\n                    pageCache = Collections.synchronizedMap(new LRUCache<Long, Page>(pageCacheSize, pageCacheSize, 0.75f, true));\n                }\n            }\n\n            File file = getMainPageFile();\n            IOHelper.mkdirs(file.getParentFile());\n            writeFile = new RandomAccessFile(file, \"rw\");\n            readFile = new RandomAccessFile(file, \"r\");\n\n            if (readFile.length() > 0) {\n                // Load the page size setting cause that can't change once the file is created.\n                loadMetaData();\n                pageSize = metaData.getPageSize();\n            } else {\n                // Store the page size setting cause that can't change once the file is created.\n                metaData = new MetaData();\n                metaData.setFileType(PageFile.class.getName());\n                metaData.setFileTypeVersion(\"1\");\n                metaData.setPageSize(getPageSize());\n                metaData.setCleanShutdown(true);\n                metaData.setFreePages(-1);\n                metaData.setLastTxId(0);\n                storeMetaData();\n            }\n\n            if (enableRecoveryFile) {\n                recoveryFile = new RandomAccessFile(getRecoveryFile(), \"rw\");\n            }\n\n            if (metaData.isCleanShutdown()) {\n                nextTxid.set(metaData.getLastTxId() + 1);\n                if (metaData.getFreePages() > 0) {\n                    loadFreeList();\n                }\n            } else {\n                LOG.debug(toString() + \", Recovering page file...\");\n                nextTxid.set(redoRecoveryUpdates());\n\n                // Scan all to find the free pages.\n                freeList = new SequenceSet();\n                for (Iterator<Page> i = tx().iterator(true); i.hasNext(); ) {\n                    Page page = i.next();\n                    if (page.getType() == Page.PAGE_FREE_TYPE) {\n                        freeList.add(page.getPageId());\n                    }\n                }\n            }\n\n            metaData.setCleanShutdown(false);\n            storeMetaData();\n            getFreeFile().delete();\n\n            if (writeFile.length() < PAGE_FILE_HEADER_SIZE) {\n                writeFile.setLength(PAGE_FILE_HEADER_SIZE);\n            }\n            nextFreePageId.set((writeFile.length() - PAGE_FILE_HEADER_SIZE) / pageSize);\n            startWriter();\n\n        } else {\n            throw new IllegalStateException(\"Cannot load the page file when it is already loaded.\");\n        }\n    }\n\n    private void setDefaultIOExceptionHandler() {\n        // Implementation to set the default IOExceptionHandler\n        // This could involve registering a handler that logs or manages IOExceptions appropriately.\n    }"
        }
    },
    {
        "filename": "AMQ-5016.json",
        "creation_time": "2014-02-03T16:40:26.000+0000",
        "bug_report": {
            "Title": "BitArrayBin doesn't work well with index larger than Integer.MAX_VALUE",
            "Description": "The issue arises in the BitArrayBin class, where the index is represented as a long, while the firstIndex variable, which indicates the starting point of the window, is an int. When the index exceeds Integer.MAX_VALUE, the methods setBit() and getBit() return incorrect values. This defect significantly impacts the performance of the ActiveMQ client, particularly when processing messages with sequence IDs larger than the maximum integer value. The system experiences excessive delays due to window shifting, leading to blocked consumer threads. The provided stack trace illustrates the problematic behavior during message auditing.",
            "StackTrace": [
                "\"ActiveMQ Session Task-869879\" prio=10 tid=0x00007f412d6ee000 nid=0x3cbe runnable [0x00007f405b7b6000]",
                "java.lang.Thread.State: RUNNABLE",
                "at java.util.LinkedList.linkLast(LinkedList.java:140)",
                "at java.util.LinkedList.add(LinkedList.java:336)",
                "at org.apache.activemq.util.BitArrayBin.getBitArray(BitArrayBin.java:123)",
                "at org.apache.activemq.util.BitArrayBin.setBit(BitArrayBin.java:59)",
                "at org.apache.activemq.ActiveMQMessageAuditNoSync.isDuplicate(ActiveMQMessageAuditNoSync.java:160)",
                "at org.apache.activemq.ActiveMQMessageAudit.isDuplicate(ActiveMQMessageAudit.java:59)",
                "at org.apache.activemq.ActiveMQMessageAuditNoSync.isDuplicate(ActiveMQMessageAuditNoSync.java:140)",
                "at org.apache.activemq.ConnectionAudit.isDuplicate(ConnectionAudit.java:52)",
                "at org.apache.activemq.ActiveMQConnection.isDuplicate(ActiveMQConnection.java:2291)",
                "at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1223)",
                "at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:134)",
                "at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:205)",
                "at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:127)",
                "at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:48)",
                "at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)",
                "at java.lang.Thread.run(Thread.java:722)"
            ],
            "RootCause": "The root cause of the issue is the mismatch in data types between the index (long) and firstIndex (int) in the BitArrayBin class. This leads to incorrect calculations and behavior when the index exceeds Integer.MAX_VALUE.",
            "StepsToReproduce": [
                "1. Create an instance of BitArrayBin.",
                "2. Attempt to set a bit using an index greater than Integer.MAX_VALUE.",
                "3. Observe the return values from setBit() and getBit() methods."
            ],
            "ExpectedBehavior": "The setBit() and getBit() methods should correctly handle indices larger than Integer.MAX_VALUE without returning incorrect values.",
            "ObservedBehavior": "When the index exceeds Integer.MAX_VALUE, setBit() and getBit() return incorrect values, leading to performance degradation and blocking of consumer threads.",
            "Suggestions": "Refactor the BitArrayBin class to ensure that both the index and firstIndex variables are of the same type (long) to prevent overflow issues. Additionally, consider implementing checks to handle cases where the index exceeds Integer.MAX_VALUE gracefully.",
            "problem_location": {
                "files": [
                    "BitArrayBin.java"
                ],
                "classes": [
                    "org.apache.activemq.util.BitArrayBin"
                ],
                "methods": [
                    "BitArrayBin.setBit",
                    "BitArrayBin.getBit"
                ]
            },
            "possible_fix": "Change the type of firstIndex from int to long in the BitArrayBin class to ensure consistent handling of large indices. Example modification:\n\n```java\nprivate long firstIndex;\n```"
        },
        "possible_fix_code": {
            "BitArrayBin.setBit": "    public boolean setBit(long index, boolean value) {\n        boolean answer = false;\n        BitArray ba = getBitArray(index);\n        if (ba != null) {\n            int offset = getOffset(index);\n            if (offset >= 0) {\n                answer = ba.set(offset, value);\n            }\n        }\n        return answer;\n    }",
            "BitArrayBin.getOffset": "    private int getOffset(long index) {\n        int answer = 0;\n        if (firstIndex >= 0) {\n            answer = (int)((index - firstIndex) - (BitArray.LONG_SIZE * getBin(index)));\n        }\n        return answer;\n    }",
            "BitArrayBin.getBin": "    private int getBin(long index) {\n        int answer = 0;\n        if (firstIndex < 0) {\n            firstIndex = (int) (index - (index % BitArray.LONG_SIZE));\n        } else if (firstIndex >= 0) {\n            answer = (int)((index - firstIndex) / BitArray.LONG_SIZE);\n        }\n        return answer;\n    }",
            "BitArrayBin.getBitArray": "    private BitArray getBitArray(long index) {\n        int bin = getBin(index);\n        BitArray answer = null;\n        if (bin >= 0) {\n            if (bin >= maxNumberOfArrays) {\n                int overShoot = bin - maxNumberOfArrays + 1;\n                while (overShoot > 0) {\n                    list.removeFirst();\n                    firstIndex += BitArray.LONG_SIZE;\n                    list.add(new BitArray());\n                    overShoot--;\n                }\n                \n                bin = maxNumberOfArrays - 1;\n            }\n            answer = list.get(bin);\n            if (answer == null) {\n                answer = new BitArray();\n                list.set(bin, answer);\n            }\n        }\n        return answer;\n    }"
        }
    },
    {
        "filename": "AMQ-4407.json",
        "creation_time": "2013-03-26T15:41:15.000+0000",
        "bug_report": {
            "Title": "mKahaDB: PageFile is not loaded when recreating queue",
            "Description": "The issue arises when using mKahaDB to create a queue, delete it via the admin interface, and then attempt to recreate it. An error is encountered indicating that the PageFile is not loaded, which suggests that the KahaDB storage mechanism is not properly initialized or that the PageFile has not been loaded correctly before operations are attempted on it.",
            "StackTrace": [
                "2013-03-08 10:29:17,903 | WARN  | Async error occurred: java.lang.IllegalStateException: PageFile is not loaded | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: tcp:///0:0:0:0:0:0:0:1%0:65222@61613",
                "java.lang.IllegalStateException: PageFile is not loaded",
                "\tat org.apache.activemq.store.kahadb.disk.page.PageFile.assertLoaded(PageFile.java:809)",
                "\tat org.apache.activemq.store.kahadb.disk.page.PageFile.tx(PageFile.java:303)",
                "\tat org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.getMessageCount(KahaDBStore.java:478)",
                "\tat org.apache.activemq.store.ProxyMessageStore.getMessageCount(ProxyMessageStore.java:101)",
                "\tat org.apache.activemq.broker.region.Queue.initialize(Queue.java:376)",
                "\tat org.apache.activemq.broker.region.DestinationFactoryImpl.createDestination(DestinationFactoryImpl.java:87)",
                "\tat org.apache.activemq.broker.region.AbstractRegion.createDestination(AbstractRegion.java:526)",
                "\tat org.apache.activemq.broker.region.RegionBroker.addDestination(RegionBroker.java:277)",
                "\tat org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)",
                "\tat org.apache.activemq.broker.MutableBrokerFilter.addDestination(MutableBrokerFilter.java:151)",
                "\tat org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:387)",
                "\tat org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:282)",
                "\tat org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)",
                "\tat org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:317)",
                "\tat org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)",
                "\tat org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:499)",
                "\tat org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:749)",
                "\tat org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:329)",
                "\tat org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:184)",
                "\tat org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:45)",
                "\tat org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)",
                "\tat org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:84)",
                "\tat org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:195)",
                "\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:321)",
                "\tat org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:233)",
                "\tat org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:73)",
                "\tat org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "\tat org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)",
                "\tat org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)",
                "\tat java.lang.Thread.run(Thread.java:680)",
                "2013-03-08 10:29:17,905 | WARN  | Exception occurred processing: \nnull: java.lang.IllegalStateException: PageFile is not loaded | org.apache.activemq.transport.stomp.ProtocolConverter | ActiveMQ Connection Dispatcher: tcp://0:0:0:0:0:0:0:1%0:65222"
            ],
            "RootCause": "The root cause of the issue is that the PageFile is not loaded when the application attempts to access it. This indicates a failure in the initialization process of the KahaDB storage mechanism, which is expected to load the PageFile before any operations are performed on it.",
            "StepsToReproduce": [
                "1. Create a queue using mKahaDB.",
                "2. Delete the queue through the admin interface.",
                "3. Attempt to recreate the queue."
            ],
            "ExpectedBehavior": "The queue should be recreated successfully without any errors, indicating that the PageFile is properly loaded and accessible.",
            "ObservedBehavior": "An IllegalStateException is thrown, indicating that the PageFile is not loaded, preventing the queue from being recreated.",
            "Suggestions": "Check the initialization process of the KahaDBStore to ensure that the PageFile is loaded correctly. Verify that the necessary configuration settings for KahaDB are properly set and that the storage mechanism is initialized before attempting to recreate the queue.",
            "problem_location": {
                "files": [
                    "KahaDBStore.java",
                    "PageFile.java"
                ],
                "classes": [
                    "org.apache.activemq.store.kahadb.KahaDBStore",
                    "org.apache.activemq.store.kahadb.disk.page.PageFile"
                ],
                "methods": [
                    "KahaDBStore.initialize",
                    "PageFile.load"
                ]
            },
            "possible_fix": "Ensure that the KahaDBStore's initialization method is called before any operations that require the PageFile. If the method is not found, review the KahaDBStore implementation for any missing initialization logic or configuration settings that may prevent the PageFile from loading."
        },
        "possible_fix_code": {
            "KahaDBStore.initialize": "public void initialize() throws Exception {\n    if (pageFile == null) {\n        pageFile = new PageFile(); // Ensure PageFile is instantiated\n    }\n    pageFile.load(); // Load the PageFile to ensure it is ready for use\n    // Existing initialization logic...\n    if (this.messages == null) {\n        if (destination.isTemporary() || broker == null || store == null) {\n            this.messages = new VMPendingMessageCursor(isPrioritizedMessages());\n        } else {\n            this.messages = new StoreQueueCursor(broker, this);\n        }\n    }\n    // Additional existing initialization logic...\n}"
        }
    },
    {
        "filename": "AMQ-4221.json",
        "creation_time": "2012-12-13T16:15:04.000+0000",
        "bug_report": {
            "Title": "NPE plist (temp) sparse removal - filependingmessagecursor with selector and expiry",
            "Description": "The application encounters a NullPointerException (NPE) during the processing of queue messages in ActiveMQ's KahaDB implementation. The error occurs specifically in the `ListNode` class while attempting to write payloads during message dispatching. The stack trace indicates that the issue arises when the `doPageInForDispatch` method in the `Queue` class attempts to access or manipulate message references that may not be properly initialized, leading to the NPE.",
            "StackTrace": [
                "java.lang.NullPointerException",
                "at org.apache.kahadb.index.ListNode.access$200(ListNode.java:37)",
                "at org.apache.kahadb.index.ListNode$NodeMarshaller.writePayload(ListNode.java:265)",
                "at org.apache.kahadb.index.ListNode$NodeMarshaller.writePayload(ListNode.java:255)",
                "at org.apache.kahadb.page.Transaction.store(Transaction.java:248)",
                "at org.apache.kahadb.index.ListIndex.storeNode(ListIndex.java:326)",
                "at org.apache.kahadb.index.ListNode.store(ListNode.java:332)",
                "at org.apache.kahadb.index.ListNode.access$500(ListNode.java:37)",
                "at org.apache.kahadb.index.ListNode$ListIterator.remove(ListNode.java:227)",
                "at org.apache.activemq.store.kahadb.plist.PList$PListIterator$1.execute(PList.java:229)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:771)",
                "at org.apache.activemq.store.kahadb.plist.PList$PListIterator.remove(PList.java:226)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.remove(FilePendingMessageCursor.java:517)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.remove(FilePendingMessageCursor.java:321)",
                "at org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1735)",
                "at org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1948)",
                "at org.apache.activemq.broker.region.Queue.iterate(Queue.java:1465)",
                "at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)",
                "at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
                "at java.lang.Thread.run(Thread.java:680)"
            ],
            "RootCause": "The NullPointerException is likely caused by uninitialized variables in the `Queue` class, particularly during the execution of the `doPageInForDispatch` method. The method attempts to access message references that may not have been properly initialized or may be null, leading to the exception when trying to manipulate these references.",
            "StepsToReproduce": [
                "1. Start the ActiveMQ broker with KahaDB as the message store.",
                "2. Send a series of messages to a queue.",
                "3. Attempt to remove messages from the queue using a selector and expiry settings.",
                "4. Monitor the logs for any NullPointerException errors."
            ],
            "ExpectedBehavior": "The system should successfully process and remove messages from the queue without encountering any exceptions, ensuring that all message references are properly initialized and managed.",
            "ObservedBehavior": "The system throws a NullPointerException when attempting to remove messages from the queue, indicating that some message references are null or uninitialized.",
            "Suggestions": "Ensure that all message references and related variables in the `Queue` class are properly initialized before they are accessed. Implement null checks where necessary to prevent the NullPointerException from occurring.",
            "problem_location": {
                "files": [
                    "activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.region.Queue"
                ],
                "methods": [
                    "Queue.doPageInForDispatch",
                    "Queue.pageInMessages",
                    "Queue.iterate"
                ]
            },
            "possible_fix": "In the `doPageInForDispatch` method, add null checks for the `messages`, `pagedInPendingDispatch`, and `consumers` variables before they are accessed. Ensure that these variables are initialized in the constructor of the `Queue` class or at the appropriate point in the lifecycle."
        },
        "possible_fix_code": {
            "Queue.doPageInForDispatch": "    private PendingList doPageInForDispatch(boolean force) throws Exception {\n        List<QueueMessageReference> result = null;\n        PendingList resultList = null;\n\n        // Ensure messages, pagedInPendingDispatch, and consumers are initialized\n        if (messages == null || pagedInPendingDispatch == null || consumers == null) {\n            throw new IllegalStateException(\"Queue is not properly initialized.\");\n        }\n\n        int toPageIn = Math.min(getMaxPageSize(), messages.size());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(destination.getPhysicalName() + \" toPageIn: \" + toPageIn + \", Inflight: \"\n                    + destinationStatistics.getInflight().getCount() + \", pagedInMessages.size \"\n                    + pagedInMessages.size() + \", enqueueCount: \" + destinationStatistics.getEnqueues().getCount()\n                    + \", dequeueCount: \" + destinationStatistics.getDequeues().getCount());\n        }\n\n        if (isLazyDispatch() && !force) {\n            // Only page in the minimum number of messages which can be\n            // dispatched immediately.\n            toPageIn = Math.min(getConsumerMessageCountBeforeFull(), toPageIn);\n        }\n        int pagedInPendingSize = 0;\n        pagedInPendingDispatchLock.readLock().lock();\n        try {\n            pagedInPendingSize = pagedInPendingDispatch.size();\n        } finally {\n            pagedInPendingDispatchLock.readLock().unlock();\n        }\n        if (toPageIn > 0 && (force || (!consumers.isEmpty() && pagedInPendingSize < getMaxPageSize()))) {\n            int count = 0;\n            result = new ArrayList<QueueMessageReference>(toPageIn);\n            messagesLock.writeLock().lock();\n            try {\n                try {\n                    messages.setMaxBatchSize(toPageIn);\n                    messages.reset();\n                    while (messages.hasNext() && count < toPageIn) {\n                        MessageReference node = messages.next();\n                        messages.remove();\n\n                        QueueMessageReference ref = createMessageReference(node.getMessage());\n                        if (ref.isExpired()) {\n                            if (broker.isExpired(ref)) {\n                                messageExpired(createConnectionContext(), ref);\n                            } else {\n                                ref.decrementReferenceCount();\n                            }\n                        } else {\n                            result.add(ref);\n                            count++;\n                        }\n                    }\n                } finally {\n                    messages.release();\n                }\n            } finally {\n                messagesLock.writeLock().unlock();\n            }\n            // Only add new messages, not already pagedIn to avoid multiple\n            // dispatch attempts\n            pagedInMessagesLock.writeLock().lock();\n            try {\n                if(isPrioritizedMessages()) {\n                    resultList = new PrioritizedPendingList();\n                } else {\n                    resultList = new OrderedPendingList();\n                }\n                for (QueueMessageReference ref : result) {\n                    if (!pagedInMessages.containsKey(ref.getMessageId())) {\n                        pagedInMessages.put(ref.getMessageId(), ref);\n                        resultList.addMessageLast(ref);\n                    } else {\n                        ref.decrementReferenceCount();\n                    }\n                }\n            } finally {\n                pagedInMessagesLock.writeLock().unlock();\n            }\n        } else {\n            // Avoid return null list, if condition is not validated\n            resultList = new OrderedPendingList();\n        }\n\n        return resultList;\n    }"
        }
    },
    {
        "filename": "AMQ-3622.json",
        "creation_time": "2011-12-06T15:16:49.000+0000",
        "bug_report": {
            "Title": "NPE in LastImageSubscriptionRecoveryPolicy",
            "Description": "A NullPointerException (NPE) occurs in the `LastImageSubscriptionRecoveryPolicy.browse` method when attempting to browse messages from a topic without any messages available. The issue arises when the `lastImage` variable, which is expected to hold a reference to the last message, is `null`. This leads to an exception being thrown when the method tries to access `lastImage.getMessage()`. The NPE is logged repeatedly every 30 seconds until a message is sent to the topic.",
            "StackTrace": [
                "2011-12-02 15:01:00,588 | WARN  | Failed to browse Topic: xxx | org.apache.activemq.broker.region.Topic | ActiveMQ Broker[xxx] Scheduler",
                "java.lang.NullPointerException",
                "\tat org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy.browse(LastImageSubscriptionRecoveryPolicy.java:63)",
                "\tat org.apache.activemq.broker.region.Topic.browse(Topic.java:564)",
                "\tat org.apache.activemq.broker.region.Topic$6.run(Topic.java:659)",
                "\tat org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)",
                "\tat java.util.TimerThread.mainLoop(Timer.java:512)",
                "\tat java.util.TimerThread.run(Timer.java:462)"
            ],
            "RootCause": "The root cause of the NullPointerException is that the `lastImage` variable in the `LastImageSubscriptionRecoveryPolicy` class is not initialized before the `browse` method is called. This can happen if the `add` method, which sets `lastImage`, is not invoked prior to calling `browse`, or if it is called with a null value.",
            "StepsToReproduce": [
                "Start the ActiveMQ broker.",
                "Attempt to browse a topic with no messages available.",
                "Observe the logs for the NullPointerException."
            ],
            "ExpectedBehavior": "The `browse` method should return an empty array of messages when there are no messages available, without throwing any exceptions.",
            "ObservedBehavior": "The `browse` method throws a NullPointerException when attempting to access `lastImage.getMessage()` because `lastImage` is null.",
            "Suggestions": "Ensure that the `add` method is called with a valid `MessageReference` before invoking the `browse` method. Additionally, implement a null check for `lastImage` in the `browse` method to prevent the NPE.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/broker/region/policy/LastImageSubscriptionRecoveryPolicy.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy"
                ],
                "methods": [
                    "LastImageSubscriptionRecoveryPolicy.browse",
                    "LastImageSubscriptionRecoveryPolicy.add"
                ]
            },
            "possible_fix": "Modify the `browse` method to include a null check for `lastImage` before accessing it:\n\npublic Message[] browse(ActiveMQDestination destination) throws Exception {\n    List<Message> result = new ArrayList<Message>();\n    if (lastImage != null && filter.matches(lastImage.getMessage().getDestination())) {\n        result.add(lastImage.getMessage());\n    }\n    return result.toArray(new Message[result.size()]);\n}"
        },
        "possible_fix_code": {
            "LastImageSubscriptionRecoveryPolicy.browse": "    public Message[] browse(ActiveMQDestination destination) throws Exception {\n        List<Message> result = new ArrayList<Message>();\n        DestinationFilter filter = DestinationFilter.parseFilter(destination);\n        if (lastImage != null && filter.matches(lastImage.getMessage().getDestination())) {\n            result.add(lastImage.getMessage());\n        }\n        return result.toArray(new Message[result.size()]);\n    }"
        }
    },
    {
        "filename": "AMQ-6016.json",
        "creation_time": "2015-10-21T12:55:55.000+0000",
        "bug_report": {
            "Title": "java.lang.IllegalArgumentException: Comparison method violates its general contract!",
            "Description": "The issue arises from the `Queue.addToConsumerList` method in the ActiveMQ library, where a comparator named `orderedCompare` is used to sort consumers based on their priority. Under certain conditions, particularly when multiple consumers have the same priority, the comparator fails to maintain the transitive property required by the `Comparator` interface, leading to an `IllegalArgumentException`. This violation typically occurs when the comparator does not handle ties correctly, resulting in inconsistent sorting behavior.",
            "StackTrace": [
                "java.lang.IllegalArgumentException: Comparison method violates its general contract!",
                "at java.util.TimSort.mergeHi(TimSort.java:868)[:1.7.0_65]",
                "at java.util.TimSort.mergeAt(TimSort.java:485)[:1.7.0_65]",
                "at java.util.TimSort.mergeCollapse(TimSort.java:410)[:1.7.0_65]",
                "at java.util.TimSort.sort(TimSort.java:214)[:1.7.0_65]",
                "at java.util.TimSort.sort(TimSort.java:173)[:1.7.0_65]",
                "at java.util.Arrays.sort(Arrays.java:659)[:1.7.0_65]",
                "at java.util.Collections.sort(Collections.java:217)[:1.7.0_65]",
                "at org.apache.activemq.broker.region.Queue.addToConsumerList(Queue.java:2131)[121:org.apache.activemq.activemq-osgi:5.9.0]",
                "at org.apache.activemq.broker.region.Queue.doActualDispatch(Queue.java:2067)[121:org.apache.activemq.activemq-osgi:5.9.0]",
                "at org.apache.activemq.broker.region.Queue.doDispatch(Queue.java:1972)[121:org.apache.activemq.activemq-osgi:5.9.0]"
            ],
            "RootCause": "The root cause of the issue is the `orderedCompare` comparator used in the `Queue.addToConsumerList` method. It fails to maintain the transitive property when comparing consumers with equal priority, particularly in how it handles the assigned message group counts, leading to inconsistent sorting results.",
            "StepsToReproduce": [
                "1. Start the ActiveMQ broker with multiple consumers having the same priority.",
                "2. Trigger a scenario that causes the consumers to be added to the consumer list.",
                "3. Observe the logs for the IllegalArgumentException."
            ],
            "ExpectedBehavior": "The consumers should be sorted correctly based on their priority and assigned message group counts without throwing any exceptions.",
            "ObservedBehavior": "An `IllegalArgumentException` is thrown indicating that the comparison method violates its general contract, disrupting the sorting process.",
            "Suggestions": "Review the implementation of the `orderedCompare` comparator to ensure it adheres to the comparator contract, particularly in handling ties correctly. Consider adding additional checks to maintain consistency when priorities are equal.",
            "problem_location": {
                "files": [
                    "activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.region.Queue"
                ],
                "methods": [
                    "Queue.addToConsumerList",
                    "Queue.orderedCompare"
                ]
            },
            "possible_fix": "Modify the `orderedCompare` comparator to ensure that it correctly handles cases where consumer priorities are equal. For example, ensure that the comparison of assigned group counts is consistent and does not lead to contradictions."
        },
        "possible_fix_code": {
            "addToConsumerList": "    private void addToConsumerList(Subscription sub) {\n        if (useConsumerPriority) {\n            consumers.add(sub);\n            Collections.sort(consumers, new Comparator<Subscription>() {\n                @Override\n                public int compare(Subscription s1, Subscription s2) {\n                    // We want the list sorted in descending order\n                    int val = s2.getConsumerInfo().getPriority() - s1.getConsumerInfo().getPriority();\n                    if (val == 0 && messageGroupOwners != null) {\n                        // then ascending order of assigned message groups to favour less loaded consumers\n                        long x = s1.getConsumerInfo().getAssignedGroupCount();\n                        long y = s2.getConsumerInfo().getAssignedGroupCount();\n                        val = Long.compare(x, y);\n                    }\n                    return val;\n                }\n            });\n        } else {\n            consumers.add(sub);\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3490.json",
        "creation_time": "2011-09-08T20:31:57.000+0000",
        "bug_report": {
            "Title": "NPEs during message processing, using FileCursor",
            "Description": "The application encounters a NullPointerException (NPE) during message processing when using a file cursor to manage a backlog in a single-consumer queue for non-persistent messages. This issue arises particularly during bursts of messages, leading to multiple instances of NPEs as indicated by the stack traces. The root cause appears to be related to the handling of metadata within the PageFile class, specifically during the storage and loading of metadata.",
            "StackTrace": [
                "java.lang.NullPointerException",
                "at java.io.Writer.write(Writer.java:140)",
                "at java.io.BufferedWriter.newLine(BufferedWriter.java:225)",
                "at java.util.Properties.writeComments(Properties.java:671)",
                "at java.util.Properties.store0(Properties.java:805)",
                "at java.util.Properties.store(Properties.java:796)",
                "at org.apache.kahadb.page.PageFile.storeMetaData(PageFile.java:570)",
                "at org.apache.kahadb.page.PageFile.load(PageFile.java:361)",
                "at org.apache.activemq.store.kahadb.plist.PListStore.intialize(PListStore.java:285)",
                "at org.apache.activemq.store.kahadb.plist.PListStore.getPList(PListStore.java:218)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.getDiskList(FilePendingMessageCursor.java:457)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.flushToDisk(FilePendingMessageCursor.java:435)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.onUsageChanged(FilePendingMessageCursor.java:388)",
                "at org.apache.activemq.usage.Usage$1.run(Usage.java:268)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
                "at java.lang.Thread.run(Thread.java:619)"
            ],
            "RootCause": "The NullPointerException is likely caused by the metaData object being null in the storeMetaData method of the PageFile class. This can occur if the loadMetaData method fails to properly initialize metaData, possibly due to issues with the properties being loaded from the file.",
            "StepsToReproduce": [
                "Set up a single-consumer queue for non-persistent messages.",
                "Use a file cursor to manage the backlog.",
                "Send a burst of messages to the queue.",
                "Monitor the logs for NullPointerExceptions."
            ],
            "ExpectedBehavior": "The system should process messages without encountering NullPointerExceptions, successfully writing metadata to the file and managing the message queue.",
            "ObservedBehavior": "The system throws NullPointerExceptions during message processing, particularly when attempting to write metadata to a file, leading to message processing failures.",
            "Suggestions": "Investigate the initialization of the metaData object in the PageFile class. Ensure that the loadMetaData method correctly populates the metaData object before it is accessed in the storeMetaData method. Consider adding null checks and handling for the properties being loaded.",
            "problem_location": {
                "files": [
                    "PageFile.java",
                    "PListStore.java"
                ],
                "classes": [
                    "org.apache.kahadb.page.PageFile",
                    "org.apache.activemq.store.kahadb.plist.PListStore"
                ],
                "methods": [
                    "PageFile.storeMetaData",
                    "PageFile.loadMetaData",
                    "PListStore.intialize"
                ]
            },
            "possible_fix": "Ensure that the loadMetaData method correctly initializes the metaData object. Add checks to handle cases where both v1 and v2 are null, and ensure that properties loaded into these objects are valid before proceeding to store them."
        },
        "possible_fix_code": {
            "PageFile.loadMetaData": "    private void loadMetaData() throws IOException {\n\n        ByteArrayInputStream is;\n        MetaData v1 = new MetaData();\n        MetaData v2 = new MetaData();\n        try {\n            Properties p = new Properties();\n            byte[] d = new byte[PAGE_FILE_HEADER_SIZE/2];\n            readFile.seek(0);\n            readFile.readFully(d);\n            is = new ByteArrayInputStream(d);\n            p.load(is);\n            IntrospectionSupport.setProperties(v1, p);\n        } catch (IOException e) {\n            v1 = null;\n        }\n        \n        try {\n            Properties p = new Properties();\n            byte[] d = new byte[PAGE_FILE_HEADER_SIZE/2];\n            readFile.seek(PAGE_FILE_HEADER_SIZE/2);\n            readFile.readFully(d);\n            is = new ByteArrayInputStream(d);\n            p.load(is);\n            IntrospectionSupport.setProperties(v2, p);\n        } catch (IOException e) {\n            v2 = null;\n        }\n        \n        if( v1==null && v2==null ) {\n            throw new IOException(\"Could not load page file meta data\");\n        } \n        \n        if( v1 == null || v1.metaDataTxId<0 ) {\n            metaData = v2;\n        } else if( v2==null || v1.metaDataTxId<0 ) {\n            metaData = v1;\n        } else if( v1.metaDataTxId==v2.metaDataTxId ) {\n            metaData = v1; // use the first since the 2nd could be a partial..\n        } else {\n            metaData = v2; // use the second cause the first is probably a partial.\n        }\n        \n        // Additional null checks to ensure metaData is not null before proceeding\n        if (metaData == null) {\n            throw new IOException(\"MetaData is null after loading\");\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-6831.json",
        "creation_time": "2017-10-09T10:35:53.000+0000",
        "bug_report": {
            "Title": "Broker fails to start complaining about missing/corrupt journal files after upgrading to 5.15.1",
            "Description": "After upgrading to ActiveMQ version 5.15.1, the broker fails to start due to an IOException indicating missing or corrupt journal files. The error message specifies that 3 messages are affected, which are referenced by the ActiveMQ Dead Letter Queue (DLQ). The issue arises during the recovery process of the KahaDB storage, specifically in the `recoverIndex` method of the `MessageDatabase` class. This method attempts to verify the existence of journal files and handle any corruptions, but fails due to the missing files.",
            "StackTrace": [
                "java.io.IOException: Detected missing/corrupt journal files referenced by:[0:ActiveMQ.DLQ] 3 messages affected.",
                "at org.apache.activemq.store.kahadb.MessageDatabase.recoverIndex(MessageDatabase.java:965)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$5.execute(MessageDatabase.java:717)",
                "at org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.recover(MessageDatabase.java:714)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.open(MessageDatabase.java:473)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.load(MessageDatabase.java:493)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.doStart(MessageDatabase.java:297)",
                "at org.apache.activemq.store.kahadb.KahaDBStore.doStart(KahaDBStore.java:219)",
                "at org.apache.activemq.util.ServiceSupport.start(ServiceSupport.java:55)"
            ],
            "RootCause": "The root cause of the issue is the failure of the `recoverIndex` method in the `MessageDatabase` class to locate the required journal files, leading to an IOException. This occurs because the configuration settings for handling missing journal files are not allowing the broker to start.",
            "StepsToReproduce": [
                "Upgrade ActiveMQ to version 5.15.1.",
                "Start the broker with the current configuration.",
                "Observe the error message regarding missing/corrupt journal files."
            ],
            "ExpectedBehavior": "The broker should start successfully without any errors related to missing or corrupt journal files.",
            "ObservedBehavior": "The broker fails to start and throws an IOException indicating missing or corrupt journal files, specifically affecting 3 messages in the ActiveMQ DLQ.",
            "Suggestions": "1. Verify that all journal files are present in the expected directory. Restore any missing files from a backup if necessary. 2. Review the KahaDB configuration settings, particularly `ignoreMissingJournalfiles` and `checkForCorruptJournalFiles`. Setting `ignoreMissingJournalfiles` to true may allow the broker to start but will drop messages referencing the missing files. 3. Consider running a data integrity check or restoring from a backup if corruption is suspected. 4. Regularly back up journal files to prevent data loss.",
            "problem_location": {
                "files": [
                    "MessageDatabase.java",
                    "KahaDBStore.java"
                ],
                "classes": [
                    "org.apache.activemq.store.kahadb.MessageDatabase",
                    "org.apache.activemq.store.kahadb.KahaDBStore"
                ],
                "methods": [
                    "MessageDatabase.recoverIndex",
                    "KahaDBStore.doStart"
                ]
            },
            "possible_fix": "To resolve the issue, ensure that all required journal files are present. If files are missing, restore them from a backup. Additionally, review and adjust the configuration settings for KahaDB to allow for better handling of missing files, such as setting `ignoreMissingJournalfiles` to true if appropriate."
        },
        "possible_fix_code": {
            "MessageDatabase.recoverIndex": "    protected void recoverIndex(Transaction tx) throws IOException {\n        long start = System.currentTimeMillis();\n        final Location lastAppendLocation = journal.getLastAppendLocation();\n        long undoCounter=0;\n\n        for (String key : storedDestinations.keySet()) {\n            StoredDestination sd = storedDestinations.get(key);\n\n            final ArrayList<Long> matches = new ArrayList<>();\n            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor<Location, Long>(lastAppendLocation) {\n                @Override\n                protected void matched(Location key, Long value) {\n                    matches.add(value);\n                }\n            });\n\n            for (Long sequenceId : matches) {\n                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                if (keys != null) {\n                    sd.locationIndex.remove(tx, keys.location);\n                    sd.messageIdIndex.remove(tx, keys.messageId);\n                    metadata.producerSequenceIdTracker.rollback(keys.messageId);\n                    undoCounter++;\n                    decrementAndSubSizeToStoreStat(key, keys.location.getSize());\n                }\n            }\n        }\n\n        if (undoCounter > 0) {\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Rolled back \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n\n        undoCounter = 0;\n        start = System.currentTimeMillis();\n\n        final SequenceSet ss = new SequenceSet();\n        for (StoredDestination sd : storedDestinations.values()) {\n            sd.locationIndex.visit(tx, new BTreeVisitor<Location, Long>() {\n                int last=-1;\n\n                @Override\n                public boolean isInterestedInKeysBetween(Location first, Location second) {\n                    if( first==null ) {\n                        return !ss.contains(0, second.getDataFileId());\n                    } else if( second==null ) {\n                        return true;\n                    } else {\n                        return !ss.contains(first.getDataFileId(), second.getDataFileId());\n                    }\n                }\n\n                @Override\n                public void visit(List<Location> keys, List<Long> values) {\n                    for (Location l : keys) {\n                        int fileId = l.getDataFileId();\n                        if( last != fileId ) {\n                            ss.add(fileId);\n                            last = fileId;\n                        }\n                    }\n                }\n\n            });\n        }\n        HashSet<Integer> missingJournalFiles = new HashSet<>();\n        while (!ss.isEmpty()) {\n            missingJournalFiles.add((int) ss.removeFirst());\n        }\n\n        for (Entry<Integer, Set<Integer>> entry : metadata.ackMessageFileMap.entrySet()) {\n            missingJournalFiles.add(entry.getKey());\n            for (Integer i : entry.getValue()) {\n                missingJournalFiles.add(i);\n            }\n        }\n\n        missingJournalFiles.removeAll(journal.getFileMap().keySet());\n\n        if (!missingJournalFiles.isEmpty()) {\n            LOG.warn(\"Some journal files are missing: \" + missingJournalFiles);\n        }\n\n        ArrayList<BTreeVisitor.Predicate<Location>> knownCorruption = new ArrayList<>();\n        ArrayList<BTreeVisitor.Predicate<Location>> missingPredicates = new ArrayList<>();\n        for (Integer missing : missingJournalFiles) {\n            missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(missing, 0), new Location(missing + 1, 0)));\n        }\n\n        if (checkForCorruptJournalFiles) {\n            Collection<DataFile> dataFiles = journal.getFileMap().values();\n            for (DataFile dataFile : dataFiles) {\n                int id = dataFile.getDataFileId();\n                missingPredicates.add(new BTreeVisitor.BetweenVisitor<Location, Long>(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));\n                Sequence seq = dataFile.getCorruptedBlocks().getHead();\n                while (seq != null) {\n                    BTreeVisitor.BetweenVisitor<Location, Long> visitor =\n                        new BTreeVisitor.BetweenVisitor<>(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1));\n                    missingPredicates.add(visitor);\n                    knownCorruption.add(visitor);\n                    seq = seq.getNext();\n                }\n            }\n        }\n\n        if (!missingPredicates.isEmpty()) {\n            for (Entry<String, StoredDestination> sdEntry : storedDestinations.entrySet()) {\n                final StoredDestination sd = sdEntry.getValue();\n                final LinkedHashMap<Long, Location> matches = new LinkedHashMap<>();\n                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor<Location, Long>(missingPredicates) {\n                    @Override\n                    protected void matched(Location key, Long value) {\n                        matches.put(value, key);\n                    }\n                });\n\n                if (!matches.isEmpty()) {\n                    if( ignoreMissingJournalfiles ) {\n                        for (Long sequenceId : matches.keySet()) {\n                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);\n                            sd.locationIndex.remove(tx, keys.location);\n                            sd.messageIdIndex.remove(tx, keys.messageId);\n                            LOG.info(\"[\" + sdEntry.getKey() + \"] dropped: \" + keys.messageId + \" at corrupt location: \" + keys.location);\n                            undoCounter++;\n                            decrementAndSubSizeToStoreStat(sdEntry.getKey(), keys.location.getSize());\n                        }\n                    } else {\n                        LOG.error(\"[\" + sdEntry.getKey() + \"] references corrupt locations: \" + matches);\n                        throw new IOException(\"Detected missing/corrupt journal files referenced by:[\" + sdEntry.getKey() + \"] \" +matches.size()+\" messages affected.\");\n                    }\n                }\n            }\n        }\n\n        if (!ignoreMissingJournalfiles) {\n            if (!knownCorruption.isEmpty()) {\n                LOG.error(\"Detected corrupt journal files. \" + knownCorruption);\n                throw new IOException(\"Detected corrupt journal files. \" + knownCorruption);\n            }\n\n            if (!missingJournalFiles.isEmpty()) {\n                LOG.error(\"Detected missing journal files. \" + missingJournalFiles);\n                throw new IOException(\"Detected missing journal files. \" + missingJournalFiles);\n            }\n        }\n\n        if (undoCounter > 0) {\n            if (LOG.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                LOG.info(\"Detected missing/corrupt journal files.  Dropped \" + undoCounter + \" messages from the index in \" + ((end - start) / 1000.0f) + \" seconds.\");\n            }\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-5525.json",
        "creation_time": "2015-01-19T13:47:50.000+0000",
        "bug_report": {
            "Title": "Error converting collection entry - activemq:browse karaf command via itests",
            "Description": "The test case `ActiveMQAMQPBrokerFeatureTest` fails due to an inability to convert command-line arguments into a `java.util.ArrayList<java.lang.String>`. The root cause appears to be related to the `AggregateConverter` class, which is responsible for converting the command-line arguments. The specific error message indicates that the value `1421674680492` could not be converted to a `String` type, leading to an empty collection being returned instead of the expected values.",
            "StackTrace": [
                "java.lang.Exception: Unable to convert from [--amqurl, tcp://localhost:61616, --user, karaf, --password, karaf, -Vbody, 1421674680492] to java.util.ArrayList<java.lang.String>(error converting collection entry)",
                "at org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:342)",
                "at org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:182)",
                "at org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.convert(ActiveMQCommand.java:143)",
                "at org.apache.activemq.karaf.commands.ActiveMQCommand$ActiveMQActionPreparator.prepare(ActiveMQCommand.java:134)",
                "at org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)",
                "at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
                "at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethod)",
                "at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)",
                "at java.lang.reflect.Method.invoke(Method.java:606)",
                "at org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)",
                "at org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)",
                "at org.apache.activemq.karaf.commands.$ActiveMQCommand695030723.execute(Unknown Source)",
                "at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)",
                "at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)",
                "at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)",
                "at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)",
                "at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)",
                "at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)",
                "at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)",
                "at org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:125)",
                "at org.apache.activemq.karaf.itest.AbstractFeatureTest$1$1.run(AbstractFeatureTest.java:117)",
                "at java.security.AccessController.doPrivileged(Native Method)",
                "at javax.security.auth.Subject.doAs(Subject.java:356)",
                "at org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:117)",
                "at org.apache.activemq.karaf.itest.AbstractFeatureTest$1.call(AbstractFeatureTest.java:109)",
                "at java.util.concurrent.FutureTask.run(FutureTask.java:262)",
                "at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)",
                "at java.util.concurrent.FutureTask.run(FutureTask.java:262)",
                "at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)",
                "at java.lang.Thread.run(Thread.java:745)",
                "Caused by: java.lang.Exception: Unable to convert value 1421674680492 to type java.lang.String",
                "at org.apache.aries.blueprint.container.AggregateConverter.convert(AggregateConverter.java:184)",
                "at org.apache.aries.blueprint.container.AggregateConverter.convertToCollection(AggregateConverter.java:340)"
            ],
            "RootCause": "The root cause of the issue is the failure of the `AggregateConverter` to convert the command-line argument `1421674680492` into a `String`. This indicates a type mismatch or incorrect formatting of the input arguments.",
            "StepsToReproduce": [
                "Run the test case `ActiveMQAMQPBrokerFeatureTest`.",
                "Execute the command `activemq:browse --amqurl tcp://localhost:61616 --user karaf --password karaf -Vbody 1421674680492`."
            ],
            "ExpectedBehavior": "The command should successfully convert the provided arguments into a list and return the expected JMS body field values.",
            "ObservedBehavior": "The command fails with an exception indicating that it cannot convert the provided arguments into the expected `ArrayList<String>`, resulting in an empty collection.",
            "Suggestions": "Check the formatting and types of the command-line arguments. Ensure that all arguments are of the expected type and that no required arguments are missing.",
            "problem_location": {
                "files": [
                    "AggregateConverter.java",
                    "ActiveMQCommand.java"
                ],
                "classes": [
                    "org.apache.aries.blueprint.container.AggregateConverter",
                    "org.apache.activemq.karaf.commands.ActiveMQCommand"
                ],
                "methods": [
                    "AggregateConverter.convertToCollection",
                    "ActiveMQCommand$ActiveMQActionPreparator.convert"
                ]
            },
            "possible_fix": "Ensure that the command-line argument `-Vbody` is correctly formatted and that the value `1421674680492` is being passed as a valid string. Consider modifying the `ActiveMQCommand` to handle such cases or validate input types before conversion."
        },
        "possible_fix_code": {
            "ActiveMQCommand.prepare": "        public boolean prepare(Action action, CommandSession session, List<Object> params) throws Exception\n        {\n            Map<Argument, Field> arguments = new HashMap<Argument, Field>();\n            List<Argument> orderedArguments = new ArrayList<Argument>();\n            // Introspect\n            for (Class type = action.getClass(); type != null; type = type.getSuperclass()) {\n                for (Field field : type.getDeclaredFields()) {\n                    Argument argument = field.getAnnotation(Argument.class);\n                    if (argument != null) {\n                        arguments.put(argument, field);\n                        int index = argument.index();\n                        while (orderedArguments.size() <= index) {\n                            orderedArguments.add(null);\n                        }\n                        if (orderedArguments.get(index) != null) {\n                            throw new IllegalArgumentException(\"Duplicate argument index: \" + index);\n                        }\n                        orderedArguments.set(index, argument);\n                    }\n                }\n            }\n            // Check indexes are correct\n            for (int i = 0; i < orderedArguments.size(); i++) {\n                if (orderedArguments.get(i) == null) {\n                    throw new IllegalArgumentException(\"Missing argument for index: \" + i);\n                }\n            }\n            // Populate\n            Map<Argument, Object> argumentValues = new HashMap<Argument, Object>();\n            int argIndex = 0;\n            for (Iterator<Object> it = params.iterator(); it.hasNext();) {\n                Object param = it.next();\n                if (argIndex >= orderedArguments.size()) {\n                    throw new IllegalArgumentException(\"Too many arguments specified\");\n                }\n                Argument argument = orderedArguments.get(argIndex);\n                if (!argument.multiValued()) {\n                    argIndex++;\n                }\n                if (argument.multiValued()) {\n                    List<Object> l = (List<Object>) argumentValues.get(argument);\n                    if (l == null) {\n                        l = new ArrayList<Object>();\n                        argumentValues.put(argument, l);\n                    }\n                    // Check if the parameter is a valid string\n                    if (param instanceof String) {\n                        l.add(param);\n                    } else {\n                        throw new IllegalArgumentException(\"Parameter for multi-valued argument must be a String: \" + param);\n                    }\n                } else {\n                    // Check if the parameter is a valid string\n                    if (param instanceof String) {\n                        argumentValues.put(argument, param);\n                    } else {\n                        throw new IllegalArgumentException(\"Parameter for argument must be a String: \" + param);\n                    }\n                }\n            }\n\n            for (Map.Entry<Argument, Object> entry : argumentValues.entrySet()) {\n                Field field = arguments.get(entry.getKey());\n                Object value = convert(action, session, entry.getValue(), field.getGenericType());\n                field.setAccessible(true);\n                field.set(action, value);\n            }\n            return true;\n        }"
        }
    },
    {
        "filename": "AMQ-4118.json",
        "creation_time": "2012-10-19T22:14:13.000+0000",
        "bug_report": {
            "Title": "Index page overflow leading to duplicate calls to free",
            "Description": "The issue arises when an overflowed chain is released without properly updating the cache with the new end page. This results in the old value being reused and freed again, causing various exceptions. The problem is exacerbated in scenarios with durable subscriptions and large backlogs, where the sequence set expansion and shrinkage can easily lead to overflow. Symptoms include ClassCastExceptions and NullPointerExceptions when the page is reused incorrectly or when a free page is accessed from disk.",
            "StackTrace": [
                "2012-10-19 22:25:11,928 [exPageUsage#5-2] - ERROR MessageDatabase - KahaDB failed to store to Journal",
                "java.io.EOFException: Chunk stream does not exist, page: 1344 is marked free",
                "at org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:481)",
                "at org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:458)",
                "at org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:455)",
                "at org.apache.kahadb.page.Transaction.load(Transaction.java:431)",
                "at org.apache.kahadb.page.Transaction.load(Transaction.java:388)",
                "at org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)",
                "at org.apache.kahadb.index.BTreeNode.getChild(BTreeNode.java:225)",
                "at org.apache.kahadb.index.BTreeNode.getLeafNode(BTreeNode.java:680)",
                "at org.apache.kahadb.index.BTreeNode.get(BTreeNode.java:562)",
                "at org.apache.kahadb.index.BTreeIndex.get(BTreeIndex.java:184)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.get(MessageDatabase.java:2616)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.updateIndex(MessageDatabase.java:1210)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$15.execute(MessageDatabase.java:1002)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:790)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1000)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:933)",
                "at org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand.visit(KahaRemoveMessageCommand.java:220)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:925)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:837)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:819)",
                "at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBTopicMessageStore.doAcknowledge(KahaDBStore.java:723)",
                "at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBTopicMessageStore.acknowledge(KahaDBStore.java:706)",
                "at org.apache.activemq.store.kahadb.KahaDBTransactionStore.acknowledge(KahaDBTransactionStore.java:519)",
                "at org.apache.activemq.store.kahadb.KahaDBTransactionStore$2.acknowledge(KahaDBTransactionStore.java:222)",
                "at org.apache.activemq.broker.region.Topic.acknowledge(Topic.java:528)",
                "at org.apache.activemq.broker.region.DurableTopicSubscription.acknowledge(DurableTopicSubscription.java:279)",
                "java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.String",
                "at java.lang.String.compareTo(String.java:92)",
                "at java.util.Arrays.binarySearch0(Arrays.java:2001)",
                "at java.util.Arrays.binarySearch(Arrays.java:1943)",
                "at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:371)",
                "at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:369)",
                "at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.put(MessageDatabase.java:2592)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1168)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:2082)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:1095)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:768)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1092)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)",
                "at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:943)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:855)",
                "at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:267)",
                "java.lang.NullPointerException",
                "at org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:264)",
                "at org.apache.kahadb.index.BTreeNode.getChild(BTreeNode.java:225)",
                "at org.apache.kahadb.index.BTreeNode.getLeafNode(BTreeNode.java:676)",
                "at org.apache.kahadb.index.BTreeNode.put(BTreeNode.java:369)",
                "at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.put(MessageDatabase.java:2592)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1168)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:2082)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:1095)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:768)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:1092)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:961)",
                "at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:943)",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:855)",
                "at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:267)"
            ],
            "RootCause": "The root cause of the issue is a combination of data corruption leading to EOFExceptions, type mismatches causing ClassCastExceptions, and uninitialized objects resulting in NullPointerExceptions. These issues stem from improper handling of the index page cache and overflow conditions in the KahaDB and ActiveMQ systems.",
            "StepsToReproduce": [
                "1. Configure a durable subscription with a large backlog.",
                "2. Trigger sequence set expansion and shrinkage to create overflow conditions.",
                "3. Attempt to access the index page that has been marked free."
            ],
            "ExpectedBehavior": "The system should correctly manage the index page cache, ensuring that pages are not reused after being freed, and that data types are handled correctly to prevent exceptions.",
            "ObservedBehavior": "The system throws EOFExceptions, ClassCastExceptions, and NullPointerExceptions, leading to instability and potential data loss.",
            "Suggestions": "1. Ensure that the cache is updated correctly when pages are freed. 2. Implement type checks to prevent ClassCastExceptions. 3. Verify that all objects are properly initialized before use.",
            "problem_location": {
                "files": [
                    "kahadb/src/main/java/org/apache/kahadb/index/BTreeNode.java",
                    "kahadb/src/main/java/org/apache/kahadb/index/BTreeIndex.java",
                    "kahadb/src/main/java/org/apache/kahadb/page/Transaction.java",
                    "kahadb/src/main/java/org/apache/activemq/store/kahadb/MessageDatabase.java"
                ],
                "classes": [
                    "org.apache.kahadb.index.BTreeNode",
                    "org.apache.kahadb.index.BTreeIndex",
                    "org.apache.kahadb.page.Transaction",
                    "org.apache.activemq.store.kahadb.MessageDatabase"
                ],
                "methods": [
                    "BTreeNode.put",
                    "BTreeIndex.loadNode",
                    "Transaction.readPage"
                ]
            },
            "possible_fix": "1. Modify the `put` method in `BTreeNode` to include type checks before inserting values. 2. Update the `loadNode` method in `BTreeIndex` to handle cases where the page cannot be loaded gracefully. 3. Ensure that the cache is synchronized properly when pages are freed."
        },
        "possible_fix_code": {
            "BTreeNode.put": "    public Value put(Transaction tx, Key key, Value value) throws IOException {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Key cannot be null\");\n        }\n\n        if (value instanceof String && key instanceof Long) {\n            throw new ClassCastException(\"Cannot insert a Long key with a String value\");\n        }\n\n        if (isBranch()) {\n            return getLeafNode(tx, this, key).put(tx, key, value);\n        } else {\n            int idx = Arrays.binarySearch(keys, key);\n            \n            Value oldValue = null;\n            if (idx >= 0) {\n                // Key was found... Overwrite\n                oldValue = values[idx];\n                values[idx] = value;\n                setLeafData(keys, values);\n            } else {\n                // Key was not found, Insert it\n                idx = -(idx + 1);\n                setLeafData(arrayInsert(keys, key, idx), arrayInsert(values, value, idx));\n            }\n            \n            try {\n                index.storeNode(tx, this, allowOverflow());\n            } catch (Transaction.PageOverflowIOException e) {\n                // If we get an overflow \n                split(tx);\n            }\n            \n            return oldValue;\n        }\n    }",
            "BTreeIndex.loadNode": "    BTreeNode<Key,Value> loadNode(Transaction tx, long pageId, BTreeNode<Key,Value> parent) throws IOException {\n        Page<BTreeNode<Key,Value>> page = tx.load(pageId, marshaller);\n        if (page == null) {\n            throw new IOException(\"Failed to load page: \" + pageId);\n        }\n        BTreeNode<Key, Value> node = page.get();\n        if (node == null) {\n            throw new NullPointerException(\"Loaded node is null for page: \" + pageId);\n        }\n        node.setPage(page);\n        node.setParent(parent);\n        return node;\n    }"
        }
    },
    {
        "filename": "AMQ-4092.json",
        "creation_time": "2012-10-04T02:56:44.000+0000",
        "bug_report": {
            "Title": "ConcurrentModificationException when using message groups",
            "Description": "The application is experiencing frequent WARN messages related to a ConcurrentModificationException while consuming messages from a queue configured with message groups (JMSXGroupID). This issue arises when the maximum number of concurrent consumers is set to 5. Disabling the message groups header eliminates these warnings, indicating a potential issue with concurrent access to shared resources in the ActiveMQ broker's Queue class. The stack trace reveals that the exception occurs during message sending operations, particularly in methods that handle shared collections without adequate synchronization.",
            "StackTrace": [
                "java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException",
                "at java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:222)",
                "at java.util.concurrent.FutureTask.get(FutureTask.java:83)",
                "at org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:785)",
                "at org.apache.activemq.broker.region.Queue.send(Queue.java:707)",
                "at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:407)",
                "at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:503)",
                "at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:305)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)",
                "at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)",
                "at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)",
                "at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:453)",
                "at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)",
                "at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)",
                "at org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:231)",
                "at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)",
                "at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)",
                "at java.lang.Thread.run(Thread.java:680)",
                "Caused by: java.util.ConcurrentModificationException",
                "at java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)",
                "at java.util.HashMap$KeyIterator.next(HashMap.java:828)",
                "at org.apache.activemq.util.MarshallingSupport.marshalPrimitiveMap(MarshallingSupport.java:64)",
                "at org.apache.activemq.command.Message.beforeMarshall(Message.java:210)",
                "at org.apache.activemq.command.ActiveMQObjectMessage.beforeMarshall(ActiveMQObjectMessage.java:199)",
                "at org.apache.activemq.openwire.v6.MessageMarshaller.looseMarshal(MessageMarshaller.java:277)",
                "at org.apache.activemq.openwire.v6.ActiveMQMessageMarshaller.looseMarshal(ActiveMQMessageMarshaller.java:111)",
                "at org.apache.activemq.openwire.v6.ActiveMQObjectMessageMarshaller.looseMarshal(ActiveMQObjectMessageMarshaller.java:111)",
                "at org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:168)",
                "at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.addMessage(KahaDBStore.java:429)",
                "at org.apache.activemq.store.kahadb.KahaDBStore$StoreQueueTask.run(KahaDBStore.java:1177)"
            ],
            "RootCause": "The ConcurrentModificationException is likely caused by concurrent access to shared collections in the ActiveMQ Queue class, particularly in methods like 'addToConsumerList' and 'send', which modify the 'consumers' list and 'messagesWaitingForSpace' without proper synchronization.",
            "StepsToReproduce": [
                "Set up a queue with message groups (JMSXGroupID) enabled.",
                "Configure the maximum number of concurrent consumers to 5.",
                "Start consuming messages from the queue.",
                "Observe the logs for WARN messages related to ConcurrentModificationException."
            ],
            "ExpectedBehavior": "The system should process messages without throwing ConcurrentModificationException, allowing for smooth message consumption and handling.",
            "ObservedBehavior": "The system throws ConcurrentModificationException, resulting in WARN messages in the logs and potential message processing failures.",
            "Suggestions": "Implement proper synchronization mechanisms in the Queue class methods that access shared collections, particularly in 'addToConsumerList' and 'send'. Consider using concurrent collections or synchronized blocks to prevent concurrent modifications.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/broker/region/Queue.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.region.Queue"
                ],
                "methods": [
                    "Queue.send",
                    "Queue.doMessageSend",
                    "Queue.addToConsumerList",
                    "Queue.checkUsage"
                ]
            },
            "possible_fix": "Add synchronization to the 'addToConsumerList' method to prevent concurrent modifications. For example, wrap the consumers list modification in a synchronized block or use a concurrent collection like CopyOnWriteArrayList."
        },
        "possible_fix_code": {
            "org.apache.activemq.broker.region.Queue.addToConsumerList": "    private void addToConsumerList(Subscription sub) {\n        synchronized (consumers) { // Added synchronization to prevent concurrent modifications\n            if (useConsumerPriority) {\n                consumers.add(sub);\n                Collections.sort(consumers, orderedCompare);\n            } else {\n                consumers.add(sub);\n            }\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3887.json",
        "creation_time": "2012-06-18T16:02:55.000+0000",
        "bug_report": {
            "Title": "Occasional Null Pointer Exception during NetworkConnector connection",
            "Description": "A Null Pointer Exception (NPE) occurs intermittently when starting a duplex NetworkConnector on the receiving side. The issue arises during the execution of the `configureMessage` method in the `DemandForwardingBridgeSupport` class, specifically when handling a `MessageDispatch` object. The NPE can be attributed to uninitialized or null references, particularly the `producerInfo` variable, which is expected to be initialized in the `startRemoteBridge` method. This problem is exacerbated by the race condition that can occur when multiple brokers are connecting simultaneously.",
            "StackTrace": [
                "java.lang.NullPointerException: null",
                "at org.apache.activemq.network.DemandForwardingBridgeSupport.configureMessage(DemandForwardingBridgeSupport.java:644) ~[activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.network.DemandForwardingBridgeSupport.serviceLocalCommand(DemandForwardingBridgeSupport.java:675) ~[activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.network.DemandForwardingBridgeSupport$1.onCommand(DemandForwardingBridgeSupport.java:139) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.vm.VMTransport.doDispatch(VMTransport.java:135) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.vm.VMTransport.dispatch(VMTransport.java:124) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.vm.VMTransport.oneway(VMTransport.java:103) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1307) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:837) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.broker.TransportConnection.iterate(TransportConnection.java:872) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122) [activemq-core-5.6.0.jar:5.6.0]",
                "at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43) [activemq-core-5.6.0.jar:5.6.0]",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source) [na:1.6.0_20]",
                "at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [na:1.6.0_20]",
                "at java.lang.Thread.run(Unknown Source) [na:1.6.0_20]"
            ],
            "RootCause": "The root cause of the Null Pointer Exception is likely due to the `producerInfo` variable being null when accessed in the `configureMessage` method. This can occur if the `startRemoteBridge` method, which initializes `producerInfo`, is not called successfully before `configureMessage` is invoked. Additionally, the `MessageDispatch` object may also be null or improperly initialized.",
            "StepsToReproduce": [
                "Start a duplex NetworkConnector with multiple brokers connecting simultaneously.",
                "Monitor the logs for occurrences of Null Pointer Exceptions during the connection process."
            ],
            "ExpectedBehavior": "The system should establish connections between brokers without throwing exceptions, and the `configureMessage` method should successfully process the `MessageDispatch` object without encountering null references.",
            "ObservedBehavior": "A Null Pointer Exception is thrown intermittently during the connection process, leading to failed message dispatching and disrupted broker communication.",
            "Suggestions": "Implement checks to ensure that `producerInfo` and the `MessageDispatch` object are properly initialized before being accessed in the `configureMessage` method. Consider adding error handling to manage scenarios where initialization fails.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/network/DemandForwardingBridgeSupport.java"
                ],
                "classes": [
                    "org.apache.activemq.network.DemandForwardingBridgeSupport"
                ],
                "methods": [
                    "DemandForwardingBridgeSupport.configureMessage",
                    "DemandForwardingBridgeSupport.startRemoteBridge"
                ]
            },
            "possible_fix": "Add null checks for `producerInfo` and the `MessageDispatch` object in the `configureMessage` method. Ensure that the `startRemoteBridge` method is called successfully before any message dispatching occurs."
        },
        "possible_fix_code": {
            "DemandForwardingBridgeSupport.configureMessage": "    protected Message configureMessage(MessageDispatch md) {\n        if (md == null || md.getMessage() == null || producerInfo == null || md.getDestination() == null) {\n            throw new IllegalArgumentException(\"MessageDispatch, Message, producerInfo, or Destination cannot be null\");\n        }\n        Message message = md.getMessage().copy();\n        // Update the packet to show where it came from.\n        message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(), localBrokerPath));\n        message.setProducerId(producerInfo.getProducerId());\n        message.setDestination(md.getDestination());\n        if (message.getOriginalTransactionId() == null) {\n            message.setOriginalTransactionId(message.getTransactionId());\n        }\n        message.setTransactionId(null);\n        return message;\n    }"
        }
    },
    {
        "filename": "AMQ-6451.json",
        "creation_time": "2016-10-03T17:09:00.000+0000",
        "bug_report": {
            "Title": "Preallocation strategy of zeros can leak file descriptors causing crash",
            "Description": "When the `preallocationStrategy` is set to 'zeros', ActiveMQ intermittently fails to allocate direct buffer memory due to an `OutOfMemoryError`. This unhandled exception leads to the creation of empty journal files and results in a file descriptor leak. Over time, ActiveMQ exhausts its available file descriptors, ultimately causing a crash. It is recommended to adjust the default JVM settings to ensure sufficient direct memory allocation for simultaneous log file creation, and to document this in the KahaDB settings.",
            "StackTrace": [
                "java.lang.OutOfMemoryError: Direct buffer memory",
                "at java.nio.Bits.reserveMemory(Bits.java:693)[:1.8.0_101]",
                "at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)[:1.8.0_101]",
                "at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)[:1.8.0_101]",
                "at sun.nio.ch.Util.getTemporaryDirectBuffer(Util.java:174)[:1.8.0_101]",
                "at sun.nio.ch.IOUtil.write(IOUtil.java:58)[:1.8.0_101]",
                "at sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:211)[:1.8.0_101]",
                "at org.apache.activemq.store.kahadb.disk.journal.Journal.doPreallocationZeros(Journal.java:366)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.Journal.preallocateEntireJournalDataFile(Journal.java:333)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.Journal.newDataFile(Journal.java:631)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.Journal.rotateWriteFile(Journal.java:595)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.Journal.getCurrentDataFile(Journal.java:984)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.enqueue(DataFileAppender.java:189)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.DataFileAppender.storeItem(DataFileAppender.java:128)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.disk.journal.Journal.write(Journal.java:890)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:1108)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:1090)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:301)[activemq-kahadb-store-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:70)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:252)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.broker.BrokerFilter.commitTransaction(BrokerFilter.java:113)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:535)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:333)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:197)[activemq-broker-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:300)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.tcp.SslTransport.doConsume(SslTransport.java:108)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)[activemq-client-5.14.0.jar:5.14.0]",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)[activemq-client-5.14.0.jar:5.14.0]",
                "at java.lang.Thread.run(Thread.java:745)[:1.8.0_101]"
            ],
            "RootCause": "The root cause of the issue is an `OutOfMemoryError` related to direct buffer memory allocation, triggered by the preallocation strategy set to 'zeros'. This leads to unhandled exceptions and file descriptor leaks.",
            "StepsToReproduce": [
                "Set the `preallocationStrategy` to 'zeros' in ActiveMQ configuration.",
                "Run the ActiveMQ broker with default JVM settings.",
                "Monitor the system for memory usage and file descriptor counts.",
                "Observe the logs for `OutOfMemoryError` messages."
            ],
            "ExpectedBehavior": "ActiveMQ should allocate direct buffer memory without errors, allowing for the creation of journal files without leaking file descriptors.",
            "ObservedBehavior": "ActiveMQ fails to allocate direct buffer memory, leading to `OutOfMemoryError`, creation of empty journal files, and eventual crash due to file descriptor exhaustion.",
            "Suggestions": "Consider increasing the maximum direct memory size using the JVM option `-XX:MaxDirectMemorySize`. Additionally, ensure that direct buffers are released properly to prevent memory leaks.",
            "problem_location": {
                "files": [
                    "Journal.java",
                    "LocalTransaction.java",
                    "TransactionBroker.java"
                ],
                "classes": [
                    "org.apache.activemq.store.kahadb.disk.journal.Journal",
                    "org.apache.activemq.transaction.LocalTransaction",
                    "org.apache.activemq.broker.TransactionBroker"
                ],
                "methods": [
                    "Journal.doPreallocationZeros",
                    "Journal.preallocateEntireJournalDataFile",
                    "LocalTransaction.commit",
                    "TransactionBroker.commitTransaction"
                ]
            },
            "possible_fix": "Increase the maximum direct memory size in the JVM options. For example, add `-XX:MaxDirectMemorySize=512m` to the JVM startup parameters. Additionally, review the code to ensure that direct buffers are being released properly."
        },
        "possible_fix_code": {
            "doPreallocationZeros": "    private void doPreallocationZeros(RecoverableRandomAccessFile file) {\n        // Ensure that we allocate direct buffer memory safely\n        if (maxFileLength > 0) {\n            ByteBuffer buffer = ByteBuffer.allocateDirect(maxFileLength);\n            buffer.put(EOF_RECORD);\n            buffer.rewind();\n            try {\n                FileChannel channel = file.getChannel();\n                channel.write(buffer);\n                channel.force(false);\n                channel.position(0);\n            } catch (ClosedByInterruptException ignored) {\n                LOG.trace(\"Could not preallocate journal file with zeros\", ignored);\n            } catch (IOException e) {\n                LOG.error(\"Could not preallocate journal file with zeros\", e);\n            } finally {\n                // Explicitly clear the buffer to help with memory management\n                buffer.clear();\n            }\n        } else {\n            LOG.warn(\"maxFileLength is not set properly, skipping preallocation.\");\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3393.json",
        "creation_time": "2011-07-05T14:31:31.000+0000",
        "bug_report": {
            "Title": "Number of established STOMP connections constantly increasing",
            "Description": "The application experiences an issue where the number of established STOMP connections increases indefinitely due to rapid connect/disconnect cycles. This leads to dangling STOMP transport connection MBeans that accumulate over time. The problem arises when a disconnect command is issued before the broker connection is fully established, causing the shutdown command from the STOMP protocol converter to bypass the necessary stop and start completion processes. A notable symptom of this issue is the failure to register MBeans, as indicated by the warning logs showing an `InstanceAlreadyExistsException` when attempting to register an MBean with a name that is already in use.",
            "StackTrace": [
                "javax.management.InstanceAlreadyExistsException: org.apache.activemq:BrokerName=xx,Type=Connection,ConnectorName=stomp,ViewType=address,Name=/xx_52170",
                "at com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:453)",
                "at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.internal_addObject(DefaultMBeanServerInterceptor.java:1484)",
                "at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:963)",
                "at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:917)",
                "at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:312)",
                "at org.apache.activemq.broker.jmx.ManagementContext.registerMBean(ManagementContext.java:299)",
                "at org.apache.activemq.broker.jmx.ManagedTransportConnection.registerMBean(ManagedTransportConnection.java:99)",
                "at org.apache.activemq.broker.jmx.ManagedTransportConnection.<init>(ManagedTransportConnection.java:57)",
                "at org.apache.activemq.broker.jmx.ManagedTransportConnector.createConnection(ManagedTransportConnector.java:52)",
                "at org.apache.activemq.broker.TransportConnector$1$1.run(TransportConnector.java:216)",
                "at java.lang.Thread.run(Thread)"
            ],
            "RootCause": "The root cause of the issue is that the `registerMBean` method in the `ManagementContext` class does not check if an MBean with the same name is already registered before attempting to register it. This oversight leads to the `InstanceAlreadyExistsException` when multiple connections are attempted without proper unregistration of previous MBeans.",
            "StepsToReproduce": [
                "1. Rapidly connect and disconnect a STOMP client to the broker.",
                "2. Monitor the MBean registrations in the JMX server.",
                "3. Observe the warning logs for `InstanceAlreadyExistsException`."
            ],
            "ExpectedBehavior": "The system should properly manage MBean registrations, ensuring that no duplicate MBeans are registered, and should clean up MBeans that are no longer needed.",
            "ObservedBehavior": "The system fails to register MBeans due to `InstanceAlreadyExistsException`, leading to an accumulation of STOMP connections and potential resource leaks.",
            "Suggestions": "Implement a check in the `registerMBean` method to verify if an MBean with the same name is already registered using the `getObjectInstance` method before attempting to register a new one. Additionally, ensure that MBeans are properly unregistered using the `unregisterMBean` method before re-registration.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/broker/jmx/ManagementContext.java",
                    "activemq-core/src/main/java/org/apache/activemq/broker/jmx/AnnotatedMBean.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.jmx.ManagementContext",
                    "org.apache.activemq.broker.jmx.AnnotatedMBean"
                ],
                "methods": [
                    "ManagementContext.registerMBean",
                    "ManagementContext.unregisterMBean",
                    "ManagementContext.getObjectInstance",
                    "AnnotatedMBean.registerMBean"
                ]
            },
            "possible_fix": "Modify the `registerMBean` method in `ManagementContext` to include a check for existing MBeans using `getObjectInstance` before registration. Example code modification:\n\n```java\npublic ObjectInstance registerMBean(Object bean, ObjectName name) throws Exception {\n    // Check if the MBean is already registered\n    try {\n        getObjectInstance(name);\n        // MBean already registered, handle accordingly (e.g., throw an exception or log a warning)\n    } catch (InstanceNotFoundException e) {\n        // MBean not registered, proceed with registration\n        ObjectInstance result = getMBeanServer().registerMBean(bean, name);\n        this.registeredMBeanNames.add(name);\n        return result;\n    }\n}\n```"
        },
        "possible_fix_code": {
            "ManagementContext.registerMBean": "    public ObjectInstance registerMBean(Object bean, ObjectName name) throws Exception {\n        // Check if the MBean is already registered\n        try {\n            getObjectInstance(name);\n            // MBean already registered, handle accordingly (e.g., throw an exception or log a warning)\n            throw new InstanceAlreadyExistsException(\"MBean with name \" + name + \" is already registered.\");\n        } catch (InstanceNotFoundException e) {\n            // MBean not registered, proceed with registration\n            ObjectInstance result = getMBeanServer().registerMBean(bean, name);\n            this.registeredMBeanNames.add(name);\n            return result;\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-5815.json",
        "creation_time": "2015-06-01T12:21:13.000+0000",
        "bug_report": {
            "Title": "Frequency IOException cast dead lock while using kahadb in high concurrency environment",
            "Description": "In a high concurrency environment with IOPS exceeding 3000/s, ActiveMQ connections become blocked, preventing data retrieval or submission until a restart occurs. This issue manifests frequently, accompanied by numerous IOExceptions in the ActiveMQ logs. The stack trace indicates that the IOException originates from the `writeLong` method in the `RecoverableRandomAccessFile` class, which is called during write operations in the KahaDB storage mechanism. The deadlock situation arises when multiple threads are waiting for locks that are not being released, particularly involving the `LocalTransaction` and `MessageDatabase` classes.",
            "StackTrace": [
                "java.io.IOException: Input/output error",
                "at java.io.RandomAccessFile.write(Native Method)[:1.6.0_30]",
                "at java.io.RandomAccessFile.writeLong(RandomAccessFile.java:1001)[:1.6.0_30]",
                "at org.apache.activemq.util.RecoverableRandomAccessFile.writeLong(RecoverableRandomAccessFile.java:305)[activemq-kahadb-store-5.10.0.jar:5.10.0]",
                "at org.apache.activemq.store.kahadb.disk.page.PageFile.writeBatch(PageFile.java:1062)[activemq-kahadb-store-5.10.0.jar:5.10.0]",
                "at org.apache.activemq.store.kahadb.disk.page.PageFile.flush(PageFile.java:516)[activemq-kahadb-store-5.10.0.jar:5.10.0]",
                "at org.apache.activemq.store.kahadb.MessageDatabase.checkpointUpdate(MessageDatabase.java:1512)[activemq-kahadb-store-5.10.0.jar:5.10.0]",
                "at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:929)[activemq-kahadb-store-5.10.0.jar:5.10.0]"
            ],
            "RootCause": "The root cause of the issue is an IOException occurring during write operations in the KahaDB storage, specifically in the `writeLong` method of the `RecoverableRandomAccessFile`. This is compounded by a deadlock situation where threads are waiting for locks that are not being released, particularly involving the `LocalTransaction` and `MessageDatabase` classes.",
            "StepsToReproduce": [
                "Set up a high concurrency environment with IOPS exceeding 3000/s.",
                "Initiate multiple ActiveMQ connections to push and retrieve data.",
                "Monitor the ActiveMQ logs for IOExceptions and blocked connections."
            ],
            "ExpectedBehavior": "In a properly functioning system, ActiveMQ should handle high concurrency without blocking connections, allowing for seamless data retrieval and submission.",
            "ObservedBehavior": "ActiveMQ connections become blocked, preventing any data operations until a restart is performed. Numerous IOExceptions are logged, indicating issues with file writing operations.",
            "Suggestions": "Investigate the file system for potential issues such as permissions or disk space. Consider implementing better error handling in the `handleException` method to log exceptions instead of ignoring them. Review the management of the `writes` collection in the `PageFile` class to ensure it is populated correctly and that the write thread is functioning as expected.",
            "problem_location": {
                "files": [
                    "activemq-kahadb-store/src/main/java/org/apache/activemq/util/RecoverableRandomAccessFile.java",
                    "activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/PageFile.java",
                    "activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/MessageDatabase.java"
                ],
                "classes": [
                    "org.apache.activemq.util.RecoverableRandomAccessFile",
                    "org.apache.activemq.store.kahadb.disk.page.PageFile",
                    "org.apache.activemq.store.kahadb.MessageDatabase"
                ],
                "methods": [
                    "RecoverableRandomAccessFile.writeLong",
                    "RecoverableRandomAccessFile.handleException",
                    "PageFile.flush",
                    "PageFile.writeBatch",
                    "MessageDatabase.checkpointUpdate"
                ]
            },
            "possible_fix": "Enhance the `handleException` method in `RecoverableRandomAccessFile` to log exceptions instead of ignoring them. Ensure that the `writes` collection in `PageFile` is managed correctly and that the write thread is operational. Additionally, consider implementing a timeout mechanism for transactions to prevent indefinite blocking."
        },
        "possible_fix_code": {
            "RecoverableRandomAccessFile.handleException": "    protected void handleException() throws IOException {\n        try {\n            if (raf != null) {\n                raf.close();\n            }\n        } catch (Throwable t) {\n            // Log the exception to provide insight into the error\n            System.err.println(\"Error closing RandomAccessFile: \" + t.getMessage());\n            t.printStackTrace();\n        } finally {\n            raf = null;\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-5141.json",
        "creation_time": "2014-04-11T11:31:51.000+0000",
        "bug_report": {
            "Title": "Message expiry that is done as part of a removeSubscription command should not use the client's credentials.",
            "Description": "The issue arises when the broker processes a RemoveInfo command, which triggers a message expiry check for prefetched messages. If messages are expired, they are sent to the ActiveMQ Dead Letter Queue (DLQ) by default. When the broker is security-enabled, it uses the client's security context to send messages to the DLQ. This behavior requires that all client users have write access to the DLQ, which poses a security risk. The broker should utilize its internal security context for message expiry operations instead of the client's context.",
            "StackTrace": [
                "java.lang.SecurityException: User Test is not authorized to write to: queue://ActiveMQ.DLQ",
                "at org.apache.activemq.security.AuthorizationBroker.send(AuthorizationBroker.java:197)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)",
                "at org.apache.activemq.broker.region.RegionBroker.sendToDeadLetterQueue(RegionBroker.java:691)",
                "at org.apache.activemq.broker.BrokerFilter.sendToDeadLetterQueue(BrokerFilter.java:262)",
                "at org.apache.activemq.broker.region.Queue.messageExpired(Queue.java:1671)",
                "at org.apache.activemq.broker.region.PrefetchSubscription.dispatchPending(PrefetchSubscription.java:648)",
                "at org.apache.activemq.broker.region.Queue.removeSubscription(Queue.java:576)"
            ],
            "RootCause": "The root cause of the issue is that the broker is using the client's security context to send expired messages to the DLQ, which requires the client to have write permissions to the DLQ. This leads to a SecurityException when the client lacks the necessary permissions.",
            "StepsToReproduce": [
                "1. Configure the ActiveMQ broker with security enabled.",
                "2. Ensure that the client user does not have write access to the ActiveMQ.DLQ.",
                "3. Send a RemoveInfo command to the broker that triggers message expiry.",
                "4. Observe the SecurityException in the logs."
            ],
            "ExpectedBehavior": "The broker should use its internal security context to handle message expiry and send messages to the DLQ without requiring client user permissions.",
            "ObservedBehavior": "The broker raises a SecurityException indicating that the client user does not have permission to write to the DLQ when messages are expired.",
            "Suggestions": "Modify the broker's implementation to ensure that it uses its internal security context for message expiry operations instead of the client's context. Review the security configuration to ensure appropriate permissions are set for users.",
            "problem_location": {
                "files": [
                    "activemq-broker/src/main/java/org/apache/activemq/broker/RegionBroker.java",
                    "activemq-broker/src/main/java/org/apache/activemq/broker/MutableBrokerFilter.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.RegionBroker",
                    "org.apache.activemq.broker.MutableBrokerFilter"
                ],
                "methods": [
                    "RegionBroker.sendToDeadLetterQueue",
                    "MutableBrokerFilter.sendToDeadLetterQueue"
                ]
            },
            "possible_fix": "In the RegionBroker class, modify the sendToDeadLetterQueue method to utilize the broker's internal security context instead of the client's context. Ensure that the internal security context is properly set up to handle message expiry operations."
        },
        "possible_fix_code": {
            "sendToDeadLetterQueue": "    @Override\n    public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference,\n                                         Subscription subscription, Throwable poisonCause) {\n        // Use the broker's internal security context instead of the client's context\n        SecurityContext originalContext = context.getSecurityContext();\n        context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);\n        try {\n            return next.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);\n        } finally {\n            // Restore the original security context\n            context.setSecurityContext(originalContext);\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-5854.json",
        "creation_time": "2015-06-19T15:36:33.000+0000",
        "bug_report": {
            "Title": "Duplicate messages when failover is done during prepare phase of two phase commit.",
            "Description": "This issue arises in a Spring DMLC setup where a JMS message is read from a queue, processed, and then written to an output queue and a database. During high CPU usage, the inactivity monitor closes connections between clients and the broker while processing 16 messages. This leads to a rollback of 15 messages, which are redelivered to another consumer. However, one message is not rolled back and is processed twice, resulting in duplicate entries in the database and multiple output JMS messages. The problem is exacerbated by a failover occurring during the prepare phase of the commit, leading to an `InactivityIOException` and subsequent duplicate message delivery.",
            "StackTrace": [
                "org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend(AbstractInactivityMonitor.java:297)",
                "org.apache.activemq.transport.AbstractInactivityMonitor.oneway(AbstractInactivityMonitor.java:286)",
                "org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:85)",
                "org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:104)",
                "org.apache.activemq.transport.failover.FailoverTransport.oneway(FailoverTransport.java:658)",
                "org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1321)",
                "org.apache.activemq.ActiveMQSession.sendAck(ActiveMQSession.java:2099)",
                "org.apache.activemq.ActiveMQMessageConsumer.acknowledge(ActiveMQMessageConsumer.java:1083)",
                "com.atomikos.datasource.xa.XAResourceTransaction.prepare(XAResourceTransaction.java:608)",
                "com.atomikos.icatch.imp.CoordinatorImp.prepare(CoordinatorImp.java:832)"
            ],
            "RootCause": "The root cause of the issue is the failure of the ActiveMQ connection during the prepare phase of the transaction commit, which leads to an `InactivityIOException`. This results in one message being processed twice due to improper handling of message acknowledgments and transaction rollbacks.",
            "StepsToReproduce": [
                "Set up a Spring DMLC with ActiveMQ.",
                "Configure the broker with transport.useKeepAlive=false and client with wireFormat.maxInactivityDuration=5000.",
                "Introduce a delay in the acknowledge method of ActiveMQMessageConsumer to simulate a failover during the prepare phase.",
                "Process messages and observe the behavior during high CPU usage."
            ],
            "ExpectedBehavior": "In a properly functioning system, all messages should be processed exactly once, with no duplicates occurring during failover scenarios.",
            "ObservedBehavior": "Messages are processed multiple times, leading to duplicate entries in the database and multiple output JMS messages due to a failure in handling message acknowledgments during the failover.",
            "Suggestions": "Consider implementing a mechanism to force a rollback of transactions if a failover occurs during the prepare phase. Additionally, review the inactivity timeout settings and ensure proper error handling for JMS exceptions.",
            "problem_location": {
                "files": [
                    "ActiveMQMessageConsumer.java",
                    "XAResourceTransaction.java"
                ],
                "classes": [
                    "org.apache.activemq.ActiveMQMessageConsumer",
                    "com.atomikos.datasource.xa.XAResourceTransaction"
                ],
                "methods": [
                    "ActiveMQMessageConsumer.acknowledge",
                    "XAResourceTransaction.prepare"
                ]
            },
            "possible_fix": "Modify the ActiveMQMessageConsumer to ensure that if a failover occurs during the prepare phase, the transaction is rolled back. This may involve adding checks in the acknowledge method to handle the state of the connection and transaction appropriately."
        },
        "possible_fix_code": {
            "org.apache.activemq.ActiveMQMessageConsumer.acknowledge": "public void acknowledge() throws JMSException {\n    // Check if the connection is still active before acknowledging the message\n    if (!isConnectionActive()) {\n        throw new JMSException(\"Connection is not active, cannot acknowledge message.\");\n    }\n    try {\n        // Acknowledge the message\n        this.session.acknowledge();\n    } catch (InactivityIOException e) {\n        // Handle the inactivity exception and force a rollback\n        rollbackTransaction();\n        throw new JMSException(\"Failed to acknowledge message due to inactivity: \" + e.getMessage());\n    } catch (Exception e) {\n        throw JMSExceptionSupport.create(e);\n    }\n}\n\nprivate boolean isConnectionActive() {\n    // Logic to check if the connection is still active\n    return this.session.isConnected();\n}\n\nprivate void rollbackTransaction() throws JMSException {\n    // Logic to rollback the transaction\n    this.session.rollback();\n}"
        }
    },
    {
        "filename": "AMQ-3056.json",
        "creation_time": "2010-11-26T14:36:24.000+0000",
        "bug_report": {
            "Title": "Exception when Redelivery ack is processed by topic subscription",
            "Description": "The system encounters a `javax.jms.JMSException` indicating an invalid acknowledgment during the processing of message redelivery acknowledgments in an ActiveMQ topic subscription. This issue arises when the acknowledgment does not match the expected state of the message or subscription, potentially due to multiple factors such as acknowledging a message that has already been processed, mismatched message IDs, or invalid consumer subscriptions.",
            "StackTrace": [
                "javax.jms.JMSException: Invalid acknowledgment: MessageAck {commandId = 29455, responseRequired = false, ackType = 3, consumerId = ID:X-2506-1289583778418-0:0:1:1, firstMessageId = ID:X-51821-634249796434830099-1:5:1:3:313195, lastMessageId = ID:X-51821-634249796434830099-1:5:1:3:313195, destination = topic://help.Publish.Instance1, transactionId = null, messageCount = 1}",
                "at org.apache.activemq.broker.region.TopicSubscription.acknowledge(TopicSubscription.java:286)",
                "at org.apache.activemq.broker.region.AbstractRegion.acknowledge(AbstractRegion.java:383)",
                "at org.apache.activemq.broker.region.RegionBroker.acknowledge(RegionBroker.java:544)",
                "at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)",
                "at org.apache.activemq.broker.TransactionBroker.acknowledge(TransactionBroker.java:200)",
                "at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)",
                "at org.apache.activemq.broker.BrokerFilter.acknowledge(BrokerFilter.java:77)",
                "at org.apache.activemq.broker.MutableBrokerFilter.acknowledge(MutableBrokerFilter.java:87)",
                "at org.apache.activemq.broker.TransportConnection.processMessageAck(TransportConnection.java:469)",
                "at org.apache.activemq.command.MessageAck.visit(MessageAck.java:214)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:311)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:185)",
                "at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)",
                "at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:228)",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:220)",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:202)",
                "at java.lang.Thread.run(Thread.java:619)"
            ],
            "RootCause": "The root cause of the issue is an invalid acknowledgment being processed in the ActiveMQ broker, likely due to a mismatch in message IDs or an attempt to acknowledge a message that has already been processed. This is indicated by the `JMSException` thrown in the `acknowledge` methods of the `TopicSubscription`, `AbstractRegion`, and `RegionBroker` classes.",
            "StepsToReproduce": [
                "1. Set up an ActiveMQ broker with a topic subscription.",
                "2. Send a message to the topic.",
                "3. Attempt to acknowledge the message multiple times or with an incorrect message ID.",
                "4. Observe the exception thrown during the acknowledgment process."
            ],
            "ExpectedBehavior": "The acknowledgment should be processed successfully without any exceptions, indicating that the message has been acknowledged and can be discarded by the broker.",
            "ObservedBehavior": "The system throws a `javax.jms.JMSException` indicating an invalid acknowledgment, preventing the message from being acknowledged correctly.",
            "Suggestions": "Review the acknowledgment logic in the `TopicSubscription` and `AbstractRegion` classes to ensure that message IDs and consumer IDs are correctly matched. Implement checks to prevent multiple acknowledgments of the same message.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/broker/region/TopicSubscription.java",
                    "activemq-core/src/main/java/org/apache/activemq/broker/region/AbstractRegion.java",
                    "activemq-core/src/main/java/org/apache/activemq/broker/RegionBroker.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.region.TopicSubscription",
                    "org.apache.activemq.broker.region.AbstractRegion",
                    "org.apache.activemq.broker.RegionBroker"
                ],
                "methods": [
                    "TopicSubscription.acknowledge",
                    "AbstractRegion.acknowledge",
                    "RegionBroker.acknowledge"
                ]
            },
            "possible_fix": "Ensure that the acknowledgment being processed matches the expected state of the message and subscription. This may involve adding validation checks in the `acknowledge` methods to verify that the acknowledgment corresponds to a valid and existing subscription."
        },
        "possible_fix_code": {
            "org.apache.activemq.broker.region.TopicSubscription.acknowledge": "    public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {\n        // Validate the acknowledgment before processing\n        if (ack.getConsumerId() == null || ack.getFirstMessageId() == null || ack.getLastMessageId() == null) {\n            throw new JMSException(\"Invalid acknowledgment: Missing consumerId or messageId\");\n        }\n\n        // Handle the standard acknowledgment case.\n        if (ack.isStandardAck() || ack.isPoisonAck() || ack.isIndividualAck()) {\n            if (context.isInTransaction()) {\n                context.getTransaction().addSynchronization(new Synchronization() {\n                    @Override\n                    public void afterCommit() throws Exception {\n                        synchronized (TopicSubscription.this) {\n                            if (singleDestination && destination != null) {\n                                destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());\n                            }\n                        }\n                        dequeueCounter.addAndGet(ack.getMessageCount());\n                        dispatchMatched();\n                    }\n                });\n            } else {\n                if (singleDestination && destination != null) {\n                    destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());\n                    destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());\n                }\n                dequeueCounter.addAndGet(ack.getMessageCount());\n            }\n            dispatchMatched();\n            return;\n        } else if (ack.isDeliveredAck()) {\n            // Message was delivered but not acknowledged: update pre-fetch\n            // counters.\n            if (destination != null && !ack.isInTransaction()) {\n                destination.getDestinationStatistics().getDequeues().add(ack.getMessageCount());\n                destination.getDestinationStatistics().getInflight().subtract(ack.getMessageCount());\n            }\n            dequeueCounter.addAndGet(ack.getMessageCount());\n            dispatchMatched();\n            return;\n        }\n        throw new JMSException(\"Invalid acknowledgment: \" + ack);\n    }"
        }
    },
    {
        "filename": "AMQ-3325.json",
        "creation_time": "2011-05-17T08:58:50.000+0000",
        "bug_report": {
            "Title": "PList temp store, chunk stream does not exist when broker under stress",
            "Description": "This bug report addresses a concurrency issue observed in the ActiveMQ broker when operating under high load conditions, particularly on multicore systems (8 CPUs). The issue manifests sporadically and is believed to be related to memory limits and the dynamic creation and deletion of destinations. The stack trace indicates an `EOFException`, which suggests that the system is attempting to read from a chunk stream that does not exist, likely due to database corruption or improper transaction management.",
            "StackTrace": [
                "2011-04-07 08:04:07,295 [Queue:loadq-4  ] ERROR FilePendingMessageCursor - I/O error",
                "java.io.EOFException: Chunk stream does not exist at page: 198",
                "at org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:454)",
                "at org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:431)",
                "at org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:428)",
                "at org.apache.kahadb.page.Transaction.load(Transaction.java:404)",
                "at org.apache.kahadb.page.Transaction.load(Transaction.java:361)",
                "at org.apache.activemq.store.kahadb.plist.PList.loadEntry(PList.java:468)",
                "at org.apache.activemq.store.kahadb.plist.PList.getNext(PList.java:483)",
                "at org.apache.activemq.store.kahadb.plist.PList$10.execute(PList.java:312)",
                "at org.apache.kahadb.page.Transaction.execute(Transaction.java:728)",
                "at org.apache.activemq.store.kahadb.plist.PList.getNext(PList.java:310)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:500)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor$DiskIterator.next(FilePendingMessageCursor.java:473)",
                "at org.apache.activemq.broker.region.cursors.FilePendingMessageCursor.next(FilePendingMessageCursor.java:293)",
                "at org.apache.activemq.broker.region.Queue.doPageInForDispatch(Queue.java:1714)",
                "at org.apache.activemq.broker.region.Queue.pageInMessages(Queue.java:1932)",
                "at org.apache.activemq.broker.region.Queue.iterate(Queue.java:1440)",
                "at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:104)",
                "at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:42)"
            ],
            "RootCause": "The root cause of the `java.io.EOFException` is that the system is attempting to access a page in the KahaDB that does not exist. This can occur due to database corruption, improper transaction management, or concurrent access issues that lead to missing pages.",
            "StepsToReproduce": [
                "Run the ActiveMQ broker under high load conditions with multiple concurrent transactions.",
                "Dynamically create and delete destinations during peak load.",
                "Monitor the broker logs for occurrences of the EOFException."
            ],
            "ExpectedBehavior": "The ActiveMQ broker should handle concurrent transactions without encountering EOFExceptions, ensuring that all pages in the KahaDB are accessible and properly managed.",
            "ObservedBehavior": "The broker throws a `java.io.EOFException` indicating that a chunk stream does not exist at a specific page, leading to potential message loss and broker instability.",
            "Suggestions": "To mitigate this issue, consider the following steps: 1. Check the integrity of the KahaDB database and run repair processes if necessary. 2. Ensure proper transaction management, including committing or rolling back transactions as needed. 3. Implement regular backups and database integrity checks. 4. Use graceful shutdown procedures for the ActiveMQ broker to prevent database inconsistencies.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/store/kahadb/plist/PList.java",
                    "activemq-core/src/main/java/org/apache/kahadb/page/Transaction.java"
                ],
                "classes": [
                    "org.apache.activemq.store.kahadb.plist.PList",
                    "org.apache.kahadb.page.Transaction"
                ],
                "methods": [
                    "PList.load",
                    "Transaction.load",
                    "PList.loadEntry"
                ]
            },
            "possible_fix": "To address the EOFException, ensure that the `load` and `loadEntry` methods in the PList and Transaction classes are robust against missing pages. Implement checks to verify the existence of pages before attempting to load them, and consider adding error handling to manage cases where pages are not found."
        },
        "possible_fix_code": {
            "PList.load": "    synchronized void load(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(false, true)) {\n            final Page<EntryLocation> p = tx.load(this.rootId, null);\n            if (p.getType() == Page.PAGE_FREE_TYPE) {\n                // Need to initialize it..\n                EntryLocation root = createEntry(p, \"root\", EntryLocation.NOT_SET, EntryLocation.NOT_SET);\n\n                storeEntry(tx, root);\n                this.lastId = root.getPage().getPageId();\n            } else {\n                // find last id\n                long nextId = this.rootId;\n                while (nextId != EntryLocation.NOT_SET) {\n                    EntryLocation next = getNext(tx, nextId);\n                    if (next != null) {\n                        this.lastId = next.getPage().getPageId();\n                        nextId = next.getNext();\n                        this.size++;\n                    } else {\n                        // Handle case where next entry is missing\n                        break;\n                    }\n                }\n            }\n        }\n    }",
            "PList.loadEntry": "    EntryLocation loadEntry(Transaction tx, long pageId) throws IOException {\n        Page<EntryLocation> page = tx.load(pageId, EntryLocationMarshaller.INSTANCE);\n        if (page == null) {\n            throw new IOException(\"Page not found for pageId: \" + pageId);\n        }\n        EntryLocation entry = page.get();\n        if (entry != null) {\n            entry.setPage(page);\n        }\n        return entry;\n    }"
        }
    },
    {
        "filename": "AMQ-2963.json",
        "creation_time": "2010-10-07T06:52:51.000+0000",
        "bug_report": {
            "Title": "JMSBridgeConnectors does not work with IBM MQ and ActiveMQ 5.4.0",
            "Description": "The integration between IBM Websphere Queue and ActiveMQ queue is failing due to an invalid JMS destination name. The configuration in activemq.xml specifies a bridge connector with the destination name '://IBM.TO.ACTIVEMQ', which does not conform to the expected JMS naming conventions. This issue arises specifically with ActiveMQ version 5.4.0, while it works correctly with version 5.2.0. The error message indicates that the destination name is not valid, leading to a DetailedInvalidDestinationException.",
            "StackTrace": [
                "com.ibm.msg.client.jms.DetailedInvalidDestinationException: JMSCMQ0005: The destination name '://IBM.TO.ACTIVEMQ' was not valid. The destination name specified does not conform to published destination syntax. Correct the specified destination name and try again.",
                "at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)",
                "at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)",
                "at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)",
                "at java.lang.reflect.Constructor.newInstance(Constructor.java:513)",
                "at com.ibm.msg.client.commonservices.j2se.NLSServices.createException(NLSServices.java:313)",
                "at com.ibm.msg.client.commonservices.nls.NLSServices.createException(NLSServices.java:388)",
                "at com.ibm.msg.client.wmq.common.internal.WMQDestinationURIParser.setUri(WMQDestinationURIParser.java:524)",
                "at com.ibm.msg.client.wmq.common.internal.WMQDestination.<init>(WMQDestination.java:3148)",
                "at com.ibm.msg.client.wmq.common.internal.WMQDestination.<init>(WMQDestination.java:3104)",
                "at com.ibm.msg.client.wmq.factories.WMQFactoryFactory.createProviderDestination(WMQFactoryFactory.java:444)",
                "at com.ibm.msg.client.jms.admin.JmsDestinationImpl.setProviderDestination(JmsDestinationImpl.java:333)",
                "at com.ibm.msg.client.jms.admin.JmsDestinationImpl.initialise(JmsDestinationImpl.java:231)",
                "at com.ibm.msg.client.jms.admin.JmsDestinationImpl.<init>(JmsDestinationImpl.java:196)",
                "at com.ibm.msg.client.jms.admin.JmsJndiDestinationImpl.<init>(JmsJndiDestinationImpl.java:129)",
                "at com.ibm.mq.jms.MQDestination.<init>(MQDestination.java:186)",
                "at com.ibm.msg.client.wmq.factories.admin.WMQJmsFactory.createDestination(WMQJmsFactory.java:125)",
                "at com.ibm.msg.client.jms.internal.JmsMessageImpl.providerDestToJmsDest(JmsMessageImpl.java:2111)",
                "at com.ibm.msg.client.jms.internal.JmsMessageImpl.getJMSDestination(JmsMessageImpl.java:686)",
                "at org.apache.activemq.ActiveMQMessageTransformation.copyProperties(ActiveMQMessageTransformation.java:206)",
                "at org.apache.activemq.ActiveMQMessageTransformation.transformMessage(ActiveMQMessageTransformation.java:188)",
                "at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1720)",
                "at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:231)",
                "at org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:300)",
                "at org.apache.activemq.ActiveMQQueueSender.send(ActiveMQQueueSender.java:111)",
                "at org.apache.activemq.network.jms.QueueBridge.sendMessage(QueueBridge.java:80)",
                "at org.apache.activemq.network.jms.DestinationBridge.onMessage(DestinationBridge.java:129)",
                "at com.ibm.mq.jms.MQMessageConsumer$FacadeMessageListener.onMessage(MQMessageConsumer.java:399)",
                "at com.ibm.msg.client.jms.internal.JmsMessageConsumerImpl$JmsProviderMessageListener.onMessage(JmsMessageConsumerImpl.java:904)",
                "at com.ibm.msg.client.wmq.internal.WMQAsyncConsumerShadow.honourNoLocal(WMQAsyncConsumerShadow.java:550)",
                "at com.ibm.msg.client.wmq.internal.WMQAsyncConsumerShadow.consumer(WMQAsyncConsumerShadow.java:384)",
                "at com.ibm.mq.jmqi.remote.internal.RemoteAsyncConsume.driveConsumer(RemoteAsyncConsume.java:1478)",
                "at com.ibm.mq.jmqi.remote.internal.RemoteDispatchThread.run(RemoteDispatchThread.java:385)",
                "at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.runTask(WorkQueueItem.java:209)",
                "at com.ibm.msg.client.commonservices.workqueue.SimpleWorkQueueItem.runItem(SimpleWorkQueueItem.java:100)",
                "at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.run(WorkQueueItem.java:224)",
                "at com.ibm.msg.client.commonservices.workqueue.WorkQueueManager.runWorkQueueItem(WorkQueueManager.java:298)",
                "at com.ibm.msg.client.commonservices.j2se.workqueue.WorkQueueManagerImplementation$ThreadPoolWorker.run(WorkQueueManagerImplementation.java:1220)"
            ],
            "RootCause": "The root cause of the issue is the invalid JMS destination name '://IBM.TO.ACTIVEMQ', which does not conform to the expected JMS naming conventions. Valid names should start with 'queue://' or 'topic://'.",
            "StepsToReproduce": [
                "Configure the activemq.xml with the following jmsBridgeConnectors information:",
                "<jmsBridgeConnectors>",
                "    <jmsQueueConnector outboundQueueConnectionFactory=\"#remoteFactory\">",
                "        <inboundQueueBridges>",
                "            <inboundQueueBridge inboundQueueName=\"IBM.TO.ACTIVEMQ\" localQueueName=\"IBM.TO.ACTIVEMQ\"/>",
                "        </inboundQueueBridges>",
                "    </jmsQueueConnector>",
                "</jmsBridgeConnectors>",
                "Attempt to send a message to the IBM queue."
            ],
            "ExpectedBehavior": "The message should be successfully sent from the IBM Websphere Queue to the ActiveMQ queue without any errors.",
            "ObservedBehavior": "An error occurs indicating that the destination name '://IBM.TO.ACTIVEMQ' is invalid and does not conform to the expected JMS destination syntax.",
            "Suggestions": "Update the destination name in the configuration to conform to JMS naming conventions, such as 'queue://IBM.TO.ACTIVEMQ'.",
            "problem_location": {
                "files": [
                    "activemq.xml",
                    "ActiveMQMessageTransformation.java",
                    "ActiveMQSession.java"
                ],
                "classes": [
                    "org.apache.activemq.ActiveMQMessageTransformation",
                    "org.apache.activemq.ActiveMQSession"
                ],
                "methods": [
                    "ActiveMQMessageTransformation.transformMessage",
                    "ActiveMQSession.send"
                ]
            },
            "possible_fix": "Change the destination name in the activemq.xml configuration from '://IBM.TO.ACTIVEMQ' to 'queue://IBM.TO.ACTIVEMQ'."
        },
        "possible_fix_code": {
            "ActiveMQMessageTransformation.transformMessage": "    public static ActiveMQMessage transformMessage(Message message, ActiveMQConnection connection)\n        throws JMSException {\n        if (message instanceof ActiveMQMessage) {\n            return (ActiveMQMessage)message;\n\n        } else {\n            ActiveMQMessage activeMessage = null;\n\n            if (message instanceof BytesMessage) {\n                BytesMessage bytesMsg = (BytesMessage)message;\n                bytesMsg.reset();\n                ActiveMQBytesMessage msg = new ActiveMQBytesMessage();\n                msg.setConnection(connection);\n                try {\n                    for (;;) {\n                        // Reads a byte from the message stream until the stream\n                        // is empty\n                        msg.writeByte(bytesMsg.readByte());\n                    }\n                } catch (MessageEOFException e) {\n                    // if an end of message stream as expected\n                } catch (JMSException e) {\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof MapMessage) {\n                MapMessage mapMsg = (MapMessage)message;\n                ActiveMQMapMessage msg = new ActiveMQMapMessage();\n                msg.setConnection(connection);\n                Enumeration iter = mapMsg.getMapNames();\n\n                while (iter.hasMoreElements()) {\n                    String name = iter.nextElement().toString();\n                    msg.setObject(name, mapMsg.getObject(name));\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof ObjectMessage) {\n                ObjectMessage objMsg = (ObjectMessage)message;\n                ActiveMQObjectMessage msg = new ActiveMQObjectMessage();\n                msg.setConnection(connection);\n                msg.setObject(objMsg.getObject());\n                msg.storeContent();\n                activeMessage = msg;\n            } else if (message instanceof StreamMessage) {\n                StreamMessage streamMessage = (StreamMessage)message;\n                streamMessage.reset();\n                ActiveMQStreamMessage msg = new ActiveMQStreamMessage();\n                msg.setConnection(connection);\n                Object obj = null;\n\n                try {\n                    while ((obj = streamMessage.readObject()) != null) {\n                        msg.writeObject(obj);\n                    }\n                } catch (MessageEOFException e) {\n                    // if an end of message stream as expected\n                } catch (JMSException e) {\n                }\n\n                activeMessage = msg;\n            } else if (message instanceof TextMessage) {\n                TextMessage textMsg = (TextMessage)message;\n                ActiveMQTextMessage msg = new ActiveMQTextMessage();\n                msg.setConnection(connection);\n                msg.setText(textMsg.getText());\n                activeMessage = msg;\n            } else if (message instanceof BlobMessage) {\n                BlobMessage blobMessage = (BlobMessage)message;\n                ActiveMQBlobMessage msg = new ActiveMQBlobMessage();\n                msg.setConnection(connection);\n                msg.setBlobDownloader(new BlobDownloader(connection.getBlobTransferPolicy()));\n                try {\n                    msg.setURL(blobMessage.getURL());\n                } catch (MalformedURLException e) {\n                }\n                activeMessage = msg;\n            } else {\n                activeMessage = new ActiveMQMessage();\n                activeMessage.setConnection(connection);\n            }\n\n            // Fixing the destination name to conform to JMS naming conventions\n            if (activeMessage.getJMSDestination() != null) {\n                String destinationName = activeMessage.getJMSDestination().toString();\n                if (destinationName.startsWith(\"://\")) {\n                    destinationName = \"queue://\" + destinationName.substring(3);\n                    activeMessage.setJMSDestination(new ActiveMQQueue(destinationName));\n                }\n            }\n\n            copyProperties(message, activeMessage);\n\n            return activeMessage;\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3903.json",
        "creation_time": "2012-06-28T14:09:35.000+0000",
        "bug_report": {
            "Title": "Failed to fire fast producer advisory, reason: java.lang.NullPointerException",
            "Description": "A NullPointerException occurs when sending multiple messages to a queue via the Webconsole with the advisoryForFastProducers set to true. The exception is triggered during the advisory process, specifically in the AdvisoryBroker class when attempting to fire a fast producer advisory. The stack trace indicates that the issue arises from the getFastProducerAdvisoryTopic method in the AdvisorySupport class, which is called with a null destination.",
            "StackTrace": [
                "java.lang.NullPointerException",
                "at org.apache.activemq.advisory.AdvisorySupport.getFastProducerAdvisoryTopic(AdvisorySupport.java:195)",
                "at org.apache.activemq.advisory.AdvisoryBroker.fastProducer(AdvisoryBroker.java:352)",
                "at org.apache.activemq.broker.BrokerFilter.fastProducer(BrokerFilter.java:275)",
                "at org.apache.activemq.broker.MutableBrokerFilter.fastProducer(MutableBrokerFilter.java:286)",
                "at org.apache.activemq.broker.region.BaseDestination.fastProducer(BaseDestination.java:512)",
                "at org.apache.activemq.broker.region.Queue.send(Queue.java:605)",
                "at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:407)",
                "at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:503)",
                "at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:305)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)",
                "at org.apache.activemq.broker.scheduler.SchedulerBroker.send(SchedulerBroker.java:189)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:129)",
                "at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)",
                "at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:306)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:135)",
                "at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:453)",
                "at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:681)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:150)",
                "at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:116)",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)",
                "at org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:231)",
                "at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)",
                "at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)"
            ],
            "RootCause": "The root cause of the NullPointerException is that the destination parameter passed to the getFastProducerAdvisoryTopic method is null. This occurs because the ProducerInfo object, which is expected to contain a valid destination, is not properly initialized or its destination is not set before being used.",
            "StepsToReproduce": [
                "1. Set up the ActiveMQ broker with advisoryForFastProducers set to true.",
                "2. Use the Webconsole to send multiple messages to a queue.",
                "3. Observe the logs for warnings or errors related to fast producer advisories."
            ],
            "ExpectedBehavior": "The system should successfully fire fast producer advisories without any exceptions, indicating that the advisory mechanism is functioning correctly.",
            "ObservedBehavior": "A java.lang.NullPointerException is thrown, preventing the fast producer advisory from being fired, and resulting in a warning message in the logs.",
            "Suggestions": "Ensure that the ProducerInfo object is properly initialized and that the setDestination method is called with a valid ActiveMQDestination before invoking the fastProducer method.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/advisory/AdvisorySupport.java",
                    "activemq-core/src/main/java/org/apache/activemq/advisory/AdvisoryBroker.java",
                    "activemq-core/src/main/java/org/apache/activemq/command/ProducerInfo.java"
                ],
                "classes": [
                    "org.apache.activemq.advisory.AdvisorySupport",
                    "org.apache.activemq.advisory.AdvisoryBroker",
                    "org.apache.activemq.command.ProducerInfo"
                ],
                "methods": [
                    "AdvisorySupport.getFastProducerAdvisoryTopic",
                    "AdvisoryBroker.fastProducer",
                    "ProducerInfo.setDestination"
                ]
            },
            "possible_fix": "Check the code where ProducerInfo instances are created and ensure that the setDestination method is called with a valid ActiveMQDestination. For example, in the addProducer method of the AdvisoryBroker class, validate that the destination is not null before proceeding."
        },
        "possible_fix_code": {
            "org.apache.activemq.advisory.AdvisoryBroker.addProducer": "    @Override\n    public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {\n        super.addProducer(context, info);\n\n        // Ensure the destination is set before proceeding\n        if (info.getDestination() == null) {\n            throw new IllegalArgumentException(\"ProducerInfo destination cannot be null\");\n        }\n\n        // Don't advise advisory topics.\n        if (!AdvisorySupport.isAdvisoryTopic(info.getDestination())) {\n            ActiveMQTopic topic = AdvisorySupport.getProducerAdvisoryTopic(info.getDestination());\n            fireProducerAdvisory(context, info.getDestination(), topic, info);\n            producers.put(info.getProducerId(), info);\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-2693.json",
        "creation_time": "2010-04-12T13:58:58.000+0000",
        "bug_report": {
            "Title": "Potential hang with failover, transactions, and slow thread creation with outstanding commit - FailoverConsumerOutstandingCommitTest intermittent failure",
            "Description": "This issue appears to be a potential deadlock scenario occurring during message dispatch in the ActiveMQ broker, particularly after a failover event. The logs indicate that the dispatch process is paused due to an outstanding commit, which is causing threads to wait indefinitely. The stack trace reveals multiple threads in various states, including RUNNABLE and TIMED_WAITING, suggesting contention for resources and possible blocking conditions.",
            "StackTrace": [
                "WARN  ActiveMQConnection - dispatch paused, waiting for outstanding dispatch interruption processing (x) to complete..",
                "java.lang.Thread.State: RUNNABLE",
                "at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1205)",
                "at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:790)",
                "java.lang.Thread.State: TIMED_WAITING (parking)",
                "at org.apache.activemq.ActiveMQConnection.waitForTransportInterruptionProcessing(ActiveMQConnection.java:2248)",
                "java.lang.Thread.State: BLOCKED (on object monitor)",
                "at org.apache.activemq.ActiveMQMessageConsumer.clearMessagesInProgress(ActiveMQMessageConsumer.java:661)"
            ],
            "RootCause": "The root cause of the issue is a deadlock situation arising from the `processDispatch` and `dispatch` methods in the `TransportConnection` class. The dispatch process is blocked by an outstanding commit, which prevents further message processing and leads to threads being stuck in a waiting state.",
            "StepsToReproduce": [
                "1. Initiate a failover scenario in the ActiveMQ broker.",
                "2. Trigger transactions that require message dispatch.",
                "3. Observe the behavior of threads during the dispatch process."
            ],
            "ExpectedBehavior": "In a properly functioning system, the message dispatch should complete without delays, and threads should not be blocked indefinitely. The system should handle failover gracefully without leading to deadlocks.",
            "ObservedBehavior": "The system experiences intermittent failures where threads are blocked or waiting indefinitely due to outstanding commits during failover, leading to potential hangs.",
            "Suggestions": "Review the implementation of the `processDispatch` and `dispatch` methods to ensure that they handle concurrent access and resource locking appropriately. Consider implementing timeout mechanisms for outstanding commits to prevent indefinite blocking.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/broker/TransportConnection.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.TransportConnection"
                ],
                "methods": [
                    "processDispatch",
                    "dispatch"
                ]
            },
            "possible_fix": "Consider adding a timeout to the `processDispatch` method to handle cases where the dispatch process is blocked by an outstanding commit. This could involve modifying the logic to check for a timeout condition and handle it gracefully."
        },
        "possible_fix_code": {
            "processDispatch": "    protected void processDispatch(Command command) throws IOException {\n        final MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);\n        long startTime = System.currentTimeMillis();\n        long timeout = 5000; // 5 seconds timeout\n        try {\n            if (!stopping.get()) {\n                if (messageDispatch != null) {\n                    broker.preProcessDispatch(messageDispatch);\n                }\n                dispatch(command);\n            }\n        } finally {\n            if (messageDispatch != null) {\n                Runnable sub = messageDispatch.getTransmitCallback();\n                broker.postProcessDispatch(messageDispatch);\n                if (sub != null) {\n                    sub.run();\n                }\n            }\n            // Check for timeout\n            if (System.currentTimeMillis() - startTime > timeout) {\n                // Handle timeout scenario, e.g., log a warning or throw an exception\n                System.err.println(\"Warning: Dispatch process timed out.\");\n            }\n            // getStatistics().getDequeues().increment();\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-4643.json",
        "creation_time": "2013-07-19T13:39:19.000+0000",
        "bug_report": {
            "Title": "JDBCPersistence DB stopped during message send with JDBCIOExceptionHandler configured; IOException/SQLException is sent back (sometimes) to the client before the transport connector is shutdown",
            "Description": "This issue is related to AMQ-4636, specifically concerning the behavior of the ActiveMQ broker when a persistent message is sent while the underlying database is shut down. The scenario involves a producer sending a message without a transaction, with the JDBCIOExceptionHandler configured. When the database is unavailable, two outcomes can occur: either an IOException/SQLException is sent back to the client wrapped in a JMSException, or the transport connector is shut down immediately upon encountering the exception. The expected behavior is that the JDBCIOExceptionHandler should manage the exception, preventing it from being reported to the producer and ensuring a graceful shutdown of the transport connectors.",
            "StackTrace": [
                "2013-07-19 15:22:05,436 [main           ] - ERROR pDBDuringProducerSendTopicTest - unexpected exception caught",
                "javax.jms.JMSException: Database 'target/derbydb_15' not found.",
                "at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:54)",
                "at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1391)",
                "at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1319)",
                "at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1809)",
                "at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:289)",
                "at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:224)",
                "at org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:241)",
                "at org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest.sendMessage(StopDBDuringProducerSendTopicTest.java:150)",
                "at org.apache.activemq.store.jdbc.StopDBDuringProducerSendTopicTest.testProducerWithDBShutdown(StopDBDuringProducerSendTopicTest.java:127)",
                "Caused by: java.io.IOException: Database 'target/derbydb_15' not found.",
                "at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:45)",
                "at org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:68)",
                "at org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doAddMessage(DefaultJDBCAdapter.java:218)",
                "at org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage(JDBCMessageStore.java:123)",
                "at org.apache.activemq.store.memory.MemoryTransactionStore.addMessage(MemoryTransactionStore.java:327)",
                "at org.apache.activemq.broker.region.Topic.doMessageSend(Topic.java:482)",
                "at org.apache.activemq.broker.region.Topic.send(Topic.java:446)",
                "at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:406)",
                "at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:431)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:147)",
                "at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)",
                "at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:317)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:152)",
                "at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:464)",
                "at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:751)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:294)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)",
                "at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:288)",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)",
                "at java.lang.Thread.run(Thread.java:680)"
            ],
            "RootCause": "The root cause of the issue is the failure to locate the database 'target/derbydb_15', which results in a java.sql.SQLException. This indicates that the database may not have been created, the path is incorrect, or the application lacks the necessary permissions to access the database.",
            "StepsToReproduce": [
                "1. Configure the JDBCIOExceptionHandler in the ActiveMQ broker.",
                "2. Ensure the database 'target/derbydb_15' is not available (e.g., shut it down).",
                "3. Send a persistent message from a producer without a transaction.",
                "4. Observe the behavior of the broker when the database is unavailable."
            ],
            "ExpectedBehavior": "The JDBCIOExceptionHandler should handle the SQL exception gracefully, preventing any IOException/SQLException from being reported to the producer and ensuring that the transport connectors are shut down properly.",
            "ObservedBehavior": "When the database is unavailable, the broker either sends an IOException/SQLException wrapped in a JMSException back to the client or shuts down the transport connector immediately, leading to inconsistent behavior.",
            "Suggestions": "Verify the database path and ensure that the database is created and accessible before sending messages. Additionally, consider enhancing the JDBCIOExceptionHandler to manage exceptions more effectively.",
            "problem_location": {
                "files": [
                    "activemq-client/src/main/java/org/apache/activemq/TransactionContext.java",
                    "activemq-jdbc-store/src/main/java/org/apache/activemq/store/jdbc/adapter/DefaultJDBCAdapter.java"
                ],
                "classes": [
                    "org.apache.activemq.TransactionContext",
                    "org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter"
                ],
                "methods": [
                    "TransactionContext.getConnection",
                    "DefaultJDBCAdapter.doAddMessage"
                ]
            },
            "possible_fix": "Ensure that the database 'target/derbydb_15' is created and accessible before running the tests. Additionally, review the JDBCIOExceptionHandler implementation to ensure it properly manages exceptions and prevents them from propagating to the producer."
        },
        "possible_fix_code": {
            "org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doAddMessage": "    public void doAddMessage(TransactionContext c, long sequence, MessageId messageID, ActiveMQDestination destination, byte[] data,\n                             long expiration, byte priority, XATransactionId xid) throws SQLException, IOException {\n        PreparedStatement s = c.getAddMessageStatement();\n        cleanupExclusiveLock.readLock().lock();\n        try {\n            if (s == null) {\n                s = c.getConnection().prepareStatement(this.statements.getAddMessageStatement());\n                if (this.batchStatments) {\n                    c.setAddMessageStatement(s);\n                }\n            }\n            s.setLong(1, sequence);\n            s.setString(2, messageID.getProducerId().toString());\n            s.setLong(3, messageID.getProducerSequenceId());\n            s.setString(4, destination.getQualifiedName());\n            s.setLong(5, expiration);\n            s.setLong(6, priority);\n            setBinaryData(s, 7, data);\n            if (xid != null) {\n                byte[] xidVal = xid.getEncodedXidBytes();\n                xidVal[0] = '+';\n                String xidString = printBase64Binary(xidVal);\n                s.setString(8, xidString);\n            } else {\n                s.setString(8, null);\n            }\n            if (this.batchStatments) {\n                s.addBatch();\n            } else if (s.executeUpdate() != 1) {\n                throw new SQLException(\"Failed to add a message\");\n            }\n        } catch (SQLException e) {\n            // Log the exception and handle it gracefully\n            LOG.error(\"SQLException occurred while adding message: \" + e.getMessage(), e);\n            throw new IOException(\"Database operation failed: \" + e.getMessage(), e);\n        } finally {\n            cleanupExclusiveLock.readLock().unlock();\n            if (!this.batchStatments) {\n                if (s != null) {\n                    s.close();\n                }\n            }\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-2902.json",
        "creation_time": "2010-09-07T11:34:15.000+0000",
        "bug_report": {
            "Title": "ResourceAdapter logs confusing Exception upon pool connection disposal",
            "Description": "After upgrading to version 5.4.0, numerous INFO level exceptions are logged, indicating that the transport connection has been disposed. The stack trace reveals that the issue arises from the `stop` method in the `VMTransport` class, which is responsible for managing the transport layer's lifecycle. The logged exceptions, while marked as INFO, are misleading and can cause confusion among developers and users.",
            "StackTrace": [
                "2010-09-07 13:23:25,824 INFO  [org.apache.activemq.broker.TransportConnection.Transport] Transport failed: org.apache.activemq.transport.TransportDisposedIOException: Peer (vm://caa.embedded?waitForStart=300000&async=false#13) disposed.",
                "org.apache.activemq.transport.TransportDisposedIOException: Peer (vm://caa.embedded?waitForStart=300000&async=false#13) disposed.",
                "at org.apache.activemq.transport.vm.VMTransport.stop(VMTransport.java:159)",
                "at org.apache.activemq.transport.vm.VMTransportServer$1.stop(VMTransportServer.java:81)",
                "at org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)",
                "at org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)",
                "at org.apache.activemq.transport.ResponseCorrelator.stop(ResponseCorrelator.java:132)",
                "at org.apache.activemq.util.ServiceSupport.dispose(ServiceSupport.java:43)",
                "at org.apache.activemq.ActiveMQConnection.close(ActiveMQConnection.java:656)",
                "at org.apache.activemq.ra.ActiveMQManagedConnection.destroy(ActiveMQManagedConnection.java:207)",
                "at org.jboss.resource.connectionmanager.InternalManagedConnectionPool.doDestroy(InternalManagedConnectionPool.java:650)",
                "at org.jboss.resource.connectionmanager.InternalManagedConnectionPool.removeTimedOut(InternalManagedConnectionPool.java:481)",
                "at org.jboss.resource.connectionmanager.IdleRemover$IdleRemoverRunnable.run(IdleRemover.java:164)",
                "at java.lang.Thread.run(Thread.java:619)"
            ],
            "RootCause": "The root cause of the issue is related to the `stop` method in the `VMTransport` class, which has potential concurrency issues and improper state management. Specifically, the method does not handle the case where multiple threads may attempt to stop the transport simultaneously, leading to inconsistent states and the logging of misleading exceptions.",
            "StepsToReproduce": [
                "Upgrade to ActiveMQ version 5.4.0.",
                "Establish a connection using the ResourceAdapter.",
                "Trigger the disposal of the connection pool.",
                "Observe the logs for INFO level exceptions related to transport disposal."
            ],
            "ExpectedBehavior": "When the connection pool is disposed, the transport should cleanly shut down without logging misleading exceptions. The system should handle the disposal gracefully, ensuring that all resources are released properly.",
            "ObservedBehavior": "Upon disposal of the connection pool, multiple INFO level exceptions are logged, indicating that the transport has been disposed. These messages are confusing and do not accurately reflect the state of the system.",
            "Suggestions": "To mitigate this issue, consider implementing proper synchronization in the `stop` method to prevent concurrent access issues. Additionally, improve exception handling to ensure that critical issues are logged appropriately rather than being ignored.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/transport/vm/VMTransport.java"
                ],
                "classes": [
                    "org.apache.activemq.transport.vm.VMTransport"
                ],
                "methods": [
                    "VMTransport.stop"
                ]
            },
            "possible_fix": "In the `stop` method of the `VMTransport` class, ensure that state changes to `started` and `disposed` are properly synchronized. Additionally, modify the exception handling to log critical exceptions instead of ignoring them. Example code changes could include using synchronized blocks or locks around state changes."
        },
        "possible_fix_code": {
            "VMTransport.stop": "    public void stop() throws Exception {\n        stopping.set(true);\n        \n        // If stop() is called while being start()ed.. then we can't stop until we return to the start() method.\n        if( enqueueValve.isOn() ) {\n        \t\n            // let the peer know that we are disconnecting..\n            try {\n            \tif (peer != null && peer.transportListener != null) {\n            \t\tpeer.transportListener.onException(new TransportDisposedIOException(\"Peer (\" + peer.toString() + \") disposed.\"));\n            \t}\n            } catch (Exception e) {\n            \t// Log the exception instead of ignoring it\n            \tSystem.err.println(\"Error notifying peer: \" + e.getMessage());\n            }\n        \t\n        \t\n            TaskRunner tr = null;\n            try {\n                enqueueValve.turnOff();\n                if (!disposed) {\n                    started = false;\n                    disposed = true;\n                    if (taskRunner != null) {\n                        tr = taskRunner;\n                        taskRunner = null;\n                    }\n                }\n            } finally {\n                stopping.set(false);\n                enqueueValve.turnOn();\n            }\n            if (tr != null) {\n                tr.shutdown(1000);\n            }\n            \n\n        }\n        \n    }"
        }
    },
    {
        "filename": "AMQ-5665.json",
        "creation_time": "2015-03-16T21:35:15.000+0000",
        "bug_report": {
            "Title": "Memory Store is Broken in 5.11.0 for Advisories (and Probably Other Issues as Well)",
            "Description": "In version 5.11.0 of ActiveMQ, a critical issue has been identified where advisories fail to fire due to a NullPointerException in the MemoryTransactionStore. This issue does not occur in version 5.10.2, indicating a regression introduced in the newer version. The problem arises when the `addMessage` method is called with a null message, leading to the failure of advisory messages to be delivered. The stack trace indicates that the `fireAdvisory` method in the `AdvisoryBroker` class is attempting to access properties of a message that is null, specifically when it tries to call `getDestination()` or `copy()` on the result of `getMessage()` from `MessageReference`.",
            "StackTrace": [
                "java.lang.NullPointerException",
                "at org.apache.activemq.advisory.AdvisoryBroker.fireAdvisory(AdvisoryBroker.java:626)",
                "at org.apache.activemq.advisory.AdvisoryBroker.messageDelivered(AdvisoryBroker.java:397)",
                "at org.apache.activemq.broker.BrokerFilter.messageDelivered(BrokerFilter.java:349)",
                "at org.apache.activemq.broker.BrokerFilter.messageDelivered(BrokerFilter.java:349)",
                "at org.apache.activemq.broker.MutableBrokerFilter.messageDelivered(MutableBrokerFilter.java:360)",
                "at org.apache.activemq.broker.MutableBrokerFilter.messageDelivered(MutableBrokerFilter.java:360)",
                "at org.apache.activemq.broker.region.BaseDestination.messageDelivered(BaseDestination.java:518)",
                "at org.apache.activemq.broker.region.Queue.messageSent(Queue.java:1806)",
                "at org.apache.activemq.broker.region.Queue.doPendingCursorAdditions(Queue.java:794)",
                "at org.apache.activemq.broker.region.Queue.orderedCursorAdd(Queue.java:875)",
                "at org.apache.activemq.broker.region.Queue.doMessageSend(Queue.java:854)",
                "at org.apache.activemq.broker.region.Queue.send(Queue.java:733)",
                "at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:419)",
                "at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:468)",
                "at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:297)",
                "at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:152)",
                "at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)",
                "at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:307)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)",
                "at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)",
                "at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:541)",
                "at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:768)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:334)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:188)",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)",
                "at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)",
                "at java.lang.Thread.run(Thread.java:724)"
            ],
            "RootCause": "The root cause of the issue is that the `messageDelivered` method in the `AdvisoryBroker` class is attempting to access properties of a `Message` object that is null. This occurs when `messageReference.getMessage()` returns null, leading to a NullPointerException when the code tries to call methods like `getDestination()` or `copy()` on the null object. This situation can arise if the message has not been properly initialized or has been removed from the queue before it is delivered.",
            "StepsToReproduce": [
                "1. Upgrade ActiveMQ from version 5.10.2 to 5.11.0.",
                "2. Configure a non-persistent broker.",
                "3. Attempt to send messages that should trigger advisories.",
                "4. Observe that advisories fail to fire and check the logs for NullPointerException."
            ],
            "ExpectedBehavior": "Advisories should fire correctly when messages are delivered, and no exceptions should occur.",
            "ObservedBehavior": "Advisories fail to fire, and a NullPointerException is thrown in the `AdvisoryBroker` class.",
            "Suggestions": "Implement null checks in the `messageDelivered` method to handle cases where `getMessage()` returns null. Ensure that messages are properly initialized and managed in the queue to prevent this issue from occurring.",
            "problem_location": {
                "files": [
                    "activemq-broker/src/main/java/org/apache/activemq/advisory/AdvisoryBroker.java",
                    "activemq-client/src/main/java/org/apache/activemq/broker/region/MessageReference.java",
                    "activemq-client/src/main/java/org/apache/activemq/command/Message.java",
                    "activemq-broker/src/main/java/org/apache/activemq/broker/region/Queue.java",
                    "activemq-broker/src/main/java/org/apache/activemq/store/memory/MemoryTransactionStore.java"
                ],
                "classes": [
                    "org.apache.activemq.advisory.AdvisoryBroker",
                    "org.apache.activemq.broker.region.MessageReference",
                    "org.apache.activemq.command.Message",
                    "org.apache.activemq.broker.region.Queue",
                    "org.apache.activemq.store.MemoryTransactionStore"
                ],
                "methods": [
                    "AdvisoryBroker.fireAdvisory",
                    "AdvisoryBroker.messageDelivered",
                    "MessageReference.getMessage",
                    "Queue.messageSent",
                    "MemoryTransactionStore.addMessage"
                ]
            },
            "possible_fix": "Add null checks in the `messageDelivered` method of the `AdvisoryBroker` class to prevent NullPointerExceptions. For example, before accessing properties of the message, check if `messageReference.getMessage()` is null and handle that case appropriately."
        },
        "possible_fix_code": {
            "org.apache.activemq.advisory.AdvisoryBroker.messageDelivered": "    public void messageDelivered(ConnectionContext context, MessageReference messageReference) {\n        super.messageDelivered(context, messageReference);\n        try {\n            if (!messageReference.isAdvisory()) {\n                Message payload = messageReference.getMessage();\n                if (payload != null) { // Check if payload is null\n                    ActiveMQTopic topic = AdvisorySupport.getMessageDeliveredAdvisoryTopic(payload.getDestination());\n                    ActiveMQMessage advisoryMessage = new ActiveMQMessage();\n                    advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_MESSAGE_ID, payload.getMessageId().toString());\n                    ActiveMQDestination destination = payload.getDestination();\n                    if (destination != null) {\n                        advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_DESTINATION, payload.getMessageId().toString());\n                    }\n                    fireAdvisory(context, topic, payload, null, advisoryMessage);\n                } else {\n                    // Handle the case where the payload is null (optional logging or error handling)\n                    LOG.warn(\"Message payload is null for messageReference: \" + messageReference.getMessageId());\n                }\n            }\n        } catch (Exception e) {\n            handleFireFailure(\"delivered\", e);\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3725.json",
        "creation_time": "2012-02-17T18:57:21.000+0000",
        "bug_report": {
            "Title": "Kahadb error during SAN failover delayed write - Allow kahaDB to recover in a similar manner as the JDBC store using the IOExceptionHandler",
            "Description": "An issue arises with the KahaDB when using a SAN, particularly during failover scenarios. While the failover process is seamless, a 2-3 second delay occurs during failback, leading to blocked writes and eventual broker termination. Unlike the JDBC datastore, which can handle such situations using the IOExceptionHandler, the addition of this handler to KahaDB prevents termination but results in an invalid index. The logs indicate multiple errors related to file access and I/O operations, specifically `java.io.SyncFailedException`, `java.io.FileNotFoundException`, and `java.io.IOException`, which suggest underlying issues with file synchronization and missing files.",
            "StackTrace": [
                "ERROR | KahaDB failed to store to Journal",
                "java.io.SyncFailedException: sync failed",
                "ERROR | Checkpoint failed",
                "java.io.FileNotFoundException: /Volumes/NAS-01/data/kahadb/db-1.log (No such file or directory)",
                "ERROR | Checkpoint failed",
                "java.io.IOException: Input/output error"
            ],
            "RootCause": "The root cause of the issue is related to file access and synchronization failures in the KahaDB journal system. Specifically, the `processQueue` method in the `DataFileAppender` class is failing to write data due to missing files and I/O errors, while the `flush` method in the `PageFile` class is unable to commit buffered writes to disk, leading to checkpoint failures.",
            "StepsToReproduce": [
                "1. Configure KahaDB with a SAN.",
                "2. Initiate a failover scenario.",
                "3. Observe the broker's behavior during failback."
            ],
            "ExpectedBehavior": "The broker should seamlessly handle failover and failback without terminating, allowing writes to continue without delays or errors.",
            "ObservedBehavior": "During failback, writes are blocked for 2-3 seconds, leading to broker termination and errors related to file access and synchronization.",
            "Suggestions": "Check the file system for the existence of required files, ensure KahaDB configuration is correct, and verify that there are no underlying hardware or permission issues affecting file access. Consider implementing a more robust error handling mechanism similar to the JDBC store.",
            "problem_location": {
                "files": [
                    "DataFileAppender.java",
                    "PageFile.java"
                ],
                "classes": [
                    "org.apache.kahadb.journal.DataFileAppender",
                    "org.apache.kahadb.page.PageFile"
                ],
                "methods": [
                    "DataFileAppender.processQueue",
                    "PageFile.flush"
                ]
            },
            "possible_fix": "Ensure that the required log files exist and are accessible. Review the `processQueue` method to improve error handling for file access issues, and verify the `flush` method to ensure it correctly handles buffered writes and checkpointing."
        },
        "possible_fix_code": {
            "DataFileAppender.processQueue": "    protected void processQueue() {\n        DataFile dataFile = null;\n        RandomAccessFile file = null;\n        WriteBatch wb = null;\n        try {\n\n            DataByteArrayOutputStream buff = new DataByteArrayOutputStream(maxWriteBatchSize);\n            while (true) {\n\n                Object o = null;\n\n                // Block till we get a command.\n                synchronized (enqueueMutex) {\n                    while (true) {\n                        if (nextWriteBatch != null) {\n                            o = nextWriteBatch;\n                            nextWriteBatch = null;\n                            break;\n                        }\n                        if (shutdown) {\n                            return;\n                        }\n                        enqueueMutex.wait();\n                    }\n                    enqueueMutex.notify();\n                }\n\n                wb = (WriteBatch)o;\n                if (dataFile != wb.dataFile) {\n                    if (file != null) {\n                        dataFile.closeRandomAccessFile(file);\n                    }\n                    dataFile = wb.dataFile;\n                    file = dataFile.openRandomAccessFile(true);\n                }\n\n                WriteCommand write = wb.first;\n\n                // Write all the data.\n                // Only need to seek to first location.. all others\n                // are in sequence.\n                file.seek(write.location.getOffset());\n\n                boolean forceToDisk=false;\n                \n                // \n                // is it just 1 big write?\n                if (wb.size == write.location.getSize()) {\n                    forceToDisk = write.sync | write.onComplete!=null;\n                    \n                    // Just write it directly..\n                    file.writeInt(write.location.getSize());\n                    file.writeByte(write.location.getType());\n                    file.write(RESERVED_SPACE);\n                    file.write(AsyncDataManager.ITEM_HEAD_SOR);\n                    file.write(write.data.getData(), write.data.getOffset(), write.data.getLength());\n                    file.write(AsyncDataManager.ITEM_HEAD_EOR);\n\n                } else {\n\n                    // Combine the smaller writes into 1 big buffer\n                    while (write != null) {\n                        forceToDisk |= write.sync | write.onComplete!=null;\n\n                        buff.writeInt(write.location.getSize());\n                        buff.writeByte(write.location.getType());\n                        buff.write(RESERVED_SPACE);\n                        buff.write(AsyncDataManager.ITEM_HEAD_SOR);\n                        buff.write(write.data.getData(), write.data.getOffset(), write.data.getLength());\n                        buff.write(AsyncDataManager.ITEM_HEAD_EOR);\n\n                        write = (WriteCommand)write.getNext();\n                    }\n\n                    // Now do the 1 big write.\n                    ByteSequence sequence = buff.toByteSequence();\n                    file.write(sequence.getData(), sequence.getOffset(), sequence.getLength());\n                    buff.reset();\n                }\n\n                if( forceToDisk ) {\n                    try {\n                        file.getFD().sync();\n                    } catch (SyncFailedException e) {\n                        // Handle sync failure gracefully\n                        System.err.println(\"Sync failed: \" + e.getMessage());\n                        // Optionally, you can set a flag or throw a custom exception\n                    }\n                }\n                \n                WriteCommand lastWrite = (WriteCommand)wb.first.getTailNode();\n                dataManager.setLastAppendLocation(lastWrite.location);\n\n                // Now that the data is on disk, remove the writes from the in\n                // flight\n                // cache.\n                write = wb.first;\n                while (write != null) {\n                    if (!write.sync) {\n                        inflightWrites.remove(new WriteKey(write.location));\n                    }\n                    if( write.onComplete != null ) {\n                        try {\n                            write.onComplete.run();\n                        } catch (Throwable e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    write = (WriteCommand)write.getNext();\n                }\n                \n                // Signal any waiting threads that the write is on disk.\n                wb.latch.countDown();\n            }\n        } catch (IOException e) {\n            synchronized (enqueueMutex) {\n                firstAsyncException = e;\n                if (wb != null) {\n                    wb.latch.countDown();\n                    wb.exception.set(e);\n                }\n                if (nextWriteBatch != null) {\n                    nextWriteBatch.latch.countDown();\n                    nextWriteBatch.exception.set(e);\n                }\n            }\n        } catch (InterruptedException e) {\n        } finally {\n            try {\n                if (file != null) {\n                    dataFile.closeRandomAccessFile(file);\n                }\n            } catch (Throwable ignore) {\n            }\n            shutdownDone.countDown();\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3085.json",
        "creation_time": "2010-12-15T12:18:12.000+0000",
        "bug_report": {
            "Title": "IndexOutOfBoundsException on FailoverTransport.updateURIs after: already known: java.net.UnknownHostException",
            "Description": "The issue arises when the broker returns hosts that are not resolvable on the client side, leading to an `IndexOutOfBoundsException` during the URI update process in the `FailoverTransport` class. This exception occurs because the code attempts to add an element at an index that exceeds the current size of a `CopyOnWriteArrayList`. Disabling the update mechanism (by setting `updateURIsSupported=false` on the failover URI) serves as a temporary workaround. However, a more robust solution should be implemented to handle such scenarios gracefully.",
            "StackTrace": [
                "2010-12-10 07:48:16,574 [ActiveMQ Transport: tcp://xx:61616] DEBUG  failover.FailoverTransport:228 - Transport failed with the following exception:",
                "java.io.IOException: Unexpected error occured",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:208) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at java.lang.Thread.run(Thread.java:619) [na:1.6.0_12]",
                "Caused by: java.lang.IndexOutOfBoundsException: Index: 12, Size: 11",
                "at java.util.concurrent.CopyOnWriteArrayList.add(CopyOnWriteArrayList.java:409) ~[na:1.6.0_12]",
                "at org.apache.activemq.transport.failover.FailoverTransport.add(FailoverTransport.java:613) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.failover.FailoverTransport.updateURIs(FailoverTransport.java:1046) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.failover.FailoverTransport.processNewTransports(FailoverTransport.java:285) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.failover.FailoverTransport.handleConnectionControl(FailoverTransport.java:265) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.failover.FailoverTransport$3.onCommand(FailoverTransport.java:177) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:228) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:219) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:201) ~[activemq-core-5.4.1.jar:5.4.1-fuse-01-00]"
            ],
            "RootCause": "The root cause of the issue is an `IndexOutOfBoundsException` occurring in the `CopyOnWriteArrayList` when attempting to add an element at an index that exceeds the current size of the list. This is likely triggered by the failure to resolve hostnames returned by the broker, leading to incorrect index calculations during URI updates.",
            "StepsToReproduce": [
                "1. Configure the ActiveMQ broker to return a list of hosts that are not resolvable.",
                "2. Attempt to connect to the broker using the failover transport.",
                "3. Observe the logs for the `IndexOutOfBoundsException` in the `FailoverTransport` class."
            ],
            "ExpectedBehavior": "The system should handle unresolvable hosts gracefully without throwing an `IndexOutOfBoundsException`. The failover transport should either skip the unresolvable hosts or retry with valid hosts.",
            "ObservedBehavior": "An `IndexOutOfBoundsException` is thrown when the failover transport attempts to update its list of URIs, causing a failure in the transport layer.",
            "Suggestions": "Review the logic that determines the index for adding elements to the `CopyOnWriteArrayList`. Ensure that the index is calculated correctly and that checks are in place to prevent out-of-bounds access. Additionally, consider implementing better error handling for unresolvable hosts.",
            "problem_location": {
                "files": [
                    "FailoverTransport.java"
                ],
                "classes": [
                    "org.apache.activemq.transport.failover.FailoverTransport"
                ],
                "methods": [
                    "FailoverTransport.updateURIs",
                    "FailoverTransport.add"
                ]
            },
            "possible_fix": "Add validation checks before adding elements to the `CopyOnWriteArrayList` in the `updateURIs` method to ensure that the index is within the valid range. For example:\n\nif (index < 0 || index > list.size()) {\n    // Handle the error appropriately\n}\n\nThis will prevent the `IndexOutOfBoundsException` from occurring."
        },
        "possible_fix_code": {
            "FailoverTransport.updateURIs": "    public void updateURIs(boolean rebalance, URI[] updatedURIs) throws IOException {\n        if (isUpdateURIsSupported()) {\n            List<URI> copy = new ArrayList<URI>(this.updated);\n            List<URI> add = new ArrayList<URI>();\n            if (updatedURIs != null && updatedURIs.length > 0) {\n                Set<URI> set = new HashSet<URI>();\n                for (int i = 0; i < updatedURIs.length; i++) {\n                    URI uri = updatedURIs[i];\n                    if (uri != null) {\n                        set.add(uri);\n                    }\n                }\n                for (URI uri : set) {\n                    if (copy.remove(uri) == false) {\n                        add.add(uri);\n                    }\n                }\n                synchronized (reconnectMutex) {\n                    this.updated.clear();\n                    this.updated.addAll(add);\n                    for (URI uri : copy) {\n                        this.uris.remove(uri);\n                    }\n                    // Check if the add list is not empty before adding\n                    if (!add.isEmpty()) {\n                        add(rebalance, add.toArray(new URI[add.size()]));\n                    }\n                }\n            }\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-3504.json",
        "creation_time": "2011-09-19T14:33:49.000+0000",
        "bug_report": {
            "Title": "NullPointerException on websocket connection",
            "Description": "A NullPointerException is thrown when attempting to connect via websockets using Chrome or Firefox 6. This issue does not occur with Firefox 5 or Safari, suggesting a potential incompatibility with the websocket implementation in ActiveMQ. The stack trace indicates that the exception arises in the `doGet` method of the `StompServlet` class, specifically when trying to forward the request to a named dispatcher. The root cause may be related to the servlet context not being properly initialized or the dispatcher not being configured correctly.",
            "StackTrace": [
                "java.lang.NullPointerException",
                "at org.apache.activemq.transport.ws.StompServlet.doGet(StompServlet.java:51)",
                "at javax.servlet.http.HttpServlet.service(HttpServlet.java:693)",
                "at org.eclipse.jetty.websocket.WebSocketServlet.service(WebSocketServlet.java:73)",
                "at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)",
                "at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:527)",
                "at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:423)",
                "at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)",
                "at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:930)",
                "at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:358)",
                "at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)",
                "at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:866)",
                "at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)",
                "at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:113)",
                "at org.eclipse.jetty.server.Server.handle(Server.java:351)",
                "at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:594)",
                "at org.eclipse.jetty.server.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:1042)",
                "at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:549)",
                "at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:211)",
                "at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:424)",
                "at org.eclipse.jetty.server.bio.SocketConnector$ConnectorEndPoint.run(SocketConnector.java:241)",
                "at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:436)",
                "at java.lang.Thread.run(Thread.java:680)"
            ],
            "RootCause": "The NullPointerException in the `doGet` method of `StompServlet` is likely caused by either a null `ServletContext` or a missing named dispatcher 'default'. The servlet context must be properly initialized before the `doGet` method is invoked, and the dispatcher must be correctly configured in the web application.",
            "StepsToReproduce": [
                "1. Deploy the application with the `StompServlet` configured.",
                "2. Attempt to connect to the websocket using Chrome or Firefox 6.",
                "3. Observe the NullPointerException in the logs."
            ],
            "ExpectedBehavior": "The websocket connection should be established successfully without throwing any exceptions.",
            "ObservedBehavior": "A NullPointerException is thrown, preventing the websocket connection from being established.",
            "Suggestions": "Ensure that the `ServletContext` is properly initialized before the `doGet` method is called. Verify that the named dispatcher 'default' is correctly defined in the web application configuration (likely in `web.xml` or through annotations).",
            "problem_location": {
                "files": [
                    "StompServlet.java"
                ],
                "classes": [
                    "org.apache.activemq.transport.ws.StompServlet"
                ],
                "methods": [
                    "StompServlet.doGet",
                    "StompServlet.init"
                ]
            },
            "possible_fix": "Check the web application configuration to ensure that the 'acceptListener' attribute is set in the `ServletContext` and that the dispatcher 'default' is correctly configured. If necessary, modify the `init` method to handle cases where the context or dispatcher is not set."
        },
        "possible_fix_code": {
            "StompServlet.doGet": "    protected void doGet(HttpServletRequest request, HttpServletResponse response) \n        throws ServletException, IOException  {\n        if (getServletContext() == null) {\n            throw new ServletException(\"ServletContext is not initialized.\");\n        }\n        if (getServletContext().getNamedDispatcher(\"default\") == null) {\n            throw new ServletException(\"Named dispatcher 'default' is not configured.\");\n        }\n        getServletContext().getNamedDispatcher(\"default\").forward(request, response);\n    }"
        }
    },
    {
        "filename": "AMQ-6707.json",
        "creation_time": "2017-06-19T11:29:47.000+0000",
        "bug_report": {
            "Title": "JDBC XA: Could not remove prepared transaction state from message",
            "Description": "The issue occurs intermittently when ActiveMQ 5.14.5 is configured with JDBC persistence storage using PostgreSQL. The error arises during the commit phase of a transaction, leading to a failure in removing the prepared transaction state. The stack trace indicates that a `javax.transaction.xa.XAException` is thrown, specifically stating 'STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104'. This suggests that the transaction could not be committed due to an underlying issue, which is further detailed by a `java.io.IOException` indicating a failure to remove the prepared transaction state for a specific message sequence ID.",
            "StackTrace": [
                "2017-06-15 01:41:37,418 | ERROR | enerContainer-21 | CommitTask | 67 - org.apache.aries.transaction.manager - 1.3.1 | Unexpected exception committing org.apache.geronimo.transaction.manager.WrapperNamedXAResource@34ac9d62; continuing to commit other RMs",
                "javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104",
                "at org.apache.activemq.TransactionContext.toXAException(TransactionContext.java:793)",
                "at org.apache.activemq.TransactionContext.commit(TransactionContext.java:622)",
                "at org.apache.geronimo.transaction.manager.WrapperNamedXAResource.commit(WrapperNamedXAResource.java:54)",
                "at org.apache.geronimo.transaction.manager.CommitTask.run(CommitTask.java:64)",
                "at org.apache.geronimo.transaction.manager.TransactionImpl.commitResources(TransactionImpl.java:688)",
                "at org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:327)",
                "at org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:252)",
                "at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1020)",
                "at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:761)",
                "at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:730)",
                "at org.apache.aries.transaction.internal.AriesPlatformTransactionManager.commit(AriesPlatformTransactionManager.java:75)",
                "at sun.reflect.GeneratedMethodAccessor180.invoke(Unknown Source)",
                "at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)",
                "at java.lang.reflect.Method.invoke(Method.java:498)",
                "at com.ectsp.spring.osgi.PlatformTransactionManagerFactoryBean$ProxyTxManagerHandler.invoke(PlatformTransactionManagerFactoryBean.java:115)",
                "at com.sun.proxy.$Proxy68.commit(Unknown Source)",
                "at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:245)",
                "at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1164)",
                "at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1156)",
                "at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1053)",
                "at java.lang.Thread.run(Thread.java:748)",
                "Caused by: javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back xaErrorCode:104",
                "at org.apache.activemq.transaction.Transaction.newXAException(Transaction.java:212)",
                "at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:93)",
                "at org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:76)",
                "at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:252)",
                "at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)",
                "at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:118)",
                "at org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:547)",
                "at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:336)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:200)",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)",
                "at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)",
                "at java.lang.Thread.run(Thread.java:745)",
                "Caused by: java.io.IOException: Could not remove prepared transaction state from message add for sequenceId: 4025171",
                "at org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doCommitAddOp(DefaultJDBCAdapter.java:1031)",
                "at org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.commitAdd(JDBCPersistenceAdapter.java:780)",
                "at org.apache.activemq.store.jdbc.JdbcMemoryTransactionStore$CommitAddOutcome.run(JdbcMemoryTransactionStore.java:146)",
                "at org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:101)",
                "at org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:270)",
                "at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:86)"
            ],
            "RootCause": "The root cause of the issue is a failure during the commit phase of a transaction, specifically due to an inability to remove the prepared transaction state from the message store, which is indicated by the IOException in the stack trace.",
            "StepsToReproduce": [
                "Configure ActiveMQ 5.14.5 with JDBC persistence storage using PostgreSQL.",
                "Trigger transactions that involve message processing.",
                "Monitor the transaction commit phase for failures."
            ],
            "ExpectedBehavior": "Transactions should commit successfully without throwing exceptions, and the prepared transaction state should be removed from the message store.",
            "ObservedBehavior": "Intermittently, transactions fail to commit, resulting in an XAException and an IOException indicating that the prepared transaction state could not be removed.",
            "Suggestions": "To resolve this issue, check the database connectivity, increase transaction timeouts, review the configuration of ActiveMQ and the JDBC adapter, and monitor the health of the message store.",
            "problem_location": {
                "files": [
                    "DefaultJDBCAdapter.java",
                    "JDBCPersistenceAdapter.java",
                    "TransactionContext.java"
                ],
                "classes": [
                    "org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter",
                    "org.apache.activemq.store.jdbc.JDBCPersistenceAdapter",
                    "org.apache.activemq.TransactionContext"
                ],
                "methods": [
                    "DefaultJDBCAdapter.doCommitAddOp",
                    "JDBCPersistenceAdapter.commitAdd",
                    "TransactionContext.commit"
                ]
            },
            "possible_fix": "Verify the JDBC adapter configuration and ensure that the database is reachable. Consider increasing the transaction timeout settings and monitoring the message store for any integrity issues."
        },
        "possible_fix_code": {
            "DefaultJDBCAdapter.doCommitAddOp": "    public void doCommitAddOp(TransactionContext c, long preparedSequence, long sequence) throws SQLException, IOException {\n        PreparedStatement s = null;\n        try {\n            s = c.getConnection().prepareStatement(this.statements.getClearXidFlagStatement());\n            s.setLong(1, sequence);\n            s.setLong(2, preparedSequence);\n            if (s.executeUpdate() != 1) {\n                throw new IOException(\"Could not remove prepared transaction state from message add for sequenceId: \" + sequence);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"SQL Exception during commit add operation: \" + e.getMessage(), e);\n            throw e; // Rethrow the SQLException for further handling\n        } finally {\n            close(s);\n        }\n    }"
        }
    },
    {
        "filename": "AMQ-5384.json",
        "creation_time": "2014-10-06T09:26:58.000+0000",
        "bug_report": {
            "Title": "Deadlock on DB connections in JDBCMessageStore.removeMessage",
            "Description": "The application experiences deadlocks on database connections when using JDBC persistence under a load of 30-50 requests per second. This issue manifests during performance testing, causing the application to hang. The stack traces indicate that the deadlock occurs due to improper management of database connections, particularly in the `JDBCMessageStore.removeMessage` method, which attempts to acquire a new database connection while already holding one.",
            "StackTrace": [
                "2014-10-06 08:44:40,646 | INFO  | Logging the stack trace by which the overdue resource was checked-out. | com.mchange.v2.resourcepool.BasicResourcePool | C3P0PooledConnectionPoolManager[identityToken->2x1e6s941raztn6mju110",
                "java.lang.Exception: DEBUG STACK TRACE: Overdue resource check-out stack trace.",
                "at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:555)",
                "at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:756)",
                "at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:683)",
                "at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)",
                "at org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)",
                "at org.apache.activemq.store.jdbc.TransactionContext.begin(TransactionContext.java:163)",
                "at org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.beginTransaction(JDBCPersistenceAdapter.java:510)",
                "at org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:92)",
                "at org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:259)",
                "at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)",
                "at org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:75)",
                "at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)",
                "at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)",
                "at org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:433)",
                "at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)",
                "at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)",
                "at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)",
                "at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)",
                "at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)",
                "at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)",
                "at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)",
                "at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)",
                "at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)",
                "at java.lang.Thread.run(Thread.java:662)"
            ],
            "RootCause": "The deadlock occurs because the `removeMessage` method in `JDBCMessageStore` attempts to acquire a new database connection while already holding one from the `ConnectionContext`. This leads to a situation where all available connections are exhausted, causing the method to wait indefinitely for a connection to become available.",
            "StepsToReproduce": [
                "1. Set up the application with JDBC persistence.",
                "2. Simulate a load of 30-50 requests per second.",
                "3. Monitor the application for deadlocks or hangs during performance testing."
            ],
            "ExpectedBehavior": "The application should handle database connections efficiently, allowing for concurrent requests without deadlocks or resource exhaustion.",
            "ObservedBehavior": "The application hangs and experiences deadlocks on database connections, particularly during high load scenarios.",
            "Suggestions": "To resolve the deadlock issue, modify the `removeMessage` method to reuse the existing database connection from the `ConnectionContext` instead of creating a new one. Additionally, review the connection pool configuration to ensure it is set up correctly to handle the expected load.",
            "problem_location": {
                "files": [
                    "JDBCMessageStore.java"
                ],
                "classes": [
                    "org.apache.activemq.store.jdbc.JDBCMessageStore"
                ],
                "methods": [
                    "JDBCMessageStore.removeMessage"
                ]
            },
            "possible_fix": "Modify the `removeMessage` method to pass the existing `ConnectionContext` to the `getStoreSequenceIdForMessageId` method, allowing it to reuse the same database connection. Example code change:\n\npublic void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n    long seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination, context)[0];\n    // other logic...\n}"
        },
        "possible_fix_code": {
            "JDBCMessageStore.removeMessage": "public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {\n    long seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination, context)[0];\n    // other logic...\n    // Ensure that we are using the existing connection from the context\n    Connection connection = context.getConnection();\n    if (connection == null) {\n        throw new IOException(\"No available connection in the context.\");\n    }\n    // Use the connection for further operations instead of acquiring a new one\n    // Example of using the connection for a database operation\n    try (PreparedStatement stmt = connection.prepareStatement(\"DELETE FROM messages WHERE id = ?\")) {\n        stmt.setLong(1, seq);\n        stmt.executeUpdate();\n    } catch (SQLException e) {\n        throw new IOException(\"Failed to remove message from database\", e);\n    }\n}"
        }
    },
    {
        "filename": "AMQ-5783.json",
        "creation_time": "2015-05-20T08:47:56.000+0000",
        "bug_report": {
            "Title": "Failed to browse Topic: XXXXX java.io.EOFException: Chunk stream does not exist, page: y is marked free",
            "Description": "The issue arises when an offline durable subscriber times out, leading to a warning message indicating a failure to browse a specific topic. The error message, 'java.io.EOFException: Chunk stream does not exist, page: 39 is marked free', suggests a problem with the KahaDB storage mechanism used by ActiveMQ. This could be due to data corruption, improper shutdowns, or other issues related to the database storage. The stack trace reveals that the error occurs during the transaction handling and message recovery processes within the KahaDB storage.",
            "StackTrace": [
                "at org.apache.activemq.store.kahadb.disk.page.Transaction$2.readPage(Transaction.java:470)",
                "at org.apache.activemq.store.kahadb.disk.page.Transaction$2.<init>(Transaction.java:447)",
                "at org.apache.activemq.store.kahadb.disk.page.Transaction.openInputStream(Transaction.java:444)",
                "at org.apache.activemq.store.kahadb.disk.page.Transaction.load(Transaction.java:420)",
                "at org.apache.activemq.store.kahadb.disk.page.Transaction.load(Transaction.java:377)",
                "at org.apache.activemq.store.kahadb.disk.index.BTreeIndex.loadNode(BTreeIndex.java:266)",
                "at org.apache.activemq.store.kahadb.disk.index.BTreeIndex.getRoot(BTreeIndex.java:174)",
                "at org.apache.activemq.store.kahadb.disk.index.BTreeIndex.iterator(BTreeIndex.java:236)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex$MessageOrderIterator.<init>(MessageDatabase.java:3033)",
                "at org.apache.activemq.store.kahadb.MessageDatabase$MessageOrderIndex.iterator(MessageDatabase.java:2985)",
                "at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore$4.execute(KahaDBStore.java:564)",
                "at org.apache.activemq.store.kahadb.disk.page.Transaction.execute(Transaction.java:779)",
                "at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.recover(KahaDBStore.java:558)",
                "at org.apache.activemq.store.ProxyTopicMessageStore.recover(ProxyTopicMessageStore.java:62)",
                "at org.apache.activemq.broker.region.Topic.doBrowse(Topic.java:589)",
                "at org.apache.activemq.broker.region.Topic.access$100(Topic.java:65)",
                "at org.apache.activemq.broker.region.Topic$6.run(Topic.java:722)",
                "at org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)",
                "at java.util.TimerThread.mainLoop(Timer.java:555)",
                "at java.util.TimerThread.run(Timer.java:505)"
            ],
            "RootCause": "The root cause of the issue is likely related to data corruption or improper handling of the KahaDB storage, specifically during the message recovery process. The error indicates that a page expected to be accessed is marked as free, which suggests that the storage may have inconsistencies.",
            "StepsToReproduce": [
                "Configure an offline durable subscriber with a timeout.",
                "Allow the subscriber to time out.",
                "Attempt to browse the topic associated with the subscriber."
            ],
            "ExpectedBehavior": "The system should successfully browse the topic and retrieve messages without encountering any exceptions.",
            "ObservedBehavior": "The system fails to browse the topic, resulting in a java.io.EOFException indicating that a chunk stream does not exist and a page is marked free.",
            "Suggestions": "1. Check for data corruption in the KahaDB storage files. 2. Restore from a backup if corruption is suspected. 3. Review KahaDB configuration settings to ensure they are correct. 4. Monitor ActiveMQ logs for additional errors or warnings.",
            "problem_location": {
                "files": [
                    "KahaDBStore.java",
                    "Transaction.java"
                ],
                "classes": [
                    "org.apache.activemq.store.kahadb.KahaDBStore",
                    "org.apache.activemq.store.kahadb.disk.page.Transaction"
                ],
                "methods": [
                    "KahaDBStore.recover",
                    "Transaction.load"
                ]
            },
            "possible_fix": "To address the EOFException, consider implementing checks for data integrity before attempting to recover messages. Additionally, ensure that the KahaDB storage is not accessed concurrently in a way that could lead to inconsistencies."
        },
        "possible_fix_code": {
            "KahaDBStore.recover": "        public void recover(final MessageRecoveryListener listener) throws Exception {\n            // recovery may involve expiry which will modify\n            indexLock.writeLock().lock();\n            try {\n                // Check for data integrity before proceeding with recovery\n                if (!isDataIntegrityValid()) {\n                    throw new IOException(\"Data integrity check failed. Aborting recovery.\");\n                }\n                pageFile.tx().execute(new Transaction.Closure<Exception>() {\n                    @Override\n                    public void execute(Transaction tx) throws Exception {\n                        StoredDestination sd = getStoredDestination(dest, tx);\n                        recoverRolledBackAcks(sd, tx, Integer.MAX_VALUE, listener);\n                        sd.orderIndex.resetCursorPosition();\n                        for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); listener.hasSpace() && iterator.hasNext(); ) {\n                            Entry<Long, MessageKeys> entry = iterator.next();\n                            if (ackedAndPrepared.contains(entry.getValue().messageId)) {\n                                continue;\n                            }\n                            Message msg = loadMessage(entry.getValue().location);\n                            listener.recoverMessage(msg);\n                        }\n                    }\n                });\n            } finally {\n                indexLock.writeLock().unlock();\n            }\n        }\n\n        private boolean isDataIntegrityValid() {\n            // Implement logic to check data integrity of KahaDB storage\n            // This is a placeholder for actual integrity check logic\n            return true; // Assume integrity is valid for now\n        }"
        }
    },
    {
        "filename": "AMQ-2965.json",
        "creation_time": "2010-10-07T20:18:59.000+0000",
        "bug_report": {
            "Title": "ActiveMQ fails to start if no DNS resolution for hostname is available",
            "Description": "ActiveMQ is installed on a physical server with two ethernet interfaces: one for external traffic (10.x.x.x) and another for internal communication (172.x.x.x). The broker is configured to listen only on the internal interface. While external DNS resolution is available, internal DNS resolution is not, leading to failures in hostname resolution. The hostname 'Q01M0003' is not resolvable, causing ActiveMQ to fail during startup. The stack trace indicates an `UnknownHostException` when attempting to resolve this hostname, which is critical for the broker's initialization and transport connector setup.",
            "StackTrace": [
                "2010-06-09 16:48:45,714 | ERROR | Failed to resolve localhost | org.apache.activemq.broker.BrokerService | WrapperSimpleAppMain",
                "java.net.UnknownHostException: Q01M0003: Q01M0003",
                "at java.net.InetAddress.getLocalHost(Unknown Source)",
                "at org.apache.activemq.util.IdGenerator.<clinit>(IdGenerator.java:52)",
                "at org.apache.activemq.broker.region.RegionBroker.<clinit>(RegionBroker.java:75)",
                "at org.apache.activemq.broker.BrokerService.createRegionBroker(BrokerService.java:1734)",
                "at org.apache.activemq.broker.BrokerService.createTransportConnector(BrokerService.java:2006)",
                "java.io.IOException: Transport Connector could not be registered in JMX: Q01M0003: Q01M0003"
            ],
            "RootCause": "The root cause of the issue is the inability of the Java application to resolve the hostname 'Q01M0003' due to the lack of internal DNS resolution. This results in an `UnknownHostException` during the initialization of the ActiveMQ broker, specifically when attempting to create transport connectors that rely on this hostname.",
            "StepsToReproduce": [
                "Install ActiveMQ on a server with two network interfaces.",
                "Configure ActiveMQ to listen only on the internal interface (172.x.x.x).",
                "Ensure that the hostname 'Q01M0003' is not resolvable in the internal DNS.",
                "Attempt to start ActiveMQ."
            ],
            "ExpectedBehavior": "ActiveMQ should start successfully and be able to resolve its hostname for internal communication.",
            "ObservedBehavior": "ActiveMQ fails to start, throwing an `UnknownHostException` for the hostname 'Q01M0003'.",
            "Suggestions": "To work around this issue, add an entry for 'Q01M0003' in the /etc/hosts file on each machine. However, this is not a scalable solution for large environments. Consider configuring a proper internal DNS or using IP addresses directly in the transport connector URIs.",
            "problem_location": {
                "files": [
                    "activemq-core/src/main/java/org/apache/activemq/broker/BrokerService.java"
                ],
                "classes": [
                    "org.apache.activemq.broker.BrokerService"
                ],
                "methods": [
                    "createRegionBroker",
                    "createTransportConnector",
                    "getTransportConnectorURIs",
                    "setTransportConnectorURIs"
                ]
            },
            "possible_fix": "Ensure that the transport connector URIs do not rely on the hostname 'Q01M0003' or provide a valid DNS entry for it. Modify the configuration to use IP addresses instead of hostnames in the transport connector URIs."
        },
        "possible_fix_code": {
            "createTransportConnector": "    protected TransportConnector createTransportConnector(URI brokerURI) throws Exception {\n        // Check if the brokerURI contains a hostname that cannot be resolved\n        String host = brokerURI.getHost();\n        if (host != null && !isHostResolvable(host)) {\n            // Fallback to using the local IP address instead of the hostname\n            String localIp = InetAddress.getLocalHost().getHostAddress();\n            brokerURI = new URI(brokerURI.getScheme(), localIp, brokerURI.getPort(), brokerURI.getPath(), brokerURI.getQuery(), brokerURI.getFragment());\n        }\n        TransportServer transport = TransportFactory.bind(this, brokerURI);\n        return new TransportConnector(transport);\n    }\n\n    private boolean isHostResolvable(String host) {\n        try {\n            InetAddress.getByName(host);\n            return true;\n        } catch (UnknownHostException e) {\n            return false;\n        }\n    }"
        }
    }
]