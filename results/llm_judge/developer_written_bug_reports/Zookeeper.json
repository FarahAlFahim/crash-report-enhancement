[
    {
        "filename": "ZOOKEEPER-1864.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties": {
                "code_before_change": "    public void parseProperties(Properties zkProp)\n    throws IOException, ConfigException {\n        int clientPort = 0;\n        String clientPortAddress = null;\n        VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n        for (Entry<Object, Object> entry : zkProp.entrySet()) {\n            String key = entry.getKey().toString().trim();\n            String value = entry.getValue().toString().trim();\n            if (key.equals(\"dataDir\")) {\n                dataDir = vff.create(value);\n            } else if (key.equals(\"dataLogDir\")) {\n                dataLogDir = vff.create(value);\n            } else if (key.equals(\"clientPort\")) {\n                clientPort = Integer.parseInt(value);\n            } else if (key.equals(\"localSessionsEnabled\")) {\n                localSessionsEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n                localSessionsUpgradingEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"clientPortAddress\")) {\n                clientPortAddress = value.trim();\n            } else if (key.equals(\"tickTime\")) {\n                tickTime = Integer.parseInt(value);\n            } else if (key.equals(\"maxClientCnxns\")) {\n                maxClientCnxns = Integer.parseInt(value);\n            } else if (key.equals(\"minSessionTimeout\")) {\n                minSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"maxSessionTimeout\")) {\n                maxSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"initLimit\")) {\n                initLimit = Integer.parseInt(value);\n            } else if (key.equals(\"syncLimit\")) {\n                syncLimit = Integer.parseInt(value);\n            } else if (key.equals(\"electionAlg\")) {\n                electionAlg = Integer.parseInt(value);\n            } else if (key.equals(\"quorumListenOnAllIPs\")) {\n                quorumListenOnAllIPs = Boolean.parseBoolean(value);\n            } else if (key.equals(\"peerType\")) {\n                if (value.toLowerCase().equals(\"observer\")) {\n                    peerType = LearnerType.OBSERVER;\n                } else if (value.toLowerCase().equals(\"participant\")) {\n                    peerType = LearnerType.PARTICIPANT;\n                } else\n                {\n                    throw new ConfigException(\"Unrecognised peertype: \" + value);\n                }\n            } else if (key.equals( \"syncEnabled\" )) {\n                syncEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"dynamicConfigFile\")){\n                dynamicConfigFileStr = value;\n            } else if (key.equals(\"autopurge.snapRetainCount\")) {\n                snapRetainCount = Integer.parseInt(value);\n            } else if (key.equals(\"autopurge.purgeInterval\")) {\n                purgeInterval = Integer.parseInt(value);\n            } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")){                \n               throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n            } else {\n                System.setProperty(\"zookeeper.\" + key, value);\n            }\n        }\n\n        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n            LOG.warn(\"Invalid autopurge.snapRetainCount: \" + snapRetainCount\n                    + \". Defaulting to \" + MIN_SNAP_RETAIN_COUNT);\n            snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n        }\n\n        if (dataDir == null) {\n            throw new IllegalArgumentException(\"dataDir is not set\");\n        }\n        if (dataLogDir == null) {\n            dataLogDir = dataDir;\n        } else {\n            if (!dataLogDir.isDirectory()) {\n                throw new IllegalArgumentException(\"dataLogDir \" + dataLogDir\n                        + \" is missing.\");\n            }\n        }\n        if (clientPortAddress != null) {\n           if (clientPort == 0) {\n               throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n        }\n             this.clientPortAddress = new InetSocketAddress(\n                      InetAddress.getByName(clientPortAddress), clientPort);\n        } else if (clientPort!=0){\n             this.clientPortAddress = new InetSocketAddress(clientPort);\n        }    \n        if (tickTime == 0) {\n            throw new IllegalArgumentException(\"tickTime is not set\");\n        }\n        if (minSessionTimeout > maxSessionTimeout) {\n            throw new IllegalArgumentException(\n                    \"minSessionTimeout must not be larger than maxSessionTimeout\");\n        }          \n    }",
                "code_after_change": "    public void parseProperties(Properties zkProp)\n    throws IOException, ConfigException {\n        int clientPort = 0;\n        String clientPortAddress = null;\n        VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n        for (Entry<Object, Object> entry : zkProp.entrySet()) {\n            String key = entry.getKey().toString().trim();\n            String value = entry.getValue().toString().trim();\n            if (key.equals(\"dataDir\")) {\n                dataDir = vff.create(value);\n            } else if (key.equals(\"dataLogDir\")) {\n                dataLogDir = vff.create(value);\n            } else if (key.equals(\"clientPort\")) {\n                clientPort = Integer.parseInt(value);\n            } else if (key.equals(\"localSessionsEnabled\")) {\n                localSessionsEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n                localSessionsUpgradingEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"clientPortAddress\")) {\n                clientPortAddress = value.trim();\n            } else if (key.equals(\"tickTime\")) {\n                tickTime = Integer.parseInt(value);\n            } else if (key.equals(\"maxClientCnxns\")) {\n                maxClientCnxns = Integer.parseInt(value);\n            } else if (key.equals(\"minSessionTimeout\")) {\n                minSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"maxSessionTimeout\")) {\n                maxSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"initLimit\")) {\n                initLimit = Integer.parseInt(value);\n            } else if (key.equals(\"syncLimit\")) {\n                syncLimit = Integer.parseInt(value);\n            } else if (key.equals(\"electionAlg\")) {\n                electionAlg = Integer.parseInt(value);\n            } else if (key.equals(\"quorumListenOnAllIPs\")) {\n                quorumListenOnAllIPs = Boolean.parseBoolean(value);\n            } else if (key.equals(\"peerType\")) {\n                if (value.toLowerCase().equals(\"observer\")) {\n                    peerType = LearnerType.OBSERVER;\n                } else if (value.toLowerCase().equals(\"participant\")) {\n                    peerType = LearnerType.PARTICIPANT;\n                } else\n                {\n                    throw new ConfigException(\"Unrecognised peertype: \" + value);\n                }\n            } else if (key.equals( \"syncEnabled\" )) {\n                syncEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"dynamicConfigFile\")){\n                dynamicConfigFileStr = value;\n            } else if (key.equals(\"autopurge.snapRetainCount\")) {\n                snapRetainCount = Integer.parseInt(value);\n            } else if (key.equals(\"autopurge.purgeInterval\")) {\n                purgeInterval = Integer.parseInt(value);\n            } else if (key.equals(\"standaloneEnabled\")) {\n                if (value.toLowerCase().equals(\"true\")) {\n                    setStandaloneEnabled(true);\n                } else if (value.toLowerCase().equals(\"false\")) {\n                    setStandaloneEnabled(false);\n                } else {\n                    throw new ConfigException(\"Invalid option for standalone mode. Choose 'true' or 'false.'\");\n                }\n            } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n                throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n            } else {\n                System.setProperty(\"zookeeper.\" + key, value);\n            }\n        }\n\n        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n            LOG.warn(\"Invalid autopurge.snapRetainCount: \" + snapRetainCount\n                    + \". Defaulting to \" + MIN_SNAP_RETAIN_COUNT);\n            snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n        }\n\n        if (dataDir == null) {\n            throw new IllegalArgumentException(\"dataDir is not set\");\n        }\n        if (dataLogDir == null) {\n            dataLogDir = dataDir;\n        }\n        if (clientPortAddress != null) {\n           if (clientPort == 0) {\n               throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n        }\n             this.clientPortAddress = new InetSocketAddress(\n                      InetAddress.getByName(clientPortAddress), clientPort);\n        } else if (clientPort!=0){\n             this.clientPortAddress = new InetSocketAddress(clientPort);\n        }    \n        if (tickTime == 0) {\n            throw new IllegalArgumentException(\"tickTime is not set\");\n        }\n\n        minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n        maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n\n        if (minSessionTimeout > maxSessionTimeout) {\n            throw new IllegalArgumentException(\n                    \"minSessionTimeout must not be larger than maxSessionTimeout\");\n        }          \n\n        // backward compatibility - dynamic configuration in the same file as\n        // static configuration params see writeDynamicConfig() - we change the\n        // config file to new format if reconfig happens\n        if (dynamicConfigFileStr == null) {\n            configBackwardCompatibilityMode = true;\n            quorumVerifier = parseDynamicConfig(zkProp, electionAlg, true,\n                configBackwardCompatibilityMode);\n            checkValidity();\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.parse": {
                "code_before_change": "    public void parse(String path) throws ConfigException {\n        LOG.info(\"Reading configuration from: \" + path);\n       \n        try {\n            File configFile = (new VerifyingFileFactory.Builder(LOG)\n                .warnForRelativePath()\n                .failForNonExistingPath()\n                .build()).create(path);\n                \n            Properties cfg = new Properties();\n            FileInputStream in = new FileInputStream(configFile);\n            try {\n                cfg.load(in);\n            } finally {\n                in.close();\n            }\n            \n            parseProperties(cfg);\n            \n            // backward compatibility - dynamic configuration in the same file as static configuration params\n            // see writeDynamicConfig() - we change the config file to new format if reconfig happens\n            if (dynamicConfigFileStr == null) {\n                configBackwardCompatibilityMode = true;\n                configFileStr = path;                \n                parseDynamicConfig(cfg, electionAlg, true);\n                checkValidity();                \n            }\n\n        } catch (IOException e) {\n            throw new ConfigException(\"Error processing \" + path, e);\n        } catch (IllegalArgumentException e) {\n            throw new ConfigException(\"Error processing \" + path, e);\n        }   \n        \n        if (dynamicConfigFileStr!=null) {\n           try {           \n               Properties dynamicCfg = new Properties();\n               FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);\n               try {\n                   dynamicCfg.load(inConfig);\n               } finally {\n                   inConfig.close();\n               }\n               parseDynamicConfig(dynamicCfg, electionAlg, true);\n               checkValidity();\n           \n           } catch (IOException e) {\n               throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n           } catch (IllegalArgumentException e) {\n               throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n           }        \n           File nextDynamicConfigFile = new File(dynamicConfigFileStr + \".next\");\n           if (nextDynamicConfigFile.exists()) {\n               try {           \n                   Properties dynamicConfigNextCfg = new Properties();\n                   FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);       \n                   try {\n                       dynamicConfigNextCfg.load(inConfigNext);\n                   } finally {\n                       inConfigNext.close();\n                   }\n                   boolean isHierarchical = false;\n                   for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {\n                       String key = entry.getKey().toString().trim();  \n                       if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n                           isHierarchical = true;\n                           break;\n                       }\n                   }\n                   lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);    \n               } catch (IOException e) {\n                   LOG.warn(\"NextQuorumVerifier is initiated to null\");\n               }\n           }\n        }\n    }",
                "code_after_change": "    public void parse(String path) throws ConfigException {\n        LOG.info(\"Reading configuration from: \" + path);\n       \n        try {\n            File configFile = (new VerifyingFileFactory.Builder(LOG)\n                .warnForRelativePath()\n                .failForNonExistingPath()\n                .build()).create(path);\n                \n            Properties cfg = new Properties();\n            FileInputStream in = new FileInputStream(configFile);\n            try {\n                cfg.load(in);\n                configFileStr = path;\n            } finally {\n                in.close();\n            }\n            \n            parseProperties(cfg);\n        } catch (IOException e) {\n            throw new ConfigException(\"Error processing \" + path, e);\n        } catch (IllegalArgumentException e) {\n            throw new ConfigException(\"Error processing \" + path, e);\n        }   \n        \n        if (dynamicConfigFileStr!=null) {\n           try {           \n               Properties dynamicCfg = new Properties();\n               FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);\n               try {\n                   dynamicCfg.load(inConfig);\n               } finally {\n                   inConfig.close();\n               }\n               quorumVerifier = parseDynamicConfig(dynamicCfg, electionAlg, true, configBackwardCompatibilityMode);\n               checkValidity();\n           \n           } catch (IOException e) {\n               throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n           } catch (IllegalArgumentException e) {\n               throw new ConfigException(\"Error processing \" + dynamicConfigFileStr, e);\n           }        \n           File nextDynamicConfigFile = new File(dynamicConfigFileStr + \".next\");\n           if (nextDynamicConfigFile.exists()) {\n               try {           \n                   Properties dynamicConfigNextCfg = new Properties();\n                   FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);       \n                   try {\n                       dynamicConfigNextCfg.load(inConfigNext);\n                   } finally {\n                       inConfigNext.close();\n                   }\n                   boolean isHierarchical = false;\n                   for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {\n                       String key = entry.getKey().toString().trim();  \n                       if (key.startsWith(\"group\") || key.startsWith(\"weight\")) {\n                           isHierarchical = true;\n                           break;\n                       }\n                   }\n                   lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);    \n               } catch (IOException e) {\n                   LOG.warn(\"NextQuorumVerifier is initiated to null\");\n               }\n           }\n        }\n    }"
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Precise",
                "sub_category": null
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Precise",
                "sub_category": null
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report precisely identifies the root cause by mentioning that 'QuorumPeerConfig:parseProperties only performs a subset of what QuorumPeerConfig:parse(String path) does,' which directly relates to the ground truth methods. However, the report does not provide any fix suggestion, hence 'Missing' for fix suggestion. The problem location is also precise as it mentions 'QuorumPeerConfig:parseProperties' and 'QuorumPeerConfig:parse', which are the ground truth methods. There is no wrong information in the bug report as all the details are relevant and accurate."
        }
    },
    {
        "filename": "ZOOKEEPER-2213.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.pRequest2Txn": {
                "code_before_change": "    protected void pRequest2Txn(int type, long zxid, Request request,\n                                Record record, boolean deserialize)\n        throws KeeperException, IOException, RequestProcessorException\n    {\n        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,\n                Time.currentWallTime(), type));\n\n        switch (type) {\n            case OpCode.create:\n            case OpCode.create2:\n            case OpCode.createContainer: {\n                CreateRequest createRequest = (CreateRequest)record;\n                if (deserialize) {\n                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);\n                }\n                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());\n                validateCreateRequest(createMode, request);\n                String path = createRequest.getPath();\n                String parentPath = validatePathForCreate(path, request.sessionId);\n\n                List<ACL> listACL = fixupACL(path, request.authInfo, createRequest.getAcl());\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n\n                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);\n                int parentCVersion = parentRecord.stat.getCversion();\n                if (createMode.isSequential()) {\n                    path = path + String.format(Locale.ENGLISH, \"%010d\", parentCVersion);\n                }\n                try {\n                    PathUtils.validatePath(path);\n                } catch(IllegalArgumentException ie) {\n                    LOG.info(\"Invalid path \" + path + \" with session 0x\" +\n                            Long.toHexString(request.sessionId));\n                    throw new KeeperException.BadArgumentsException(path);\n                }\n                try {\n                    if (getRecordForPath(path) != null) {\n                        throw new KeeperException.NodeExistsException(path);\n                    }\n                } catch (KeeperException.NoNodeException e) {\n                    // ignore this one\n                }\n                boolean ephemeralParent = (parentRecord.stat.getEphemeralOwner() != 0) &&\n                        (parentRecord.stat.getEphemeralOwner() != DataTree.CONTAINER_EPHEMERAL_OWNER);\n                if (ephemeralParent) {\n                    throw new KeeperException.NoChildrenForEphemeralsException(path);\n                }\n                int newCversion = parentRecord.stat.getCversion()+1;\n                if (type == OpCode.createContainer) {\n                    request.setTxn(new CreateContainerTxn(path, createRequest.getData(), listACL, newCversion));\n                } else {\n                    request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),\n                            newCversion));\n                }\n                StatPersisted s = new StatPersisted();\n                if (createMode.isEphemeral()) {\n                    s.setEphemeralOwner(request.sessionId);\n                }\n                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n                parentRecord.childCount++;\n                parentRecord.stat.setCversion(newCversion);\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));\n                break;\n            }\n            case OpCode.deleteContainer: {\n                String path = new String(request.request.array());\n                String parentPath = getParentPathAndValidate(path);\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n                ChangeRecord nodeRecord = getRecordForPath(path);\n                if (nodeRecord.childCount > 0) {\n                    throw new KeeperException.NotEmptyException(path);\n                }\n                if (nodeRecord.stat.getEphemeralOwner() != DataTree.CONTAINER_EPHEMERAL_OWNER) {\n                    throw new KeeperException.BadVersionException(path);\n                }\n                request.setTxn(new DeleteTxn(path));\n                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n                parentRecord.childCount--;\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));\n                break;\n            }\n            case OpCode.delete:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                DeleteRequest deleteRequest = (DeleteRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);\n                String path = deleteRequest.getPath();\n                String parentPath = getParentPathAndValidate(path);\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n                ChangeRecord nodeRecord = getRecordForPath(path);\n                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo);\n                checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);\n                if (nodeRecord.childCount > 0) {\n                    throw new KeeperException.NotEmptyException(path);\n                }\n                request.setTxn(new DeleteTxn(path));\n                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());\n                parentRecord.childCount--;\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));\n                break;\n            case OpCode.setData:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                SetDataRequest setDataRequest = (SetDataRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);\n                path = setDataRequest.getPath();\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);\n                int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);\n                request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));\n                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n                nodeRecord.stat.setVersion(newVersion);\n                addChangeRecord(nodeRecord);\n                break;\n            case OpCode.reconfig:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                ReconfigRequest reconfigRequest = (ReconfigRequest)record; \n                LeaderZooKeeperServer lzks;\n                try {\n                    lzks = (LeaderZooKeeperServer)zks;\n                } catch (ClassCastException e) {\n                    // standalone mode - reconfiguration currently not supported\n                    throw new KeeperException.UnimplementedException();\n                }\n                QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                                                                                 \n                // check that there's no reconfig in progress\n                if (lastSeenQV.getVersion()!=lzks.self.getQuorumVerifier().getVersion()) {\n                       throw new KeeperException.ReconfigInProgress(); \n                }\n                long configId = reconfigRequest.getCurConfigId();\n  \n                if (configId != -1 && configId!=lzks.self.getLastSeenQuorumVerifier().getVersion()){\n                   String msg = \"Reconfiguration from version \" + configId + \" failed -- last seen version is \" + lzks.self.getLastSeenQuorumVerifier().getVersion();\n                   throw new KeeperException.BadVersionException(msg);\n                }\n\n                String newMembers = reconfigRequest.getNewMembers();\n                \n                if (newMembers != null) { //non-incremental membership change                  \n                   LOG.info(\"Non-incremental reconfig\");\n                \n                   // Input may be delimited by either commas or newlines so convert to common newline separated format\n                   newMembers = newMembers.replaceAll(\",\", \"\\n\");\n                   \n                   try{\n                       Properties props = new Properties();                        \n                       props.load(new StringReader(newMembers));\n                       request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);\n                       request.qv.setVersion(request.getHdr().getZxid());\n                   } catch (IOException e) {\n                       throw new KeeperException.BadArgumentsException(e.getMessage());\n                   } catch (ConfigException e) {\n                       throw new KeeperException.BadArgumentsException(e.getMessage());\n                   }                   \n                } else { //incremental change - must be a majority quorum system   \n                   LOG.info(\"Incremental reconfig\");\n                   \n                   List<String> joiningServers = null; \n                   String joiningServersString = reconfigRequest.getJoiningServers();\n                   if (joiningServersString != null)\n                   {\n                       joiningServers = StringUtils.split(joiningServersString,\",\");\n                   }\n                   \n                   List<String> leavingServers = null;\n                   String leavingServersString = reconfigRequest.getLeavingServers();\n                   if (leavingServersString != null)\n                   {\n                       leavingServers = StringUtils.split(leavingServersString, \",\");\n                   }\n                   \n                   if (!(lastSeenQV instanceof QuorumMaj)) {\n                           String msg = \"Incremental reconfiguration requested but last configuration seen has a non-majority quorum system\";\n                           LOG.warn(msg);\n                           throw new KeeperException.BadArgumentsException(msg);               \n                   }\n                   Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());\n                   try {                           \n                       if (leavingServers != null) {\n                           for (String leaving: leavingServers){\n                               long sid = Long.parseLong(leaving);\n                               nextServers.remove(sid);\n                           } \n                       }\n                       if (joiningServers != null) {\n                           for (String joiner: joiningServers){\n                        \t   // joiner should have the following format: server.x = server_spec;client_spec               \n                        \t   String[] parts = StringUtils.split(joiner, \"=\").toArray(new String[0]);\n                               if (parts.length != 2) {\n                                   throw new KeeperException.BadArgumentsException(\"Wrong format of server string\");\n                               }\n                               // extract server id x from first part of joiner: server.x\n                               Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));\n                               QuorumServer qs = new QuorumServer(sid, parts[1]);\n                               if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {\n                                   throw new KeeperException.BadArgumentsException(\"Wrong format of server string - each server should have 3 ports specified\"); \t   \n                               }\n                               nextServers.remove(qs.id);\n                               nextServers.put(Long.valueOf(qs.id), qs);\n                           }  \n                       }\n                   } catch (ConfigException e){\n                       throw new KeeperException.BadArgumentsException(\"Reconfiguration failed\");\n                   }\n                   request.qv = new QuorumMaj(nextServers);\n                   request.qv.setVersion(request.getHdr().getZxid());\n                }\n                if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {\n                   String msg = \"Reconfig failed - new configuration must include at least 2 followers\";\n                   LOG.warn(msg);\n                   throw new KeeperException.BadArgumentsException(msg);\n                } else if (request.qv.getVotingMembers().size() < 1) {\n                   String msg = \"Reconfig failed - new configuration must include at least 1 follower\";\n                   LOG.warn(msg);\n                   throw new KeeperException.BadArgumentsException(msg);\n                }                           \n                   \n                if (!lzks.getLeader().isQuorumSynced(request.qv)) {\n                   String msg2 = \"Reconfig failed - there must be a connected and synced quorum in new configuration\";\n                   LOG.warn(msg2);             \n                   throw new KeeperException.NewConfigNoQuorum();\n                }\n                \n                nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);               \n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);                  \n                request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));    \n                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n                nodeRecord.stat.setVersion(-1);                \n                addChangeRecord(nodeRecord);\n                break;                         \n            case OpCode.setACL:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                SetACLRequest setAclRequest = (SetACLRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);\n                path = setAclRequest.getPath();\n                List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);\n                newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);\n                request.setTxn(new SetACLTxn(path, listACL, newVersion));\n                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());\n                nodeRecord.stat.setAversion(newVersion);\n                addChangeRecord(nodeRecord);\n                break;\n            case OpCode.createSession:\n                request.request.rewind();\n                int to = request.request.getInt();\n                request.setTxn(new CreateSessionTxn(to));\n                request.request.rewind();\n                if (request.isLocalSession()) {\n                    // This will add to local session tracker if it is enabled\n                    zks.sessionTracker.addSession(request.sessionId, to);\n                } else {\n                    // Explicitly add to global session if the flag is not set\n                    zks.sessionTracker.addGlobalSession(request.sessionId, to);\n                }\n                zks.setOwner(request.sessionId, request.getOwner());\n                break;\n            case OpCode.closeSession:\n                // We don't want to do this check since the session expiration thread\n                // queues up this operation without being the session owner.\n                // this request is the last of the session so it should be ok\n                //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                Set<String> es = zks.getZKDatabase()\n                        .getEphemerals(request.sessionId);\n                synchronized (zks.outstandingChanges) {\n                    for (ChangeRecord c : zks.outstandingChanges) {\n                        if (c.stat == null) {\n                            // Doing a delete\n                            es.remove(c.path);\n                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {\n                            es.add(c.path);\n                        }\n                    }\n                    for (String path2Delete : es) {\n                        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));\n                    }\n\n                    zks.sessionTracker.setSessionClosing(request.sessionId);\n                }\n\n                LOG.info(\"Processed session termination for sessionid: 0x\"\n                        + Long.toHexString(request.sessionId));\n                break;\n            case OpCode.check:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                CheckVersionRequest checkVersionRequest = (CheckVersionRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);\n                path = checkVersionRequest.getPath();\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo);\n                request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(),\n                        checkVersionRequest.getVersion(), path)));\n                break;\n            default:\n                LOG.warn(\"unknown type \" + type);\n                break;\n        }\n    }",
                "code_after_change": "    protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize)\n        throws KeeperException, IOException, RequestProcessorException\n    {\n        request.hdr = new TxnHeader(request.sessionId, request.cxid, zxid,\n                                    zks.getTime(), type);\n\n        switch (type) {\n            case OpCode.create:                \n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                CreateRequest createRequest = (CreateRequest)record;   \n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);\n                String path = createRequest.getPath();\n                int lastSlash = path.lastIndexOf('/');\n                if (lastSlash == -1 || path.indexOf('\\0') != -1 || failCreate) {\n                    LOG.info(\"Invalid path \" + path + \" with session 0x\" +\n                            Long.toHexString(request.sessionId));\n                    throw new KeeperException.BadArgumentsException(path);\n                }\n                List<ACL> listACL = removeDuplicates(createRequest.getAcl());\n                if (!fixupACL(request.authInfo, listACL)) {\n                    throw new KeeperException.InvalidACLException(path);\n                }\n                String parentPath = path.substring(0, lastSlash);\n                ChangeRecord parentRecord = getRecordForPath(parentPath);\n\n                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,\n                        request.authInfo);\n                int parentCVersion = parentRecord.stat.getCversion();\n                CreateMode createMode =\n                    CreateMode.fromFlag(createRequest.getFlags());\n                if (createMode.isSequential()) {\n                    path = path + String.format(Locale.ENGLISH, \"%010d\", parentCVersion);\n                }\n                validatePath(path, request.sessionId);\n                try {\n                    if (getRecordForPath(path) != null) {\n                        throw new KeeperException.NodeExistsException(path);\n                    }\n                } catch (KeeperException.NoNodeException e) {\n                    // ignore this one\n                }\n                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;\n                if (ephemeralParent) {\n                    throw new KeeperException.NoChildrenForEphemeralsException(path);\n                }\n                int newCversion = parentRecord.stat.getCversion()+1;\n                request.txn = new CreateTxn(path, createRequest.getData(),\n                        listACL,\n                        createMode.isEphemeral(), newCversion);\n                StatPersisted s = new StatPersisted();\n                if (createMode.isEphemeral()) {\n                    s.setEphemeralOwner(request.sessionId);\n                }\n                parentRecord = parentRecord.duplicate(request.hdr.getZxid());\n                parentRecord.childCount++;\n                parentRecord.stat.setCversion(newCversion);\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.hdr.getZxid(), path, s,\n                        0, listACL));\n                break;\n            case OpCode.delete:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                DeleteRequest deleteRequest = (DeleteRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);\n                path = deleteRequest.getPath();\n                lastSlash = path.lastIndexOf('/');\n                if (lastSlash == -1 || path.indexOf('\\0') != -1\n                        || zks.getZKDatabase().isSpecialPath(path)) {\n                    throw new KeeperException.BadArgumentsException(path);\n                }\n                parentPath = path.substring(0, lastSlash);\n                parentRecord = getRecordForPath(parentPath);\n                ChangeRecord nodeRecord = getRecordForPath(path);\n                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE,\n                        request.authInfo);\n                int version = deleteRequest.getVersion();\n                if (version != -1 && nodeRecord.stat.getVersion() != version) {\n                    throw new KeeperException.BadVersionException(path);\n                }\n                if (nodeRecord.childCount > 0) {\n                    throw new KeeperException.NotEmptyException(path);\n                }\n                request.txn = new DeleteTxn(path);\n                parentRecord = parentRecord.duplicate(request.hdr.getZxid());\n                parentRecord.childCount--;\n                addChangeRecord(parentRecord);\n                addChangeRecord(new ChangeRecord(request.hdr.getZxid(), path,\n                        null, -1, null));\n                break;\n            case OpCode.setData:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                SetDataRequest setDataRequest = (SetDataRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);\n                path = setDataRequest.getPath();\n                validatePath(path, request.sessionId);\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE,\n                        request.authInfo);\n                version = setDataRequest.getVersion();\n                int currentVersion = nodeRecord.stat.getVersion();\n                if (version != -1 && version != currentVersion) {\n                    throw new KeeperException.BadVersionException(path);\n                }\n                version = currentVersion + 1;\n                request.txn = new SetDataTxn(path, setDataRequest.getData(), version);\n                nodeRecord = nodeRecord.duplicate(request.hdr.getZxid());\n                nodeRecord.stat.setVersion(version);\n                addChangeRecord(nodeRecord);\n                break;\n            case OpCode.setACL:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                SetACLRequest setAclRequest = (SetACLRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);\n                path = setAclRequest.getPath();\n                validatePath(path, request.sessionId);\n                listACL = removeDuplicates(setAclRequest.getAcl());\n                if (!fixupACL(request.authInfo, listACL)) {\n                    throw new KeeperException.InvalidACLException(path);\n                }\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN,\n                        request.authInfo);\n                version = setAclRequest.getVersion();\n                currentVersion = nodeRecord.stat.getAversion();\n                if (version != -1 && version != currentVersion) {\n                    throw new KeeperException.BadVersionException(path);\n                }\n                version = currentVersion + 1;\n                request.txn = new SetACLTxn(path, listACL, version);\n                nodeRecord = nodeRecord.duplicate(request.hdr.getZxid());\n                nodeRecord.stat.setAversion(version);\n                addChangeRecord(nodeRecord);\n                break;\n            case OpCode.createSession:\n                request.request.rewind();\n                int to = request.request.getInt();\n                request.txn = new CreateSessionTxn(to);\n                request.request.rewind();\n                zks.sessionTracker.addSession(request.sessionId, to);\n                zks.setOwner(request.sessionId, request.getOwner());\n                break;\n            case OpCode.closeSession:\n                // We don't want to do this check since the session expiration thread\n                // queues up this operation without being the session owner.\n                // this request is the last of the session so it should be ok\n                //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                HashSet<String> es = zks.getZKDatabase()\n                        .getEphemerals(request.sessionId);\n                synchronized (zks.outstandingChanges) {\n                    for (ChangeRecord c : zks.outstandingChanges) {\n                        if (c.stat == null) {\n                            // Doing a delete\n                            es.remove(c.path);\n                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {\n                            es.add(c.path);\n                        }\n                    }\n                    for (String path2Delete : es) {\n                        addChangeRecord(new ChangeRecord(request.hdr.getZxid(),\n                                path2Delete, null, 0, null));\n                    }\n\n                    zks.sessionTracker.setSessionClosing(request.sessionId);\n                }\n\n                LOG.info(\"Processed session termination for sessionid: 0x\"\n                        + Long.toHexString(request.sessionId));\n                break;\n            case OpCode.check:\n                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());\n                CheckVersionRequest checkVersionRequest = (CheckVersionRequest)record;\n                if(deserialize)\n                    ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);\n                path = checkVersionRequest.getPath();\n                validatePath(path, request.sessionId);\n                nodeRecord = getRecordForPath(path);\n                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ,\n                        request.authInfo);\n                version = checkVersionRequest.getVersion();\n                currentVersion = nodeRecord.stat.getVersion();\n                if (version != -1 && version != currentVersion) {\n                    throw new KeeperException.BadVersionException(path);\n                }\n                version = currentVersion + 1;\n                request.txn = new CheckVersionTxn(path, version);\n                break;\n        }\n    }"
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report identifies the issue as an 'Invalid path' error, which is consistent with the stack trace context shared with the ground truth method 'pRequest2Txn'. However, it does not precisely identify the root cause within the ground truth method. The report does not provide any fix suggestion, hence 'Missing' for fix suggestion. The problem location is identified in the stack trace context but not precisely at the ground truth method, so it is 'Partial' with 'Shared Stack Trace Context' as the sub-category. There is no wrong information in the bug report as it accurately describes the error and its context."
        }
    },
    {
        "filename": "ZOOKEEPER-2297.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.auth.ProviderRegistry.initialize": {
                "code_before_change": "    public static void initialize() {\n        synchronized (ProviderRegistry.class) {\n            if (initialized)\n                return;\n            IPAuthenticationProvider ipp = new IPAuthenticationProvider();\n            DigestAuthenticationProvider digp = new DigestAuthenticationProvider();\n            X509AuthenticationProvider x509p = new X509AuthenticationProvider();\n            authenticationProviders.put(ipp.getScheme(), ipp);\n            authenticationProviders.put(digp.getScheme(), digp);\n            authenticationProviders.put(x509p.getScheme(), x509p);\n            Enumeration<Object> en = System.getProperties().keys();\n            while (en.hasMoreElements()) {\n                String k = (String) en.nextElement();\n                if (k.startsWith(\"zookeeper.authProvider.\")) {\n                    String className = System.getProperty(k);\n                    try {\n                        Class<?> c = ZooKeeperServer.class.getClassLoader()\n                                .loadClass(className);\n                        AuthenticationProvider ap = (AuthenticationProvider) c\n                                .newInstance();\n                        authenticationProviders.put(ap.getScheme(), ap);\n                    } catch (Exception e) {\n                        LOG.warn(\"Problems loading \" + className,e);\n                    }\n                }\n            }\n            initialized = true;\n        }\n    }",
                "code_after_change": "    public static void initialize() {\n        synchronized (ProviderRegistry.class) {\n            if (initialized)\n                return;\n            IPAuthenticationProvider ipp = new IPAuthenticationProvider();\n            DigestAuthenticationProvider digp = new DigestAuthenticationProvider();\n            authenticationProviders.put(ipp.getScheme(), ipp);\n            authenticationProviders.put(digp.getScheme(), digp);\n            Enumeration<Object> en = System.getProperties().keys();\n            while (en.hasMoreElements()) {\n                String k = (String) en.nextElement();\n                if (k.startsWith(\"zookeeper.authProvider.\")) {\n                    String className = System.getProperty(k);\n                    try {\n                        Class<?> c = ZooKeeperServer.class.getClassLoader()\n                                .loadClass(className);\n                        AuthenticationProvider ap = (AuthenticationProvider) c\n                                .newInstance();\n                        authenticationProviders.put(ap.getScheme(), ap);\n                    } catch (Exception e) {\n                        LOG.warn(\"Problems loading \" + className,e);\n                    }\n                }\n            }\n            initialized = true;\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties": {
                "code_before_change": "    public void parseProperties(Properties zkProp)\n    throws IOException, ConfigException {\n        int clientPort = 0;\n        int secureClientPort = 0;\n        String clientPortAddress = null;\n        String secureClientPortAddress = null;\n        VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n        for (Entry<Object, Object> entry : zkProp.entrySet()) {\n            String key = entry.getKey().toString().trim();\n            String value = entry.getValue().toString().trim();\n            if (key.equals(\"dataDir\")) {\n                dataDir = vff.create(value);\n            } else if (key.equals(\"dataLogDir\")) {\n                dataLogDir = vff.create(value);\n            } else if (key.equals(\"clientPort\")) {\n                clientPort = Integer.parseInt(value);\n            } else if (key.equals(\"localSessionsEnabled\")) {\n                localSessionsEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n                localSessionsUpgradingEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"clientPortAddress\")) {\n                clientPortAddress = value.trim();\n            } else if (key.equals(\"secureClientPort\")) {\n                secureClientPort = Integer.parseInt(value);\n            } else if (key.equals(\"secureClientPortAddress\")){\n                secureClientPortAddress = value.trim();\n            } else if (key.equals(\"tickTime\")) {\n                tickTime = Integer.parseInt(value);\n            } else if (key.equals(\"maxClientCnxns\")) {\n                maxClientCnxns = Integer.parseInt(value);\n            } else if (key.equals(\"minSessionTimeout\")) {\n                minSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"maxSessionTimeout\")) {\n                maxSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"initLimit\")) {\n                initLimit = Integer.parseInt(value);\n            } else if (key.equals(\"syncLimit\")) {\n                syncLimit = Integer.parseInt(value);\n            } else if (key.equals(\"electionAlg\")) {\n                electionAlg = Integer.parseInt(value);\n            } else if (key.equals(\"quorumListenOnAllIPs\")) {\n                quorumListenOnAllIPs = Boolean.parseBoolean(value);\n            } else if (key.equals(\"peerType\")) {\n                if (value.toLowerCase().equals(\"observer\")) {\n                    peerType = LearnerType.OBSERVER;\n                } else if (value.toLowerCase().equals(\"participant\")) {\n                    peerType = LearnerType.PARTICIPANT;\n                } else\n                {\n                    throw new ConfigException(\"Unrecognised peertype: \" + value);\n                }\n            } else if (key.equals( \"syncEnabled\" )) {\n                syncEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"dynamicConfigFile\")){\n                dynamicConfigFileStr = value;\n            } else if (key.equals(\"autopurge.snapRetainCount\")) {\n                snapRetainCount = Integer.parseInt(value);\n            } else if (key.equals(\"autopurge.purgeInterval\")) {\n                purgeInterval = Integer.parseInt(value);\n            } else if (key.equals(\"standaloneEnabled\")) {\n                if (value.toLowerCase().equals(\"true\")) {\n                    setStandaloneEnabled(true);\n                } else if (value.toLowerCase().equals(\"false\")) {\n                    setStandaloneEnabled(false);\n                } else {\n                    throw new ConfigException(\"Invalid option for standalone mode. Choose 'true' or 'false.'\");\n                }\n            } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n                throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n            } else {\n                System.setProperty(\"zookeeper.\" + key, value);\n            }\n        }\n\n        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n            LOG.warn(\"Invalid autopurge.snapRetainCount: \" + snapRetainCount\n                    + \". Defaulting to \" + MIN_SNAP_RETAIN_COUNT);\n            snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n        }\n\n        if (dataDir == null) {\n            throw new IllegalArgumentException(\"dataDir is not set\");\n        }\n        if (dataLogDir == null) {\n            dataLogDir = dataDir;\n        }\n\n        if (clientPort == 0) {\n            LOG.info(\"clientPort is not set\");\n            if (clientPortAddress != null) {\n                throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n            }\n        } else if (clientPortAddress != null) {\n            this.clientPortAddress = new InetSocketAddress(\n                    InetAddress.getByName(clientPortAddress), clientPort);\n            LOG.info(\"clientPortAddress is {}\", this.clientPortAddress.toString());\n        } else {\n            this.clientPortAddress = new InetSocketAddress(clientPort);\n            LOG.info(\"clientPortAddress is {}\", this.clientPortAddress.toString());\n        }\n\n        if (secureClientPort == 0) {\n            LOG.info(\"secureClientPort is not set\");\n            if (secureClientPortAddress != null) {\n                throw new IllegalArgumentException(\"secureClientPortAddress is set but secureClientPort is not set\");\n            }\n        } else if (secureClientPortAddress != null) {\n            this.secureClientPortAddress = new InetSocketAddress(\n                    InetAddress.getByName(secureClientPortAddress), secureClientPort);\n            LOG.info(\"secureClientPortAddress is {}\", this.secureClientPortAddress.toString());\n        } else {\n            this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n            LOG.info(\"secureClientPortAddress is {}\", this.secureClientPortAddress.toString());\n        }\n\n        if (tickTime == 0) {\n            throw new IllegalArgumentException(\"tickTime is not set\");\n        }\n\n        minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n        maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n\n        if (minSessionTimeout > maxSessionTimeout) {\n            throw new IllegalArgumentException(\n                    \"minSessionTimeout must not be larger than maxSessionTimeout\");\n        }          \n\n        // backward compatibility - dynamic configuration in the same file as\n        // static configuration params see writeDynamicConfig()\n        if (dynamicConfigFileStr == null) {\n            setupQuorumPeerConfig(zkProp, true);\n            if (isDistributed()) {\n                // we don't backup static config for standalone mode.\n                backupOldConfig();\n            }\n        }\n    }",
                "code_after_change": "    public void parseProperties(Properties zkProp)\n    throws IOException, ConfigException {\n        int clientPort = 0;\n        int secureClientPort = 0;\n        String clientPortAddress = null;\n        String secureClientPortAddress = null;\n        VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();\n        for (Entry<Object, Object> entry : zkProp.entrySet()) {\n            String key = entry.getKey().toString().trim();\n            String value = entry.getValue().toString().trim();\n            if (key.equals(\"dataDir\")) {\n                dataDir = vff.create(value);\n            } else if (key.equals(\"dataLogDir\")) {\n                dataLogDir = vff.create(value);\n            } else if (key.equals(\"clientPort\")) {\n                clientPort = Integer.parseInt(value);\n            } else if (key.equals(\"localSessionsEnabled\")) {\n                localSessionsEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"localSessionsUpgradingEnabled\")) {\n                localSessionsUpgradingEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"clientPortAddress\")) {\n                clientPortAddress = value.trim();\n            } else if (key.equals(\"secureClientPort\")) {\n                secureClientPort = Integer.parseInt(value);\n            } else if (key.equals(\"secureClientPortAddress\")){\n                secureClientPortAddress = value.trim();\n            } else if (key.equals(\"tickTime\")) {\n                tickTime = Integer.parseInt(value);\n            } else if (key.equals(\"maxClientCnxns\")) {\n                maxClientCnxns = Integer.parseInt(value);\n            } else if (key.equals(\"minSessionTimeout\")) {\n                minSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"maxSessionTimeout\")) {\n                maxSessionTimeout = Integer.parseInt(value);\n            } else if (key.equals(\"initLimit\")) {\n                initLimit = Integer.parseInt(value);\n            } else if (key.equals(\"syncLimit\")) {\n                syncLimit = Integer.parseInt(value);\n            } else if (key.equals(\"electionAlg\")) {\n                electionAlg = Integer.parseInt(value);\n            } else if (key.equals(\"quorumListenOnAllIPs\")) {\n                quorumListenOnAllIPs = Boolean.parseBoolean(value);\n            } else if (key.equals(\"peerType\")) {\n                if (value.toLowerCase().equals(\"observer\")) {\n                    peerType = LearnerType.OBSERVER;\n                } else if (value.toLowerCase().equals(\"participant\")) {\n                    peerType = LearnerType.PARTICIPANT;\n                } else\n                {\n                    throw new ConfigException(\"Unrecognised peertype: \" + value);\n                }\n            } else if (key.equals( \"syncEnabled\" )) {\n                syncEnabled = Boolean.parseBoolean(value);\n            } else if (key.equals(\"dynamicConfigFile\")){\n                dynamicConfigFileStr = value;\n            } else if (key.equals(\"autopurge.snapRetainCount\")) {\n                snapRetainCount = Integer.parseInt(value);\n            } else if (key.equals(\"autopurge.purgeInterval\")) {\n                purgeInterval = Integer.parseInt(value);\n            } else if (key.equals(\"standaloneEnabled\")) {\n                if (value.toLowerCase().equals(\"true\")) {\n                    setStandaloneEnabled(true);\n                } else if (value.toLowerCase().equals(\"false\")) {\n                    setStandaloneEnabled(false);\n                } else {\n                    throw new ConfigException(\"Invalid option for standalone mode. Choose 'true' or 'false.'\");\n                }\n            } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n                throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n            } else {\n                System.setProperty(\"zookeeper.\" + key, value);\n            }\n        }\n\n        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {\n            LOG.warn(\"Invalid autopurge.snapRetainCount: \" + snapRetainCount\n                    + \". Defaulting to \" + MIN_SNAP_RETAIN_COUNT);\n            snapRetainCount = MIN_SNAP_RETAIN_COUNT;\n        }\n\n        if (dataDir == null) {\n            throw new IllegalArgumentException(\"dataDir is not set\");\n        }\n        if (dataLogDir == null) {\n            dataLogDir = dataDir;\n        }\n\n        if (clientPort == 0) {\n            LOG.info(\"clientPort is not set\");\n            if (clientPortAddress != null) {\n                throw new IllegalArgumentException(\"clientPortAddress is set but clientPort is not set\");\n            }\n        } else if (clientPortAddress != null) {\n            this.clientPortAddress = new InetSocketAddress(\n                    InetAddress.getByName(clientPortAddress), clientPort);\n            LOG.info(\"clientPortAddress is {}\", this.clientPortAddress.toString());\n        } else {\n            this.clientPortAddress = new InetSocketAddress(clientPort);\n            LOG.info(\"clientPortAddress is {}\", this.clientPortAddress.toString());\n        }\n\n        if (secureClientPort == 0) {\n            LOG.info(\"secureClientPort is not set\");\n            if (secureClientPortAddress != null) {\n                throw new IllegalArgumentException(\"secureClientPortAddress is set but secureClientPort is not set\");\n            }\n        } else if (secureClientPortAddress != null) {\n            this.secureClientPortAddress = new InetSocketAddress(\n                    InetAddress.getByName(secureClientPortAddress), secureClientPort);\n            LOG.info(\"secureClientPortAddress is {}\", this.secureClientPortAddress.toString());\n        } else {\n            this.secureClientPortAddress = new InetSocketAddress(secureClientPort);\n            LOG.info(\"secureClientPortAddress is {}\", this.secureClientPortAddress.toString());\n        }\n        if (this.secureClientPortAddress != null) {\n            configureSSLAuth();\n        }\n\n        if (tickTime == 0) {\n            throw new IllegalArgumentException(\"tickTime is not set\");\n        }\n\n        minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;\n        maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;\n\n        if (minSessionTimeout > maxSessionTimeout) {\n            throw new IllegalArgumentException(\n                    \"minSessionTimeout must not be larger than maxSessionTimeout\");\n        }          \n\n        // backward compatibility - dynamic configuration in the same file as\n        // static configuration params see writeDynamicConfig()\n        if (dynamicConfigFileStr == null) {\n            setupQuorumPeerConfig(zkProp, true);\n            if (isDistributed()) {\n                // we don't backup static config for standalone mode.\n                backupOldConfig();\n            }\n        }\n    }"
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report identifies the issue as a NullPointerException occurring during the creation of key and trust managers, which is related to the stack trace context but does not precisely identify the root cause in the ground truth methods. The stack trace includes methods like 'X509Util.createKeyManager' and 'X509Util.createTrustManager', which are in the same stack trace context as the ground truth method 'ProviderRegistry.initialize'. However, the report does not mention 'ProviderRegistry.initialize' or 'QuorumPeerConfig.parseProperties', which are the actual ground truth methods. There is no fix suggestion provided in the bug report. The problem location is partially identified as it mentions methods in the shared stack trace context but not the precise ground truth methods. There is no wrong information in the bug report as it accurately describes the observed error."
        }
    },
    {
        "filename": "ZOOKEEPER-2808.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.addCommittedProposal": {
                "code_before_change": "    public void addCommittedProposal(Request request) {\n        WriteLock wl = logLock.writeLock();\n        try {\n            wl.lock();\n            if (committedLog.size() > commitLogCount) {\n                committedLog.removeFirst();\n                minCommittedLog = committedLog.getFirst().packet.getZxid();\n            }\n            if (committedLog.isEmpty()) {\n                minCommittedLog = request.zxid;\n                maxCommittedLog = request.zxid;\n            }\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n            try {\n                request.getHdr().serialize(boa, \"hdr\");\n                if (request.getTxn() != null) {\n                    request.getTxn().serialize(boa, \"txn\");\n                }\n                baos.close();\n            } catch (IOException e) {\n                LOG.error(\"This really should be impossible\", e);\n            }\n            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,\n                    baos.toByteArray(), null);\n            Proposal p = new Proposal();\n            p.packet = pp;\n            p.request = request;\n            committedLog.add(p);\n            maxCommittedLog = p.packet.getZxid();\n        } finally {\n            wl.unlock();\n        }\n    }",
                "code_after_change": "    public void addCommittedProposal(Request request) {\n        WriteLock wl = logLock.writeLock();\n        try {\n            wl.lock();\n            if (committedLog.size() > commitLogCount) {\n                committedLog.removeFirst();\n                minCommittedLog = committedLog.getFirst().packet.getZxid();\n            }\n            if (committedLog.isEmpty()) {\n                minCommittedLog = request.zxid;\n                maxCommittedLog = request.zxid;\n            }\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n            try {\n                request.getHdr().serialize(boa, \"hdr\");\n                if (request.getTxn() != null) {\n                    request.getTxn().serialize(boa, \"txn\");\n                }\n                baos.close();\n            } catch (IOException e) {\n                LOG.error(\"This really should be impossible\", e);\n            }\n            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,\n                    baos.toByteArray(), null);\n            Proposal p = new Proposal();\n            p.packet = pp;\n            p.request = request;\n            committedLog.add(p);\n            maxCommittedLog = p.packet.getZxid();\n        } finally {\n            wl.unlock();\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.containsWatcher": {
                "code_before_change": "    public boolean containsWatcher(String path, WatcherType type, Watcher watcher) {\n        return dataTree.containsWatcher(path, type, watcher);\n    }",
                "code_after_change": "    public boolean containsWatcher(String path, WatcherType type, Watcher watcher) {\n        return dataTree.containsWatcher(path, type, watcher);\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.removeWatch": {
                "code_before_change": "    public boolean removeWatch(String path, WatcherType type, Watcher watcher) {\n        boolean removed = false;\n        switch (type) {\n        case Children:\n            removed = this.childWatches.removeWatcher(path, watcher);\n            break;\n        case Data:\n            removed = this.dataWatches.removeWatcher(path, watcher);\n            break;\n        case Any:\n            if (this.childWatches.removeWatcher(path, watcher)) {\n                removed = true;\n            }\n            if (this.dataWatches.removeWatcher(path, watcher)) {\n                removed = true;\n            }\n            break;\n        }\n        return removed;\n    }",
                "code_after_change": "    public boolean removeWatch(String path, WatcherType type, Watcher watcher) {\n        boolean removed = false;\n        switch (type) {\n        case Children:\n            removed = this.childWatches.removeWatcher(path, watcher);\n            break;\n        case Data:\n            removed = this.dataWatches.removeWatcher(path, watcher);\n            break;\n        case Any:\n            if (this.childWatches.removeWatcher(path, watcher)) {\n                removed = true;\n            }\n            if (this.dataWatches.removeWatcher(path, watcher)) {\n                removed = true;\n            }\n            break;\n        }\n        return removed;\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.addConfigNode": {
                "code_before_change": "    public void addConfigNode() {\n        DataNode zookeeperZnode = nodes.get(procZookeeper);\n        if (zookeeperZnode != null) { // should always be the case\n            zookeeperZnode.addChild(configChildZookeeper);\n        } else {\n            assert false : \"There's no /zookeeper znode - this should never happen.\";\n        }\n\n        nodes.put(configZookeeper, configDataNode);\n        try {\n            // Reconfig node is access controlled by default (ZOOKEEPER-2014).\n            setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);\n        } catch (KeeperException.NoNodeException e) {\n            assert false : \"There's no \" + configZookeeper +\n                    \" znode - this should never happen.\";\n        }\n    }",
                "code_after_change": "    public void addConfigNode() {\n        DataNode zookeeperZnode = nodes.get(procZookeeper);\n        if (zookeeperZnode != null) { // should always be the case\n            zookeeperZnode.addChild(configChildZookeeper);\n        } else {\n            assert false : \"There's no /zookeeper znode - this should never happen.\";\n        }\n\n        nodes.put(configZookeeper, new DataNode(new byte[0], -1L, new StatPersisted()));\n        try {\n            // Reconfig node is access controlled by default (ZOOKEEPER-2014).\n            setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);\n        } catch (KeeperException.NoNodeException e) {\n            assert false : \"There's no \" + configZookeeper +\n                    \" znode - this should never happen.\";\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.DataTree": {
                "code_before_change": [],
                "code_after_change": []
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.updateBytes": {
                "code_before_change": "    public void updateBytes(String lastPrefix, long diff) {\n        String statNode = Quotas.statPath(lastPrefix);\n        DataNode node = nodes.get(statNode);\n        if (node == null) {\n            // should never be null but just to make\n            // findbugs happy\n            LOG.error(\"Missing stat node for bytes \" + statNode);\n            return;\n        }\n        StatsTrack updatedStat = null;\n        synchronized (node) {\n            updatedStat = new StatsTrack(new String(node.data));\n            updatedStat.setBytes(updatedStat.getBytes() + diff);\n            node.data = updatedStat.toString().getBytes();\n        }\n        // now check if the bytes match the quota\n        String quotaNode = Quotas.quotaPath(lastPrefix);\n        node = nodes.get(quotaNode);\n        if (node == null) {\n            // should never be null but just to make\n            // findbugs happy\n            LOG.error(\"Missing quota node for bytes \" + quotaNode);\n            return;\n        }\n        StatsTrack thisStats = null;\n        synchronized (node) {\n            thisStats = new StatsTrack(new String(node.data));\n        }\n        if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {\n            LOG\n            .warn(\"Quota exceeded: \" + lastPrefix + \" bytes=\"\n                    + updatedStat.getBytes() + \" limit=\"\n                    + thisStats.getBytes());\n        }\n    }",
                "code_after_change": "    public void updateBytes(String lastPrefix, long diff) {\n        String statNode = Quotas.statPath(lastPrefix);\n        DataNode node = nodes.get(statNode);\n        if (node == null) {\n            // should never be null but just to make\n            // findbugs happy\n            LOG.error(\"Missing stat node for bytes \" + statNode);\n            return;\n        }\n        StatsTrack updatedStat = null;\n        synchronized (node) {\n            updatedStat = new StatsTrack(new String(node.data));\n            updatedStat.setBytes(updatedStat.getBytes() + diff);\n            node.data = updatedStat.toString().getBytes();\n        }\n        // now check if the bytes match the quota\n        String quotaNode = Quotas.quotaPath(lastPrefix);\n        node = nodes.get(quotaNode);\n        if (node == null) {\n            // should never be null but just to make\n            // findbugs happy\n            LOG.error(\"Missing quota node for bytes \" + quotaNode);\n            return;\n        }\n        StatsTrack thisStats = null;\n        synchronized (node) {\n            thisStats = new StatsTrack(new String(node.data));\n        }\n        if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {\n            LOG\n            .warn(\"Quota exceeded: \" + lastPrefix + \" bytes=\"\n                    + updatedStat.getBytes() + \" limit=\"\n                    + thisStats.getBytes());\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZKDatabase.initConfigInZKDatabase": {
                "code_before_change": "    public synchronized void initConfigInZKDatabase(QuorumVerifier qv) {\n        if (qv == null) return; // only happens during tests\n        try {\n            if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {\n                // should only happen during upgrade\n                LOG.warn(\"configuration znode missing (hould only happen during upgrade), creating the node\");\n                this.dataTree.addConfigNode();\n            }\n            this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());\n        } catch (NoNodeException e) {\n            System.out.println(\"configuration node missing - should not happen\");\n        }\n    }",
                "code_after_change": "    public synchronized void initConfigInZKDatabase(QuorumVerifier qv) {\n        if (qv == null) return; // only happens during tests\n        try {\n            if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {\n                // should only happen during upgrade\n                LOG.warn(\"configuration znode missing (should only happen during upgrade), creating the node\");\n                this.dataTree.addConfigNode();\n            }\n            this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());\n        } catch (NoNodeException e) {\n            System.out.println(\"configuration node missing - should not happen\");\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.createNode": {
                "code_before_change": "    public void createNode(final String path, byte data[], List<ACL> acl,\n            long ephemeralOwner, int parentCVersion, long zxid, long time)\n    \t\tthrows NoNodeException, NodeExistsException {\n    \tcreateNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, null);\n    }",
                "code_after_change": "    public void createNode(final String path, byte data[], List<ACL> acl,\n            long ephemeralOwner, int parentCVersion, long zxid, long time)\n    \t\tthrows NoNodeException, NodeExistsException {\n    \tcreateNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, null);\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.setWatches": {
                "code_before_change": "    public void setWatches(long relativeZxid, List<String> dataWatches,\n            List<String> existWatches, List<String> childWatches,\n            Watcher watcher) {\n        for (String path : dataWatches) {\n            DataNode node = getNode(path);\n            WatchedEvent e = null;\n            if (node == null) {\n                watcher.process(new WatchedEvent(EventType.NodeDeleted, \n                            KeeperState.SyncConnected, path));\n            } else if (node.stat.getMzxid() > relativeZxid) {\n                watcher.process(new WatchedEvent(EventType.NodeDataChanged, \n                            KeeperState.SyncConnected, path));\n            } else {\n                this.dataWatches.addWatch(path, watcher);\n            }    \n        }    \n        for (String path : existWatches) {\n            DataNode node = getNode(path);\n            if (node != null) {\n                watcher.process(new WatchedEvent(EventType.NodeCreated, \n                            KeeperState.SyncConnected, path));\n            } else {\n                this.dataWatches.addWatch(path, watcher);\n            }    \n        }    \n        for (String path : childWatches) {\n            DataNode node = getNode(path);\n            if (node == null) {\n                watcher.process(new WatchedEvent(EventType.NodeDeleted, \n                            KeeperState.SyncConnected, path));\n            } else if (node.stat.getPzxid() > relativeZxid) {\n                watcher.process(new WatchedEvent(EventType.NodeChildrenChanged, \n                            KeeperState.SyncConnected, path));\n            } else {\n                this.childWatches.addWatch(path, watcher);\n            }    \n        }    \n    }    ",
                "code_after_change": "    public void setWatches(long relativeZxid, List<String> dataWatches,\n            List<String> existWatches, List<String> childWatches,\n            Watcher watcher) {\n        for (String path : dataWatches) {\n            DataNode node = getNode(path);\n            WatchedEvent e = null;\n            if (node == null) {\n                watcher.process(new WatchedEvent(EventType.NodeDeleted,\n                            KeeperState.SyncConnected, path));\n            } else if (node.stat.getMzxid() > relativeZxid) {\n                watcher.process(new WatchedEvent(EventType.NodeDataChanged,\n                            KeeperState.SyncConnected, path));\n            } else {\n                this.dataWatches.addWatch(path, watcher);\n            }\n        }\n        for (String path : existWatches) {\n            DataNode node = getNode(path);\n            if (node != null) {\n                watcher.process(new WatchedEvent(EventType.NodeCreated,\n                            KeeperState.SyncConnected, path));\n            } else {\n                this.dataWatches.addWatch(path, watcher);\n            }\n        }\n        for (String path : childWatches) {\n            DataNode node = getNode(path);\n            if (node == null) {\n                watcher.process(new WatchedEvent(EventType.NodeDeleted,\n                            KeeperState.SyncConnected, path));\n            } else if (node.stat.getPzxid() > relativeZxid) {\n                watcher.process(new WatchedEvent(EventType.NodeChildrenChanged,\n                            KeeperState.SyncConnected, path));\n            } else {\n                this.childWatches.addWatch(path, watcher);\n            }\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.DataTree.approximateDataSize": {
                "code_before_change": "    public long approximateDataSize() {\n        long result = 0;\n        for (Map.Entry<String, DataNode> entry : nodes.entrySet()) {\n            DataNode value = entry.getValue();\n            synchronized (value) {\n                result += entry.getKey().length();\n                result += value.getApproximateDataSize();\n            }\n        }\n        return result;\n    }",
                "code_after_change": "    public long approximateDataSize() {\n        long result = 0;\n        for (Map.Entry<String, DataNode> entry : nodes.entrySet()) {\n            DataNode value = entry.getValue();\n            synchronized (value) {\n                result += entry.getKey().length();\n                result += value.getApproximateDataSize();\n            }\n        }\n        return result;\n    }"
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report identifies the issue with ACLs being removed due to reference count issues, which is related to the methods in the stack trace, such as DataTree.getACL and ZKDatabase.getACL. However, it does not precisely identify the root cause in the ground truth methods. The report does not provide any fix suggestion, hence 'Missing' for fix suggestion. The problem location is partially identified as it mentions methods in the stack trace context but not the exact ground truth methods. There is no wrong information as the report accurately describes the problem context."
        }
    },
    {
        "filename": "ZOOKEEPER-2982.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.quorum.Learner.findLeader": {
                "code_before_change": "    protected QuorumServer findLeader() {\n        QuorumServer leaderServer = null;\n        // Find the leader by id\n        Vote current = self.getCurrentVote();\n        for (QuorumServer s : self.getView().values()) {\n            if (s.id == current.getId()) {\n                leaderServer = s;\n                break;\n            }\n        }\n        if (leaderServer == null) {\n            LOG.warn(\"Couldn't find the leader with id = \"\n                    + current.getId());\n        }\n        return leaderServer;\n    }",
                "code_after_change": "    protected QuorumServer findLeader() {\n        QuorumServer leaderServer = null;\n        // Find the leader by id\n        Vote current = self.getCurrentVote();\n        for (QuorumServer s : self.getView().values()) {\n            if (s.id == current.getId()) {\n                // Ensure we have the leader's correct IP address before\n                // attempting to connect.\n                s.recreateSocketAddresses();\n                leaderServer = s;\n                break;\n            }\n        }\n        if (leaderServer == null) {\n            LOG.warn(\"Couldn't find the leader with id = \"\n                    + current.getId());\n        }\n        return leaderServer;\n    }"
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report identifies the issue as a DNS resolution problem, which is related to the stack trace context but does not precisely identify the root cause in the 'findLeader' method. The stack trace mentions 'sockConnect' and 'connectToLeader', which are in the same context as 'findLeader'. There is no explicit fix suggestion provided in the bug report. The problem location is partially identified as it mentions methods in the stack trace context but not the exact ground truth method. There is no wrong information in the bug report as it accurately describes the DNS resolution issue."
        }
    },
    {
        "filename": "ZOOKEEPER-1179.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.NettyServerCnxn.enableRecv": {
                "code_before_change": "    public void enableRecv() {\n        if (throttled) {\n            throttled = false;\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending unthrottle event \" + this);\n            }\n            channel.getPipeline().sendUpstream(new ResumeMessageEvent(channel));\n        }\n    }",
                "code_after_change": "    public void enableRecv() {\n        if (throttled) {\n            throttled = false;\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sending unthrottle event \" + this);\n            }\n            channel.getPipeline().sendUpstream(new ResumeMessageEvent(channel));\n        }\n    }"
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report mentions the method 'NettyServerCnxn.close' in the stack trace, which is in the same stack trace context as the ground truth method 'NettyServerCnxn.enableRecv'. However, it does not precisely identify the root cause or problem location as 'enableRecv'. There is no fix suggestion provided in the bug report. All information in the bug report is relevant to the context of the bug, so there is no wrong information."
        }
    },
    {
        "filename": "ZOOKEEPER-2581.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.auth.X509AuthenticationProvider.X509AuthenticationProvider": {
                "code_before_change": [],
                "code_after_change": []
            },
            "src.java.main.org.apache.zookeeper.server.auth.X509AuthenticationProvider.init": {
                "code_before_change": [],
                "code_after_change": []
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report identifies the issue as a NullPointerException occurring during the creation of key and trust managers, which is mentioned in the stack trace. However, it does not precisely identify the root cause in the ground truth methods, but it is in the shared stack trace context with the ground truth methods. There is no fix suggestion provided in the bug report, as there is no 'Suggestions' or 'possible_fix' field, nor is there any suggestion in the 'Description'. The problem location is partially identified as it mentions methods in the stack trace context but not the exact ground truth methods. There is no wrong information in the bug report as all the information is relevant to the context of the bug."
        }
    },
    {
        "filename": "ZOOKEEPER-2247.json",
        "code_diff": {
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.removeCnxn": {
                "code_before_change": "    void removeCnxn(ServerCnxn cnxn) {\n        zkDb.removeCnxn(cnxn);\n    }",
                "code_after_change": "    void removeCnxn(ServerCnxn cnxn) {\n        zkDb.removeCnxn(cnxn);\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.getServerId": {
                "code_before_change": "    public long getServerId() {\n        return self.getId();\n    }",
                "code_after_change": "    public long getServerId() {\n        return self.getId();\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.Follower.followLeader": {
                "code_before_change": "    void followLeader() throws InterruptedException {\n        self.end_fle = Time.currentElapsedTime();\n        LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - \" +\n              (self.end_fle - self.start_fle));\n        self.start_fle = 0;\n        self.end_fle = 0;\n        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n        try {\n            InetSocketAddress addr = findLeader();            \n            try {\n                connectToLeader(addr);\n                long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n                if (self.isReconfigStateChange())\n                   throw new Exception(\"learned about role change\");\n                //check to see if the leader zxid is lower than ours\n                //this should never happen but is just a safety check\n                long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n                if (newEpoch < self.getAcceptedEpoch()) {\n                    LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid)\n                            + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n                    throw new IOException(\"Error: Epoch of leader is lower\");\n                }\n                syncWithLeader(newEpochZxid);                \n                QuorumPacket qp = new QuorumPacket();\n                while (self.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when following the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n    \n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX((Learner)this);\n        }\n    }",
                "code_after_change": "    void followLeader() throws InterruptedException {\n        self.end_fle = System.currentTimeMillis();\n        LOG.info(\"FOLLOWING - LEADER ELECTION TOOK - \" +\n              (self.end_fle - self.start_fle));\n        self.start_fle = 0;\n        self.end_fle = 0;\n        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n        try {\n            InetSocketAddress addr = findLeader();            \n            try {\n                connectToLeader(addr);\n                long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n\n                //check to see if the leader zxid is lower than ours\n                //this should never happen but is just a safety check\n                long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);\n                if (newEpoch < self.getAcceptedEpoch()) {\n                    LOG.error(\"Proposed leader epoch \" + ZxidUtils.zxidToString(newEpochZxid)\n                            + \" is less than our accepted epoch \" + ZxidUtils.zxidToString(self.getAcceptedEpoch()));\n                    throw new IOException(\"Error: Epoch of leader is lower\");\n                }\n                syncWithLeader(newEpochZxid);                \n                QuorumPacket qp = new QuorumPacket();\n                while (this.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when following the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n    \n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX((Learner)this);\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.Leader.lead": {
                "code_before_change": "    void lead() throws IOException, InterruptedException {\n        self.end_fle = Time.currentElapsedTime();\n        LOG.info(\"LEADING - LEADER ELECTION TOOK - \" +\n              (self.end_fle - self.start_fle));\n        self.start_fle = 0;\n        self.end_fle = 0;\n\n        zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n\n        try {\n            self.tick.set(0);\n            zk.loadData();\n\n            leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n\n            // Start thread that waits for connection requests from\n            // new followers.\n            cnxAcceptor = new LearnerCnxAcceptor();\n            cnxAcceptor.start();\n\n            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());\n\n            zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n\n            synchronized(this){\n                lastProposed = zk.getZxid();\n            }\n\n            newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),\n                   null, null);\n\n\n            if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n                LOG.info(\"NEWLEADER proposal has Zxid of \"\n                        + Long.toHexString(newLeaderProposal.packet.getZxid()));\n            }\n\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            QuorumVerifier curQV = self.getQuorumVerifier();\n            if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {\n                // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly\n                // specified by the user; the lack of version in a config file is interpreted as version=0). \n                // As soon as a config is established we would like to increase its version so that it\n                // takes presedence over other initial configs that were not established (such as a config\n                // of a server trying to join the ensemble, which may be a partial view of the system, not the full config). \n                // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that\n                // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,\n                // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier, \n                // and there's still no agreement on the new version that we'd like to use. Instead, we use \n                // lastSeenQuorumVerifier which is being sent with NEWLEADER message\n                // so its a good way to let followers know about the new version. (The original reason for sending \n                // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs\n                // that it finds before starting to propose operations. Here we're reusing the same code path for \n                // reaching consensus on the new version number.)\n                \n                // It is important that this is done before the leader executes waitForEpochAck,\n                // so before LearnerHandlers return from their waitForEpochAck\n                // hence before they construct the NEWLEADER message containing\n                // the last-seen-quorumverifier of the leader, which we change below\n               try {\n                   QuorumVerifier newQV = self.configFromString(curQV.toString());\n                   newQV.setVersion(zk.getZxid());\n                   self.setLastSeenQuorumVerifier(newQV, true);    \n               } catch (Exception e) {\n                   throw new IOException(e);\n               }\n            }\n            \n            newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());\n            if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()){\n               newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());\n            }\n            \n            // We have to get at least a majority of servers in sync with\n            // us. We do this by waiting for the NEWLEADER packet to get\n            // acknowledged\n                       \n             waitForEpochAck(self.getId(), leaderStateSummary);\n             self.setCurrentEpoch(epoch);    \n            \n             try {\n                 waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);\n             } catch (InterruptedException e) {\n                 shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \"\n                         + newLeaderProposal.ackSetsToString() + \" ]\");\n                 HashSet<Long> followerSet = new HashSet<Long>();\n\n                 for(LearnerHandler f : getLearners()) {\n                     if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())){\n                         followerSet.add(f.getSid());\n                     }\n                 }    \n                 boolean initTicksShouldBeIncreased = true;\n                 for (Proposal.QuorumVerifierAcksetPair qvAckset:newLeaderProposal.qvAcksetPairs) {\n                     if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {\n                         initTicksShouldBeIncreased = false;\n                         break;\n                     }\n                 }                  \n                 if (initTicksShouldBeIncreased) {\n                     LOG.warn(\"Enough followers present. \"+\n                             \"Perhaps the initTicks need to be increased.\");\n                 }\n                 return;\n             }\n\n             startZkServer();\n             \n            /**\n             * WARNING: do not use this for anything other than QA testing\n             * on a real cluster. Specifically to enable verification that quorum\n             * can handle the lower 32bit roll-over issue identified in\n             * ZOOKEEPER-1277. Without this option it would take a very long\n             * time (on order of a month say) to see the 4 billion writes\n             * necessary to cause the roll-over to occur.\n             *\n             * This field allows you to override the zxid of the server. Typically\n             * you'll want to set it to something like 0xfffffff0 and then\n             * start the quorum, run some operations and see the re-election.\n             */\n            String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n            if (initialZxid != null) {\n                long zxid = Long.parseLong(initialZxid);\n                zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n            }\n\n            if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n                self.setZooKeeperServer(zk);\n            }\n\n            self.adminServer.setZooKeeperServer(zk);\n\n            // Everything is a go, simply start counting the ticks\n            // WARNING: I couldn't find any wait statement on a synchronized\n            // block that would be notified by this notifyAll() call, so\n            // I commented it out\n            //synchronized (this) {\n            //    notifyAll();\n            //}\n            // We ping twice a tick, so we only update the tick every other\n            // iteration\n            boolean tickSkip = true;\n\n            while (true) {\n                synchronized (this) {\n                    long start = Time.currentElapsedTime();\n                    long cur = start;\n                    long end = start + self.tickTime / 2;\n                    while (cur < end) {\n                        wait(end - cur);\n                        cur = Time.currentElapsedTime();\n                    }\n\n                    if (!tickSkip) {\n                        self.tick.incrementAndGet();\n                    }\n\n                    // We use an instance of SyncedLearnerTracker to\n                    // track synced learners to make sure we still have a\n                    // quorum of current (and potentially next pending) view.\n                    SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();\n                    syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());\n                    if (self.getLastSeenQuorumVerifier() != null\n                            && self.getLastSeenQuorumVerifier().getVersion() > self\n                                    .getQuorumVerifier().getVersion()) {\n                        syncedAckSet.addQuorumVerifier(self\n                                .getLastSeenQuorumVerifier());\n                    }\n\n                    syncedAckSet.addAck(self.getId());\n\n                    for (LearnerHandler f : getLearners()) {\n                        if (f.synced()) {\n                            syncedAckSet.addAck(f.getSid());\n                        }\n                    }\n\n                    if (!tickSkip && !syncedAckSet.hasAllQuorums()) {\n                        // Lost quorum of last committed and/or last proposed\n                        // config, shutdown\n                        shutdown(\"Not sufficient followers synced, only synced with sids: [ \"\n                                + syncedAckSet.ackSetsToString() + \" ]\");\n                        // make sure the order is the same!\n                        // the leader goes to looking\n                        return;\n                    }\n                    tickSkip = !tickSkip;\n                }\n                for (LearnerHandler f : getLearners()) {\n                    f.ping();\n                }\n            }\n        } finally {\n            zk.unregisterJMX(this);\n        }\n    }",
                "code_after_change": "    void lead() throws IOException, InterruptedException {\n        self.end_fle = System.currentTimeMillis();\n        LOG.info(\"LEADING - LEADER ELECTION TOOK - \" +\n              (self.end_fle - self.start_fle));\n        self.start_fle = 0;\n        self.end_fle = 0;\n\n        zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);\n\n        try {\n            self.tick = 0;\n            zk.loadData();\n            \n            leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());\n\n            // Start thread that waits for connection requests from \n            // new followers.\n            cnxAcceptor = new LearnerCnxAcceptor();\n            cnxAcceptor.start();\n            \n            readyToStart = true;\n            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());\n            \n            zk.setZxid(ZxidUtils.makeZxid(epoch, 0));\n            \n            synchronized(this){\n                lastProposed = zk.getZxid();\n            }\n            \n            newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),\n                    null, null);\n\n\n            if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n                LOG.info(\"NEWLEADER proposal has Zxid of \"\n                        + Long.toHexString(newLeaderProposal.packet.getZxid()));\n            }\n            \n            waitForEpochAck(self.getId(), leaderStateSummary);\n            self.setCurrentEpoch(epoch);\n\n            // We have to get at least a majority of servers in sync with\n            // us. We do this by waiting for the NEWLEADER packet to get\n            // acknowledged\n            try {\n                waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);\n            } catch (InterruptedException e) {\n                shutdown(\"Waiting for a quorum of followers, only synced with sids: [ \"\n                        + getSidSetString(newLeaderProposal.ackSet) + \" ]\");\n                HashSet<Long> followerSet = new HashSet<Long>();\n                for (LearnerHandler f : learners)\n                    followerSet.add(f.getSid());\n                    \n                if (self.getQuorumVerifier().containsQuorum(followerSet)) {\n                    LOG.warn(\"Enough followers present. \"\n                            + \"Perhaps the initTicks need to be increased.\");\n                }\n                Thread.sleep(self.tickTime);\n                self.tick++;\n                return;\n            }\n            \n            startZkServer();\n            \n            /**\n             * WARNING: do not use this for anything other than QA testing\n             * on a real cluster. Specifically to enable verification that quorum\n             * can handle the lower 32bit roll-over issue identified in\n             * ZOOKEEPER-1277. Without this option it would take a very long\n             * time (on order of a month say) to see the 4 billion writes\n             * necessary to cause the roll-over to occur.\n             * \n             * This field allows you to override the zxid of the server. Typically\n             * you'll want to set it to something like 0xfffffff0 and then\n             * start the quorum, run some operations and see the re-election.\n             */\n            String initialZxid = System.getProperty(\"zookeeper.testingonly.initialZxid\");\n            if (initialZxid != null) {\n                long zxid = Long.parseLong(initialZxid);\n                zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);\n            }\n            \n            if (!System.getProperty(\"zookeeper.leaderServes\", \"yes\").equals(\"no\")) {\n                self.cnxnFactory.setZooKeeperServer(zk);\n            }\n            // Everything is a go, simply start counting the ticks\n            // WARNING: I couldn't find any wait statement on a synchronized\n            // block that would be notified by this notifyAll() call, so\n            // I commented it out\n            //synchronized (this) {\n            //    notifyAll();\n            //}\n            // We ping twice a tick, so we only update the tick every other\n            // iteration\n            boolean tickSkip = true;\n    \n            while (true) {\n                Thread.sleep(self.tickTime / 2);\n                if (!tickSkip) {\n                    self.tick++;\n                }\n                HashSet<Long> syncedSet = new HashSet<Long>();\n\n                // lock on the followers when we use it.\n                syncedSet.add(self.getId());\n\n                for (LearnerHandler f : getLearners()) {\n                    // Synced set is used to check we have a supporting quorum, so only\n                    // PARTICIPANT, not OBSERVER, learners should be used\n                    if (f.synced() && f.getLearnerType() == LearnerType.PARTICIPANT) {\n                        syncedSet.add(f.getSid());\n                    }\n                    f.ping();\n                }\n\n                // check leader running status\n                if (!this.isRunning()) {\n                    shutdown(\"Unexpected internal error\");\n                    return;\n                }\n\n              if (!tickSkip && !self.getQuorumVerifier().containsQuorum(syncedSet)) {\n                //if (!tickSkip && syncedCount < self.quorumPeers.size() / 2) {\n                    // Lost quorum, shutdown\n                    shutdown(\"Not sufficient followers synced, only synced with sids: [ \"\n                            + getSidSetString(syncedSet) + \" ]\");\n                    // make sure the order is the same!\n                    // the leader goes to looking\n                    return;\n              } \n              tickSkip = !tickSkip;\n            }\n        } finally {\n            zk.unregisterJMX(this);\n        }\n    }\n\n    boolean isShutdown;\n\n    /**\n     * Close down all the LearnerHandlers\n     */\n    void shutdown(String reason) {\n        LOG.info(\"Shutting down\");\n\n        if (isShutdown) {\n            return;\n        }\n        \n        LOG.info(\"Shutdown called\",\n                new Exception(\"shutdown Leader! reason: \" + reason));\n\n        if (cnxAcceptor != null) {\n            cnxAcceptor.halt();\n        }\n        \n        // NIO should not accept conenctions\n        self.cnxnFactory.setZooKeeperServer(null);\n        try {\n            ss.close();\n        } catch (IOException e) {\n            LOG.warn(\"Ignoring unexpected exception during close\",e);\n        }\n        // clear all the connections\n        self.cnxnFactory.closeAll();\n        // shutdown the previous zk\n        if (zk != null) {\n            zk.shutdown();\n        }\n        synchronized (learners) {\n            for (Iterator<LearnerHandler> it = learners.iterator(); it\n                    .hasNext();) {\n                LearnerHandler f = it.next();\n                it.remove();\n                f.shutdown();\n            }\n        }\n        isShutdown = true;\n    }\n\n    /**\n     * Keep a count of acks that are received by the leader for a particular\n     * proposal\n     * \n     * @param zxid\n     *                the zxid of the proposal sent out\n     * @param followerAddr\n     */\n    synchronized public void processAck(long sid, long zxid, SocketAddress followerAddr) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Ack zxid: 0x{}\", Long.toHexString(zxid));\n            for (Proposal p : outstandingProposals.values()) {\n                long packetZxid = p.packet.getZxid();\n                LOG.trace(\"outstanding proposal: 0x{}\",\n                        Long.toHexString(packetZxid));\n            }\n            LOG.trace(\"outstanding proposals all\");\n        }\n\n        if ((zxid & 0xffffffffL) == 0) {\n            /*\n             * We no longer process NEWLEADER ack by this method. However,\n             * the learner sends ack back to the leader after it gets UPTODATE\n             * so we just ignore the message.\n             */\n            return;\n        }\n    \n        if (outstandingProposals.size() == 0) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"outstanding is 0\");\n            }\n            return;\n        }\n        if (lastCommitted >= zxid) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"proposal has already been committed, pzxid: 0x{} zxid: 0x{}\",\n                        Long.toHexString(lastCommitted), Long.toHexString(zxid));\n            }\n            // The proposal has already been committed\n            return;\n        }\n        Proposal p = outstandingProposals.get(zxid);\n        if (p == null) {\n            LOG.warn(\"Trying to commit future proposal: zxid 0x{} from {}\",\n                    Long.toHexString(zxid), followerAddr);\n            return;\n        }\n        \n        p.ackSet.add(sid);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Count for zxid: 0x{} is {}\",\n                    Long.toHexString(zxid), p.ackSet.size());\n        }\n        if (self.getQuorumVerifier().containsQuorum(p.ackSet)){             \n            if (zxid != lastCommitted+1) {\n                LOG.warn(\"Commiting zxid 0x{} from {} not first!\",\n                        Long.toHexString(zxid), followerAddr);\n                LOG.warn(\"First is 0x{}\", Long.toHexString(lastCommitted + 1));\n            }\n            outstandingProposals.remove(zxid);\n            if (p.request != null) {\n                toBeApplied.add(p);\n            }\n\n            if (p.request == null) {\n                LOG.warn(\"Going to commmit null request for proposal: {}\", p);\n            }\n            commit(zxid);\n            inform(p);\n            zk.commitProcessor.commit(p.request);\n            if(pendingSyncs.containsKey(zxid)){\n                for(LearnerSyncRequest r: pendingSyncs.remove(zxid)) {\n                    sendSync(r);\n                }\n            }\n        }\n    }\n\n    static class ToBeAppliedRequestProcessor implements RequestProcessor {\n        private RequestProcessor next;\n\n        private ConcurrentLinkedQueue<Proposal> toBeApplied;\n\n        /**\n         * This request processor simply maintains the toBeApplied list. For\n         * this to work next must be a FinalRequestProcessor and\n         * FinalRequestProcessor.processRequest MUST process the request\n         * synchronously!\n         * \n         * @param next\n         *                a reference to the FinalRequestProcessor\n         */\n        ToBeAppliedRequestProcessor(RequestProcessor next,\n                ConcurrentLinkedQueue<Proposal> toBeApplied) {\n            if (!(next instanceof FinalRequestProcessor)) {\n                throw new RuntimeException(ToBeAppliedRequestProcessor.class\n                        .getName()\n                        + \" must be connected to \"\n                        + FinalRequestProcessor.class.getName()\n                        + \" not \"\n                        + next.getClass().getName());\n            }\n            this.toBeApplied = toBeApplied;\n            this.next = next;\n        }\n\n        /*\n         * (non-Javadoc)\n         * \n         * @see org.apache.zookeeper.server.RequestProcessor#processRequest(org.apache.zookeeper.server.Request)\n         */\n        public void processRequest(Request request) throws RequestProcessorException {\n            // request.addRQRec(\">tobe\");\n            next.processRequest(request);\n            Proposal p = toBeApplied.peek();\n            if (p != null && p.request != null\n                    && p.request.zxid == request.zxid) {\n                toBeApplied.remove();\n            }\n        }\n\n        /*\n         * (non-Javadoc)\n         * \n         * @see org.apache.zookeeper.server.RequestProcessor#shutdown()\n         */\n        public void shutdown() {\n            LOG.info(\"Shutting down\");\n            next.shutdown();\n        }\n    }\n\n    /**\n     * send a packet to all the followers ready to follow\n     * \n     * @param qp\n     *                the packet to be sent\n     */\n    void sendPacket(QuorumPacket qp) {\n        synchronized (forwardingFollowers) {\n            for (LearnerHandler f : forwardingFollowers) {                \n                f.queuePacket(qp);\n            }\n        }\n    }\n    \n    /**\n     * send a packet to all observers     \n     */\n    void sendObserverPacket(QuorumPacket qp) {        \n        for (LearnerHandler f : getObservingLearners()) {\n            f.queuePacket(qp);\n        }\n    }\n\n    long lastCommitted = -1;\n\n    /**\n     * Create a commit packet and send it to all the members of the quorum\n     * \n     * @param zxid\n     */\n    public void commit(long zxid) {\n        synchronized(this){\n            lastCommitted = zxid;\n        }\n        QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);\n        sendPacket(qp);\n    }\n    \n    /**\n     * Create an inform packet and send it to all observers.\n     * @param zxid\n     * @param proposal\n     */\n    public void inform(Proposal proposal) {   \n        QuorumPacket qp = new QuorumPacket(Leader.INFORM, proposal.request.zxid, \n                                            proposal.packet.getData(), null);\n        sendObserverPacket(qp);\n    }\n\n    long lastProposed;\n\n    \n    /**\n     * Returns the current epoch of the leader.\n     * \n     * @return\n     */\n    public long getEpoch(){\n        return ZxidUtils.getEpochFromZxid(lastProposed);\n    }\n    \n    @SuppressWarnings(\"serial\")\n    public static class XidRolloverException extends Exception {\n        public XidRolloverException(String message) {\n            super(message);\n        }\n    }\n\n    /**\n     * create a proposal and send it out to all the members\n     * \n     * @param request\n     * @return the proposal that is queued to send to all the members\n     */\n    public Proposal propose(Request request) throws XidRolloverException {\n        /**\n         * Address the rollover issue. All lower 32bits set indicate a new leader\n         * election. Force a re-election instead. See ZOOKEEPER-1277\n         */\n        if ((request.zxid & 0xffffffffL) == 0xffffffffL) {\n            String msg =\n                    \"zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start\";\n            shutdown(msg);\n            throw new XidRolloverException(msg);\n        }\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);\n        try {\n            request.hdr.serialize(boa, \"hdr\");\n            if (request.txn != null) {\n                request.txn.serialize(boa, \"txn\");\n            }\n            baos.close();\n        } catch (IOException e) {\n            LOG.warn(\"This really should be impossible\", e);\n        }\n        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, \n                baos.toByteArray(), null);\n        \n        Proposal p = new Proposal();\n        p.packet = pp;\n        p.request = request;\n        synchronized (this) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Proposing:: \" + request);\n            }\n\n            lastProposed = p.packet.getZxid();\n            outstandingProposals.put(lastProposed, p);\n            sendPacket(pp);\n        }\n        return p;\n    }\n            \n    /**\n     * Process sync requests\n     * \n     * @param r the request\n     */\n    \n    synchronized public void processSync(LearnerSyncRequest r){\n        if(outstandingProposals.isEmpty()){\n            sendSync(r);\n        } else {\n            List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);\n            if (l == null) {\n                l = new ArrayList<LearnerSyncRequest>();\n            }\n            l.add(r);\n            pendingSyncs.put(lastProposed, l);\n        }\n    }\n        \n    /**\n     * Sends a sync message to the appropriate server\n     * \n     * @param f\n     * @param r\n     */\n            \n    public void sendSync(LearnerSyncRequest r){\n        QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);\n        r.fh.queuePacket(qp);\n    }\n                \n    /**\n     * lets the leader know that a follower is capable of following and is done\n     * syncing\n     * \n     * @param handler handler of the follower\n     * @return last proposed zxid\n     */\n    synchronized public long startForwarding(LearnerHandler handler,\n            long lastSeenZxid) {\n        // Queue up any outstanding requests enabling the receipt of\n        // new requests\n        if (lastProposed > lastSeenZxid) {\n            for (Proposal p : toBeApplied) {\n                if (p.packet.getZxid() <= lastSeenZxid) {\n                    continue;\n                }\n                handler.queuePacket(p.packet);\n                // Since the proposal has been committed we need to send the\n                // commit message also\n                QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet\n                        .getZxid(), null, null);\n                handler.queuePacket(qp);\n            }\n            // Only participant need to get outstanding proposals\n            if (handler.getLearnerType() == LearnerType.PARTICIPANT) {\n                List<Long>zxids = new ArrayList<Long>(outstandingProposals.keySet());\n                Collections.sort(zxids);\n                for (Long zxid: zxids) {\n                    if (zxid <= lastSeenZxid) {\n                        continue;\n                    }\n                    handler.queuePacket(outstandingProposals.get(zxid).packet);\n                }\n            }\n        }\n        if (handler.getLearnerType() == LearnerType.PARTICIPANT) {\n            addForwardingFollower(handler);\n        } else {\n            addObserverLearnerHandler(handler);\n        }\n                \n        return lastProposed;\n    }\n\n    private HashSet<Long> connectingFollowers = new HashSet<Long>();\n    public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {\n        synchronized(connectingFollowers) {\n            if (!waitingForNewEpoch) {\n                return epoch;\n            }\n            if (lastAcceptedEpoch >= epoch) {\n                epoch = lastAcceptedEpoch+1;\n            }\n            connectingFollowers.add(sid);\n            QuorumVerifier verifier = self.getQuorumVerifier();\n            if (connectingFollowers.contains(self.getId()) && \n                                            verifier.containsQuorum(connectingFollowers)) {\n                waitingForNewEpoch = false;\n                self.setAcceptedEpoch(epoch);\n                connectingFollowers.notifyAll();\n            } else {\n                long start = System.currentTimeMillis();\n                long cur = start;\n                long end = start + self.getInitLimit()*self.getTickTime();\n                while(waitingForNewEpoch && cur < end) {\n                    connectingFollowers.wait(end - cur);\n                    cur = System.currentTimeMillis();\n                }\n                if (waitingForNewEpoch) {\n                    throw new InterruptedException(\"Timeout while waiting for epoch from quorum\");        \n                }\n            }\n            return epoch;\n        }\n    }\n\n    private HashSet<Long> electingFollowers = new HashSet<Long>();\n    private boolean electionFinished = false;\n    public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException {\n        synchronized(electingFollowers) {\n            if (electionFinished) {\n                return;\n            }\n            if (ss.getCurrentEpoch() != -1) {\n                if (ss.isMoreRecentThan(leaderStateSummary)) {\n                    throw new IOException(\"Follower is ahead of the leader, leader summary: \" \n                                                    + leaderStateSummary.getCurrentEpoch()\n                                                    + \" (current epoch), \"\n                                                    + leaderStateSummary.getLastZxid()\n                                                    + \" (last zxid)\");\n                }\n                electingFollowers.add(id);\n            }\n            QuorumVerifier verifier = self.getQuorumVerifier();\n            if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {\n                electionFinished = true;\n                electingFollowers.notifyAll();\n            } else {                \n                long start = System.currentTimeMillis();\n                long cur = start;\n                long end = start + self.getInitLimit()*self.getTickTime();\n                while(!electionFinished && cur < end) {\n                    electingFollowers.wait(end - cur);\n                    cur = System.currentTimeMillis();\n                }\n                if (!electionFinished) {\n                    throw new InterruptedException(\"Timeout while waiting for epoch to be acked by quorum\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Return a list of sid in set as string  \n     */\n    private String getSidSetString(Set<Long> sidSet) {\n        StringBuilder sids = new StringBuilder();\n        Iterator<Long> iter = sidSet.iterator();\n        while (iter.hasNext()) {\n            sids.append(iter.next());\n            if (!iter.hasNext()) {\n              break;\n            }\n            sids.append(\",\");\n        }\n        return sids.toString();\n    }\n\n    /**\n     * Start up Leader ZooKeeper server and initialize zxid to the new epoch\n     */\n    private synchronized void startZkServer() {\n        // Update lastCommitted and Db's zxid to a value representing the new epoch\n        lastCommitted = zk.getZxid();\n        LOG.info(\"Have quorum of supporters, sids: [ \"\n                + getSidSetString(newLeaderProposal.ackSet)\n                + \" ]; starting up and setting last processed zxid: 0x{}\",\n                Long.toHexString(zk.getZxid()));\n        zk.startup();\n        /*\n         * Update the election vote here to ensure that all members of the\n         * ensemble report the same vote to new servers that start up and\n         * send leader election notifications to the ensemble.\n         * \n         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n         */\n        self.updateElectionVote(getEpoch());\n\n        zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());\n    }\n\n    /**\n     * Process NEWLEADER ack of a given sid and wait until the leader receives\n     * sufficient acks.\n     *\n     * @param sid\n     * @param learnerType\n     * @throws InterruptedException\n     */\n    public void waitForNewLeaderAck(long sid, long zxid, LearnerType learnerType)\n            throws InterruptedException {\n\n        synchronized (newLeaderProposal.ackSet) {\n\n            if (quorumFormed) {\n                return;\n            }\n\n            long currentZxid = newLeaderProposal.packet.getZxid();\n            if (zxid != currentZxid) {\n                LOG.error(\"NEWLEADER ACK from sid: \" + sid\n                        + \" is from a different epoch - current 0x\"\n                        + Long.toHexString(currentZxid) + \" receieved 0x\"\n                        + Long.toHexString(zxid));\n                return;\n            }\n\n            if (learnerType == LearnerType.PARTICIPANT) {\n                newLeaderProposal.ackSet.add(sid);\n            }\n\n            if (self.getQuorumVerifier().containsQuorum(\n                    newLeaderProposal.ackSet)) {\n                quorumFormed = true;\n                newLeaderProposal.ackSet.notifyAll();\n            } else {\n                long start = System.currentTimeMillis();\n                long cur = start;\n                long end = start + self.getInitLimit() * self.getTickTime();\n                while (!quorumFormed && cur < end) {\n                    newLeaderProposal.ackSet.wait(end - cur);\n                    cur = System.currentTimeMillis();\n                }\n                if (!quorumFormed) {\n                    throw new InterruptedException(\n                            \"Timeout while waiting for NEWLEADER to be acked by quorum\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Get string representation of a given packet type\n     * @param packetType\n     * @return string representing the packet type\n     */\n    public static String getPacketType(int packetType) {\n        switch (packetType) {\n        case DIFF:\n            return \"DIFF\";\n        case TRUNC:\n            return \"TRUNC\";\n        case SNAP:\n            return \"SNAP\";\n        case OBSERVERINFO:\n            return \"OBSERVERINFO\";\n        case NEWLEADER:\n            return \"NEWLEADER\";\n        case FOLLOWERINFO:\n            return \"FOLLOWERINFO\";\n        case UPTODATE:\n            return \"UPTODATE\";\n        case LEADERINFO:\n            return \"LEADERINFO\";\n        case ACKEPOCH:\n            return \"ACKEPOCH\";\n        case REQUEST:\n            return \"REQUEST\";\n        case PROPOSAL:\n            return \"PROPOSAL\";\n        case ACK:\n            return \"ACK\";\n        case COMMIT:\n            return \"COMMIT\";\n        case PING:\n            return \"PING\";\n        case REVALIDATE:\n            return \"REVALIDATE\";\n        case SYNC:\n            return \"SYNC\";\n        case INFORM:\n            return \"INFORM\";\n        default:\n            return \"UNKNOWN\";\n        }\n    }\n\n    private boolean isRunning() {\n        return self.isRunning() && zk.isRunning();\n    }\n}"
            },
            "src.java.main.org.apache.zookeeper.server.ServerCnxnFactory.getNumAliveConnections": {
                "code_before_change": "    public int getNumAliveConnections() {\n        return cnxns.size();\n    }",
                "code_after_change": "    public int getNumAliveConnections() {\n        synchronized(cnxns) {\n            return cnxns.size();\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.Observer.observeLeader": {
                "code_before_change": "    void observeLeader() throws Exception {\n        zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n\n        try {\n            InetSocketAddress addr = findLeader();\n            LOG.info(\"Observing \" + addr);\n            try {\n                connectToLeader(addr);\n                long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n                if (self.isReconfigStateChange())\n                   throw new Exception(\"learned about role change\");\n \n                syncWithLeader(newLeaderZxid);\n                QuorumPacket qp = new QuorumPacket();\n                while (self.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when observing the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n\n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX(this);\n        }\n    }",
                "code_after_change": "    void observeLeader() throws InterruptedException {\n        zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n\n        try {\n            InetSocketAddress addr = findLeader();\n            LOG.info(\"Observing \" + addr);\n            try {\n                connectToLeader(addr);\n                long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n\n                syncWithLeader(newLeaderZxid);\n                QuorumPacket qp = new QuorumPacket();\n                while (this.isRunning()) {\n                    readPacket(qp);\n                    processPacket(qp);                   \n                }\n            } catch (Exception e) {\n                LOG.warn(\"Exception when observing the leader\", e);\n                try {\n                    sock.close();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n    \n                // clear pending revalidations\n                pendingRevalidations.clear();\n            }\n        } finally {\n            zk.unregisterJMX(this);\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer": {
                "code_before_change": [],
                "code_after_change": []
            },
            "src.java.main.org.apache.zookeeper.server.quorum.Learner.shutdown": {
                "code_before_change": "    public void shutdown() {\n        self.setZooKeeperServer(null);\n        self.closeAllConnections();\n        self.adminServer.setZooKeeperServer(null);\n        // shutdown previous zookeeper\n        if (zk != null) {\n            zk.shutdown();\n        }\n    }",
                "code_after_change": "    public void shutdown() {\n        // set the zookeeper server to null\n        self.cnxnFactory.setZooKeeperServer(null);\n        // clear all the connections\n        self.cnxnFactory.closeAll();\n        // shutdown previous zookeeper\n        if (zk != null) {\n            zk.shutdown();\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.dumpConf": {
                "code_before_change": "    public void dumpConf(PrintWriter pwriter) {\n        super.dumpConf(pwriter);\n\n        pwriter.print(\"initLimit=\");\n        pwriter.println(self.getInitLimit());\n        pwriter.print(\"syncLimit=\");\n        pwriter.println(self.getSyncLimit());\n        pwriter.print(\"electionAlg=\");\n        pwriter.println(self.getElectionType());\n        pwriter.print(\"electionPort=\");\n        pwriter.println(self.getElectionAddress().getPort());\n        pwriter.print(\"quorumPort=\");\n        pwriter.println(self.getQuorumAddress().getPort());\n        pwriter.print(\"peerType=\");\n        pwriter.println(self.getLearnerType().ordinal());\n        pwriter.println(\"membership: \");\n        pwriter.print(new String(self.getQuorumVerifier().toString().getBytes()));\n    }",
                "code_after_change": "    public void dumpConf(PrintWriter pwriter) {\n        super.dumpConf(pwriter);\n\n        pwriter.print(\"initLimit=\");\n        pwriter.println(self.getInitLimit());\n        pwriter.print(\"syncLimit=\");\n        pwriter.println(self.getSyncLimit());\n        pwriter.print(\"electionAlg=\");\n        pwriter.println(self.getElectionType());\n        pwriter.print(\"electionPort=\");\n        pwriter.println(self.quorumPeers.get(self.getId()).electionAddr\n                .getPort());\n        pwriter.print(\"quorumPort=\");\n        pwriter.println(self.quorumPeers.get(self.getId()).addr.getPort());\n        pwriter.print(\"peerType=\");\n        pwriter.println(self.getLearnerType().ordinal());\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.run": {
                "code_before_change": "    public void run() {\n        try {\n            int logCount = 0;\n\n            // we do this in an attempt to ensure that not all of the servers\n            // in the ensemble take a snapshot at the same time\n            int randRoll = r.nextInt(snapCount/2);\n            while (true) {\n                Request si = null;\n                if (toFlush.isEmpty()) {\n                    si = queuedRequests.take();\n                } else {\n                    si = queuedRequests.poll();\n                    if (si == null) {\n                        flush(toFlush);\n                        continue;\n                    }\n                }\n                if (si == requestOfDeath) {\n                    break;\n                }\n                if (si != null) {\n                    // track the number of records written to the log\n                    if (zks.getZKDatabase().append(si)) {\n                        logCount++;\n                        if (logCount > (snapCount / 2 + randRoll)) {\n                            randRoll = r.nextInt(snapCount/2);\n                            // roll the log\n                            zks.getZKDatabase().rollLog();\n                            // take a snapshot\n                            if (snapInProcess != null && snapInProcess.isAlive()) {\n                                LOG.warn(\"Too busy to snap, skipping\");\n                            } else {\n                                snapInProcess = new ZooKeeperThread(\"Snapshot Thread\") {\n                                        public void run() {\n                                            try {\n                                                zks.takeSnapshot();\n                                            } catch(Exception e) {\n                                                LOG.warn(\"Unexpected exception\", e);\n                                            }\n                                        }\n                                    };\n                                snapInProcess.start();\n                            }\n                            logCount = 0;\n                        }\n                    } else if (toFlush.isEmpty()) {\n                        // optimization for read heavy workloads\n                        // iff this is a read, and there are no pending\n                        // flushes (writes), then just pass this to the next\n                        // processor\n                        if (nextProcessor != null) {\n                            nextProcessor.processRequest(si);\n                            if (nextProcessor instanceof Flushable) {\n                                ((Flushable)nextProcessor).flush();\n                            }\n                        }\n                        continue;\n                    }\n                    toFlush.add(si);\n                    if (toFlush.size() > 1000) {\n                        flush(toFlush);\n                    }\n                }\n            }\n        } catch (Throwable t) {\n            handleException(this.getName(), t);\n        } finally{\n            running = false;\n        }\n        LOG.info(\"SyncRequestProcessor exited!\");\n    }",
                "code_after_change": "    public void run() {\n        try {\n            int logCount = 0;\n\n            // we do this in an attempt to ensure that not all of the servers\n            // in the ensemble take a snapshot at the same time\n            setRandRoll(r.nextInt(snapCount/2));\n            while (true) {\n                Request si = null;\n                if (toFlush.isEmpty()) {\n                    si = queuedRequests.take();\n                } else {\n                    si = queuedRequests.poll();\n                    if (si == null) {\n                        flush(toFlush);\n                        continue;\n                    }\n                }\n                if (si == requestOfDeath) {\n                    break;\n                }\n                if (si != null) {\n                    // track the number of records written to the log\n                    if (zks.getZKDatabase().append(si)) {\n                        logCount++;\n                        if (logCount > (snapCount / 2 + randRoll)) {\n                            randRoll = r.nextInt(snapCount/2);\n                            // roll the log\n                            zks.getZKDatabase().rollLog();\n                            // take a snapshot\n                            if (snapInProcess != null && snapInProcess.isAlive()) {\n                                LOG.warn(\"Too busy to snap, skipping\");\n                            } else {\n                                snapInProcess = new ZooKeeperThread(\"Snapshot Thread\") {\n                                        public void run() {\n                                            try {\n                                                zks.takeSnapshot();\n                                            } catch(Exception e) {\n                                                LOG.warn(\"Unexpected exception\", e);\n                                            }\n                                        }\n                                    };\n                                snapInProcess.start();\n                            }\n                            logCount = 0;\n                        }\n                    } else if (toFlush.isEmpty()) {\n                        // optimization for read heavy workloads\n                        // iff this is a read, and there are no pending\n                        // flushes (writes), then just pass this to the next\n                        // processor\n                        if (nextProcessor != null) {\n                            nextProcessor.processRequest(si);\n                            if (nextProcessor instanceof Flushable) {\n                                ((Flushable)nextProcessor).flush();\n                            }\n                        }\n                        continue;\n                    }\n                    toFlush.add(si);\n                    if (toFlush.size() > 1000) {\n                        flush(toFlush);\n                    }\n                }\n            }\n        } catch (Throwable t) {\n            handleException(this.getName(), t);\n            running = false;\n        }\n        LOG.info(\"SyncRequestProcessor exited!\");\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.Leader.getPacketType": {
                "code_before_change": "    public static String getPacketType(int packetType) {\n        switch (packetType) {\n        case DIFF:\n            return \"DIFF\";\n        case TRUNC:\n            return \"TRUNC\";\n        case SNAP:\n            return \"SNAP\";\n        case OBSERVERINFO:\n            return \"OBSERVERINFO\";\n        case NEWLEADER:\n            return \"NEWLEADER\";\n        case FOLLOWERINFO:\n            return \"FOLLOWERINFO\";\n        case UPTODATE:\n            return \"UPTODATE\";\n        case LEADERINFO:\n            return \"LEADERINFO\";\n        case ACKEPOCH:\n            return \"ACKEPOCH\";\n        case REQUEST:\n            return \"REQUEST\";\n        case PROPOSAL:\n            return \"PROPOSAL\";\n        case ACK:\n            return \"ACK\";\n        case COMMIT:\n            return \"COMMIT\";\n        case COMMITANDACTIVATE:\n            return \"COMMITANDACTIVATE\";           \n        case PING:\n            return \"PING\";\n        case REVALIDATE:\n            return \"REVALIDATE\";\n        case SYNC:\n            return \"SYNC\";\n        case INFORM:\n            return \"INFORM\";\n        case INFORMANDACTIVATE:\n            return \"INFORMANDACTIVATE\";\n        default:\n            return \"UNKNOWN\";\n        }\n    }",
                "code_after_change": "    public static String getPacketType(int packetType) {\n        switch (packetType) {\n        case DIFF:\n            return \"DIFF\";\n        case TRUNC:\n            return \"TRUNC\";\n        case SNAP:\n            return \"SNAP\";\n        case OBSERVERINFO:\n            return \"OBSERVERINFO\";\n        case NEWLEADER:\n            return \"NEWLEADER\";\n        case FOLLOWERINFO:\n            return \"FOLLOWERINFO\";\n        case UPTODATE:\n            return \"UPTODATE\";\n        case LEADERINFO:\n            return \"LEADERINFO\";\n        case ACKEPOCH:\n            return \"ACKEPOCH\";\n        case REQUEST:\n            return \"REQUEST\";\n        case PROPOSAL:\n            return \"PROPOSAL\";\n        case ACK:\n            return \"ACK\";\n        case COMMIT:\n            return \"COMMIT\";\n        case PING:\n            return \"PING\";\n        case REVALIDATE:\n            return \"REVALIDATE\";\n        case SYNC:\n            return \"SYNC\";\n        case INFORM:\n            return \"INFORM\";\n        default:\n            return \"UNKNOWN\";\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.getZooKeeperServerListener": {
                "code_before_change": "    public ZooKeeperServerListener getZooKeeperServerListener() {\n        return listener;\n    }",
                "code_after_change": "    public ZooKeeperServerListener getZooKeeperServerListener() {\n        return listener;\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.startSessionTracker": {
                "code_before_change": "    protected void startSessionTracker() {\n        ((SessionTrackerImpl)sessionTracker).start();\n    }",
                "code_after_change": "    protected void startSessionTracker() {\n        ((SessionTrackerImpl)sessionTracker).start();\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.startup": {
                "code_before_change": "    public synchronized void startup() {\n        if (sessionTracker == null) {\n            createSessionTracker();\n        }\n        startSessionTracker();\n        setupRequestProcessors();\n\n        registerJMX();\n\n        state = State.RUNNING;\n        notifyAll();\n    }",
                "code_after_change": "    public synchronized void startup() {\n        if (sessionTracker == null) {\n            createSessionTracker();\n        }\n        startSessionTracker();\n        setupRequestProcessors();\n\n        registerJMX();\n\n        setState(State.RUNNING);\n        notifyAll();\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.processTxn": {
                "code_before_change": "    public ProcessTxnResult processTxn(TxnHeader hdr, Record txn) {\n        return processTxn(null, hdr, txn);\n    }",
                "code_after_change": "    public ProcessTxnResult processTxn(TxnHeader hdr, Record txn) {\n        ProcessTxnResult rc;\n        int opCode = hdr.getType();\n        long sessionId = hdr.getClientId();\n        rc = getZKDatabase().processTxn(hdr, txn);\n        if (opCode == OpCode.createSession) {\n            if (txn instanceof CreateSessionTxn) {\n                CreateSessionTxn cst = (CreateSessionTxn) txn;\n                sessionTracker.addSession(sessionId, cst\n                        .getTimeOut());\n            } else {\n                LOG.warn(\"*****>>>>> Got \"\n                        + txn.getClass() + \" \"\n                        + txn.toString());\n            }\n        } else if (opCode == OpCode.closeSession) {\n            sessionTracker.removeSession(sessionId);\n        }\n        return rc;\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServer.build": {
                "code_before_change": [],
                "code_after_change": "        public DataTree build();\n    }\n\n    static public class BasicDataTreeBuilder implements DataTreeBuilder {"
            },
            "src.java.main.org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig": {
                "code_before_change": "    public void runFromConfig(ServerConfig config) throws IOException, AdminServerException {\n        LOG.info(\"Starting server\");\n        FileTxnSnapLog txnLog = null;\n        try {\n            // Note that this thread isn't going to be doing anything else,\n            // so rather than spawning another thread, we will just call\n            // run() in this thread.\n            // create a file logger url from the command line args\n            txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);\n            ZooKeeperServer zkServer = new ZooKeeperServer( txnLog,\n                    config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, null);\n\n            // Start Admin server\n            adminServer = AdminServerFactory.createAdminServer();\n            adminServer.setZooKeeperServer(zkServer);\n            adminServer.start();\n\n            boolean needStartZKServer = true;\n            if (config.getClientPortAddress() != null) {\n                cnxnFactory = ServerCnxnFactory.createFactory();\n                cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), false);\n                cnxnFactory.startup(zkServer);\n                // zkServer has been started. So we don't need to start it again in secureCnxnFactory.\n                needStartZKServer = false;\n            }\n            if (config.getSecureClientPortAddress() != null) {\n                secureCnxnFactory = ServerCnxnFactory.createFactory();\n                secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), true);\n                secureCnxnFactory.startup(zkServer, needStartZKServer);\n            }\n\n            containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor,\n                    Integer.getInteger(\"znode.container.checkIntervalMs\", (int) TimeUnit.MINUTES.toMillis(1)),\n                    Integer.getInteger(\"znode.container.maxPerMinute\", 10000)\n            );\n            containerManager.start();\n\n            if (cnxnFactory != null) {\n                cnxnFactory.join();\n            }\n            if (secureCnxnFactory != null) {\n                secureCnxnFactory.join();\n            }\n\n            if (zkServer.isRunning()) {\n                zkServer.shutdown();\n            }\n        } catch (InterruptedException e) {\n            // warn, but generally this is ok\n            LOG.warn(\"Server interrupted\", e);\n        } finally {\n            if (txnLog != null) {\n                txnLog.close();\n            }\n        }\n    }",
                "code_after_change": "    public void runFromConfig(ServerConfig config) throws IOException {\n        LOG.info(\"Starting server\");\n        FileTxnSnapLog txnLog = null;\n        try {\n            // Note that this thread isn't going to be doing anything else,\n            // so rather than spawning another thread, we will just call\n            // run() in this thread.\n            // create a file logger url from the command line args\n            final ZooKeeperServer zkServer = new ZooKeeperServer();\n            // Registers shutdown handler which will be used to know the\n            // server error or shutdown state changes.\n            final CountDownLatch shutdownLatch = new CountDownLatch(1);\n            zkServer.registerServerShutdownHandler(\n                    new ZooKeeperServerShutdownHandler(shutdownLatch));\n\n            txnLog = new FileTxnSnapLog(new File(config.dataLogDir), new File(\n                    config.dataDir));\n            zkServer.setTxnLogFactory(txnLog);\n            zkServer.setTickTime(config.tickTime);\n            zkServer.setMinSessionTimeout(config.minSessionTimeout);\n            zkServer.setMaxSessionTimeout(config.maxSessionTimeout);\n            cnxnFactory = ServerCnxnFactory.createFactory();\n            cnxnFactory.configure(config.getClientPortAddress(),\n                    config.getMaxClientCnxns());\n            cnxnFactory.startup(zkServer);\n            // Watch status of ZooKeeper server. It will do a graceful shutdown\n            // if the server is not running or hits an internal error.\n            shutdownLatch.await();\n            shutdown();\n\n            cnxnFactory.join();\n            if (zkServer.canShutdown()) {\n                zkServer.shutdown();\n            }\n        } catch (InterruptedException e) {\n            // warn, but generally this is ok\n            LOG.warn(\"Server interrupted\", e);\n        } finally {\n            if (txnLog != null) {\n                txnLog.close();\n            }\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX": {
                "code_before_change": "    protected void registerJMX() {\n        // register with JMX\n        try {\n            jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());\n            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to register with JMX\", e);\n            jmxDataTreeBean = null;\n        }\n    }",
                "code_after_change": "    protected void registerJMX() {\n        // register with JMX\n        try {\n            jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());\n            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to register with JMX\", e);\n            jmxDataTreeBean = null;\n        }\n    }"
            },
            "src.java.main.org.apache.zookeeper.server.quorum.ObserverZooKeeperServer.getState": {
                "code_before_change": "    public String getState() {\n        return \"observer\";\n    };    ",
                "code_after_change": "    public String getState() {\n        return \"observer\";\n    };    "
            }
        },
        "llm_judgement": {
            "root_cause_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "fix_suggestion": "Missing",
            "problem_location_identification": {
                "level": "Partial",
                "sub_category": "Shared Stack Trace Context"
            },
            "wrong_information": "No",
            "explanation_of_judgement": "The bug report identifies the issue occurring when the leader fails to write the transaction log, which is related to the stack trace context but does not precisely identify the root cause in the ground truth methods. The stack trace includes 'SyncRequestProcessor.run', which is a ground truth method, but the report does not pinpoint it as the root cause. There is no fix suggestion provided in the bug report. The problem location is partially identified as it mentions methods in the stack trace context but not the exact ground truth methods. There is no wrong information in the bug report as it accurately describes the issue and the context in which it occurs."
        }
    }
]